#![allow(unused_qualifications)]

use validator::Validate;

use crate::models;
#[cfg(any(feature = "client", feature = "server"))]
use crate::header;

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AcceptOrderCancellationRequest {
    /// Решение об отмене заказа:  * `true` — заказ отменяется, служба доставки узнала об отмене до передачи заказа покупателю. * `false` — заказ не отменяется, так как он уже доставлен покупателю курьером или передан в пункт выдачи заказов. 
    #[serde(rename = "accepted")]
    pub accepted: bool,

    #[serde(rename = "reason")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub reason: Option<models::OrderCancellationReasonType>,

}


impl AcceptOrderCancellationRequest {
    #[allow(clippy::new_without_default)]
    pub fn new(accepted: bool, ) -> AcceptOrderCancellationRequest {
        AcceptOrderCancellationRequest {
            accepted,
            reason: None,
        }
    }
}

/// Converts the AcceptOrderCancellationRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for AcceptOrderCancellationRequest {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            Some("accepted".to_string()),
            Some(self.accepted.to_string()),

            // Skipping reason in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AcceptOrderCancellationRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AcceptOrderCancellationRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub accepted: Vec<bool>,
            pub reason: Vec<models::OrderCancellationReasonType>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing AcceptOrderCancellationRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "accepted" => intermediate_rep.accepted.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "reason" => intermediate_rep.reason.push(<models::OrderCancellationReasonType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing AcceptOrderCancellationRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AcceptOrderCancellationRequest {
            accepted: intermediate_rep.accepted.into_iter().next().ok_or_else(|| "accepted missing in AcceptOrderCancellationRequest".to_string())?,
            reason: intermediate_rep.reason.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AcceptOrderCancellationRequest> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<AcceptOrderCancellationRequest>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<AcceptOrderCancellationRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for AcceptOrderCancellationRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<AcceptOrderCancellationRequest> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AcceptOrderCancellationRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into AcceptOrderCancellationRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Запрос на скрытие оферов.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AddHiddenOffersRequest {
    /// Список скрытых товаров. 
    #[serde(rename = "hiddenOffers")]
    #[validate(
            length(min = 1, max = 500),
        )]
    pub hidden_offers: Vec<models::HiddenOfferDto>,

}


impl AddHiddenOffersRequest {
    #[allow(clippy::new_without_default)]
    pub fn new(hidden_offers: Vec<models::HiddenOfferDto>, ) -> AddHiddenOffersRequest {
        AddHiddenOffersRequest {
            hidden_offers,
        }
    }
}

/// Converts the AddHiddenOffersRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for AddHiddenOffersRequest {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping hiddenOffers in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AddHiddenOffersRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AddHiddenOffersRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub hidden_offers: Vec<Vec<models::HiddenOfferDto>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing AddHiddenOffersRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "hiddenOffers" => return std::result::Result::Err("Parsing a container in this style is not supported in AddHiddenOffersRequest".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing AddHiddenOffersRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AddHiddenOffersRequest {
            hidden_offers: intermediate_rep.hidden_offers.into_iter().next().ok_or_else(|| "hiddenOffers missing in AddHiddenOffersRequest".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AddHiddenOffersRequest> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<AddHiddenOffersRequest>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<AddHiddenOffersRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for AddHiddenOffersRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<AddHiddenOffersRequest> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AddHiddenOffersRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into AddHiddenOffersRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Товары, которые не удалось поместить в архив.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AddOffersToArchiveDto {
    /// Список товаров, которые не удалось поместить в архив.
    #[serde(rename = "notArchivedOffers")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub not_archived_offers: Option<swagger::Nullable<Vec<models::AddOffersToArchiveErrorDto>>>,

}


impl AddOffersToArchiveDto {
    #[allow(clippy::new_without_default)]
    pub fn new() -> AddOffersToArchiveDto {
        AddOffersToArchiveDto {
            not_archived_offers: None,
        }
    }
}

/// Converts the AddOffersToArchiveDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for AddOffersToArchiveDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping notArchivedOffers in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AddOffersToArchiveDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AddOffersToArchiveDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub not_archived_offers: Vec<Vec<models::AddOffersToArchiveErrorDto>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing AddOffersToArchiveDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "notArchivedOffers" => return std::result::Result::Err("Parsing a container in this style is not supported in AddOffersToArchiveDto".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing AddOffersToArchiveDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AddOffersToArchiveDto {
            not_archived_offers: std::result::Result::Err("Nullable types not supported in AddOffersToArchiveDto".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AddOffersToArchiveDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<AddOffersToArchiveDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<AddOffersToArchiveDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for AddOffersToArchiveDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<AddOffersToArchiveDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AddOffersToArchiveDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into AddOffersToArchiveDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Товар, который не удалось поместить в архив.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AddOffersToArchiveErrorDto {
    /// Ваш SKU — идентификатор товара в вашей системе.  Разрешена любая последовательность длиной до 255 знаков.  Правила использования SKU:  * У каждого товара SKU должен быть свой.  * SKU товара нельзя менять — можно только удалить товар и добавить заново с новым SKU.  * Уже заданный SKU нельзя освободить и использовать заново для другого товара. Каждый товар должен получать новый идентификатор, до того никогда не использовавшийся в вашем каталоге.  [Что такое SKU и как его назначать](https://yandex.ru/support/marketplace/assortment/add/index.html#fields) 
    #[serde(rename = "offerId")]
    #[validate(
            length(min = 1, max = 255),
           regex = "RE_ADDOFFERSTOARCHIVEERRORDTO_OFFER_ID",
        )]
    pub offer_id: String,

    #[serde(rename = "error")]
    pub error: models::AddOffersToArchiveErrorType,

}

lazy_static::lazy_static! {
    static ref RE_ADDOFFERSTOARCHIVEERRORDTO_OFFER_ID: regex::Regex = regex::Regex::new(r"^[^\\x00-\\x08\\x0A-\\x1f\\x7f]{1,255}$").unwrap();
}

impl AddOffersToArchiveErrorDto {
    #[allow(clippy::new_without_default)]
    pub fn new(offer_id: String, error: models::AddOffersToArchiveErrorType, ) -> AddOffersToArchiveErrorDto {
        AddOffersToArchiveErrorDto {
            offer_id,
            error,
        }
    }
}

/// Converts the AddOffersToArchiveErrorDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for AddOffersToArchiveErrorDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            Some("offerId".to_string()),
            Some(self.offer_id.to_string()),

            // Skipping error in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AddOffersToArchiveErrorDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AddOffersToArchiveErrorDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub offer_id: Vec<String>,
            pub error: Vec<models::AddOffersToArchiveErrorType>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing AddOffersToArchiveErrorDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "offerId" => intermediate_rep.offer_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "error" => intermediate_rep.error.push(<models::AddOffersToArchiveErrorType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing AddOffersToArchiveErrorDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AddOffersToArchiveErrorDto {
            offer_id: intermediate_rep.offer_id.into_iter().next().ok_or_else(|| "offerId missing in AddOffersToArchiveErrorDto".to_string())?,
            error: intermediate_rep.error.into_iter().next().ok_or_else(|| "error missing in AddOffersToArchiveErrorDto".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AddOffersToArchiveErrorDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<AddOffersToArchiveErrorDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<AddOffersToArchiveErrorDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for AddOffersToArchiveErrorDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<AddOffersToArchiveErrorDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AddOffersToArchiveErrorDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into AddOffersToArchiveErrorDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Причина, по которой товар не удалось поместить в архив:  * `OFFER_HAS_STOCKS` — товар хранится на складе Маркета. 
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum AddOffersToArchiveErrorType {
    #[serde(rename = "OFFER_HAS_STOCKS")]
    OfferHasStocks,
    #[serde(rename = "UNKNOWN")]
    Unknown,
}

impl std::fmt::Display for AddOffersToArchiveErrorType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            AddOffersToArchiveErrorType::OfferHasStocks => write!(f, "OFFER_HAS_STOCKS"),
            AddOffersToArchiveErrorType::Unknown => write!(f, "UNKNOWN"),
        }
    }
}

impl std::str::FromStr for AddOffersToArchiveErrorType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "OFFER_HAS_STOCKS" => std::result::Result::Ok(AddOffersToArchiveErrorType::OfferHasStocks),
            "UNKNOWN" => std::result::Result::Ok(AddOffersToArchiveErrorType::Unknown),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Товары, которые нужно поместить в архив. 
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AddOffersToArchiveRequest {
    /// Список товаров, которые нужно поместить в архив.
    #[serde(rename = "offerIds")]
    #[validate(
            length(min = 1, max = 200),
        )]
    pub offer_ids: Vec<models::ShopSku>,

}


impl AddOffersToArchiveRequest {
    #[allow(clippy::new_without_default)]
    pub fn new(offer_ids: Vec<models::ShopSku>, ) -> AddOffersToArchiveRequest {
        AddOffersToArchiveRequest {
            offer_ids,
        }
    }
}

/// Converts the AddOffersToArchiveRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for AddOffersToArchiveRequest {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            Some("offerIds".to_string()),
            Some(self.offer_ids.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AddOffersToArchiveRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AddOffersToArchiveRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub offer_ids: Vec<Vec<models::ShopSku>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing AddOffersToArchiveRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "offerIds" => return std::result::Result::Err("Parsing a container in this style is not supported in AddOffersToArchiveRequest".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing AddOffersToArchiveRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AddOffersToArchiveRequest {
            offer_ids: intermediate_rep.offer_ids.into_iter().next().ok_or_else(|| "offerIds missing in AddOffersToArchiveRequest".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AddOffersToArchiveRequest> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<AddOffersToArchiveRequest>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<AddOffersToArchiveRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for AddOffersToArchiveRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<AddOffersToArchiveRequest> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AddOffersToArchiveRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into AddOffersToArchiveRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Результат архивации товаров.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AddOffersToArchiveResponse {
    #[serde(rename = "status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<models::ApiResponseStatusType>,

    #[serde(rename = "result")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub result: Option<models::AddOffersToArchiveDto>,

}


impl AddOffersToArchiveResponse {
    #[allow(clippy::new_without_default)]
    pub fn new() -> AddOffersToArchiveResponse {
        AddOffersToArchiveResponse {
            status: None,
            result: None,
        }
    }
}

/// Converts the AddOffersToArchiveResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for AddOffersToArchiveResponse {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping status in query parameter serialization

            // Skipping result in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AddOffersToArchiveResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AddOffersToArchiveResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub status: Vec<models::ApiResponseStatusType>,
            pub result: Vec<models::AddOffersToArchiveDto>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing AddOffersToArchiveResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(<models::ApiResponseStatusType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "result" => intermediate_rep.result.push(<models::AddOffersToArchiveDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing AddOffersToArchiveResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AddOffersToArchiveResponse {
            status: intermediate_rep.status.into_iter().next(),
            result: intermediate_rep.result.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AddOffersToArchiveResponse> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<AddOffersToArchiveResponse>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<AddOffersToArchiveResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for AddOffersToArchiveResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<AddOffersToArchiveResponse> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AddOffersToArchiveResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into AddOffersToArchiveResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Составляющие индекса качества.  **Для модели DBS:** * `DBS_CANCELLATION_RATE` — доля отмененных товаров. * `DBS_LATE_DELIVERY_RATE` — доля заказов, доставленных после плановой даты.  **Для моделей FBS и Экспресс:** * `FBS_CANCELLATION_RATE` — доля отмененных товаров. * `FBS_LATE_SHIP_RATE` — доля не вовремя отгруженных заказов. 
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum AffectedOrderQualityRatingComponentType {
    #[serde(rename = "DBS_CANCELLATION_RATE")]
    DbsCancellationRate,
    #[serde(rename = "DBS_LATE_DELIVERY_RATE")]
    DbsLateDeliveryRate,
    #[serde(rename = "FBS_CANCELLATION_RATE")]
    FbsCancellationRate,
    #[serde(rename = "FBS_LATE_SHIP_RATE")]
    FbsLateShipRate,
}

impl std::fmt::Display for AffectedOrderQualityRatingComponentType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            AffectedOrderQualityRatingComponentType::DbsCancellationRate => write!(f, "DBS_CANCELLATION_RATE"),
            AffectedOrderQualityRatingComponentType::DbsLateDeliveryRate => write!(f, "DBS_LATE_DELIVERY_RATE"),
            AffectedOrderQualityRatingComponentType::FbsCancellationRate => write!(f, "FBS_CANCELLATION_RATE"),
            AffectedOrderQualityRatingComponentType::FbsLateShipRate => write!(f, "FBS_LATE_SHIP_RATE"),
        }
    }
}

impl std::str::FromStr for AffectedOrderQualityRatingComponentType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "DBS_CANCELLATION_RATE" => std::result::Result::Ok(AffectedOrderQualityRatingComponentType::DbsCancellationRate),
            "DBS_LATE_DELIVERY_RATE" => std::result::Result::Ok(AffectedOrderQualityRatingComponentType::DbsLateDeliveryRate),
            "FBS_CANCELLATION_RATE" => std::result::Result::Ok(AffectedOrderQualityRatingComponentType::FbsCancellationRate),
            "FBS_LATE_SHIP_RATE" => std::result::Result::Ok(AffectedOrderQualityRatingComponentType::FbsLateShipRate),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Возраст в заданных единицах измерения.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AgeDto {
    /// Значение. 
    #[serde(rename = "value")]
    #[validate(
            range(min = 0),
        )]
    pub value: f64,

    #[serde(rename = "ageUnit")]
    pub age_unit: models::AgeUnitType,

}


impl AgeDto {
    #[allow(clippy::new_without_default)]
    pub fn new(value: f64, age_unit: models::AgeUnitType, ) -> AgeDto {
        AgeDto {
            value,
            age_unit,
        }
    }
}

/// Converts the AgeDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for AgeDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            Some("value".to_string()),
            Some(self.value.to_string()),

            // Skipping ageUnit in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AgeDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AgeDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub value: Vec<f64>,
            pub age_unit: Vec<models::AgeUnitType>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing AgeDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "value" => intermediate_rep.value.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "ageUnit" => intermediate_rep.age_unit.push(<models::AgeUnitType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing AgeDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AgeDto {
            value: intermediate_rep.value.into_iter().next().ok_or_else(|| "value missing in AgeDto".to_string())?,
            age_unit: intermediate_rep.age_unit.into_iter().next().ok_or_else(|| "ageUnit missing in AgeDto".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AgeDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<AgeDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<AgeDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for AgeDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<AgeDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AgeDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into AgeDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Единицы измерения возраста:  * `YEAR` — год. * `MONTH` — месяц. 
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum AgeUnitType {
    #[serde(rename = "YEAR")]
    Year,
    #[serde(rename = "MONTH")]
    Month,
}

impl std::fmt::Display for AgeUnitType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            AgeUnitType::Year => write!(f, "YEAR"),
            AgeUnitType::Month => write!(f, "MONTH"),
        }
    }
}

impl std::str::FromStr for AgeUnitType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "YEAR" => std::result::Result::Ok(AgeUnitType::Year),
            "MONTH" => std::result::Result::Ok(AgeUnitType::Month),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Ошибка в данных переданных от клиента.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ApiClientDataErrorResponse {
    #[serde(rename = "status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<models::ApiResponseStatusType>,

    /// Список ошибок.
    #[serde(rename = "errors")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub errors: Option<swagger::Nullable<Vec<models::ApiErrorDto>>>,

}


impl ApiClientDataErrorResponse {
    #[allow(clippy::new_without_default)]
    pub fn new() -> ApiClientDataErrorResponse {
        ApiClientDataErrorResponse {
            status: None,
            errors: None,
        }
    }
}

/// Converts the ApiClientDataErrorResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ApiClientDataErrorResponse {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping status in query parameter serialization

            // Skipping errors in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ApiClientDataErrorResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ApiClientDataErrorResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub status: Vec<models::ApiResponseStatusType>,
            pub errors: Vec<Vec<models::ApiErrorDto>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ApiClientDataErrorResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(<models::ApiResponseStatusType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "errors" => return std::result::Result::Err("Parsing a container in this style is not supported in ApiClientDataErrorResponse".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing ApiClientDataErrorResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ApiClientDataErrorResponse {
            status: intermediate_rep.status.into_iter().next(),
            errors: std::result::Result::Err("Nullable types not supported in ApiClientDataErrorResponse".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ApiClientDataErrorResponse> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<ApiClientDataErrorResponse>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ApiClientDataErrorResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ApiClientDataErrorResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<ApiClientDataErrorResponse> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ApiClientDataErrorResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ApiClientDataErrorResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Общий формат ошибки.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ApiErrorDto {
    /// Код ошибки.
    #[serde(rename = "code")]
    pub code: String,

    /// Описание ошибки.
    #[serde(rename = "message")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub message: Option<String>,

}


impl ApiErrorDto {
    #[allow(clippy::new_without_default)]
    pub fn new(code: String, ) -> ApiErrorDto {
        ApiErrorDto {
            code,
            message: None,
        }
    }
}

/// Converts the ApiErrorDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ApiErrorDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            Some("code".to_string()),
            Some(self.code.to_string()),


            self.message.as_ref().map(|message| {
                [
                    "message".to_string(),
                    message.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ApiErrorDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ApiErrorDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub code: Vec<String>,
            pub message: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ApiErrorDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "code" => intermediate_rep.code.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "message" => intermediate_rep.message.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ApiErrorDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ApiErrorDto {
            code: intermediate_rep.code.into_iter().next().ok_or_else(|| "code missing in ApiErrorDto".to_string())?,
            message: intermediate_rep.message.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ApiErrorDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<ApiErrorDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ApiErrorDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ApiErrorDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<ApiErrorDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ApiErrorDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ApiErrorDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Стандартная обертка для ошибок сервера.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ApiErrorResponse {
    #[serde(rename = "status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<models::ApiResponseStatusType>,

    /// Список ошибок.
    #[serde(rename = "errors")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub errors: Option<swagger::Nullable<Vec<models::ApiErrorDto>>>,

}


impl ApiErrorResponse {
    #[allow(clippy::new_without_default)]
    pub fn new() -> ApiErrorResponse {
        ApiErrorResponse {
            status: None,
            errors: None,
        }
    }
}

/// Converts the ApiErrorResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ApiErrorResponse {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping status in query parameter serialization

            // Skipping errors in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ApiErrorResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ApiErrorResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub status: Vec<models::ApiResponseStatusType>,
            pub errors: Vec<Vec<models::ApiErrorDto>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ApiErrorResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(<models::ApiResponseStatusType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "errors" => return std::result::Result::Err("Parsing a container in this style is not supported in ApiErrorResponse".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing ApiErrorResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ApiErrorResponse {
            status: intermediate_rep.status.into_iter().next(),
            errors: std::result::Result::Err("Nullable types not supported in ApiErrorResponse".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ApiErrorResponse> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<ApiErrorResponse>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ApiErrorResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ApiErrorResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<ApiErrorResponse> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ApiErrorResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ApiErrorResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Неверны авторизационные данные, указанные в запросе, или запрещен доступ к запрашиваемому ресурсу.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ApiForbiddenErrorResponse {
    #[serde(rename = "status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<models::ApiResponseStatusType>,

    /// Список ошибок.
    #[serde(rename = "errors")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub errors: Option<swagger::Nullable<Vec<models::ApiErrorDto>>>,

}


impl ApiForbiddenErrorResponse {
    #[allow(clippy::new_without_default)]
    pub fn new() -> ApiForbiddenErrorResponse {
        ApiForbiddenErrorResponse {
            status: None,
            errors: None,
        }
    }
}

/// Converts the ApiForbiddenErrorResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ApiForbiddenErrorResponse {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping status in query parameter serialization

            // Skipping errors in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ApiForbiddenErrorResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ApiForbiddenErrorResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub status: Vec<models::ApiResponseStatusType>,
            pub errors: Vec<Vec<models::ApiErrorDto>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ApiForbiddenErrorResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(<models::ApiResponseStatusType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "errors" => return std::result::Result::Err("Parsing a container in this style is not supported in ApiForbiddenErrorResponse".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing ApiForbiddenErrorResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ApiForbiddenErrorResponse {
            status: intermediate_rep.status.into_iter().next(),
            errors: std::result::Result::Err("Nullable types not supported in ApiForbiddenErrorResponse".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ApiForbiddenErrorResponse> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<ApiForbiddenErrorResponse>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ApiForbiddenErrorResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ApiForbiddenErrorResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<ApiForbiddenErrorResponse> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ApiForbiddenErrorResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ApiForbiddenErrorResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Превышено ограничение на доступ к ресурсу.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ApiLimitErrorResponse {
    #[serde(rename = "status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<models::ApiResponseStatusType>,

    /// Список ошибок.
    #[serde(rename = "errors")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub errors: Option<swagger::Nullable<Vec<models::ApiErrorDto>>>,

}


impl ApiLimitErrorResponse {
    #[allow(clippy::new_without_default)]
    pub fn new() -> ApiLimitErrorResponse {
        ApiLimitErrorResponse {
            status: None,
            errors: None,
        }
    }
}

/// Converts the ApiLimitErrorResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ApiLimitErrorResponse {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping status in query parameter serialization

            // Skipping errors in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ApiLimitErrorResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ApiLimitErrorResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub status: Vec<models::ApiResponseStatusType>,
            pub errors: Vec<Vec<models::ApiErrorDto>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ApiLimitErrorResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(<models::ApiResponseStatusType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "errors" => return std::result::Result::Err("Parsing a container in this style is not supported in ApiLimitErrorResponse".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing ApiLimitErrorResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ApiLimitErrorResponse {
            status: intermediate_rep.status.into_iter().next(),
            errors: std::result::Result::Err("Nullable types not supported in ApiLimitErrorResponse".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ApiLimitErrorResponse> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<ApiLimitErrorResponse>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ApiLimitErrorResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ApiLimitErrorResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<ApiLimitErrorResponse> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ApiLimitErrorResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ApiLimitErrorResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Ресурс из запроса заблокирован от применения к нему указанного метода.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ApiLockedErrorResponse {
    #[serde(rename = "status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<models::ApiResponseStatusType>,

    /// Список ошибок.
    #[serde(rename = "errors")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub errors: Option<swagger::Nullable<Vec<models::ApiErrorDto>>>,

}


impl ApiLockedErrorResponse {
    #[allow(clippy::new_without_default)]
    pub fn new() -> ApiLockedErrorResponse {
        ApiLockedErrorResponse {
            status: None,
            errors: None,
        }
    }
}

/// Converts the ApiLockedErrorResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ApiLockedErrorResponse {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping status in query parameter serialization

            // Skipping errors in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ApiLockedErrorResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ApiLockedErrorResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub status: Vec<models::ApiResponseStatusType>,
            pub errors: Vec<Vec<models::ApiErrorDto>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ApiLockedErrorResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(<models::ApiResponseStatusType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "errors" => return std::result::Result::Err("Parsing a container in this style is not supported in ApiLockedErrorResponse".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing ApiLockedErrorResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ApiLockedErrorResponse {
            status: intermediate_rep.status.into_iter().next(),
            errors: std::result::Result::Err("Nullable types not supported in ApiLockedErrorResponse".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ApiLockedErrorResponse> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<ApiLockedErrorResponse>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ApiLockedErrorResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ApiLockedErrorResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<ApiLockedErrorResponse> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ApiLockedErrorResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ApiLockedErrorResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Запрашиваемый ресурс не найден.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ApiNotFoundErrorResponse {
    #[serde(rename = "status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<models::ApiResponseStatusType>,

    /// Список ошибок.
    #[serde(rename = "errors")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub errors: Option<swagger::Nullable<Vec<models::ApiErrorDto>>>,

}


impl ApiNotFoundErrorResponse {
    #[allow(clippy::new_without_default)]
    pub fn new() -> ApiNotFoundErrorResponse {
        ApiNotFoundErrorResponse {
            status: None,
            errors: None,
        }
    }
}

/// Converts the ApiNotFoundErrorResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ApiNotFoundErrorResponse {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping status in query parameter serialization

            // Skipping errors in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ApiNotFoundErrorResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ApiNotFoundErrorResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub status: Vec<models::ApiResponseStatusType>,
            pub errors: Vec<Vec<models::ApiErrorDto>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ApiNotFoundErrorResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(<models::ApiResponseStatusType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "errors" => return std::result::Result::Err("Parsing a container in this style is not supported in ApiNotFoundErrorResponse".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing ApiNotFoundErrorResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ApiNotFoundErrorResponse {
            status: intermediate_rep.status.into_iter().next(),
            errors: std::result::Result::Err("Nullable types not supported in ApiNotFoundErrorResponse".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ApiNotFoundErrorResponse> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<ApiNotFoundErrorResponse>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ApiNotFoundErrorResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ApiNotFoundErrorResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<ApiNotFoundErrorResponse> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ApiNotFoundErrorResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ApiNotFoundErrorResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Стандартная обертка для ответов сервера.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ApiResponse {
    #[serde(rename = "status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<models::ApiResponseStatusType>,

}


impl ApiResponse {
    #[allow(clippy::new_without_default)]
    pub fn new() -> ApiResponse {
        ApiResponse {
            status: None,
        }
    }
}

/// Converts the ApiResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ApiResponse {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping status in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ApiResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ApiResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub status: Vec<models::ApiResponseStatusType>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ApiResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(<models::ApiResponseStatusType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ApiResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ApiResponse {
            status: intermediate_rep.status.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ApiResponse> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<ApiResponse>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ApiResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ApiResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<ApiResponse> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ApiResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ApiResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Тип ответа.
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum ApiResponseStatusType {
    #[serde(rename = "OK")]
    Ok,
    #[serde(rename = "ERROR")]
    Error,
}

impl std::fmt::Display for ApiResponseStatusType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            ApiResponseStatusType::Ok => write!(f, "OK"),
            ApiResponseStatusType::Error => write!(f, "ERROR"),
        }
    }
}

impl std::str::FromStr for ApiResponseStatusType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "OK" => std::result::Result::Ok(ApiResponseStatusType::Ok),
            "ERROR" => std::result::Result::Ok(ApiResponseStatusType::Error),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Внутренняя ошибка сервера.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ApiServerErrorResponse {
    #[serde(rename = "status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<models::ApiResponseStatusType>,

    /// Список ошибок.
    #[serde(rename = "errors")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub errors: Option<swagger::Nullable<Vec<models::ApiErrorDto>>>,

}


impl ApiServerErrorResponse {
    #[allow(clippy::new_without_default)]
    pub fn new() -> ApiServerErrorResponse {
        ApiServerErrorResponse {
            status: None,
            errors: None,
        }
    }
}

/// Converts the ApiServerErrorResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ApiServerErrorResponse {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping status in query parameter serialization

            // Skipping errors in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ApiServerErrorResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ApiServerErrorResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub status: Vec<models::ApiResponseStatusType>,
            pub errors: Vec<Vec<models::ApiErrorDto>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ApiServerErrorResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(<models::ApiResponseStatusType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "errors" => return std::result::Result::Err("Parsing a container in this style is not supported in ApiServerErrorResponse".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing ApiServerErrorResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ApiServerErrorResponse {
            status: intermediate_rep.status.into_iter().next(),
            errors: std::result::Result::Err("Nullable types not supported in ApiServerErrorResponse".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ApiServerErrorResponse> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<ApiServerErrorResponse>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ApiServerErrorResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ApiServerErrorResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<ApiServerErrorResponse> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ApiServerErrorResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ApiServerErrorResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// В запросе не указаны авторизационные данные.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ApiUnauthorizedErrorResponse {
    #[serde(rename = "status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<models::ApiResponseStatusType>,

    /// Список ошибок.
    #[serde(rename = "errors")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub errors: Option<swagger::Nullable<Vec<models::ApiErrorDto>>>,

}


impl ApiUnauthorizedErrorResponse {
    #[allow(clippy::new_without_default)]
    pub fn new() -> ApiUnauthorizedErrorResponse {
        ApiUnauthorizedErrorResponse {
            status: None,
            errors: None,
        }
    }
}

/// Converts the ApiUnauthorizedErrorResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ApiUnauthorizedErrorResponse {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping status in query parameter serialization

            // Skipping errors in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ApiUnauthorizedErrorResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ApiUnauthorizedErrorResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub status: Vec<models::ApiResponseStatusType>,
            pub errors: Vec<Vec<models::ApiErrorDto>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ApiUnauthorizedErrorResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(<models::ApiResponseStatusType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "errors" => return std::result::Result::Err("Parsing a container in this style is not supported in ApiUnauthorizedErrorResponse".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing ApiUnauthorizedErrorResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ApiUnauthorizedErrorResponse {
            status: intermediate_rep.status.into_iter().next(),
            errors: std::result::Result::Err("Nullable types not supported in ApiUnauthorizedErrorResponse".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ApiUnauthorizedErrorResponse> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<ApiUnauthorizedErrorResponse>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ApiUnauthorizedErrorResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ApiUnauthorizedErrorResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<ApiUnauthorizedErrorResponse> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ApiUnauthorizedErrorResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ApiUnauthorizedErrorResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Информация о новой цене на товар.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct BaseCampaignOfferDto {
    /// Ваш SKU — идентификатор товара в вашей системе.  Разрешена любая последовательность длиной до 255 знаков.  Правила использования SKU:  * У каждого товара SKU должен быть свой.  * SKU товара нельзя менять — можно только удалить товар и добавить заново с новым SKU.  * Уже заданный SKU нельзя освободить и использовать заново для другого товара. Каждый товар должен получать новый идентификатор, до того никогда не использовавшийся в вашем каталоге.  [Что такое SKU и как его назначать](https://yandex.ru/support/marketplace/assortment/add/index.html#fields) 
    #[serde(rename = "offerId")]
    #[validate(
            length(min = 1, max = 255),
           regex = "RE_BASECAMPAIGNOFFERDTO_OFFER_ID",
        )]
    pub offer_id: String,

    #[serde(rename = "quantum")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub quantum: Option<models::QuantumDto>,

    /// Есть ли товар в продаже. 
    #[serde(rename = "available")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub available: Option<bool>,

}

lazy_static::lazy_static! {
    static ref RE_BASECAMPAIGNOFFERDTO_OFFER_ID: regex::Regex = regex::Regex::new(r"^[^\\x00-\\x08\\x0A-\\x1f\\x7f]{1,255}$").unwrap();
}

impl BaseCampaignOfferDto {
    #[allow(clippy::new_without_default)]
    pub fn new(offer_id: String, ) -> BaseCampaignOfferDto {
        BaseCampaignOfferDto {
            offer_id,
            quantum: None,
            available: None,
        }
    }
}

/// Converts the BaseCampaignOfferDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for BaseCampaignOfferDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            Some("offerId".to_string()),
            Some(self.offer_id.to_string()),

            // Skipping quantum in query parameter serialization


            self.available.as_ref().map(|available| {
                [
                    "available".to_string(),
                    available.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a BaseCampaignOfferDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for BaseCampaignOfferDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub offer_id: Vec<String>,
            pub quantum: Vec<models::QuantumDto>,
            pub available: Vec<bool>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing BaseCampaignOfferDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "offerId" => intermediate_rep.offer_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "quantum" => intermediate_rep.quantum.push(<models::QuantumDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "available" => intermediate_rep.available.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing BaseCampaignOfferDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(BaseCampaignOfferDto {
            offer_id: intermediate_rep.offer_id.into_iter().next().ok_or_else(|| "offerId missing in BaseCampaignOfferDto".to_string())?,
            quantum: intermediate_rep.quantum.into_iter().next(),
            available: intermediate_rep.available.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<BaseCampaignOfferDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<BaseCampaignOfferDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<BaseCampaignOfferDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for BaseCampaignOfferDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<BaseCampaignOfferDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <BaseCampaignOfferDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into BaseCampaignOfferDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Основные параметры товара.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct BaseOfferDto {
    /// Ваш SKU — идентификатор товара в вашей системе.  Разрешена любая последовательность длиной до 255 знаков.  Правила использования SKU:  * У каждого товара SKU должен быть свой.  * SKU товара нельзя менять — можно только удалить товар и добавить заново с новым SKU.  * Уже заданный SKU нельзя освободить и использовать заново для другого товара. Каждый товар должен получать новый идентификатор, до того никогда не использовавшийся в вашем каталоге.  [Что такое SKU и как его назначать](https://yandex.ru/support/marketplace/assortment/add/index.html#fields) 
    #[serde(rename = "offerId")]
    #[validate(
            length(min = 1, max = 255),
           regex = "RE_BASEOFFERDTO_OFFER_ID",
        )]
    pub offer_id: String,

    /// Составляйте название по схеме: тип + бренд или производитель + модель + особенности, если есть (например, цвет, размер или вес) и количество в упаковке.  Не включайте в название условия продажи (например, «скидка», «бесплатная доставка» и т. д.), эмоциональные характеристики («хит», «супер» и т. д.). Не пишите слова большими буквами — кроме устоявшихся названий брендов и моделей.  Оптимальная длина — 50–60 символов, максимальная — 256.  [Рекомендации и правила](https://yandex.ru/support/marketplace/assortment/fields/title.html) 
    #[serde(rename = "name")]
    #[validate(
            length(max = 256),
        )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

    /// Идентификатор категории на Маркете, к которой вы относите свой товар.  Если не указать `marketCategoryId`, то маркетная категория будет определена автоматически.  При изменении информации о товаре передавайте тот же идентификатор категории. Если вы укажете другой, категория товара не поменяется. Изменить ее можно только в кабинете продавца на Маркете.  Список категорий Маркета можно получить с помощью запроса  [POST categories/tree](../../reference/categories/getCategoriesTree.md). 
    #[serde(rename = "marketCategoryId")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub market_category_id: Option<i64>,

    /// Категория товара в вашем магазине. Значение будет использовано для определения категории товара на Маркете в случае, если вы не передали категорию в параметре `marketCategoryId`.  Указывайте конкретные категории — например, набор ножей лучше отнести к категории **Столовые приборы**, а не просто **Посуда**.  Выбирайте категории, которые описывают товар, а не абстрактный признак — например, **Духи**, а не **Подарки**.  Значение будет использовано для определения категории товара на Маркете в случае, если вы не передали категорию в параметре `marketCategoryId`. 
    #[serde(rename = "category")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub category: Option<String>,

    /// Ссылки на изображения товара. Изображение по первой ссылке считается основным, остальные дополнительными.  **Требования к ссылкам**  * Ссылок может быть до 30. * Указывайте ссылку целиком, включая протокол http или https. * Максимальная длина — 512 символов. * Русские буквы в URL можно. * Можно использовать прямые ссылки на изображения и на Яндекс Диск. Ссылки на Яндекс Диске нужно копировать с помощью функции **Поделиться**. Относительные ссылки и ссылки на другие облачные хранилища — не работают.  ✅ `https://example-shop.ru/images/sku12345.jpg`  ✅ `https://yadi.sk/i/NaBoRsimVOLov`  ❌ `/images/sku12345.jpg`  ❌ `https://www.dropbox.com/s/818f/tovar.jpg`  Ссылки на изображение должны быть постоянными. Нельзя использовать динамические ссылки, меняющиеся от выгрузки к выгрузке.  Если нужно заменить изображение, выложите новое изображение по новой ссылке, а ссылку на старое удалите. Если просто заменить изображение по старой ссылке, оно не обновится.  [Требования к изображениям](https://yandex.ru/support/marketplace/assortment/fields/images.html) 
    #[serde(rename = "pictures")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub pictures: Option<swagger::Nullable<Vec<String>>>,

    /// Ссылка (URL) на видео товара.  Максимальное количество ссылок — 6.  **Требования к ссылке**  * Указывайте ссылку целиком, включая протокол http или https. * Максимальная длина — 512 символов. * Русские буквы в URL можно. * Можно использовать прямые ссылки на видео и на Яндекс Диск. Ссылки на Яндекс Диске нужно копировать с помощью функции **Поделиться**. Относительные ссылки и ссылки на другие облачные хранилища — не работают.  ✅ `https://example-shop.ru/video/sku12345.avi`  ✅ `https://yadi.sk/i/NaBoRsimVOLov`  ❌ `/video/sku12345.avi`  ❌ `https://www.dropbox.com/s/818f/super-tovar.avi`  Ссылки на видео должны быть постоянными. Нельзя использовать динамические ссылки, меняющиеся от выгрузки к выгрузке.  Если нужно заменить видео, выложите новое видео по новой ссылке, а ссылку на старое удалите. Если просто заменить видео по старой ссылке, оно не обновится.  [Требования к видео](https://yandex.ru/support/marketplace/assortment/fields/video.html) 
    #[serde(rename = "videos")]
    #[validate(
            length(max = 6),
        )]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub videos: Option<swagger::Nullable<Vec<String>>>,

    /// Список инструкций по использованию товара.  Максимальное количество инструкций — 6.  Если вы передадите пустое поле `manuals`, загруженные ранее инструкции удалятся. 
    #[serde(rename = "manuals")]
    #[validate(
            length(max = 6),
        )]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub manuals: Option<swagger::Nullable<Vec<models::OfferManualDto>>>,

    /// Название бренда или производителя. Должно быть записано так, как его пишет сам бренд.
    #[serde(rename = "vendor")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub vendor: Option<String>,

    /// Указывайте в виде последовательности цифр. Подойдут коды EAN-13, EAN-8, UPC-A, UPC-E или Code 128.  Для книг указывайте ISBN.  Для товаров [определенных категорий и торговых марок](https://yastatic.net/s3/doc-binary/src/support/market/ru/yandex-market-list-for-gtin.xlsx) штрихкод должен быть действительным кодом GTIN. Обратите внимание: внутренние штрихкоды, начинающиеся на 2 или 02, и коды формата Code 128 не являются GTIN.  [Что такое GTIN](*gtin)  
    #[serde(rename = "barcodes")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub barcodes: Option<swagger::Nullable<Vec<String>>>,

    /// Подробное описание товара: например, его преимущества и особенности.  Не давайте в описании инструкций по установке и сборке. Не используйте слова «скидка», «распродажа», «дешевый», «подарок» (кроме подарочных категорий), «бесплатно», «акция», «специальная цена», «новинка», «new», «аналог», «заказ», «хит». Не указывайте никакой контактной информации и не давайте ссылок.  Можно использовать теги:  * \\<h>, \\<h1>, \\<h2> и так далее — для заголовков; * \\<br> и \\<p> — для переноса строки; * \\<ol> — для нумерованного списка; * \\<ul> — для маркированного списка; * \\<li> — для создания элементов списка (должен находиться внутри \\<ol> или \\<ul>); * \\<div> — поддерживается, но не влияет на отображение текста.  Оптимальная длина — 400–600 символов, максимальная — 6000.  [Рекомендации и правила](https://yandex.ru/support/marketplace/assortment/fields/description.html) 
    #[serde(rename = "description")]
    #[validate(
            length(max = 6000),
        )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,

    /// Страна, где был произведен товар.  Записывайте названия стран так, как они записаны в [списке](https://yastatic.net/s3/doc-binary/src/support/market/ru/countries.xlsx). 
    #[serde(rename = "manufacturerCountries")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub manufacturer_countries: Option<swagger::Nullable<Vec<String>>>,

    #[serde(rename = "weightDimensions")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub weight_dimensions: Option<models::OfferWeightDimensionsDto>,

    /// Артикул товара от производителя.
    #[serde(rename = "vendorCode")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub vendor_code: Option<String>,

    /// Метки товара, используемые магазином. Покупателям теги не видны. По тегам можно группировать и фильтровать разные товары в каталоге — например, товары одной серии, коллекции или линейки.  Максимальная длина тега 20 символов. У одного товара может быть максимум 10 тегов. Всего можно создать не больше 50 разных тегов. 
    #[serde(rename = "tags")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub tags: Option<swagger::Nullable<Vec<String>>>,

    #[serde(rename = "shelfLife")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub shelf_life: Option<models::TimePeriodDto>,

    #[serde(rename = "lifeTime")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub life_time: Option<models::TimePeriodDto>,

    #[serde(rename = "guaranteePeriod")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub guarantee_period: Option<models::TimePeriodDto>,

    /// Код товара в единой Товарной номенклатуре внешнеэкономической деятельности (ТН ВЭД) — 10 или 14 цифр без пробелов.  Обязательно укажите, если он есть. 
    #[serde(rename = "customsCommodityCode")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub customs_commodity_code: Option<String>,

    /// Номера документов на товар: сертификата, декларации соответствия и т. п.  Передавать можно только номера документов, сканы которого загружены в кабинете продавца по [инструкции](https://yandex.ru/support/marketplace/assortment/restrictions/certificates.html). 
    #[serde(rename = "certificates")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub certificates: Option<swagger::Nullable<Vec<String>>>,

    /// Количество грузовых мест.  Параметр используется, если товар представляет собой несколько коробок, упаковок и так далее. Например, кондиционер занимает два места — внешний и внутренний блоки в двух коробках.  Для товаров, занимающих одно место, не передавайте этот параметр. 
    #[serde(rename = "boxCount")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub box_count: Option<i32>,

    #[serde(rename = "condition")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub condition: Option<models::OfferConditionDto>,

    #[serde(rename = "type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub r#type: Option<models::OfferType>,

    /// Признак цифрового товара. Укажите `true`, если товар доставляется по электронной почте.  [Как работать с цифровыми товарами](../../step-by-step/digital.md) 
    #[serde(rename = "downloadable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub downloadable: Option<bool>,

    /// Параметр включает для товара пометку 18+. Устанавливайте ее только для товаров, которые относятся к удовлетворению сексуальных потребностей. 
    #[serde(rename = "adult")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub adult: Option<bool>,

    #[serde(rename = "age")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub age: Option<models::AgeDto>,

    /// {% note warning \"\" %}  Этот параметр устарел. При передаче характеристик используйте `parameterValues`.  {% endnote %}  Характеристики, которые есть только у товаров конкретной категории — например, диаметр колес велосипеда или материал подошвы обуви. 
    #[serde(rename = "params")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub params: Option<swagger::Nullable<Vec<models::OfferParamDto>>>,

}

lazy_static::lazy_static! {
    static ref RE_BASEOFFERDTO_OFFER_ID: regex::Regex = regex::Regex::new(r"^[^\\x00-\\x08\\x0A-\\x1f\\x7f]{1,255}$").unwrap();
}

impl BaseOfferDto {
    #[allow(clippy::new_without_default)]
    pub fn new(offer_id: String, ) -> BaseOfferDto {
        BaseOfferDto {
            offer_id,
            name: None,
            market_category_id: None,
            category: None,
            pictures: None,
            videos: None,
            manuals: None,
            vendor: None,
            barcodes: None,
            description: None,
            manufacturer_countries: None,
            weight_dimensions: None,
            vendor_code: None,
            tags: None,
            shelf_life: None,
            life_time: None,
            guarantee_period: None,
            customs_commodity_code: None,
            certificates: None,
            box_count: None,
            condition: None,
            r#type: None,
            downloadable: None,
            adult: None,
            age: None,
            params: None,
        }
    }
}

/// Converts the BaseOfferDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for BaseOfferDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            Some("offerId".to_string()),
            Some(self.offer_id.to_string()),


            self.name.as_ref().map(|name| {
                [
                    "name".to_string(),
                    name.to_string(),
                ].join(",")
            }),


            self.market_category_id.as_ref().map(|market_category_id| {
                [
                    "marketCategoryId".to_string(),
                    market_category_id.to_string(),
                ].join(",")
            }),


            self.category.as_ref().map(|category| {
                [
                    "category".to_string(),
                    category.to_string(),
                ].join(",")
            }),


            self.pictures.as_ref().map(|pictures| {
                [
                    "pictures".to_string(),
                    pictures.as_ref().map_or("null".to_string(), |x| x.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),
                ].join(",")
            }),


            self.videos.as_ref().map(|videos| {
                [
                    "videos".to_string(),
                    videos.as_ref().map_or("null".to_string(), |x| x.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),
                ].join(",")
            }),

            // Skipping manuals in query parameter serialization


            self.vendor.as_ref().map(|vendor| {
                [
                    "vendor".to_string(),
                    vendor.to_string(),
                ].join(",")
            }),


            self.barcodes.as_ref().map(|barcodes| {
                [
                    "barcodes".to_string(),
                    barcodes.as_ref().map_or("null".to_string(), |x| x.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),
                ].join(",")
            }),


            self.description.as_ref().map(|description| {
                [
                    "description".to_string(),
                    description.to_string(),
                ].join(",")
            }),


            self.manufacturer_countries.as_ref().map(|manufacturer_countries| {
                [
                    "manufacturerCountries".to_string(),
                    manufacturer_countries.as_ref().map_or("null".to_string(), |x| x.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),
                ].join(",")
            }),

            // Skipping weightDimensions in query parameter serialization


            self.vendor_code.as_ref().map(|vendor_code| {
                [
                    "vendorCode".to_string(),
                    vendor_code.to_string(),
                ].join(",")
            }),


            self.tags.as_ref().map(|tags| {
                [
                    "tags".to_string(),
                    tags.as_ref().map_or("null".to_string(), |x| x.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),
                ].join(",")
            }),

            // Skipping shelfLife in query parameter serialization

            // Skipping lifeTime in query parameter serialization

            // Skipping guaranteePeriod in query parameter serialization


            self.customs_commodity_code.as_ref().map(|customs_commodity_code| {
                [
                    "customsCommodityCode".to_string(),
                    customs_commodity_code.to_string(),
                ].join(",")
            }),


            self.certificates.as_ref().map(|certificates| {
                [
                    "certificates".to_string(),
                    certificates.as_ref().map_or("null".to_string(), |x| x.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),
                ].join(",")
            }),


            self.box_count.as_ref().map(|box_count| {
                [
                    "boxCount".to_string(),
                    box_count.to_string(),
                ].join(",")
            }),

            // Skipping condition in query parameter serialization

            // Skipping type in query parameter serialization


            self.downloadable.as_ref().map(|downloadable| {
                [
                    "downloadable".to_string(),
                    downloadable.to_string(),
                ].join(",")
            }),


            self.adult.as_ref().map(|adult| {
                [
                    "adult".to_string(),
                    adult.to_string(),
                ].join(",")
            }),

            // Skipping age in query parameter serialization

            // Skipping params in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a BaseOfferDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for BaseOfferDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub offer_id: Vec<String>,
            pub name: Vec<String>,
            pub market_category_id: Vec<i64>,
            pub category: Vec<String>,
            pub pictures: Vec<Vec<String>>,
            pub videos: Vec<Vec<String>>,
            pub manuals: Vec<Vec<models::OfferManualDto>>,
            pub vendor: Vec<String>,
            pub barcodes: Vec<Vec<String>>,
            pub description: Vec<String>,
            pub manufacturer_countries: Vec<Vec<String>>,
            pub weight_dimensions: Vec<models::OfferWeightDimensionsDto>,
            pub vendor_code: Vec<String>,
            pub tags: Vec<Vec<String>>,
            pub shelf_life: Vec<models::TimePeriodDto>,
            pub life_time: Vec<models::TimePeriodDto>,
            pub guarantee_period: Vec<models::TimePeriodDto>,
            pub customs_commodity_code: Vec<String>,
            pub certificates: Vec<Vec<String>>,
            pub box_count: Vec<i32>,
            pub condition: Vec<models::OfferConditionDto>,
            pub r#type: Vec<models::OfferType>,
            pub downloadable: Vec<bool>,
            pub adult: Vec<bool>,
            pub age: Vec<models::AgeDto>,
            pub params: Vec<Vec<models::OfferParamDto>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing BaseOfferDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "offerId" => intermediate_rep.offer_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "marketCategoryId" => intermediate_rep.market_category_id.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "category" => intermediate_rep.category.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "pictures" => return std::result::Result::Err("Parsing a container in this style is not supported in BaseOfferDto".to_string()),
                    "videos" => return std::result::Result::Err("Parsing a container in this style is not supported in BaseOfferDto".to_string()),
                    "manuals" => return std::result::Result::Err("Parsing a container in this style is not supported in BaseOfferDto".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "vendor" => intermediate_rep.vendor.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "barcodes" => return std::result::Result::Err("Parsing a container in this style is not supported in BaseOfferDto".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "description" => intermediate_rep.description.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "manufacturerCountries" => return std::result::Result::Err("Parsing a container in this style is not supported in BaseOfferDto".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "weightDimensions" => intermediate_rep.weight_dimensions.push(<models::OfferWeightDimensionsDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "vendorCode" => intermediate_rep.vendor_code.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "tags" => return std::result::Result::Err("Parsing a container in this style is not supported in BaseOfferDto".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "shelfLife" => intermediate_rep.shelf_life.push(<models::TimePeriodDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "lifeTime" => intermediate_rep.life_time.push(<models::TimePeriodDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "guaranteePeriod" => intermediate_rep.guarantee_period.push(<models::TimePeriodDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "customsCommodityCode" => intermediate_rep.customs_commodity_code.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "certificates" => return std::result::Result::Err("Parsing a container in this style is not supported in BaseOfferDto".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "boxCount" => intermediate_rep.box_count.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "condition" => intermediate_rep.condition.push(<models::OfferConditionDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r#type.push(<models::OfferType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "downloadable" => intermediate_rep.downloadable.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "adult" => intermediate_rep.adult.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "age" => intermediate_rep.age.push(<models::AgeDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "params" => return std::result::Result::Err("Parsing a container in this style is not supported in BaseOfferDto".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing BaseOfferDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(BaseOfferDto {
            offer_id: intermediate_rep.offer_id.into_iter().next().ok_or_else(|| "offerId missing in BaseOfferDto".to_string())?,
            name: intermediate_rep.name.into_iter().next(),
            market_category_id: intermediate_rep.market_category_id.into_iter().next(),
            category: intermediate_rep.category.into_iter().next(),
            pictures: std::result::Result::Err("Nullable types not supported in BaseOfferDto".to_string())?,
            videos: std::result::Result::Err("Nullable types not supported in BaseOfferDto".to_string())?,
            manuals: std::result::Result::Err("Nullable types not supported in BaseOfferDto".to_string())?,
            vendor: intermediate_rep.vendor.into_iter().next(),
            barcodes: std::result::Result::Err("Nullable types not supported in BaseOfferDto".to_string())?,
            description: intermediate_rep.description.into_iter().next(),
            manufacturer_countries: std::result::Result::Err("Nullable types not supported in BaseOfferDto".to_string())?,
            weight_dimensions: intermediate_rep.weight_dimensions.into_iter().next(),
            vendor_code: intermediate_rep.vendor_code.into_iter().next(),
            tags: std::result::Result::Err("Nullable types not supported in BaseOfferDto".to_string())?,
            shelf_life: intermediate_rep.shelf_life.into_iter().next(),
            life_time: intermediate_rep.life_time.into_iter().next(),
            guarantee_period: intermediate_rep.guarantee_period.into_iter().next(),
            customs_commodity_code: intermediate_rep.customs_commodity_code.into_iter().next(),
            certificates: std::result::Result::Err("Nullable types not supported in BaseOfferDto".to_string())?,
            box_count: intermediate_rep.box_count.into_iter().next(),
            condition: intermediate_rep.condition.into_iter().next(),
            r#type: intermediate_rep.r#type.into_iter().next(),
            downloadable: intermediate_rep.downloadable.into_iter().next(),
            adult: intermediate_rep.adult.into_iter().next(),
            age: intermediate_rep.age.into_iter().next(),
            params: std::result::Result::Err("Nullable types not supported in BaseOfferDto".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<BaseOfferDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<BaseOfferDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<BaseOfferDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for BaseOfferDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<BaseOfferDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <BaseOfferDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into BaseOfferDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Цена на товар.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct BasePriceDto {
    /// Значение.
    #[serde(rename = "value")]
    #[validate(
            range(min = 0),
        )]
    pub value: f64,

    #[serde(rename = "currencyId")]
    pub currency_id: models::CurrencyType,

}


impl BasePriceDto {
    #[allow(clippy::new_without_default)]
    pub fn new(value: f64, currency_id: models::CurrencyType, ) -> BasePriceDto {
        BasePriceDto {
            value,
            currency_id,
        }
    }
}

/// Converts the BasePriceDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for BasePriceDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            Some("value".to_string()),
            Some(self.value.to_string()),

            // Skipping currencyId in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a BasePriceDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for BasePriceDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub value: Vec<f64>,
            pub currency_id: Vec<models::CurrencyType>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing BasePriceDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "value" => intermediate_rep.value.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "currencyId" => intermediate_rep.currency_id.push(<models::CurrencyType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing BasePriceDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(BasePriceDto {
            value: intermediate_rep.value.into_iter().next().ok_or_else(|| "value missing in BasePriceDto".to_string())?,
            currency_id: intermediate_rep.currency_id.into_iter().next().ok_or_else(|| "currencyId missing in BasePriceDto".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<BasePriceDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<BasePriceDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<BasePriceDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for BasePriceDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<BasePriceDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <BasePriceDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into BasePriceDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Информация об отгрузке.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct BaseShipmentDto {
    /// Идентификатор отгрузки.
    #[serde(rename = "id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,

    /// Начало планового интервала отгрузки.
    #[serde(rename = "planIntervalFrom")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub plan_interval_from: Option<chrono::DateTime::<chrono::Utc>>,

    /// Конец планового интервала отгрузки.
    #[serde(rename = "planIntervalTo")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub plan_interval_to: Option<chrono::DateTime::<chrono::Utc>>,

    #[serde(rename = "shipmentType")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub shipment_type: Option<models::ShipmentType>,

    #[serde(rename = "warehouse")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub warehouse: Option<models::PartnerShipmentWarehouseDto>,

    #[serde(rename = "warehouseTo")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub warehouse_to: Option<models::PartnerShipmentWarehouseDto>,

    /// Идентификатор отгрузки в вашей системе. Если вы еще не передавали идентификатор, вернется идентификатор из параметра `id`.
    #[serde(rename = "externalId")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub external_id: Option<String>,

    #[serde(rename = "deliveryService")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub delivery_service: Option<models::DeliveryServiceDto>,

    #[serde(rename = "palletsCount")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub pallets_count: Option<models::PalletsCountDto>,

    /// Идентификаторы заказов в отгрузке.
    #[serde(rename = "orderIds")]
    #[validate(
        )]
    pub order_ids: Vec<i64>,

    /// Количество заказов, которое Маркет запланировал к отгрузке.
    #[serde(rename = "draftCount")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub draft_count: Option<i32>,

    /// Количество заказов, которое Маркет подтвердил к отгрузке.
    #[serde(rename = "plannedCount")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub planned_count: Option<i32>,

    /// Количество заказов, принятых в сортировочном центре или пункте приема.
    #[serde(rename = "factCount")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub fact_count: Option<i32>,

}


impl BaseShipmentDto {
    #[allow(clippy::new_without_default)]
    pub fn new(order_ids: Vec<i64>, ) -> BaseShipmentDto {
        BaseShipmentDto {
            id: None,
            plan_interval_from: None,
            plan_interval_to: None,
            shipment_type: None,
            warehouse: None,
            warehouse_to: None,
            external_id: None,
            delivery_service: None,
            pallets_count: None,
            order_ids,
            draft_count: None,
            planned_count: None,
            fact_count: None,
        }
    }
}

/// Converts the BaseShipmentDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for BaseShipmentDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.id.as_ref().map(|id| {
                [
                    "id".to_string(),
                    id.to_string(),
                ].join(",")
            }),

            // Skipping planIntervalFrom in query parameter serialization

            // Skipping planIntervalTo in query parameter serialization

            // Skipping shipmentType in query parameter serialization

            // Skipping warehouse in query parameter serialization

            // Skipping warehouseTo in query parameter serialization


            self.external_id.as_ref().map(|external_id| {
                [
                    "externalId".to_string(),
                    external_id.to_string(),
                ].join(",")
            }),

            // Skipping deliveryService in query parameter serialization

            // Skipping palletsCount in query parameter serialization


            Some("orderIds".to_string()),
            Some(self.order_ids.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),


            self.draft_count.as_ref().map(|draft_count| {
                [
                    "draftCount".to_string(),
                    draft_count.to_string(),
                ].join(",")
            }),


            self.planned_count.as_ref().map(|planned_count| {
                [
                    "plannedCount".to_string(),
                    planned_count.to_string(),
                ].join(",")
            }),


            self.fact_count.as_ref().map(|fact_count| {
                [
                    "factCount".to_string(),
                    fact_count.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a BaseShipmentDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for BaseShipmentDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<i64>,
            pub plan_interval_from: Vec<chrono::DateTime::<chrono::Utc>>,
            pub plan_interval_to: Vec<chrono::DateTime::<chrono::Utc>>,
            pub shipment_type: Vec<models::ShipmentType>,
            pub warehouse: Vec<models::PartnerShipmentWarehouseDto>,
            pub warehouse_to: Vec<models::PartnerShipmentWarehouseDto>,
            pub external_id: Vec<String>,
            pub delivery_service: Vec<models::DeliveryServiceDto>,
            pub pallets_count: Vec<models::PalletsCountDto>,
            pub order_ids: Vec<Vec<i64>>,
            pub draft_count: Vec<i32>,
            pub planned_count: Vec<i32>,
            pub fact_count: Vec<i32>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing BaseShipmentDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "planIntervalFrom" => intermediate_rep.plan_interval_from.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "planIntervalTo" => intermediate_rep.plan_interval_to.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "shipmentType" => intermediate_rep.shipment_type.push(<models::ShipmentType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "warehouse" => intermediate_rep.warehouse.push(<models::PartnerShipmentWarehouseDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "warehouseTo" => intermediate_rep.warehouse_to.push(<models::PartnerShipmentWarehouseDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "externalId" => intermediate_rep.external_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "deliveryService" => intermediate_rep.delivery_service.push(<models::DeliveryServiceDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "palletsCount" => intermediate_rep.pallets_count.push(<models::PalletsCountDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "orderIds" => return std::result::Result::Err("Parsing a container in this style is not supported in BaseShipmentDto".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "draftCount" => intermediate_rep.draft_count.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "plannedCount" => intermediate_rep.planned_count.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "factCount" => intermediate_rep.fact_count.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing BaseShipmentDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(BaseShipmentDto {
            id: intermediate_rep.id.into_iter().next(),
            plan_interval_from: intermediate_rep.plan_interval_from.into_iter().next(),
            plan_interval_to: intermediate_rep.plan_interval_to.into_iter().next(),
            shipment_type: intermediate_rep.shipment_type.into_iter().next(),
            warehouse: intermediate_rep.warehouse.into_iter().next(),
            warehouse_to: intermediate_rep.warehouse_to.into_iter().next(),
            external_id: intermediate_rep.external_id.into_iter().next(),
            delivery_service: intermediate_rep.delivery_service.into_iter().next(),
            pallets_count: intermediate_rep.pallets_count.into_iter().next(),
            order_ids: intermediate_rep.order_ids.into_iter().next().ok_or_else(|| "orderIds missing in BaseShipmentDto".to_string())?,
            draft_count: intermediate_rep.draft_count.into_iter().next(),
            planned_count: intermediate_rep.planned_count.into_iter().next(),
            fact_count: intermediate_rep.fact_count.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<BaseShipmentDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<BaseShipmentDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<BaseShipmentDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for BaseShipmentDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<BaseShipmentDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <BaseShipmentDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into BaseShipmentDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Значение ставки.
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Bid(i32);

impl std::convert::From<i32> for Bid {
    fn from(x: i32) -> Self {
        Bid(x)
    }
}

impl std::convert::From<Bid> for i32 {
    fn from(x: Bid) -> Self {
        x.0
    }
}

impl std::ops::Deref for Bid {
    type Target = i32;
    fn deref(&self) -> &i32 {
        &self.0
    }
}

impl std::ops::DerefMut for Bid {
    fn deref_mut(&mut self) -> &mut i32 {
        &mut self.0
    }
}


/// Рекомендованная ставка и возможная доля показов.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct BidRecommendationItemDto {
    /// Значение ставки.
    #[serde(rename = "bid")]
    #[validate(
            range(min = 0, max = 9999),
        )]
    pub bid: u32,

    /// Доля показов. 
    #[serde(rename = "showPercent")]
    #[validate(
            range(min = 0, max = 100),
        )]
    pub show_percent: i64,

}


impl BidRecommendationItemDto {
    #[allow(clippy::new_without_default)]
    pub fn new(bid: u32, show_percent: i64, ) -> BidRecommendationItemDto {
        BidRecommendationItemDto {
            bid,
            show_percent,
        }
    }
}

/// Converts the BidRecommendationItemDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for BidRecommendationItemDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            Some("bid".to_string()),
            Some(self.bid.to_string()),


            Some("showPercent".to_string()),
            Some(self.show_percent.to_string()),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a BidRecommendationItemDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for BidRecommendationItemDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub bid: Vec<u32>,
            pub show_percent: Vec<i64>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing BidRecommendationItemDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "bid" => intermediate_rep.bid.push(<u32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "showPercent" => intermediate_rep.show_percent.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing BidRecommendationItemDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(BidRecommendationItemDto {
            bid: intermediate_rep.bid.into_iter().next().ok_or_else(|| "bid missing in BidRecommendationItemDto".to_string())?,
            show_percent: intermediate_rep.show_percent.into_iter().next().ok_or_else(|| "showPercent missing in BidRecommendationItemDto".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<BidRecommendationItemDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<BidRecommendationItemDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<BidRecommendationItemDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for BidRecommendationItemDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<BidRecommendationItemDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <BidRecommendationItemDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into BidRecommendationItemDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Информация о маркированном товаре.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct BriefOrderItemDto {
    /// Идентификатор товара в заказе.  Позволяет идентифицировать товар в рамках данного заказа. 
    #[serde(rename = "id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,

    #[serde(rename = "vat")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub vat: Option<models::OrderVatType>,

    /// Количество единиц товара.
    #[serde(rename = "count")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub count: Option<i32>,

    /// Цена на товар. Указана в той валюте, которая была задана в каталоге. Разделитель целой и дробной части — точка. 
    #[serde(rename = "price")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub price: Option<f64>,

    /// Название товара.
    #[serde(rename = "offerName")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub offer_name: Option<String>,

    /// Ваш SKU — идентификатор товара в вашей системе.  Разрешена любая последовательность длиной до 255 знаков.  Правила использования SKU:  * У каждого товара SKU должен быть свой.  * SKU товара нельзя менять — можно только удалить товар и добавить заново с новым SKU.  * Уже заданный SKU нельзя освободить и использовать заново для другого товара. Каждый товар должен получать новый идентификатор, до того никогда не использовавшийся в вашем каталоге.  [Что такое SKU и как его назначать](https://yandex.ru/support/marketplace/assortment/add/index.html#fields) 
    #[serde(rename = "offerId")]
    #[validate(
            length(min = 1, max = 255),
           regex = "RE_BRIEFORDERITEMDTO_OFFER_ID",
        )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub offer_id: Option<String>,

    /// Переданные вами коды маркировки.
    #[serde(rename = "instances")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub instances: Option<swagger::Nullable<Vec<models::OrderItemInstanceDto>>>,

}

lazy_static::lazy_static! {
    static ref RE_BRIEFORDERITEMDTO_OFFER_ID: regex::Regex = regex::Regex::new(r"^[^\\x00-\\x08\\x0A-\\x1f\\x7f]{1,255}$").unwrap();
}

impl BriefOrderItemDto {
    #[allow(clippy::new_without_default)]
    pub fn new() -> BriefOrderItemDto {
        BriefOrderItemDto {
            id: None,
            vat: None,
            count: None,
            price: None,
            offer_name: None,
            offer_id: None,
            instances: None,
        }
    }
}

/// Converts the BriefOrderItemDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for BriefOrderItemDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.id.as_ref().map(|id| {
                [
                    "id".to_string(),
                    id.to_string(),
                ].join(",")
            }),

            // Skipping vat in query parameter serialization


            self.count.as_ref().map(|count| {
                [
                    "count".to_string(),
                    count.to_string(),
                ].join(",")
            }),


            self.price.as_ref().map(|price| {
                [
                    "price".to_string(),
                    price.to_string(),
                ].join(",")
            }),


            self.offer_name.as_ref().map(|offer_name| {
                [
                    "offerName".to_string(),
                    offer_name.to_string(),
                ].join(",")
            }),


            self.offer_id.as_ref().map(|offer_id| {
                [
                    "offerId".to_string(),
                    offer_id.to_string(),
                ].join(",")
            }),

            // Skipping instances in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a BriefOrderItemDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for BriefOrderItemDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<i64>,
            pub vat: Vec<models::OrderVatType>,
            pub count: Vec<i32>,
            pub price: Vec<f64>,
            pub offer_name: Vec<String>,
            pub offer_id: Vec<String>,
            pub instances: Vec<Vec<models::OrderItemInstanceDto>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing BriefOrderItemDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "vat" => intermediate_rep.vat.push(<models::OrderVatType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "count" => intermediate_rep.count.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "price" => intermediate_rep.price.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "offerName" => intermediate_rep.offer_name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "offerId" => intermediate_rep.offer_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "instances" => return std::result::Result::Err("Parsing a container in this style is not supported in BriefOrderItemDto".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing BriefOrderItemDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(BriefOrderItemDto {
            id: intermediate_rep.id.into_iter().next(),
            vat: intermediate_rep.vat.into_iter().next(),
            count: intermediate_rep.count.into_iter().next(),
            price: intermediate_rep.price.into_iter().next(),
            offer_name: intermediate_rep.offer_name.into_iter().next(),
            offer_id: intermediate_rep.offer_id.into_iter().next(),
            instances: std::result::Result::Err("Nullable types not supported in BriefOrderItemDto".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<BriefOrderItemDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<BriefOrderItemDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<BriefOrderItemDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for BriefOrderItemDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<BriefOrderItemDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <BriefOrderItemDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into BriefOrderItemDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Идентификатор единицы товара.  Заполните только одно поле в зависимости от того, в какой системе маркирован товар.  Подробно о работе с маркируемыми товарами рассказано [в Справке Маркета для продавцов](https://yandex.ru/support/marketplace/orders/cz.html). 
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct BriefOrderItemInstanceDto {
    /// Код идентификации единицы товара [в системе «Честный ЗНАК»](https://честныйзнак.рф/).  {% note warning %}  Не экранируйте косую черту в коде символа-разделителя `\\u001d`!  ✅ `01030410947874432155Qbag!\\u001d93Zjqw`  ❌ `01030410947874432155Qbag!\\\\u001d93Zjqw`  Косые черты и кавычки в других местах экранируйте по правилам JSON: `\\\\` и `\\\"`  {% endnote %} 
    #[serde(rename = "cis")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub cis: Option<String>,

    /// Уникальный идентификационный номер ювелирного изделия.  Представляет собой число из 16 цифр. 
    #[serde(rename = "uin")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub uin: Option<String>,

    /// Регистрационный номер партии товара.  Представляет собой строку из четырех чисел, разделенных косой чертой: ХХХХХХХХ/ХХХХХХ/ХХХХХХХ/ХХХ.  Первая часть — код таможни, которая зарегистрировала декларацию на партию товара. Далее — дата, номер декларации и номер маркированного товара в декларации. 
    #[serde(rename = "rnpt")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub rnpt: Option<String>,

    /// Грузовая таможенная декларация.  Представляет собой строку из трех чисел, разделенных косой чертой: ХХХХХХХХ/ХХХХХХ/ХХХХХХХ.  Первая часть — код таможни, которая зарегистрировала декларацию на ввезенные товары. Далее — дата и номер декларации. 
    #[serde(rename = "gtd")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub gtd: Option<String>,

}


impl BriefOrderItemInstanceDto {
    #[allow(clippy::new_without_default)]
    pub fn new() -> BriefOrderItemInstanceDto {
        BriefOrderItemInstanceDto {
            cis: None,
            uin: None,
            rnpt: None,
            gtd: None,
        }
    }
}

/// Converts the BriefOrderItemInstanceDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for BriefOrderItemInstanceDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.cis.as_ref().map(|cis| {
                [
                    "cis".to_string(),
                    cis.to_string(),
                ].join(",")
            }),


            self.uin.as_ref().map(|uin| {
                [
                    "uin".to_string(),
                    uin.to_string(),
                ].join(",")
            }),


            self.rnpt.as_ref().map(|rnpt| {
                [
                    "rnpt".to_string(),
                    rnpt.to_string(),
                ].join(",")
            }),


            self.gtd.as_ref().map(|gtd| {
                [
                    "gtd".to_string(),
                    gtd.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a BriefOrderItemInstanceDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for BriefOrderItemInstanceDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub cis: Vec<String>,
            pub uin: Vec<String>,
            pub rnpt: Vec<String>,
            pub gtd: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing BriefOrderItemInstanceDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "cis" => intermediate_rep.cis.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "uin" => intermediate_rep.uin.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "rnpt" => intermediate_rep.rnpt.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "gtd" => intermediate_rep.gtd.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing BriefOrderItemInstanceDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(BriefOrderItemInstanceDto {
            cis: intermediate_rep.cis.into_iter().next(),
            uin: intermediate_rep.uin.into_iter().next(),
            rnpt: intermediate_rep.rnpt.into_iter().next(),
            gtd: intermediate_rep.gtd.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<BriefOrderItemInstanceDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<BriefOrderItemInstanceDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<BriefOrderItemInstanceDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for BriefOrderItemInstanceDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<BriefOrderItemInstanceDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <BriefOrderItemInstanceDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into BriefOrderItemInstanceDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Информация о кабинете.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct BusinessDto {
    /// Идентификатор кабинета.
    #[serde(rename = "id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,

    /// Название бизнеса.
    #[serde(rename = "name")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

}


impl BusinessDto {
    #[allow(clippy::new_without_default)]
    pub fn new() -> BusinessDto {
        BusinessDto {
            id: None,
            name: None,
        }
    }
}

/// Converts the BusinessDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for BusinessDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.id.as_ref().map(|id| {
                [
                    "id".to_string(),
                    id.to_string(),
                ].join(",")
            }),


            self.name.as_ref().map(|name| {
                [
                    "name".to_string(),
                    name.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a BusinessDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for BusinessDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<i64>,
            pub name: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing BusinessDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing BusinessDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(BusinessDto {
            id: intermediate_rep.id.into_iter().next(),
            name: intermediate_rep.name.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<BusinessDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<BusinessDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<BusinessDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for BusinessDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<BusinessDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <BusinessDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into BusinessDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Настройки кабинета.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct BusinessSettingsDto {
    /// Можно ли установить только [базовую цену](*rule): * `false` — можно задать и базовую цену, и цены в конкретных магазинах. * `true` — можно задать только базовую цену. 
    #[serde(rename = "onlyDefaultPrice")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub only_default_price: Option<bool>,

    #[serde(rename = "currency")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub currency: Option<models::CurrencyType>,

}


impl BusinessSettingsDto {
    #[allow(clippy::new_without_default)]
    pub fn new() -> BusinessSettingsDto {
        BusinessSettingsDto {
            only_default_price: None,
            currency: None,
        }
    }
}

/// Converts the BusinessSettingsDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for BusinessSettingsDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.only_default_price.as_ref().map(|only_default_price| {
                [
                    "onlyDefaultPrice".to_string(),
                    only_default_price.to_string(),
                ].join(",")
            }),

            // Skipping currency in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a BusinessSettingsDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for BusinessSettingsDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub only_default_price: Vec<bool>,
            pub currency: Vec<models::CurrencyType>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing BusinessSettingsDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "onlyDefaultPrice" => intermediate_rep.only_default_price.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "currency" => intermediate_rep.currency.push(<models::CurrencyType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing BusinessSettingsDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(BusinessSettingsDto {
            only_default_price: intermediate_rep.only_default_price.into_iter().next(),
            currency: intermediate_rep.currency.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<BusinessSettingsDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<BusinessSettingsDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<BusinessSettingsDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for BusinessSettingsDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<BusinessSettingsDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <BusinessSettingsDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into BusinessSettingsDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Параметры товара, для которого нужно рассчитать стоимость услуг.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CalculateTariffsOfferDto {
    /// Идентификатор категории товара на Маркете.  Для расчета стоимости услуг необходимо указать идентификатор листовой категории товара — той, которая не имеет дочерних категорий.  Чтобы узнать идентификатор категории, к которой относится товар, воспользуйтесь запросом [POST categories/tree](../../reference/categories/getCategoriesTree.md). 
    #[serde(rename = "categoryId")]
    #[validate(
            range(min = 0),
        )]
    pub category_id: i64,

    /// Цена на товар в рублях.
    #[serde(rename = "price")]
    #[validate(
            range(min = 0),
        )]
    pub price: f64,

    /// Длина товара в сантиметрах.
    #[serde(rename = "length")]
    #[validate(
            range(min = 0),
        )]
    pub length: f64,

    /// Ширина товара в сантиметрах.
    #[serde(rename = "width")]
    #[validate(
            range(min = 0),
        )]
    pub width: f64,

    /// Высота товара в сантиметрах.
    #[serde(rename = "height")]
    #[validate(
            range(min = 0),
        )]
    pub height: f64,

    /// Вес товара в килограммах.
    #[serde(rename = "weight")]
    #[validate(
            range(min = 0),
        )]
    pub weight: f64,

    /// Квант продажи — количество единиц товара в одном товарном предложении.
    #[serde(rename = "quantity")]
    #[validate(
            range(min = 1),
        )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub quantity: Option<u32>,

}


impl CalculateTariffsOfferDto {
    #[allow(clippy::new_without_default)]
    pub fn new(category_id: i64, price: f64, length: f64, width: f64, height: f64, weight: f64, ) -> CalculateTariffsOfferDto {
        CalculateTariffsOfferDto {
            category_id,
            price,
            length,
            width,
            height,
            weight,
            quantity: Some(1),
        }
    }
}

/// Converts the CalculateTariffsOfferDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for CalculateTariffsOfferDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            Some("categoryId".to_string()),
            Some(self.category_id.to_string()),


            Some("price".to_string()),
            Some(self.price.to_string()),


            Some("length".to_string()),
            Some(self.length.to_string()),


            Some("width".to_string()),
            Some(self.width.to_string()),


            Some("height".to_string()),
            Some(self.height.to_string()),


            Some("weight".to_string()),
            Some(self.weight.to_string()),


            self.quantity.as_ref().map(|quantity| {
                [
                    "quantity".to_string(),
                    quantity.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CalculateTariffsOfferDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CalculateTariffsOfferDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub category_id: Vec<i64>,
            pub price: Vec<f64>,
            pub length: Vec<f64>,
            pub width: Vec<f64>,
            pub height: Vec<f64>,
            pub weight: Vec<f64>,
            pub quantity: Vec<u32>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CalculateTariffsOfferDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "categoryId" => intermediate_rep.category_id.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "price" => intermediate_rep.price.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "length" => intermediate_rep.length.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "width" => intermediate_rep.width.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "height" => intermediate_rep.height.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "weight" => intermediate_rep.weight.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "quantity" => intermediate_rep.quantity.push(<u32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CalculateTariffsOfferDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CalculateTariffsOfferDto {
            category_id: intermediate_rep.category_id.into_iter().next().ok_or_else(|| "categoryId missing in CalculateTariffsOfferDto".to_string())?,
            price: intermediate_rep.price.into_iter().next().ok_or_else(|| "price missing in CalculateTariffsOfferDto".to_string())?,
            length: intermediate_rep.length.into_iter().next().ok_or_else(|| "length missing in CalculateTariffsOfferDto".to_string())?,
            width: intermediate_rep.width.into_iter().next().ok_or_else(|| "width missing in CalculateTariffsOfferDto".to_string())?,
            height: intermediate_rep.height.into_iter().next().ok_or_else(|| "height missing in CalculateTariffsOfferDto".to_string())?,
            weight: intermediate_rep.weight.into_iter().next().ok_or_else(|| "weight missing in CalculateTariffsOfferDto".to_string())?,
            quantity: intermediate_rep.quantity.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CalculateTariffsOfferDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<CalculateTariffsOfferDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CalculateTariffsOfferDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CalculateTariffsOfferDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<CalculateTariffsOfferDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CalculateTariffsOfferDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CalculateTariffsOfferDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Стоимость услуг.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CalculateTariffsOfferInfoDto {
    #[serde(rename = "offer")]
    pub offer: models::CalculateTariffsOfferDto,

    /// Список услуг и их стоимость.  По некоторым услугам могут возвращаться несколько разных стоимостей. Например, в модели FBS стоимость услуги `SORTING` (обработка заказа) зависит от способа отгрузки и количества заказов в отгрузке. Подробнее о тарифах на услуги читайте [в Справке Маркета для продавцов](https://yandex.ru/support2/marketplace/ru/introduction/rates/models/). 
    #[serde(rename = "tariffs")]
    pub tariffs: Vec<models::CalculatedTariffDto>,

}


impl CalculateTariffsOfferInfoDto {
    #[allow(clippy::new_without_default)]
    pub fn new(offer: models::CalculateTariffsOfferDto, tariffs: Vec<models::CalculatedTariffDto>, ) -> CalculateTariffsOfferInfoDto {
        CalculateTariffsOfferInfoDto {
            offer,
            tariffs,
        }
    }
}

/// Converts the CalculateTariffsOfferInfoDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for CalculateTariffsOfferInfoDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping offer in query parameter serialization

            // Skipping tariffs in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CalculateTariffsOfferInfoDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CalculateTariffsOfferInfoDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub offer: Vec<models::CalculateTariffsOfferDto>,
            pub tariffs: Vec<Vec<models::CalculatedTariffDto>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CalculateTariffsOfferInfoDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "offer" => intermediate_rep.offer.push(<models::CalculateTariffsOfferDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "tariffs" => return std::result::Result::Err("Parsing a container in this style is not supported in CalculateTariffsOfferInfoDto".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing CalculateTariffsOfferInfoDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CalculateTariffsOfferInfoDto {
            offer: intermediate_rep.offer.into_iter().next().ok_or_else(|| "offer missing in CalculateTariffsOfferInfoDto".to_string())?,
            tariffs: intermediate_rep.tariffs.into_iter().next().ok_or_else(|| "tariffs missing in CalculateTariffsOfferInfoDto".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CalculateTariffsOfferInfoDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<CalculateTariffsOfferInfoDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CalculateTariffsOfferInfoDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CalculateTariffsOfferInfoDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<CalculateTariffsOfferInfoDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CalculateTariffsOfferInfoDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CalculateTariffsOfferInfoDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Параметры для расчета стоимости услуг.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CalculateTariffsParametersDto {
    /// Идентификатор кампании. У пользователя, который выполняет запрос, должен быть доступ к этой кампании.  Используйте параметр `campaignId`, если уже завершили подключение магазина на Маркете. Иначе вернется пустой список.  Обязательный параметр, если не указан параметр `sellingProgram`. Совместное использование параметров приведет к ошибке. 
    #[serde(rename = "campaignId")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub campaign_id: Option<i64>,

    #[serde(rename = "sellingProgram")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub selling_program: Option<models::SellingProgramType>,

    #[serde(rename = "frequency")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub frequency: Option<models::PaymentFrequencyType>,

}


impl CalculateTariffsParametersDto {
    #[allow(clippy::new_without_default)]
    pub fn new() -> CalculateTariffsParametersDto {
        CalculateTariffsParametersDto {
            campaign_id: None,
            selling_program: None,
            frequency: None,
        }
    }
}

/// Converts the CalculateTariffsParametersDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for CalculateTariffsParametersDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.campaign_id.as_ref().map(|campaign_id| {
                [
                    "campaignId".to_string(),
                    campaign_id.to_string(),
                ].join(",")
            }),

            // Skipping sellingProgram in query parameter serialization

            // Skipping frequency in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CalculateTariffsParametersDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CalculateTariffsParametersDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub campaign_id: Vec<i64>,
            pub selling_program: Vec<models::SellingProgramType>,
            pub frequency: Vec<models::PaymentFrequencyType>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CalculateTariffsParametersDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "campaignId" => intermediate_rep.campaign_id.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "sellingProgram" => intermediate_rep.selling_program.push(<models::SellingProgramType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "frequency" => intermediate_rep.frequency.push(<models::PaymentFrequencyType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CalculateTariffsParametersDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CalculateTariffsParametersDto {
            campaign_id: intermediate_rep.campaign_id.into_iter().next(),
            selling_program: intermediate_rep.selling_program.into_iter().next(),
            frequency: intermediate_rep.frequency.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CalculateTariffsParametersDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<CalculateTariffsParametersDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CalculateTariffsParametersDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CalculateTariffsParametersDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<CalculateTariffsParametersDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CalculateTariffsParametersDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CalculateTariffsParametersDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CalculateTariffsRequest {
    #[serde(rename = "parameters")]
    pub parameters: models::CalculateTariffsParametersDto,

    /// Товары, для которых нужно рассчитать стоимость услуг.
    #[serde(rename = "offers")]
    #[validate(
            length(min = 1, max = 200),
        )]
    pub offers: Vec<models::CalculateTariffsOfferDto>,

}


impl CalculateTariffsRequest {
    #[allow(clippy::new_without_default)]
    pub fn new(parameters: models::CalculateTariffsParametersDto, offers: Vec<models::CalculateTariffsOfferDto>, ) -> CalculateTariffsRequest {
        CalculateTariffsRequest {
            parameters,
            offers,
        }
    }
}

/// Converts the CalculateTariffsRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for CalculateTariffsRequest {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping parameters in query parameter serialization

            // Skipping offers in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CalculateTariffsRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CalculateTariffsRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub parameters: Vec<models::CalculateTariffsParametersDto>,
            pub offers: Vec<Vec<models::CalculateTariffsOfferDto>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CalculateTariffsRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "parameters" => intermediate_rep.parameters.push(<models::CalculateTariffsParametersDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "offers" => return std::result::Result::Err("Parsing a container in this style is not supported in CalculateTariffsRequest".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing CalculateTariffsRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CalculateTariffsRequest {
            parameters: intermediate_rep.parameters.into_iter().next().ok_or_else(|| "parameters missing in CalculateTariffsRequest".to_string())?,
            offers: intermediate_rep.offers.into_iter().next().ok_or_else(|| "offers missing in CalculateTariffsRequest".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CalculateTariffsRequest> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<CalculateTariffsRequest>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CalculateTariffsRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CalculateTariffsRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<CalculateTariffsRequest> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CalculateTariffsRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CalculateTariffsRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CalculateTariffsResponse {
    #[serde(rename = "status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<models::ApiResponseStatusType>,

    #[serde(rename = "result")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub result: Option<models::CalculateTariffsResponseDto>,

}


impl CalculateTariffsResponse {
    #[allow(clippy::new_without_default)]
    pub fn new() -> CalculateTariffsResponse {
        CalculateTariffsResponse {
            status: None,
            result: None,
        }
    }
}

/// Converts the CalculateTariffsResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for CalculateTariffsResponse {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping status in query parameter serialization

            // Skipping result in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CalculateTariffsResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CalculateTariffsResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub status: Vec<models::ApiResponseStatusType>,
            pub result: Vec<models::CalculateTariffsResponseDto>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CalculateTariffsResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(<models::ApiResponseStatusType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "result" => intermediate_rep.result.push(<models::CalculateTariffsResponseDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CalculateTariffsResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CalculateTariffsResponse {
            status: intermediate_rep.status.into_iter().next(),
            result: intermediate_rep.result.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CalculateTariffsResponse> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<CalculateTariffsResponse>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CalculateTariffsResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CalculateTariffsResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<CalculateTariffsResponse> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CalculateTariffsResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CalculateTariffsResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Расчет стоимости услуг.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CalculateTariffsResponseDto {
    /// Стоимость услуг.
    #[serde(rename = "offers")]
    pub offers: Vec<models::CalculateTariffsOfferInfoDto>,

}


impl CalculateTariffsResponseDto {
    #[allow(clippy::new_without_default)]
    pub fn new(offers: Vec<models::CalculateTariffsOfferInfoDto>, ) -> CalculateTariffsResponseDto {
        CalculateTariffsResponseDto {
            offers,
        }
    }
}

/// Converts the CalculateTariffsResponseDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for CalculateTariffsResponseDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping offers in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CalculateTariffsResponseDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CalculateTariffsResponseDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub offers: Vec<Vec<models::CalculateTariffsOfferInfoDto>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CalculateTariffsResponseDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "offers" => return std::result::Result::Err("Parsing a container in this style is not supported in CalculateTariffsResponseDto".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing CalculateTariffsResponseDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CalculateTariffsResponseDto {
            offers: intermediate_rep.offers.into_iter().next().ok_or_else(|| "offers missing in CalculateTariffsResponseDto".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CalculateTariffsResponseDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<CalculateTariffsResponseDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CalculateTariffsResponseDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CalculateTariffsResponseDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<CalculateTariffsResponseDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CalculateTariffsResponseDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CalculateTariffsResponseDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Информация об услугах Маркета.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CalculatedTariffDto {
    #[serde(rename = "type")]
    pub r#type: models::CalculatedTariffType,

    /// Стоимость услуги в рублях.
    #[serde(rename = "amount")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub amount: Option<f64>,

    /// Параметры расчета тарифа.
    #[serde(rename = "parameters")]
    pub parameters: Vec<models::TariffParameterDto>,

}


impl CalculatedTariffDto {
    #[allow(clippy::new_without_default)]
    pub fn new(r#type: models::CalculatedTariffType, parameters: Vec<models::TariffParameterDto>, ) -> CalculatedTariffDto {
        CalculatedTariffDto {
            r#type,
            amount: None,
            parameters,
        }
    }
}

/// Converts the CalculatedTariffDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for CalculatedTariffDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping type in query parameter serialization


            self.amount.as_ref().map(|amount| {
                [
                    "amount".to_string(),
                    amount.to_string(),
                ].join(",")
            }),

            // Skipping parameters in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CalculatedTariffDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CalculatedTariffDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub r#type: Vec<models::CalculatedTariffType>,
            pub amount: Vec<f64>,
            pub parameters: Vec<Vec<models::TariffParameterDto>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CalculatedTariffDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r#type.push(<models::CalculatedTariffType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "amount" => intermediate_rep.amount.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "parameters" => return std::result::Result::Err("Parsing a container in this style is not supported in CalculatedTariffDto".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing CalculatedTariffDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CalculatedTariffDto {
            r#type: intermediate_rep.r#type.into_iter().next().ok_or_else(|| "type missing in CalculatedTariffDto".to_string())?,
            amount: intermediate_rep.amount.into_iter().next(),
            parameters: intermediate_rep.parameters.into_iter().next().ok_or_else(|| "parameters missing in CalculatedTariffDto".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CalculatedTariffDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<CalculatedTariffDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CalculatedTariffDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CalculatedTariffDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<CalculatedTariffDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CalculatedTariffDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CalculatedTariffDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Услуга Маркета:  * `AGENCY_COMMISSION` — прием платежа покупателя.  * `PAYMENT_TRANSFER` — перевод платежа покупателя.  * `FEE` — размещение товара на Маркете.  * `DELIVERY_TO_CUSTOMER` — доставка покупателю.  * `CROSSREGIONAL_DELIVERY` — доставка в федеральный округ, город или населенный пункт.  * `EXPRESS_DELIVERY` — экспресс-доставка покупателю.  * `SORTING` — обработка заказа.  * `MIDDLE_MILE` — средняя миля.  Подробнее об услугах Маркета читайте [в Справке Маркета для продавцов](https://yandex.ru/support/marketplace/introduction/rates/index.html). 
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum CalculatedTariffType {
    #[serde(rename = "AGENCY_COMMISSION")]
    AgencyCommission,
    #[serde(rename = "PAYMENT_TRANSFER")]
    PaymentTransfer,
    #[serde(rename = "FEE")]
    Fee,
    #[serde(rename = "DELIVERY_TO_CUSTOMER")]
    DeliveryToCustomer,
    #[serde(rename = "CROSSREGIONAL_DELIVERY")]
    CrossregionalDelivery,
    #[serde(rename = "EXPRESS_DELIVERY")]
    ExpressDelivery,
    #[serde(rename = "SORTING")]
    Sorting,
    #[serde(rename = "MIDDLE_MILE")]
    MiddleMile,
}

impl std::fmt::Display for CalculatedTariffType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            CalculatedTariffType::AgencyCommission => write!(f, "AGENCY_COMMISSION"),
            CalculatedTariffType::PaymentTransfer => write!(f, "PAYMENT_TRANSFER"),
            CalculatedTariffType::Fee => write!(f, "FEE"),
            CalculatedTariffType::DeliveryToCustomer => write!(f, "DELIVERY_TO_CUSTOMER"),
            CalculatedTariffType::CrossregionalDelivery => write!(f, "CROSSREGIONAL_DELIVERY"),
            CalculatedTariffType::ExpressDelivery => write!(f, "EXPRESS_DELIVERY"),
            CalculatedTariffType::Sorting => write!(f, "SORTING"),
            CalculatedTariffType::MiddleMile => write!(f, "MIDDLE_MILE"),
        }
    }
}

impl std::str::FromStr for CalculatedTariffType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "AGENCY_COMMISSION" => std::result::Result::Ok(CalculatedTariffType::AgencyCommission),
            "PAYMENT_TRANSFER" => std::result::Result::Ok(CalculatedTariffType::PaymentTransfer),
            "FEE" => std::result::Result::Ok(CalculatedTariffType::Fee),
            "DELIVERY_TO_CUSTOMER" => std::result::Result::Ok(CalculatedTariffType::DeliveryToCustomer),
            "CROSSREGIONAL_DELIVERY" => std::result::Result::Ok(CalculatedTariffType::CrossregionalDelivery),
            "EXPRESS_DELIVERY" => std::result::Result::Ok(CalculatedTariffType::ExpressDelivery),
            "SORTING" => std::result::Result::Ok(CalculatedTariffType::Sorting),
            "MIDDLE_MILE" => std::result::Result::Ok(CalculatedTariffType::MiddleMile),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Информация о магазине.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CampaignDto {
    /// URL магазина.
    #[serde(rename = "domain")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub domain: Option<String>,

    /// Идентификатор кампании.
    #[serde(rename = "id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,

    /// Идентификатор плательщика в Яндекс Балансе.
    #[serde(rename = "clientId")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub client_id: Option<i64>,

    #[serde(rename = "business")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub business: Option<models::BusinessDto>,

    #[serde(rename = "placementType")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub placement_type: Option<models::PlacementType>,

}


impl CampaignDto {
    #[allow(clippy::new_without_default)]
    pub fn new() -> CampaignDto {
        CampaignDto {
            domain: None,
            id: None,
            client_id: None,
            business: None,
            placement_type: None,
        }
    }
}

/// Converts the CampaignDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for CampaignDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.domain.as_ref().map(|domain| {
                [
                    "domain".to_string(),
                    domain.to_string(),
                ].join(",")
            }),


            self.id.as_ref().map(|id| {
                [
                    "id".to_string(),
                    id.to_string(),
                ].join(",")
            }),


            self.client_id.as_ref().map(|client_id| {
                [
                    "clientId".to_string(),
                    client_id.to_string(),
                ].join(",")
            }),

            // Skipping business in query parameter serialization

            // Skipping placementType in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CampaignDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CampaignDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub domain: Vec<String>,
            pub id: Vec<i64>,
            pub client_id: Vec<i64>,
            pub business: Vec<models::BusinessDto>,
            pub placement_type: Vec<models::PlacementType>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CampaignDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "domain" => intermediate_rep.domain.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "clientId" => intermediate_rep.client_id.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "business" => intermediate_rep.business.push(<models::BusinessDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "placementType" => intermediate_rep.placement_type.push(<models::PlacementType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CampaignDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CampaignDto {
            domain: intermediate_rep.domain.into_iter().next(),
            id: intermediate_rep.id.into_iter().next(),
            client_id: intermediate_rep.client_id.into_iter().next(),
            business: intermediate_rep.business.into_iter().next(),
            placement_type: intermediate_rep.placement_type.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CampaignDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<CampaignDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CampaignDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CampaignDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<CampaignDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CampaignDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CampaignDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Информация об индексе качества магазина.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CampaignQualityRatingDto {
    /// Идентификатор магазина.
    #[serde(rename = "campaignId")]
    pub campaign_id: i64,

    /// Список значений индекса качества.
    #[serde(rename = "ratings")]
    pub ratings: Vec<models::QualityRatingDto>,

}


impl CampaignQualityRatingDto {
    #[allow(clippy::new_without_default)]
    pub fn new(campaign_id: i64, ratings: Vec<models::QualityRatingDto>, ) -> CampaignQualityRatingDto {
        CampaignQualityRatingDto {
            campaign_id,
            ratings,
        }
    }
}

/// Converts the CampaignQualityRatingDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for CampaignQualityRatingDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            Some("campaignId".to_string()),
            Some(self.campaign_id.to_string()),

            // Skipping ratings in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CampaignQualityRatingDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CampaignQualityRatingDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub campaign_id: Vec<i64>,
            pub ratings: Vec<Vec<models::QualityRatingDto>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CampaignQualityRatingDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "campaignId" => intermediate_rep.campaign_id.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "ratings" => return std::result::Result::Err("Parsing a container in this style is not supported in CampaignQualityRatingDto".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing CampaignQualityRatingDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CampaignQualityRatingDto {
            campaign_id: intermediate_rep.campaign_id.into_iter().next().ok_or_else(|| "campaignId missing in CampaignQualityRatingDto".to_string())?,
            ratings: intermediate_rep.ratings.into_iter().next().ok_or_else(|| "ratings missing in CampaignQualityRatingDto".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CampaignQualityRatingDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<CampaignQualityRatingDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CampaignQualityRatingDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CampaignQualityRatingDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<CampaignQualityRatingDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CampaignQualityRatingDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CampaignQualityRatingDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Информация о доставке в своем регионе магазина.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CampaignSettingsDeliveryDto {
    #[serde(rename = "schedule")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub schedule: Option<models::CampaignSettingsScheduleDto>,

}


impl CampaignSettingsDeliveryDto {
    #[allow(clippy::new_without_default)]
    pub fn new() -> CampaignSettingsDeliveryDto {
        CampaignSettingsDeliveryDto {
            schedule: None,
        }
    }
}

/// Converts the CampaignSettingsDeliveryDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for CampaignSettingsDeliveryDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping schedule in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CampaignSettingsDeliveryDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CampaignSettingsDeliveryDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub schedule: Vec<models::CampaignSettingsScheduleDto>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CampaignSettingsDeliveryDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "schedule" => intermediate_rep.schedule.push(<models::CampaignSettingsScheduleDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CampaignSettingsDeliveryDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CampaignSettingsDeliveryDto {
            schedule: intermediate_rep.schedule.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CampaignSettingsDeliveryDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<CampaignSettingsDeliveryDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CampaignSettingsDeliveryDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CampaignSettingsDeliveryDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<CampaignSettingsDeliveryDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CampaignSettingsDeliveryDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CampaignSettingsDeliveryDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Настройки магазина.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CampaignSettingsDto {
    /// Идентификатор региона, в котором находится магазин.
    #[serde(rename = "countryRegion")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub country_region: Option<i64>,

    /// Наименование магазина на Яндекс Маркете. Если наименование отсутствует, значение параметра выводится — `null`. 
    #[serde(rename = "shopName")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub shop_name: Option<String>,

    /// Признак размещения магазина на сайтах партнеров Яндекс Дистрибуции. Возможные значения: * `false` — магазин не размещен на сайтах партнеров Яндекс Дистрибуции. * `true` — магазин размещен на сайтах партнеров Яндекс Дистрибуции. 
    #[serde(rename = "showInContext")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub show_in_context: Option<bool>,

    /// Признак показа предложений магазина в рекламном блоке над результатами поиска (cпецразмещение). Возможные значения: * `false` — предложения не показываются в блоке cпецразмещения. * `true` — предложения показываются в блоке cпецразмещения. 
    #[serde(rename = "showInPremium")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub show_in_premium: Option<bool>,

    /// Признак использования внешней интернет-статистики. Возможные значения: * `false` — внешняя интернет-статистика не используется. * `true` — внешняя интернет-статистика используется. 
    #[serde(rename = "useOpenStat")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub use_open_stat: Option<bool>,

    #[serde(rename = "localRegion")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub local_region: Option<models::CampaignSettingsLocalRegionDto>,

}


impl CampaignSettingsDto {
    #[allow(clippy::new_without_default)]
    pub fn new() -> CampaignSettingsDto {
        CampaignSettingsDto {
            country_region: None,
            shop_name: None,
            show_in_context: None,
            show_in_premium: None,
            use_open_stat: None,
            local_region: None,
        }
    }
}

/// Converts the CampaignSettingsDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for CampaignSettingsDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.country_region.as_ref().map(|country_region| {
                [
                    "countryRegion".to_string(),
                    country_region.to_string(),
                ].join(",")
            }),


            self.shop_name.as_ref().map(|shop_name| {
                [
                    "shopName".to_string(),
                    shop_name.to_string(),
                ].join(",")
            }),


            self.show_in_context.as_ref().map(|show_in_context| {
                [
                    "showInContext".to_string(),
                    show_in_context.to_string(),
                ].join(",")
            }),


            self.show_in_premium.as_ref().map(|show_in_premium| {
                [
                    "showInPremium".to_string(),
                    show_in_premium.to_string(),
                ].join(",")
            }),


            self.use_open_stat.as_ref().map(|use_open_stat| {
                [
                    "useOpenStat".to_string(),
                    use_open_stat.to_string(),
                ].join(",")
            }),

            // Skipping localRegion in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CampaignSettingsDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CampaignSettingsDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub country_region: Vec<i64>,
            pub shop_name: Vec<String>,
            pub show_in_context: Vec<bool>,
            pub show_in_premium: Vec<bool>,
            pub use_open_stat: Vec<bool>,
            pub local_region: Vec<models::CampaignSettingsLocalRegionDto>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CampaignSettingsDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "countryRegion" => intermediate_rep.country_region.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "shopName" => intermediate_rep.shop_name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "showInContext" => intermediate_rep.show_in_context.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "showInPremium" => intermediate_rep.show_in_premium.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "useOpenStat" => intermediate_rep.use_open_stat.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "localRegion" => intermediate_rep.local_region.push(<models::CampaignSettingsLocalRegionDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CampaignSettingsDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CampaignSettingsDto {
            country_region: intermediate_rep.country_region.into_iter().next(),
            shop_name: intermediate_rep.shop_name.into_iter().next(),
            show_in_context: intermediate_rep.show_in_context.into_iter().next(),
            show_in_premium: intermediate_rep.show_in_premium.into_iter().next(),
            use_open_stat: intermediate_rep.use_open_stat.into_iter().next(),
            local_region: intermediate_rep.local_region.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CampaignSettingsDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<CampaignSettingsDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CampaignSettingsDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CampaignSettingsDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<CampaignSettingsDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CampaignSettingsDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CampaignSettingsDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Информация о своем регионе магазина.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CampaignSettingsLocalRegionDto {
    /// Идентификатор региона.
    #[serde(rename = "id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,

    /// Название региона.
    #[serde(rename = "name")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

    #[serde(rename = "type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub r#type: Option<models::RegionType>,

    #[serde(rename = "deliveryOptionsSource")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub delivery_options_source: Option<models::CampaignSettingsScheduleSourceType>,

    #[serde(rename = "delivery")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub delivery: Option<models::CampaignSettingsDeliveryDto>,

}


impl CampaignSettingsLocalRegionDto {
    #[allow(clippy::new_without_default)]
    pub fn new() -> CampaignSettingsLocalRegionDto {
        CampaignSettingsLocalRegionDto {
            id: None,
            name: None,
            r#type: None,
            delivery_options_source: None,
            delivery: None,
        }
    }
}

/// Converts the CampaignSettingsLocalRegionDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for CampaignSettingsLocalRegionDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.id.as_ref().map(|id| {
                [
                    "id".to_string(),
                    id.to_string(),
                ].join(",")
            }),


            self.name.as_ref().map(|name| {
                [
                    "name".to_string(),
                    name.to_string(),
                ].join(",")
            }),

            // Skipping type in query parameter serialization

            // Skipping deliveryOptionsSource in query parameter serialization

            // Skipping delivery in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CampaignSettingsLocalRegionDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CampaignSettingsLocalRegionDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<i64>,
            pub name: Vec<String>,
            pub r#type: Vec<models::RegionType>,
            pub delivery_options_source: Vec<models::CampaignSettingsScheduleSourceType>,
            pub delivery: Vec<models::CampaignSettingsDeliveryDto>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CampaignSettingsLocalRegionDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r#type.push(<models::RegionType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "deliveryOptionsSource" => intermediate_rep.delivery_options_source.push(<models::CampaignSettingsScheduleSourceType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "delivery" => intermediate_rep.delivery.push(<models::CampaignSettingsDeliveryDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CampaignSettingsLocalRegionDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CampaignSettingsLocalRegionDto {
            id: intermediate_rep.id.into_iter().next(),
            name: intermediate_rep.name.into_iter().next(),
            r#type: intermediate_rep.r#type.into_iter().next(),
            delivery_options_source: intermediate_rep.delivery_options_source.into_iter().next(),
            delivery: intermediate_rep.delivery.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CampaignSettingsLocalRegionDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<CampaignSettingsLocalRegionDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CampaignSettingsLocalRegionDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CampaignSettingsLocalRegionDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<CampaignSettingsLocalRegionDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CampaignSettingsLocalRegionDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CampaignSettingsLocalRegionDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Расписание работы службы доставки в своем регионе.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CampaignSettingsScheduleDto {
    /// Признак работы службы доставки в государственные праздники. Возможные значения. * `false` — служба доставки не работает в праздничные дни. * `true` — служба доставки работает в праздничные дни. 
    #[serde(rename = "availableOnHolidays")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub available_on_holidays: Option<bool>,

    /// Список дней, в которые служба доставки не работает. Дни магазин указал в кабинете продавца на Маркете.
    #[serde(rename = "customHolidays")]
    pub custom_holidays: Vec<models::DateDdMmYyyy>,

    /// Список выходных и праздничных дней, в которые служба доставки работает. Дни магазин указал в кабинете продавца на Маркете.
    #[serde(rename = "customWorkingDays")]
    pub custom_working_days: Vec<models::DateDdMmYyyy>,

    #[serde(rename = "period")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub period: Option<models::CampaignSettingsTimePeriodDto>,

    /// Итоговый список нерабочих дней службы доставки. Список рассчитывается с учетом выходных, нерабочих дней и государственных праздников. Информацию по ним магазин указывает в кабинете продавца на Маркете.
    #[serde(rename = "totalHolidays")]
    pub total_holidays: Vec<models::DateDdMmYyyy>,

    /// Список выходных дней недели и государственных праздников.
    #[serde(rename = "weeklyHolidays")]
    pub weekly_holidays: Vec<i32>,

}


impl CampaignSettingsScheduleDto {
    #[allow(clippy::new_without_default)]
    pub fn new(custom_holidays: Vec<models::DateDdMmYyyy>, custom_working_days: Vec<models::DateDdMmYyyy>, total_holidays: Vec<models::DateDdMmYyyy>, weekly_holidays: Vec<i32>, ) -> CampaignSettingsScheduleDto {
        CampaignSettingsScheduleDto {
            available_on_holidays: None,
            custom_holidays,
            custom_working_days,
            period: None,
            total_holidays,
            weekly_holidays,
        }
    }
}

/// Converts the CampaignSettingsScheduleDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for CampaignSettingsScheduleDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.available_on_holidays.as_ref().map(|available_on_holidays| {
                [
                    "availableOnHolidays".to_string(),
                    available_on_holidays.to_string(),
                ].join(",")
            }),


            Some("customHolidays".to_string()),
            Some(self.custom_holidays.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),


            Some("customWorkingDays".to_string()),
            Some(self.custom_working_days.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),

            // Skipping period in query parameter serialization


            Some("totalHolidays".to_string()),
            Some(self.total_holidays.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),


            Some("weeklyHolidays".to_string()),
            Some(self.weekly_holidays.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CampaignSettingsScheduleDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CampaignSettingsScheduleDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub available_on_holidays: Vec<bool>,
            pub custom_holidays: Vec<Vec<models::DateDdMmYyyy>>,
            pub custom_working_days: Vec<Vec<models::DateDdMmYyyy>>,
            pub period: Vec<models::CampaignSettingsTimePeriodDto>,
            pub total_holidays: Vec<Vec<models::DateDdMmYyyy>>,
            pub weekly_holidays: Vec<Vec<i32>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CampaignSettingsScheduleDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "availableOnHolidays" => intermediate_rep.available_on_holidays.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "customHolidays" => return std::result::Result::Err("Parsing a container in this style is not supported in CampaignSettingsScheduleDto".to_string()),
                    "customWorkingDays" => return std::result::Result::Err("Parsing a container in this style is not supported in CampaignSettingsScheduleDto".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "period" => intermediate_rep.period.push(<models::CampaignSettingsTimePeriodDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "totalHolidays" => return std::result::Result::Err("Parsing a container in this style is not supported in CampaignSettingsScheduleDto".to_string()),
                    "weeklyHolidays" => return std::result::Result::Err("Parsing a container in this style is not supported in CampaignSettingsScheduleDto".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing CampaignSettingsScheduleDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CampaignSettingsScheduleDto {
            available_on_holidays: intermediate_rep.available_on_holidays.into_iter().next(),
            custom_holidays: intermediate_rep.custom_holidays.into_iter().next().ok_or_else(|| "customHolidays missing in CampaignSettingsScheduleDto".to_string())?,
            custom_working_days: intermediate_rep.custom_working_days.into_iter().next().ok_or_else(|| "customWorkingDays missing in CampaignSettingsScheduleDto".to_string())?,
            period: intermediate_rep.period.into_iter().next(),
            total_holidays: intermediate_rep.total_holidays.into_iter().next().ok_or_else(|| "totalHolidays missing in CampaignSettingsScheduleDto".to_string())?,
            weekly_holidays: intermediate_rep.weekly_holidays.into_iter().next().ok_or_else(|| "weeklyHolidays missing in CampaignSettingsScheduleDto".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CampaignSettingsScheduleDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<CampaignSettingsScheduleDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CampaignSettingsScheduleDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CampaignSettingsScheduleDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<CampaignSettingsScheduleDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CampaignSettingsScheduleDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CampaignSettingsScheduleDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Источник информации о расписании работы службы доставки. Возможные значения: * `WEB` — информация получена из настроек кабинета продавца на Маркете. * `YML` — информация получена из прайс-листа магазина. 
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum CampaignSettingsScheduleSourceType {
    #[serde(rename = "WEB")]
    Web,
    #[serde(rename = "YML")]
    Yml,
}

impl std::fmt::Display for CampaignSettingsScheduleSourceType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            CampaignSettingsScheduleSourceType::Web => write!(f, "WEB"),
            CampaignSettingsScheduleSourceType::Yml => write!(f, "YML"),
        }
    }
}

impl std::str::FromStr for CampaignSettingsScheduleSourceType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "WEB" => std::result::Result::Ok(CampaignSettingsScheduleSourceType::Web),
            "YML" => std::result::Result::Ok(CampaignSettingsScheduleSourceType::Yml),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Период, за который рассчитывается итоговый список нерабочих дней службы доставки.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CampaignSettingsTimePeriodDto {
    /// Формат даты: `ДД-ММ-ГГГГ`. 
    #[serde(rename = "fromDate")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub from_date: Option<String>,

    /// Формат даты: `ДД-ММ-ГГГГ`. 
    #[serde(rename = "toDate")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub to_date: Option<String>,

}


impl CampaignSettingsTimePeriodDto {
    #[allow(clippy::new_without_default)]
    pub fn new() -> CampaignSettingsTimePeriodDto {
        CampaignSettingsTimePeriodDto {
            from_date: None,
            to_date: None,
        }
    }
}

/// Converts the CampaignSettingsTimePeriodDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for CampaignSettingsTimePeriodDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.from_date.as_ref().map(|from_date| {
                [
                    "fromDate".to_string(),
                    from_date.to_string(),
                ].join(",")
            }),


            self.to_date.as_ref().map(|to_date| {
                [
                    "toDate".to_string(),
                    to_date.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CampaignSettingsTimePeriodDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CampaignSettingsTimePeriodDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub from_date: Vec<String>,
            pub to_date: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CampaignSettingsTimePeriodDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "fromDate" => intermediate_rep.from_date.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "toDate" => intermediate_rep.to_date.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CampaignSettingsTimePeriodDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CampaignSettingsTimePeriodDto {
            from_date: intermediate_rep.from_date.into_iter().next(),
            to_date: intermediate_rep.to_date.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CampaignSettingsTimePeriodDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<CampaignSettingsTimePeriodDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CampaignSettingsTimePeriodDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CampaignSettingsTimePeriodDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<CampaignSettingsTimePeriodDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CampaignSettingsTimePeriodDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CampaignSettingsTimePeriodDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Информация об индексе качества магазинов.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CampaignsQualityRatingDto {
    /// Список магазинов c информацией об их индексе качества.
    #[serde(rename = "campaignRatings")]
    pub campaign_ratings: Vec<models::CampaignQualityRatingDto>,

}


impl CampaignsQualityRatingDto {
    #[allow(clippy::new_without_default)]
    pub fn new(campaign_ratings: Vec<models::CampaignQualityRatingDto>, ) -> CampaignsQualityRatingDto {
        CampaignsQualityRatingDto {
            campaign_ratings,
        }
    }
}

/// Converts the CampaignsQualityRatingDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for CampaignsQualityRatingDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping campaignRatings in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CampaignsQualityRatingDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CampaignsQualityRatingDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub campaign_ratings: Vec<Vec<models::CampaignQualityRatingDto>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CampaignsQualityRatingDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "campaignRatings" => return std::result::Result::Err("Parsing a container in this style is not supported in CampaignsQualityRatingDto".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing CampaignsQualityRatingDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CampaignsQualityRatingDto {
            campaign_ratings: intermediate_rep.campaign_ratings.into_iter().next().ok_or_else(|| "campaignRatings missing in CampaignsQualityRatingDto".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CampaignsQualityRatingDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<CampaignsQualityRatingDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CampaignsQualityRatingDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CampaignsQualityRatingDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<CampaignsQualityRatingDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CampaignsQualityRatingDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CampaignsQualityRatingDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Информация о параметрах категории.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CategoryContentParametersDto {
    /// Идентификатор категории на Маркете. Чтобы узнать идентификатор категории, к которой относится товар, воспользуйтесь запросом [POST categories/tree](../../reference/categories/getCategoriesTree.md).
    #[serde(rename = "categoryId")]
    pub category_id: i32,

    /// Список характеристик.
    #[serde(rename = "parameters")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub parameters: Option<swagger::Nullable<Vec<models::CategoryParameterDto>>>,

}


impl CategoryContentParametersDto {
    #[allow(clippy::new_without_default)]
    pub fn new(category_id: i32, ) -> CategoryContentParametersDto {
        CategoryContentParametersDto {
            category_id,
            parameters: None,
        }
    }
}

/// Converts the CategoryContentParametersDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for CategoryContentParametersDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            Some("categoryId".to_string()),
            Some(self.category_id.to_string()),

            // Skipping parameters in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CategoryContentParametersDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CategoryContentParametersDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub category_id: Vec<i32>,
            pub parameters: Vec<Vec<models::CategoryParameterDto>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CategoryContentParametersDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "categoryId" => intermediate_rep.category_id.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "parameters" => return std::result::Result::Err("Parsing a container in this style is not supported in CategoryContentParametersDto".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing CategoryContentParametersDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CategoryContentParametersDto {
            category_id: intermediate_rep.category_id.into_iter().next().ok_or_else(|| "categoryId missing in CategoryContentParametersDto".to_string())?,
            parameters: std::result::Result::Err("Nullable types not supported in CategoryContentParametersDto".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CategoryContentParametersDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<CategoryContentParametersDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CategoryContentParametersDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CategoryContentParametersDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<CategoryContentParametersDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CategoryContentParametersDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CategoryContentParametersDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Информация о категории.  Категория считается листовой, если у нее нет дочерних категорий. 
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CategoryDto {
    /// Идентификатор категории.
    #[serde(rename = "id")]
    pub id: i64,

    /// Название категории.
    #[serde(rename = "name")]
    pub name: String,

    /// Дочерние категории.
    #[serde(rename = "children")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub children: Option<swagger::Nullable<Vec<models::CategoryDto>>>,

}


impl CategoryDto {
    #[allow(clippy::new_without_default)]
    pub fn new(id: i64, name: String, ) -> CategoryDto {
        CategoryDto {
            id,
            name,
            children: None,
        }
    }
}

/// Converts the CategoryDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for CategoryDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            Some("id".to_string()),
            Some(self.id.to_string()),


            Some("name".to_string()),
            Some(self.name.to_string()),

            // Skipping children in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CategoryDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CategoryDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<i64>,
            pub name: Vec<String>,
            pub children: Vec<Vec<models::CategoryDto>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CategoryDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "children" => return std::result::Result::Err("Parsing a container in this style is not supported in CategoryDto".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing CategoryDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CategoryDto {
            id: intermediate_rep.id.into_iter().next().ok_or_else(|| "id missing in CategoryDto".to_string())?,
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "name missing in CategoryDto".to_string())?,
            children: std::result::Result::Err("Nullable types not supported in CategoryDto".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CategoryDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<CategoryDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CategoryDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CategoryDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<CategoryDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CategoryDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CategoryDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Текст ошибки.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CategoryErrorDto {
    /// Идентификатор категории.
    #[serde(rename = "categoryId")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub category_id: Option<i64>,

    #[serde(rename = "type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub r#type: Option<models::CategoryErrorType>,

}


impl CategoryErrorDto {
    #[allow(clippy::new_without_default)]
    pub fn new() -> CategoryErrorDto {
        CategoryErrorDto {
            category_id: None,
            r#type: None,
        }
    }
}

/// Converts the CategoryErrorDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for CategoryErrorDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.category_id.as_ref().map(|category_id| {
                [
                    "categoryId".to_string(),
                    category_id.to_string(),
                ].join(",")
            }),

            // Skipping type in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CategoryErrorDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CategoryErrorDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub category_id: Vec<i64>,
            pub r#type: Vec<models::CategoryErrorType>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CategoryErrorDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "categoryId" => intermediate_rep.category_id.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r#type.push(<models::CategoryErrorType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CategoryErrorDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CategoryErrorDto {
            category_id: intermediate_rep.category_id.into_iter().next(),
            r#type: intermediate_rep.r#type.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CategoryErrorDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<CategoryErrorDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CategoryErrorDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CategoryErrorDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<CategoryErrorDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CategoryErrorDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CategoryErrorDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Типы ошибок:  * `UNKNOWN_CATEGORY` — указана неизвестная категория. * `CATEGORY_IS_NOT_LEAF` — указана нелистовая категория. Укажите ту, которая не имеет дочерних категорий. 
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum CategoryErrorType {
    #[serde(rename = "UNKNOWN_CATEGORY")]
    UnknownCategory,
    #[serde(rename = "CATEGORY_IS_NOT_LEAF")]
    CategoryIsNotLeaf,
}

impl std::fmt::Display for CategoryErrorType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            CategoryErrorType::UnknownCategory => write!(f, "UNKNOWN_CATEGORY"),
            CategoryErrorType::CategoryIsNotLeaf => write!(f, "CATEGORY_IS_NOT_LEAF"),
        }
    }
}

impl std::str::FromStr for CategoryErrorType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "UNKNOWN_CATEGORY" => std::result::Result::Ok(CategoryErrorType::UnknownCategory),
            "CATEGORY_IS_NOT_LEAF" => std::result::Result::Ok(CategoryErrorType::CategoryIsNotLeaf),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Идентификатор категории на Маркете. Чтобы узнать идентификатор категории, к которой относится товар, воспользуйтесь запросом [POST categories/tree](../../reference/categories/getCategoriesTree.md).
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CategoryId(i32);

impl std::convert::From<i32> for CategoryId {
    fn from(x: i32) -> Self {
        CategoryId(x)
    }
}

impl std::convert::From<CategoryId> for i32 {
    fn from(x: CategoryId) -> Self {
        x.0
    }
}

impl std::ops::Deref for CategoryId {
    type Target = i32;
    fn deref(&self) -> &i32 {
        &self.0
    }
}

impl std::ops::DerefMut for CategoryId {
    fn deref_mut(&mut self) -> &mut i32 {
        &mut self.0
    }
}


/// Характеристика товара.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CategoryParameterDto {
    /// Идентификатор характеристики.
    #[serde(rename = "id")]
    pub id: i64,

    /// Название характеристики.
    #[serde(rename = "name")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

    #[serde(rename = "type")]
    pub r#type: models::ParameterType,

    #[serde(rename = "unit")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub unit: Option<models::CategoryParameterUnitDto>,

    /// Описание характеристики.
    #[serde(rename = "description")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,

    /// Перечень возможных рекомендаций по заполнению карточки, к которым относится данная характеристика.
    #[serde(rename = "recommendationTypes")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub recommendation_types: Option<swagger::Nullable<Vec<models::OfferCardRecommendationType>>>,

    /// Обязательность характеристики.
    #[serde(rename = "required")]
    pub required: bool,

    /// Используется ли характеристика в фильтре.
    #[serde(rename = "filtering")]
    pub filtering: bool,

    /// Является ли характеристика особенностью варианта.
    #[serde(rename = "distinctive")]
    pub distinctive: bool,

    /// Можно ли передать сразу несколько значений.
    #[serde(rename = "multivalue")]
    pub multivalue: bool,

    /// Можно ли передавать собственное значение, которого нет в списке вариантов Маркета. Только для характеристик типа `ENUM`.
    #[serde(rename = "allowCustomValues")]
    pub allow_custom_values: bool,

    /// Список допустимых значений параметра. Только для характеристик типа `ENUM`.
    #[serde(rename = "values")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub values: Option<swagger::Nullable<Vec<models::ParameterValueOptionDto>>>,

    #[serde(rename = "constraints")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub constraints: Option<models::ParameterValueConstraintsDto>,

    /// Ограничения на значения, накладываемые другими характеристиками. Только для характеристик типа `ENUM`.
    #[serde(rename = "valueRestrictions")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub value_restrictions: Option<swagger::Nullable<Vec<models::ValueRestrictionDto>>>,

}


impl CategoryParameterDto {
    #[allow(clippy::new_without_default)]
    pub fn new(id: i64, r#type: models::ParameterType, required: bool, filtering: bool, distinctive: bool, multivalue: bool, allow_custom_values: bool, ) -> CategoryParameterDto {
        CategoryParameterDto {
            id,
            name: None,
            r#type,
            unit: None,
            description: None,
            recommendation_types: None,
            required,
            filtering,
            distinctive,
            multivalue,
            allow_custom_values,
            values: None,
            constraints: None,
            value_restrictions: None,
        }
    }
}

/// Converts the CategoryParameterDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for CategoryParameterDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            Some("id".to_string()),
            Some(self.id.to_string()),


            self.name.as_ref().map(|name| {
                [
                    "name".to_string(),
                    name.to_string(),
                ].join(",")
            }),

            // Skipping type in query parameter serialization

            // Skipping unit in query parameter serialization


            self.description.as_ref().map(|description| {
                [
                    "description".to_string(),
                    description.to_string(),
                ].join(",")
            }),

            // Skipping recommendationTypes in query parameter serialization


            Some("required".to_string()),
            Some(self.required.to_string()),


            Some("filtering".to_string()),
            Some(self.filtering.to_string()),


            Some("distinctive".to_string()),
            Some(self.distinctive.to_string()),


            Some("multivalue".to_string()),
            Some(self.multivalue.to_string()),


            Some("allowCustomValues".to_string()),
            Some(self.allow_custom_values.to_string()),

            // Skipping values in query parameter serialization

            // Skipping constraints in query parameter serialization

            // Skipping valueRestrictions in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CategoryParameterDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CategoryParameterDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<i64>,
            pub name: Vec<String>,
            pub r#type: Vec<models::ParameterType>,
            pub unit: Vec<models::CategoryParameterUnitDto>,
            pub description: Vec<String>,
            pub recommendation_types: Vec<Vec<models::OfferCardRecommendationType>>,
            pub required: Vec<bool>,
            pub filtering: Vec<bool>,
            pub distinctive: Vec<bool>,
            pub multivalue: Vec<bool>,
            pub allow_custom_values: Vec<bool>,
            pub values: Vec<Vec<models::ParameterValueOptionDto>>,
            pub constraints: Vec<models::ParameterValueConstraintsDto>,
            pub value_restrictions: Vec<Vec<models::ValueRestrictionDto>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CategoryParameterDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r#type.push(<models::ParameterType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "unit" => intermediate_rep.unit.push(<models::CategoryParameterUnitDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "description" => intermediate_rep.description.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "recommendationTypes" => return std::result::Result::Err("Parsing a container in this style is not supported in CategoryParameterDto".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "required" => intermediate_rep.required.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "filtering" => intermediate_rep.filtering.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "distinctive" => intermediate_rep.distinctive.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "multivalue" => intermediate_rep.multivalue.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "allowCustomValues" => intermediate_rep.allow_custom_values.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "values" => return std::result::Result::Err("Parsing a container in this style is not supported in CategoryParameterDto".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "constraints" => intermediate_rep.constraints.push(<models::ParameterValueConstraintsDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "valueRestrictions" => return std::result::Result::Err("Parsing a container in this style is not supported in CategoryParameterDto".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing CategoryParameterDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CategoryParameterDto {
            id: intermediate_rep.id.into_iter().next().ok_or_else(|| "id missing in CategoryParameterDto".to_string())?,
            name: intermediate_rep.name.into_iter().next(),
            r#type: intermediate_rep.r#type.into_iter().next().ok_or_else(|| "type missing in CategoryParameterDto".to_string())?,
            unit: intermediate_rep.unit.into_iter().next(),
            description: intermediate_rep.description.into_iter().next(),
            recommendation_types: std::result::Result::Err("Nullable types not supported in CategoryParameterDto".to_string())?,
            required: intermediate_rep.required.into_iter().next().ok_or_else(|| "required missing in CategoryParameterDto".to_string())?,
            filtering: intermediate_rep.filtering.into_iter().next().ok_or_else(|| "filtering missing in CategoryParameterDto".to_string())?,
            distinctive: intermediate_rep.distinctive.into_iter().next().ok_or_else(|| "distinctive missing in CategoryParameterDto".to_string())?,
            multivalue: intermediate_rep.multivalue.into_iter().next().ok_or_else(|| "multivalue missing in CategoryParameterDto".to_string())?,
            allow_custom_values: intermediate_rep.allow_custom_values.into_iter().next().ok_or_else(|| "allowCustomValues missing in CategoryParameterDto".to_string())?,
            values: std::result::Result::Err("Nullable types not supported in CategoryParameterDto".to_string())?,
            constraints: intermediate_rep.constraints.into_iter().next(),
            value_restrictions: std::result::Result::Err("Nullable types not supported in CategoryParameterDto".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CategoryParameterDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<CategoryParameterDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CategoryParameterDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CategoryParameterDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<CategoryParameterDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CategoryParameterDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CategoryParameterDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Единицы измерения характеристики товара.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CategoryParameterUnitDto {
    /// Единица измерения по умолчанию.
    #[serde(rename = "defaultUnitId")]
    pub default_unit_id: i64,

    /// Допустимые единицы измерения.
    #[serde(rename = "units")]
    pub units: Vec<models::UnitDto>,

}


impl CategoryParameterUnitDto {
    #[allow(clippy::new_without_default)]
    pub fn new(default_unit_id: i64, units: Vec<models::UnitDto>, ) -> CategoryParameterUnitDto {
        CategoryParameterUnitDto {
            default_unit_id,
            units,
        }
    }
}

/// Converts the CategoryParameterUnitDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for CategoryParameterUnitDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            Some("defaultUnitId".to_string()),
            Some(self.default_unit_id.to_string()),

            // Skipping units in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CategoryParameterUnitDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CategoryParameterUnitDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub default_unit_id: Vec<i64>,
            pub units: Vec<Vec<models::UnitDto>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CategoryParameterUnitDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "defaultUnitId" => intermediate_rep.default_unit_id.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "units" => return std::result::Result::Err("Parsing a container in this style is not supported in CategoryParameterUnitDto".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing CategoryParameterUnitDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CategoryParameterUnitDto {
            default_unit_id: intermediate_rep.default_unit_id.into_iter().next().ok_or_else(|| "defaultUnitId missing in CategoryParameterUnitDto".to_string())?,
            units: intermediate_rep.units.into_iter().next().ok_or_else(|| "units missing in CategoryParameterUnitDto".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CategoryParameterUnitDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<CategoryParameterUnitDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CategoryParameterUnitDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CategoryParameterUnitDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<CategoryParameterUnitDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CategoryParameterUnitDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CategoryParameterUnitDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ChangeOutletRequest {
    /// Название точки продаж. 
    #[serde(rename = "name")]
    pub name: String,

    #[serde(rename = "type")]
    pub r#type: models::OutletType,

    /// Координаты точки продаж.  Формат: долгота, широта. Разделители: запятая и / или пробел. Например, `20.4522144, 54.7104264`.  Если параметр не передан, координаты будут определены по значениям параметров, вложенных в `address`. 
    #[serde(rename = "coords")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub coords: Option<String>,

    /// Признак основной точки продаж.  Возможные значения:  * `false` — неосновная точка продаж. * `true` — основная точка продаж. 
    #[serde(rename = "isMain")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub is_main: Option<bool>,

    /// Идентификатор точки продаж, присвоенный магазином.
    #[serde(rename = "shopOutletCode")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub shop_outlet_code: Option<String>,

    #[serde(rename = "visibility")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub visibility: Option<models::OutletVisibilityType>,

    #[serde(rename = "address")]
    pub address: models::OutletAddressDto,

    /// Номера телефонов точки продаж. Передавайте в формате: `+7 (999) 999-99-99`. 
    #[serde(rename = "phones")]
    #[validate(
            length(min = 1),
        )]
    pub phones: Vec<String>,

    #[serde(rename = "workingSchedule")]
    pub working_schedule: models::OutletWorkingScheduleDto,

    /// Информация об условиях доставки для данной точки продаж.  Обязательный параметр, если параметр `type=DEPOT` или `type=MIXED`. 
    #[serde(rename = "deliveryRules")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub delivery_rules: Option<swagger::Nullable<Vec<models::OutletDeliveryRuleDto>>>,

    /// Срок хранения заказа в собственном пункте выдачи заказов. Считается в днях.
    #[serde(rename = "storagePeriod")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub storage_period: Option<i64>,

}


impl ChangeOutletRequest {
    #[allow(clippy::new_without_default)]
    pub fn new(name: String, r#type: models::OutletType, address: models::OutletAddressDto, phones: Vec<String>, working_schedule: models::OutletWorkingScheduleDto, ) -> ChangeOutletRequest {
        ChangeOutletRequest {
            name,
            r#type,
            coords: None,
            is_main: None,
            shop_outlet_code: None,
            visibility: None,
            address,
            phones,
            working_schedule,
            delivery_rules: None,
            storage_period: None,
        }
    }
}

/// Converts the ChangeOutletRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ChangeOutletRequest {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            Some("name".to_string()),
            Some(self.name.to_string()),

            // Skipping type in query parameter serialization


            self.coords.as_ref().map(|coords| {
                [
                    "coords".to_string(),
                    coords.to_string(),
                ].join(",")
            }),


            self.is_main.as_ref().map(|is_main| {
                [
                    "isMain".to_string(),
                    is_main.to_string(),
                ].join(",")
            }),


            self.shop_outlet_code.as_ref().map(|shop_outlet_code| {
                [
                    "shopOutletCode".to_string(),
                    shop_outlet_code.to_string(),
                ].join(",")
            }),

            // Skipping visibility in query parameter serialization

            // Skipping address in query parameter serialization


            Some("phones".to_string()),
            Some(self.phones.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),

            // Skipping workingSchedule in query parameter serialization

            // Skipping deliveryRules in query parameter serialization


            self.storage_period.as_ref().map(|storage_period| {
                [
                    "storagePeriod".to_string(),
                    storage_period.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ChangeOutletRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ChangeOutletRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub name: Vec<String>,
            pub r#type: Vec<models::OutletType>,
            pub coords: Vec<String>,
            pub is_main: Vec<bool>,
            pub shop_outlet_code: Vec<String>,
            pub visibility: Vec<models::OutletVisibilityType>,
            pub address: Vec<models::OutletAddressDto>,
            pub phones: Vec<Vec<String>>,
            pub working_schedule: Vec<models::OutletWorkingScheduleDto>,
            pub delivery_rules: Vec<Vec<models::OutletDeliveryRuleDto>>,
            pub storage_period: Vec<i64>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ChangeOutletRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r#type.push(<models::OutletType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "coords" => intermediate_rep.coords.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "isMain" => intermediate_rep.is_main.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "shopOutletCode" => intermediate_rep.shop_outlet_code.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "visibility" => intermediate_rep.visibility.push(<models::OutletVisibilityType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "address" => intermediate_rep.address.push(<models::OutletAddressDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "phones" => return std::result::Result::Err("Parsing a container in this style is not supported in ChangeOutletRequest".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "workingSchedule" => intermediate_rep.working_schedule.push(<models::OutletWorkingScheduleDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "deliveryRules" => return std::result::Result::Err("Parsing a container in this style is not supported in ChangeOutletRequest".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "storagePeriod" => intermediate_rep.storage_period.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ChangeOutletRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ChangeOutletRequest {
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "name missing in ChangeOutletRequest".to_string())?,
            r#type: intermediate_rep.r#type.into_iter().next().ok_or_else(|| "type missing in ChangeOutletRequest".to_string())?,
            coords: intermediate_rep.coords.into_iter().next(),
            is_main: intermediate_rep.is_main.into_iter().next(),
            shop_outlet_code: intermediate_rep.shop_outlet_code.into_iter().next(),
            visibility: intermediate_rep.visibility.into_iter().next(),
            address: intermediate_rep.address.into_iter().next().ok_or_else(|| "address missing in ChangeOutletRequest".to_string())?,
            phones: intermediate_rep.phones.into_iter().next().ok_or_else(|| "phones missing in ChangeOutletRequest".to_string())?,
            working_schedule: intermediate_rep.working_schedule.into_iter().next().ok_or_else(|| "workingSchedule missing in ChangeOutletRequest".to_string())?,
            delivery_rules: std::result::Result::Err("Nullable types not supported in ChangeOutletRequest".to_string())?,
            storage_period: intermediate_rep.storage_period.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ChangeOutletRequest> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<ChangeOutletRequest>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ChangeOutletRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ChangeOutletRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<ChangeOutletRequest> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ChangeOutletRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ChangeOutletRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Каналы продвижения товаров:  * `PUSH` — пуш-уведомление из приложения Яндекс Маркет.  * `STRETCH_MAIN` — верхний баннер-растяжка на главной странице Яндекс Маркета.  * `MAIN_PAGE_CAROUSEL` — карусель акций на главной странице Яндекс Маркета.  * `PRODUCT_RETAIL_PAGE` — товар на странице ритейл-повода.  * `MAIN_PAGE_CAROUSEL_WEB` — карусель акций на главной странице веб версии Яндекс Маркета.  * `PRODUCT_SEPARATE_LANDING` — товар на лендинге акции.  * `SUPER_SHELF_CATEGORY` — полка в категориях.  * `CAROUSEL_RETAIL_PAGE` — карусель на лендинге ритейл-повода.  * `POPUP_APPLICATION` — всплывающее окно в приложении Яндекс Маркет.  * `POST_TELEGRAM` — пост в Телеграм-канале Яндекс Маркета.  * `CPA` — реклама в партнерской сети Яндекс Маркета.  * `WEB_PERFORMANCE_DIRECT` — реклама в Яндекс Директе.  * `APP_PERFORMANCE` — реклама в AppStore и Google Play.  * `BANNER_PICKUP_POINT` — баннер в ПВЗ Маркета.  * `BLOGGER_PERFORMANCE` — рекламная интеграция у блогеров.  * `DIGITAL_CHANNEL_BANNER` — баннер в digital-каналах и социальных сетях VK, Одноклассники.  * `YANDEX_ECOSYSTEM_CHANNELS` — реклама в других сервисах Яндекса: GO, Delivery, Еда.  * `PARTNERS_MAIN_BANNER` — баннер на главной странице mail.ru, auto.ru, ya.ru.  * `OTHER` — прочее. 
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ChannelType {
}


impl ChannelType {
    #[allow(clippy::new_without_default)]
    pub fn new() -> ChannelType {
        ChannelType {
        }
    }
}

/// Converts the ChannelType value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ChannelType {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ChannelType value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ChannelType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ChannelType".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    _ => return std::result::Result::Err("Unexpected key while parsing ChannelType".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ChannelType {
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ChannelType> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<ChannelType>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ChannelType>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ChannelType - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<ChannelType> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ChannelType as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ChannelType - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Информация о сообщениях.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ChatMessageDto {
    /// Идентификатор сообщения.
    #[serde(rename = "messageId")]
    pub message_id: i64,

    /// Дата и время создания сообщения.  Формат даты: ISO 8601 со смещением относительно UTC. Например, `2017-11-21T00:00:00+03:00`. 
    #[serde(rename = "createdAt")]
    pub created_at: chrono::DateTime::<chrono::Utc>,

    #[serde(rename = "sender")]
    pub sender: models::ChatMessageSenderType,

    /// Текст сообщения.  Необязательный параметр, если возвращается параметр `payload`. 
    #[serde(rename = "message")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub message: Option<String>,

    /// Информация о приложенных к сообщению файлах.  Необязательный параметр, если возвращается параметр `message`. 
    #[serde(rename = "payload")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub payload: Option<swagger::Nullable<Vec<models::ChatMessagePayloadDto>>>,

}


impl ChatMessageDto {
    #[allow(clippy::new_without_default)]
    pub fn new(message_id: i64, created_at: chrono::DateTime::<chrono::Utc>, sender: models::ChatMessageSenderType, ) -> ChatMessageDto {
        ChatMessageDto {
            message_id,
            created_at,
            sender,
            message: None,
            payload: None,
        }
    }
}

/// Converts the ChatMessageDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ChatMessageDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            Some("messageId".to_string()),
            Some(self.message_id.to_string()),

            // Skipping createdAt in query parameter serialization

            // Skipping sender in query parameter serialization


            self.message.as_ref().map(|message| {
                [
                    "message".to_string(),
                    message.to_string(),
                ].join(",")
            }),

            // Skipping payload in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ChatMessageDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ChatMessageDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub message_id: Vec<i64>,
            pub created_at: Vec<chrono::DateTime::<chrono::Utc>>,
            pub sender: Vec<models::ChatMessageSenderType>,
            pub message: Vec<String>,
            pub payload: Vec<Vec<models::ChatMessagePayloadDto>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ChatMessageDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "messageId" => intermediate_rep.message_id.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "createdAt" => intermediate_rep.created_at.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "sender" => intermediate_rep.sender.push(<models::ChatMessageSenderType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "message" => intermediate_rep.message.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "payload" => return std::result::Result::Err("Parsing a container in this style is not supported in ChatMessageDto".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing ChatMessageDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ChatMessageDto {
            message_id: intermediate_rep.message_id.into_iter().next().ok_or_else(|| "messageId missing in ChatMessageDto".to_string())?,
            created_at: intermediate_rep.created_at.into_iter().next().ok_or_else(|| "createdAt missing in ChatMessageDto".to_string())?,
            sender: intermediate_rep.sender.into_iter().next().ok_or_else(|| "sender missing in ChatMessageDto".to_string())?,
            message: intermediate_rep.message.into_iter().next(),
            payload: std::result::Result::Err("Nullable types not supported in ChatMessageDto".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ChatMessageDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<ChatMessageDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ChatMessageDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ChatMessageDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<ChatMessageDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ChatMessageDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ChatMessageDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Информация о приложенных к сообщению файлах.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ChatMessagePayloadDto {
    /// Имя файла.
    #[serde(rename = "name")]
    pub name: String,

    /// Ссылка для скачивания файла.
    #[serde(rename = "url")]
    pub url: String,

    /// Размер файла в байтах.
    #[serde(rename = "size")]
    pub size: i32,

}


impl ChatMessagePayloadDto {
    #[allow(clippy::new_without_default)]
    pub fn new(name: String, url: String, size: i32, ) -> ChatMessagePayloadDto {
        ChatMessagePayloadDto {
            name,
            url,
            size,
        }
    }
}

/// Converts the ChatMessagePayloadDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ChatMessagePayloadDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            Some("name".to_string()),
            Some(self.name.to_string()),


            Some("url".to_string()),
            Some(self.url.to_string()),


            Some("size".to_string()),
            Some(self.size.to_string()),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ChatMessagePayloadDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ChatMessagePayloadDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub name: Vec<String>,
            pub url: Vec<String>,
            pub size: Vec<i32>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ChatMessagePayloadDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "url" => intermediate_rep.url.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "size" => intermediate_rep.size.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ChatMessagePayloadDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ChatMessagePayloadDto {
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "name missing in ChatMessagePayloadDto".to_string())?,
            url: intermediate_rep.url.into_iter().next().ok_or_else(|| "url missing in ChatMessagePayloadDto".to_string())?,
            size: intermediate_rep.size.into_iter().next().ok_or_else(|| "size missing in ChatMessagePayloadDto".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ChatMessagePayloadDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<ChatMessagePayloadDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ChatMessagePayloadDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ChatMessagePayloadDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<ChatMessagePayloadDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ChatMessagePayloadDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ChatMessagePayloadDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Кто отправил сообщение:  * `PARTNER` — магазин. * `CUSTOMER` — покупатель. * `MARKET` — Маркет. * `SUPPORT` — сотрудник службы поддержки Маркета. 
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum ChatMessageSenderType {
    #[serde(rename = "PARTNER")]
    Partner,
    #[serde(rename = "CUSTOMER")]
    Customer,
    #[serde(rename = "MARKET")]
    Market,
    #[serde(rename = "SUPPORT")]
    Support,
}

impl std::fmt::Display for ChatMessageSenderType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            ChatMessageSenderType::Partner => write!(f, "PARTNER"),
            ChatMessageSenderType::Customer => write!(f, "CUSTOMER"),
            ChatMessageSenderType::Market => write!(f, "MARKET"),
            ChatMessageSenderType::Support => write!(f, "SUPPORT"),
        }
    }
}

impl std::str::FromStr for ChatMessageSenderType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "PARTNER" => std::result::Result::Ok(ChatMessageSenderType::Partner),
            "CUSTOMER" => std::result::Result::Ok(ChatMessageSenderType::Customer),
            "MARKET" => std::result::Result::Ok(ChatMessageSenderType::Market),
            "SUPPORT" => std::result::Result::Ok(ChatMessageSenderType::Support),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Информация о сообщениях.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ChatMessagesResultDto {
    /// Идентификатор заказа.
    #[serde(rename = "orderId")]
    pub order_id: i64,

    /// Информация о сообщениях.
    #[serde(rename = "messages")]
    pub messages: Vec<models::ChatMessageDto>,

    #[serde(rename = "paging")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub paging: Option<models::ForwardScrollingPagerDto>,

}


impl ChatMessagesResultDto {
    #[allow(clippy::new_without_default)]
    pub fn new(order_id: i64, messages: Vec<models::ChatMessageDto>, ) -> ChatMessagesResultDto {
        ChatMessagesResultDto {
            order_id,
            messages,
            paging: None,
        }
    }
}

/// Converts the ChatMessagesResultDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ChatMessagesResultDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            Some("orderId".to_string()),
            Some(self.order_id.to_string()),

            // Skipping messages in query parameter serialization

            // Skipping paging in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ChatMessagesResultDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ChatMessagesResultDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub order_id: Vec<i64>,
            pub messages: Vec<Vec<models::ChatMessageDto>>,
            pub paging: Vec<models::ForwardScrollingPagerDto>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ChatMessagesResultDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "orderId" => intermediate_rep.order_id.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "messages" => return std::result::Result::Err("Parsing a container in this style is not supported in ChatMessagesResultDto".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "paging" => intermediate_rep.paging.push(<models::ForwardScrollingPagerDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ChatMessagesResultDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ChatMessagesResultDto {
            order_id: intermediate_rep.order_id.into_iter().next().ok_or_else(|| "orderId missing in ChatMessagesResultDto".to_string())?,
            messages: intermediate_rep.messages.into_iter().next().ok_or_else(|| "messages missing in ChatMessagesResultDto".to_string())?,
            paging: intermediate_rep.paging.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ChatMessagesResultDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<ChatMessagesResultDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ChatMessagesResultDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ChatMessagesResultDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<ChatMessagesResultDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ChatMessagesResultDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ChatMessagesResultDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Статус чата:  * `NEW` — новый чат. * `WAITING_FOR_CUSTOMER` — нужен ответ покупателя. * `WAITING_FOR_PARTNER` — нужен ответ магазина. * `WAITING_FOR_ARBITER` — нужен ответ арбитра. * `WAITING_FOR_MARKET` — нужен ответ Маркета. * `FINISHED` — чат завершен. 
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum ChatStatusType {
    #[serde(rename = "NEW")]
    New,
    #[serde(rename = "WAITING_FOR_CUSTOMER")]
    WaitingForCustomer,
    #[serde(rename = "WAITING_FOR_PARTNER")]
    WaitingForPartner,
    #[serde(rename = "WAITING_FOR_ARBITER")]
    WaitingForArbiter,
    #[serde(rename = "WAITING_FOR_MARKET")]
    WaitingForMarket,
    #[serde(rename = "FINISHED")]
    Finished,
}

impl std::fmt::Display for ChatStatusType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            ChatStatusType::New => write!(f, "NEW"),
            ChatStatusType::WaitingForCustomer => write!(f, "WAITING_FOR_CUSTOMER"),
            ChatStatusType::WaitingForPartner => write!(f, "WAITING_FOR_PARTNER"),
            ChatStatusType::WaitingForArbiter => write!(f, "WAITING_FOR_ARBITER"),
            ChatStatusType::WaitingForMarket => write!(f, "WAITING_FOR_MARKET"),
            ChatStatusType::Finished => write!(f, "FINISHED"),
        }
    }
}

impl std::str::FromStr for ChatStatusType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "NEW" => std::result::Result::Ok(ChatStatusType::New),
            "WAITING_FOR_CUSTOMER" => std::result::Result::Ok(ChatStatusType::WaitingForCustomer),
            "WAITING_FOR_PARTNER" => std::result::Result::Ok(ChatStatusType::WaitingForPartner),
            "WAITING_FOR_ARBITER" => std::result::Result::Ok(ChatStatusType::WaitingForArbiter),
            "WAITING_FOR_MARKET" => std::result::Result::Ok(ChatStatusType::WaitingForMarket),
            "FINISHED" => std::result::Result::Ok(ChatStatusType::Finished),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Тип чата:  * `CHAT` — чат с покупателем. * `ARBITRAGE` — спор. 
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum ChatType {
    #[serde(rename = "CHAT")]
    Chat,
    #[serde(rename = "ARBITRAGE")]
    Arbitrage,
}

impl std::fmt::Display for ChatType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            ChatType::Chat => write!(f, "CHAT"),
            ChatType::Arbitrage => write!(f, "ARBITRAGE"),
        }
    }
}

impl std::str::FromStr for ChatType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "CHAT" => std::result::Result::Ok(ChatType::Chat),
            "ARBITRAGE" => std::result::Result::Ok(ChatType::Arbitrage),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Код идентификации единицы товара [в системе «Честный ЗНАК»](https://честныйзнак.рф/).  {% note warning %}  Не экранируйте косую черту в коде символа-разделителя `\\u001d`!  ✅ `01030410947874432155Qbag!\\u001d93Zjqw`  ❌ `01030410947874432155Qbag!\\\\u001d93Zjqw`  Косые черты и кавычки в других местах экранируйте по правилам JSON: `\\\\` и `\\\"`  {% endnote %} 
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Cis(String);

impl std::convert::From<String> for Cis {
    fn from(x: String) -> Self {
        Cis(x)
    }
}

impl std::string::ToString for Cis {
    fn to_string(&self) -> String {
       self.0.to_string()
    }
}

impl std::str::FromStr for Cis {
    type Err = std::string::ParseError;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(Cis(x.to_string()))
    }
}

impl std::convert::From<Cis> for String {
    fn from(x: Cis) -> Self {
        x.0
    }
}

impl std::ops::Deref for Cis {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for Cis {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}


/// Запрос на подтверждение цены. 
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ConfirmPricesRequest {
    /// Идентификаторы товаров, у которых подтверждается цена.
    #[serde(rename = "offerIds")]
    #[validate(
            length(min = 1, max = 200),
        )]
    pub offer_ids: Vec<models::ShopSku>,

}


impl ConfirmPricesRequest {
    #[allow(clippy::new_without_default)]
    pub fn new(offer_ids: Vec<models::ShopSku>, ) -> ConfirmPricesRequest {
        ConfirmPricesRequest {
            offer_ids,
        }
    }
}

/// Converts the ConfirmPricesRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ConfirmPricesRequest {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            Some("offerIds".to_string()),
            Some(self.offer_ids.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ConfirmPricesRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ConfirmPricesRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub offer_ids: Vec<Vec<models::ShopSku>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ConfirmPricesRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "offerIds" => return std::result::Result::Err("Parsing a container in this style is not supported in ConfirmPricesRequest".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing ConfirmPricesRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ConfirmPricesRequest {
            offer_ids: intermediate_rep.offer_ids.into_iter().next().ok_or_else(|| "offerIds missing in ConfirmPricesRequest".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ConfirmPricesRequest> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<ConfirmPricesRequest>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ConfirmPricesRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ConfirmPricesRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<ConfirmPricesRequest> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ConfirmPricesRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ConfirmPricesRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Запрос для подтверждения отгрузки.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ConfirmShipmentRequest {
    /// Идентификатор отгрузки в системе поставщика.
    #[serde(rename = "externalShipmentId")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub external_shipment_id: Option<String>,

}


impl ConfirmShipmentRequest {
    #[allow(clippy::new_without_default)]
    pub fn new() -> ConfirmShipmentRequest {
        ConfirmShipmentRequest {
            external_shipment_id: None,
        }
    }
}

/// Converts the ConfirmShipmentRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ConfirmShipmentRequest {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.external_shipment_id.as_ref().map(|external_shipment_id| {
                [
                    "externalShipmentId".to_string(),
                    external_shipment_id.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ConfirmShipmentRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ConfirmShipmentRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub external_shipment_id: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ConfirmShipmentRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "externalShipmentId" => intermediate_rep.external_shipment_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ConfirmShipmentRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ConfirmShipmentRequest {
            external_shipment_id: intermediate_rep.external_shipment_id.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ConfirmShipmentRequest> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<ConfirmShipmentRequest>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ConfirmShipmentRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ConfirmShipmentRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<ConfirmShipmentRequest> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ConfirmShipmentRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ConfirmShipmentRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Заказ, для которого нужно создать чат. 
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CreateChatRequest {
    /// Идентификатор заказа на Маркете.
    #[serde(rename = "orderId")]
    pub order_id: i64,

}


impl CreateChatRequest {
    #[allow(clippy::new_without_default)]
    pub fn new(order_id: i64, ) -> CreateChatRequest {
        CreateChatRequest {
            order_id,
        }
    }
}

/// Converts the CreateChatRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for CreateChatRequest {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            Some("orderId".to_string()),
            Some(self.order_id.to_string()),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CreateChatRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CreateChatRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub order_id: Vec<i64>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CreateChatRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "orderId" => intermediate_rep.order_id.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CreateChatRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CreateChatRequest {
            order_id: intermediate_rep.order_id.into_iter().next().ok_or_else(|| "orderId missing in CreateChatRequest".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CreateChatRequest> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<CreateChatRequest>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CreateChatRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CreateChatRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<CreateChatRequest> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CreateChatRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CreateChatRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Результат создания чата.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CreateChatResponse {
    #[serde(rename = "status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<models::ApiResponseStatusType>,

    #[serde(rename = "result")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub result: Option<models::CreateChatResultDto>,

}


impl CreateChatResponse {
    #[allow(clippy::new_without_default)]
    pub fn new() -> CreateChatResponse {
        CreateChatResponse {
            status: None,
            result: None,
        }
    }
}

/// Converts the CreateChatResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for CreateChatResponse {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping status in query parameter serialization

            // Skipping result in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CreateChatResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CreateChatResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub status: Vec<models::ApiResponseStatusType>,
            pub result: Vec<models::CreateChatResultDto>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CreateChatResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(<models::ApiResponseStatusType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "result" => intermediate_rep.result.push(<models::CreateChatResultDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CreateChatResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CreateChatResponse {
            status: intermediate_rep.status.into_iter().next(),
            result: intermediate_rep.result.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CreateChatResponse> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<CreateChatResponse>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CreateChatResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CreateChatResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<CreateChatResponse> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CreateChatResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CreateChatResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Информация о созданном чате.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CreateChatResultDto {
    /// Идентификатор чата.
    #[serde(rename = "chatId")]
    pub chat_id: i64,

}


impl CreateChatResultDto {
    #[allow(clippy::new_without_default)]
    pub fn new(chat_id: i64, ) -> CreateChatResultDto {
        CreateChatResultDto {
            chat_id,
        }
    }
}

/// Converts the CreateChatResultDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for CreateChatResultDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            Some("chatId".to_string()),
            Some(self.chat_id.to_string()),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CreateChatResultDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CreateChatResultDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub chat_id: Vec<i64>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CreateChatResultDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "chatId" => intermediate_rep.chat_id.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CreateChatResultDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CreateChatResultDto {
            chat_id: intermediate_rep.chat_id.into_iter().next().ok_or_else(|| "chatId missing in CreateChatResultDto".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CreateChatResultDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<CreateChatResultDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CreateChatResultDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CreateChatResultDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<CreateChatResultDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CreateChatResultDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CreateChatResultDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Ответ на запрос о создании точки продаж.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CreateOutletResponse {
    #[serde(rename = "status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<models::ApiResponseStatusType>,

    #[serde(rename = "result")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub result: Option<models::OutletResponseDto>,

}


impl CreateOutletResponse {
    #[allow(clippy::new_without_default)]
    pub fn new() -> CreateOutletResponse {
        CreateOutletResponse {
            status: None,
            result: None,
        }
    }
}

/// Converts the CreateOutletResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for CreateOutletResponse {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping status in query parameter serialization

            // Skipping result in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CreateOutletResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CreateOutletResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub status: Vec<models::ApiResponseStatusType>,
            pub result: Vec<models::OutletResponseDto>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CreateOutletResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(<models::ApiResponseStatusType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "result" => intermediate_rep.result.push(<models::OutletResponseDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CreateOutletResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CreateOutletResponse {
            status: intermediate_rep.status.into_iter().next(),
            result: intermediate_rep.result.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CreateOutletResponse> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<CreateOutletResponse>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CreateOutletResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CreateOutletResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<CreateOutletResponse> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CreateOutletResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CreateOutletResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Коды валют. Возможные значения: * `BYR` — белорусский рубль. * `KZT` — казахстанский тенге. * `RUR` — российский рубль. * `UAH` — украинская гривна. 
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum CurrencyType {
    #[serde(rename = "RUR")]
    Rur,
    #[serde(rename = "USD")]
    Usd,
    #[serde(rename = "EUR")]
    Eur,
    #[serde(rename = "UAH")]
    Uah,
    #[serde(rename = "AUD")]
    Aud,
    #[serde(rename = "GBP")]
    Gbp,
    #[serde(rename = "BYR")]
    Byr,
    #[serde(rename = "BYN")]
    Byn,
    #[serde(rename = "DKK")]
    Dkk,
    #[serde(rename = "ISK")]
    Isk,
    #[serde(rename = "KZT")]
    Kzt,
    #[serde(rename = "CAD")]
    Cad,
    #[serde(rename = "CNY")]
    Cny,
    #[serde(rename = "NOK")]
    Nok,
    #[serde(rename = "XDR")]
    Xdr,
    #[serde(rename = "SGD")]
    Sgd,
    #[serde(rename = "TRY")]
    Try,
    #[serde(rename = "SEK")]
    Sek,
    #[serde(rename = "CHF")]
    Chf,
    #[serde(rename = "JPY")]
    Jpy,
    #[serde(rename = "AZN")]
    Azn,
    #[serde(rename = "ALL")]
    All,
    #[serde(rename = "DZD")]
    Dzd,
    #[serde(rename = "AOA")]
    Aoa,
    #[serde(rename = "ARS")]
    Ars,
    #[serde(rename = "AMD")]
    Amd,
    #[serde(rename = "AFN")]
    Afn,
    #[serde(rename = "BHD")]
    Bhd,
    #[serde(rename = "BGN")]
    Bgn,
    #[serde(rename = "BOB")]
    Bob,
    #[serde(rename = "BWP")]
    Bwp,
    #[serde(rename = "BND")]
    Bnd,
    #[serde(rename = "BRL")]
    Brl,
    #[serde(rename = "BIF")]
    Bif,
    #[serde(rename = "HUF")]
    Huf,
    #[serde(rename = "VEF")]
    Vef,
    #[serde(rename = "KPW")]
    Kpw,
    #[serde(rename = "VND")]
    Vnd,
    #[serde(rename = "GMD")]
    Gmd,
    #[serde(rename = "GHS")]
    Ghs,
    #[serde(rename = "GNF")]
    Gnf,
    #[serde(rename = "HKD")]
    Hkd,
    #[serde(rename = "GEL")]
    Gel,
    #[serde(rename = "AED")]
    Aed,
    #[serde(rename = "EGP")]
    Egp,
    #[serde(rename = "ZMK")]
    Zmk,
    #[serde(rename = "ILS")]
    Ils,
    #[serde(rename = "INR")]
    Inr,
    #[serde(rename = "IDR")]
    Idr,
    #[serde(rename = "JOD")]
    Jod,
    #[serde(rename = "IQD")]
    Iqd,
    #[serde(rename = "IRR")]
    Irr,
    #[serde(rename = "YER")]
    Yer,
    #[serde(rename = "QAR")]
    Qar,
    #[serde(rename = "KES")]
    Kes,
    #[serde(rename = "KGS")]
    Kgs,
    #[serde(rename = "COP")]
    Cop,
    #[serde(rename = "CDF")]
    Cdf,
    #[serde(rename = "CRC")]
    Crc,
    #[serde(rename = "KWD")]
    Kwd,
    #[serde(rename = "CUP")]
    Cup,
    #[serde(rename = "LAK")]
    Lak,
    #[serde(rename = "LVL")]
    Lvl,
    #[serde(rename = "SLL")]
    Sll,
    #[serde(rename = "LBP")]
    Lbp,
    #[serde(rename = "LYD")]
    Lyd,
    #[serde(rename = "SZL")]
    Szl,
    #[serde(rename = "LTL")]
    Ltl,
    #[serde(rename = "MUR")]
    Mur,
    #[serde(rename = "MRO")]
    Mro,
    #[serde(rename = "MKD")]
    Mkd,
    #[serde(rename = "MWK")]
    Mwk,
    #[serde(rename = "MGA")]
    Mga,
    #[serde(rename = "MYR")]
    Myr,
    #[serde(rename = "MAD")]
    Mad,
    #[serde(rename = "MXN")]
    Mxn,
    #[serde(rename = "MZN")]
    Mzn,
    #[serde(rename = "MDL")]
    Mdl,
    #[serde(rename = "MNT")]
    Mnt,
    #[serde(rename = "NPR")]
    Npr,
    #[serde(rename = "NGN")]
    Ngn,
    #[serde(rename = "NIO")]
    Nio,
    #[serde(rename = "NZD")]
    Nzd,
    #[serde(rename = "OMR")]
    Omr,
    #[serde(rename = "PKR")]
    Pkr,
    #[serde(rename = "PYG")]
    Pyg,
    #[serde(rename = "PEN")]
    Pen,
    #[serde(rename = "PLN")]
    Pln,
    #[serde(rename = "KHR")]
    Khr,
    #[serde(rename = "SAR")]
    Sar,
    #[serde(rename = "RON")]
    Ron,
    #[serde(rename = "SCR")]
    Scr,
    #[serde(rename = "SYP")]
    Syp,
    #[serde(rename = "SKK")]
    Skk,
    #[serde(rename = "SOS")]
    Sos,
    #[serde(rename = "SDG")]
    Sdg,
    #[serde(rename = "SRD")]
    Srd,
    #[serde(rename = "TJS")]
    Tjs,
    #[serde(rename = "THB")]
    Thb,
    #[serde(rename = "TWD")]
    Twd,
    #[serde(rename = "BDT")]
    Bdt,
    #[serde(rename = "TZS")]
    Tzs,
    #[serde(rename = "TND")]
    Tnd,
    #[serde(rename = "TMM")]
    Tmm,
    #[serde(rename = "UGX")]
    Ugx,
    #[serde(rename = "UZS")]
    Uzs,
    #[serde(rename = "UYU")]
    Uyu,
    #[serde(rename = "PHP")]
    Php,
    #[serde(rename = "DJF")]
    Djf,
    #[serde(rename = "XAF")]
    Xaf,
    #[serde(rename = "XOF")]
    Xof,
    #[serde(rename = "HRK")]
    Hrk,
    #[serde(rename = "CZK")]
    Czk,
    #[serde(rename = "CLP")]
    Clp,
    #[serde(rename = "LKR")]
    Lkr,
    #[serde(rename = "EEK")]
    Eek,
    #[serde(rename = "ETB")]
    Etb,
    #[serde(rename = "RSD")]
    Rsd,
    #[serde(rename = "ZAR")]
    Zar,
    #[serde(rename = "KRW")]
    Krw,
    #[serde(rename = "NAD")]
    Nad,
    #[serde(rename = "TL")]
    Tl,
    #[serde(rename = "UE")]
    Ue,
}

impl std::fmt::Display for CurrencyType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            CurrencyType::Rur => write!(f, "RUR"),
            CurrencyType::Usd => write!(f, "USD"),
            CurrencyType::Eur => write!(f, "EUR"),
            CurrencyType::Uah => write!(f, "UAH"),
            CurrencyType::Aud => write!(f, "AUD"),
            CurrencyType::Gbp => write!(f, "GBP"),
            CurrencyType::Byr => write!(f, "BYR"),
            CurrencyType::Byn => write!(f, "BYN"),
            CurrencyType::Dkk => write!(f, "DKK"),
            CurrencyType::Isk => write!(f, "ISK"),
            CurrencyType::Kzt => write!(f, "KZT"),
            CurrencyType::Cad => write!(f, "CAD"),
            CurrencyType::Cny => write!(f, "CNY"),
            CurrencyType::Nok => write!(f, "NOK"),
            CurrencyType::Xdr => write!(f, "XDR"),
            CurrencyType::Sgd => write!(f, "SGD"),
            CurrencyType::Try => write!(f, "TRY"),
            CurrencyType::Sek => write!(f, "SEK"),
            CurrencyType::Chf => write!(f, "CHF"),
            CurrencyType::Jpy => write!(f, "JPY"),
            CurrencyType::Azn => write!(f, "AZN"),
            CurrencyType::All => write!(f, "ALL"),
            CurrencyType::Dzd => write!(f, "DZD"),
            CurrencyType::Aoa => write!(f, "AOA"),
            CurrencyType::Ars => write!(f, "ARS"),
            CurrencyType::Amd => write!(f, "AMD"),
            CurrencyType::Afn => write!(f, "AFN"),
            CurrencyType::Bhd => write!(f, "BHD"),
            CurrencyType::Bgn => write!(f, "BGN"),
            CurrencyType::Bob => write!(f, "BOB"),
            CurrencyType::Bwp => write!(f, "BWP"),
            CurrencyType::Bnd => write!(f, "BND"),
            CurrencyType::Brl => write!(f, "BRL"),
            CurrencyType::Bif => write!(f, "BIF"),
            CurrencyType::Huf => write!(f, "HUF"),
            CurrencyType::Vef => write!(f, "VEF"),
            CurrencyType::Kpw => write!(f, "KPW"),
            CurrencyType::Vnd => write!(f, "VND"),
            CurrencyType::Gmd => write!(f, "GMD"),
            CurrencyType::Ghs => write!(f, "GHS"),
            CurrencyType::Gnf => write!(f, "GNF"),
            CurrencyType::Hkd => write!(f, "HKD"),
            CurrencyType::Gel => write!(f, "GEL"),
            CurrencyType::Aed => write!(f, "AED"),
            CurrencyType::Egp => write!(f, "EGP"),
            CurrencyType::Zmk => write!(f, "ZMK"),
            CurrencyType::Ils => write!(f, "ILS"),
            CurrencyType::Inr => write!(f, "INR"),
            CurrencyType::Idr => write!(f, "IDR"),
            CurrencyType::Jod => write!(f, "JOD"),
            CurrencyType::Iqd => write!(f, "IQD"),
            CurrencyType::Irr => write!(f, "IRR"),
            CurrencyType::Yer => write!(f, "YER"),
            CurrencyType::Qar => write!(f, "QAR"),
            CurrencyType::Kes => write!(f, "KES"),
            CurrencyType::Kgs => write!(f, "KGS"),
            CurrencyType::Cop => write!(f, "COP"),
            CurrencyType::Cdf => write!(f, "CDF"),
            CurrencyType::Crc => write!(f, "CRC"),
            CurrencyType::Kwd => write!(f, "KWD"),
            CurrencyType::Cup => write!(f, "CUP"),
            CurrencyType::Lak => write!(f, "LAK"),
            CurrencyType::Lvl => write!(f, "LVL"),
            CurrencyType::Sll => write!(f, "SLL"),
            CurrencyType::Lbp => write!(f, "LBP"),
            CurrencyType::Lyd => write!(f, "LYD"),
            CurrencyType::Szl => write!(f, "SZL"),
            CurrencyType::Ltl => write!(f, "LTL"),
            CurrencyType::Mur => write!(f, "MUR"),
            CurrencyType::Mro => write!(f, "MRO"),
            CurrencyType::Mkd => write!(f, "MKD"),
            CurrencyType::Mwk => write!(f, "MWK"),
            CurrencyType::Mga => write!(f, "MGA"),
            CurrencyType::Myr => write!(f, "MYR"),
            CurrencyType::Mad => write!(f, "MAD"),
            CurrencyType::Mxn => write!(f, "MXN"),
            CurrencyType::Mzn => write!(f, "MZN"),
            CurrencyType::Mdl => write!(f, "MDL"),
            CurrencyType::Mnt => write!(f, "MNT"),
            CurrencyType::Npr => write!(f, "NPR"),
            CurrencyType::Ngn => write!(f, "NGN"),
            CurrencyType::Nio => write!(f, "NIO"),
            CurrencyType::Nzd => write!(f, "NZD"),
            CurrencyType::Omr => write!(f, "OMR"),
            CurrencyType::Pkr => write!(f, "PKR"),
            CurrencyType::Pyg => write!(f, "PYG"),
            CurrencyType::Pen => write!(f, "PEN"),
            CurrencyType::Pln => write!(f, "PLN"),
            CurrencyType::Khr => write!(f, "KHR"),
            CurrencyType::Sar => write!(f, "SAR"),
            CurrencyType::Ron => write!(f, "RON"),
            CurrencyType::Scr => write!(f, "SCR"),
            CurrencyType::Syp => write!(f, "SYP"),
            CurrencyType::Skk => write!(f, "SKK"),
            CurrencyType::Sos => write!(f, "SOS"),
            CurrencyType::Sdg => write!(f, "SDG"),
            CurrencyType::Srd => write!(f, "SRD"),
            CurrencyType::Tjs => write!(f, "TJS"),
            CurrencyType::Thb => write!(f, "THB"),
            CurrencyType::Twd => write!(f, "TWD"),
            CurrencyType::Bdt => write!(f, "BDT"),
            CurrencyType::Tzs => write!(f, "TZS"),
            CurrencyType::Tnd => write!(f, "TND"),
            CurrencyType::Tmm => write!(f, "TMM"),
            CurrencyType::Ugx => write!(f, "UGX"),
            CurrencyType::Uzs => write!(f, "UZS"),
            CurrencyType::Uyu => write!(f, "UYU"),
            CurrencyType::Php => write!(f, "PHP"),
            CurrencyType::Djf => write!(f, "DJF"),
            CurrencyType::Xaf => write!(f, "XAF"),
            CurrencyType::Xof => write!(f, "XOF"),
            CurrencyType::Hrk => write!(f, "HRK"),
            CurrencyType::Czk => write!(f, "CZK"),
            CurrencyType::Clp => write!(f, "CLP"),
            CurrencyType::Lkr => write!(f, "LKR"),
            CurrencyType::Eek => write!(f, "EEK"),
            CurrencyType::Etb => write!(f, "ETB"),
            CurrencyType::Rsd => write!(f, "RSD"),
            CurrencyType::Zar => write!(f, "ZAR"),
            CurrencyType::Krw => write!(f, "KRW"),
            CurrencyType::Nad => write!(f, "NAD"),
            CurrencyType::Tl => write!(f, "TL"),
            CurrencyType::Ue => write!(f, "UE"),
        }
    }
}

impl std::str::FromStr for CurrencyType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "RUR" => std::result::Result::Ok(CurrencyType::Rur),
            "USD" => std::result::Result::Ok(CurrencyType::Usd),
            "EUR" => std::result::Result::Ok(CurrencyType::Eur),
            "UAH" => std::result::Result::Ok(CurrencyType::Uah),
            "AUD" => std::result::Result::Ok(CurrencyType::Aud),
            "GBP" => std::result::Result::Ok(CurrencyType::Gbp),
            "BYR" => std::result::Result::Ok(CurrencyType::Byr),
            "BYN" => std::result::Result::Ok(CurrencyType::Byn),
            "DKK" => std::result::Result::Ok(CurrencyType::Dkk),
            "ISK" => std::result::Result::Ok(CurrencyType::Isk),
            "KZT" => std::result::Result::Ok(CurrencyType::Kzt),
            "CAD" => std::result::Result::Ok(CurrencyType::Cad),
            "CNY" => std::result::Result::Ok(CurrencyType::Cny),
            "NOK" => std::result::Result::Ok(CurrencyType::Nok),
            "XDR" => std::result::Result::Ok(CurrencyType::Xdr),
            "SGD" => std::result::Result::Ok(CurrencyType::Sgd),
            "TRY" => std::result::Result::Ok(CurrencyType::Try),
            "SEK" => std::result::Result::Ok(CurrencyType::Sek),
            "CHF" => std::result::Result::Ok(CurrencyType::Chf),
            "JPY" => std::result::Result::Ok(CurrencyType::Jpy),
            "AZN" => std::result::Result::Ok(CurrencyType::Azn),
            "ALL" => std::result::Result::Ok(CurrencyType::All),
            "DZD" => std::result::Result::Ok(CurrencyType::Dzd),
            "AOA" => std::result::Result::Ok(CurrencyType::Aoa),
            "ARS" => std::result::Result::Ok(CurrencyType::Ars),
            "AMD" => std::result::Result::Ok(CurrencyType::Amd),
            "AFN" => std::result::Result::Ok(CurrencyType::Afn),
            "BHD" => std::result::Result::Ok(CurrencyType::Bhd),
            "BGN" => std::result::Result::Ok(CurrencyType::Bgn),
            "BOB" => std::result::Result::Ok(CurrencyType::Bob),
            "BWP" => std::result::Result::Ok(CurrencyType::Bwp),
            "BND" => std::result::Result::Ok(CurrencyType::Bnd),
            "BRL" => std::result::Result::Ok(CurrencyType::Brl),
            "BIF" => std::result::Result::Ok(CurrencyType::Bif),
            "HUF" => std::result::Result::Ok(CurrencyType::Huf),
            "VEF" => std::result::Result::Ok(CurrencyType::Vef),
            "KPW" => std::result::Result::Ok(CurrencyType::Kpw),
            "VND" => std::result::Result::Ok(CurrencyType::Vnd),
            "GMD" => std::result::Result::Ok(CurrencyType::Gmd),
            "GHS" => std::result::Result::Ok(CurrencyType::Ghs),
            "GNF" => std::result::Result::Ok(CurrencyType::Gnf),
            "HKD" => std::result::Result::Ok(CurrencyType::Hkd),
            "GEL" => std::result::Result::Ok(CurrencyType::Gel),
            "AED" => std::result::Result::Ok(CurrencyType::Aed),
            "EGP" => std::result::Result::Ok(CurrencyType::Egp),
            "ZMK" => std::result::Result::Ok(CurrencyType::Zmk),
            "ILS" => std::result::Result::Ok(CurrencyType::Ils),
            "INR" => std::result::Result::Ok(CurrencyType::Inr),
            "IDR" => std::result::Result::Ok(CurrencyType::Idr),
            "JOD" => std::result::Result::Ok(CurrencyType::Jod),
            "IQD" => std::result::Result::Ok(CurrencyType::Iqd),
            "IRR" => std::result::Result::Ok(CurrencyType::Irr),
            "YER" => std::result::Result::Ok(CurrencyType::Yer),
            "QAR" => std::result::Result::Ok(CurrencyType::Qar),
            "KES" => std::result::Result::Ok(CurrencyType::Kes),
            "KGS" => std::result::Result::Ok(CurrencyType::Kgs),
            "COP" => std::result::Result::Ok(CurrencyType::Cop),
            "CDF" => std::result::Result::Ok(CurrencyType::Cdf),
            "CRC" => std::result::Result::Ok(CurrencyType::Crc),
            "KWD" => std::result::Result::Ok(CurrencyType::Kwd),
            "CUP" => std::result::Result::Ok(CurrencyType::Cup),
            "LAK" => std::result::Result::Ok(CurrencyType::Lak),
            "LVL" => std::result::Result::Ok(CurrencyType::Lvl),
            "SLL" => std::result::Result::Ok(CurrencyType::Sll),
            "LBP" => std::result::Result::Ok(CurrencyType::Lbp),
            "LYD" => std::result::Result::Ok(CurrencyType::Lyd),
            "SZL" => std::result::Result::Ok(CurrencyType::Szl),
            "LTL" => std::result::Result::Ok(CurrencyType::Ltl),
            "MUR" => std::result::Result::Ok(CurrencyType::Mur),
            "MRO" => std::result::Result::Ok(CurrencyType::Mro),
            "MKD" => std::result::Result::Ok(CurrencyType::Mkd),
            "MWK" => std::result::Result::Ok(CurrencyType::Mwk),
            "MGA" => std::result::Result::Ok(CurrencyType::Mga),
            "MYR" => std::result::Result::Ok(CurrencyType::Myr),
            "MAD" => std::result::Result::Ok(CurrencyType::Mad),
            "MXN" => std::result::Result::Ok(CurrencyType::Mxn),
            "MZN" => std::result::Result::Ok(CurrencyType::Mzn),
            "MDL" => std::result::Result::Ok(CurrencyType::Mdl),
            "MNT" => std::result::Result::Ok(CurrencyType::Mnt),
            "NPR" => std::result::Result::Ok(CurrencyType::Npr),
            "NGN" => std::result::Result::Ok(CurrencyType::Ngn),
            "NIO" => std::result::Result::Ok(CurrencyType::Nio),
            "NZD" => std::result::Result::Ok(CurrencyType::Nzd),
            "OMR" => std::result::Result::Ok(CurrencyType::Omr),
            "PKR" => std::result::Result::Ok(CurrencyType::Pkr),
            "PYG" => std::result::Result::Ok(CurrencyType::Pyg),
            "PEN" => std::result::Result::Ok(CurrencyType::Pen),
            "PLN" => std::result::Result::Ok(CurrencyType::Pln),
            "KHR" => std::result::Result::Ok(CurrencyType::Khr),
            "SAR" => std::result::Result::Ok(CurrencyType::Sar),
            "RON" => std::result::Result::Ok(CurrencyType::Ron),
            "SCR" => std::result::Result::Ok(CurrencyType::Scr),
            "SYP" => std::result::Result::Ok(CurrencyType::Syp),
            "SKK" => std::result::Result::Ok(CurrencyType::Skk),
            "SOS" => std::result::Result::Ok(CurrencyType::Sos),
            "SDG" => std::result::Result::Ok(CurrencyType::Sdg),
            "SRD" => std::result::Result::Ok(CurrencyType::Srd),
            "TJS" => std::result::Result::Ok(CurrencyType::Tjs),
            "THB" => std::result::Result::Ok(CurrencyType::Thb),
            "TWD" => std::result::Result::Ok(CurrencyType::Twd),
            "BDT" => std::result::Result::Ok(CurrencyType::Bdt),
            "TZS" => std::result::Result::Ok(CurrencyType::Tzs),
            "TND" => std::result::Result::Ok(CurrencyType::Tnd),
            "TMM" => std::result::Result::Ok(CurrencyType::Tmm),
            "UGX" => std::result::Result::Ok(CurrencyType::Ugx),
            "UZS" => std::result::Result::Ok(CurrencyType::Uzs),
            "UYU" => std::result::Result::Ok(CurrencyType::Uyu),
            "PHP" => std::result::Result::Ok(CurrencyType::Php),
            "DJF" => std::result::Result::Ok(CurrencyType::Djf),
            "XAF" => std::result::Result::Ok(CurrencyType::Xaf),
            "XOF" => std::result::Result::Ok(CurrencyType::Xof),
            "HRK" => std::result::Result::Ok(CurrencyType::Hrk),
            "CZK" => std::result::Result::Ok(CurrencyType::Czk),
            "CLP" => std::result::Result::Ok(CurrencyType::Clp),
            "LKR" => std::result::Result::Ok(CurrencyType::Lkr),
            "EEK" => std::result::Result::Ok(CurrencyType::Eek),
            "ETB" => std::result::Result::Ok(CurrencyType::Etb),
            "RSD" => std::result::Result::Ok(CurrencyType::Rsd),
            "ZAR" => std::result::Result::Ok(CurrencyType::Zar),
            "KRW" => std::result::Result::Ok(CurrencyType::Krw),
            "NAD" => std::result::Result::Ok(CurrencyType::Nad),
            "TL" => std::result::Result::Ok(CurrencyType::Tl),
            "UE" => std::result::Result::Ok(CurrencyType::Ue),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Формат даты: `ДД-ММ-ГГГГ`. 
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct DateDdMmYyyy(String);

impl std::convert::From<String> for DateDdMmYyyy {
    fn from(x: String) -> Self {
        DateDdMmYyyy(x)
    }
}

impl std::string::ToString for DateDdMmYyyy {
    fn to_string(&self) -> String {
       self.0.to_string()
    }
}

impl std::str::FromStr for DateDdMmYyyy {
    type Err = std::string::ParseError;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(DateDdMmYyyy(x.to_string()))
    }
}

impl std::convert::From<DateDdMmYyyy> for String {
    fn from(x: DateDdMmYyyy) -> Self {
        x.0
    }
}

impl std::ops::Deref for DateDdMmYyyy {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for DateDdMmYyyy {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}


#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct DateDdMmYyyyHhMmSs(String);

impl std::convert::From<String> for DateDdMmYyyyHhMmSs {
    fn from(x: String) -> Self {
        DateDdMmYyyyHhMmSs(x)
    }
}

impl std::string::ToString for DateDdMmYyyyHhMmSs {
    fn to_string(&self) -> String {
       self.0.to_string()
    }
}

impl std::str::FromStr for DateDdMmYyyyHhMmSs {
    type Err = std::string::ParseError;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(DateDdMmYyyyHhMmSs(x.to_string()))
    }
}

impl std::convert::From<DateDdMmYyyyHhMmSs> for String {
    fn from(x: DateDdMmYyyyHhMmSs) -> Self {
        x.0
    }
}

impl std::ops::Deref for DateDdMmYyyyHhMmSs {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for DateDdMmYyyyHhMmSs {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}


/// День недели:  * `MONDAY` — понедельник. * `TUESDAY` — вторник. * `WEDNESDAY` — среда. * `THURSDAY` — четверг. * `FRIDAY` — пятница. * `SATURDAY` — суббота. * `SUNDAY` — воскресенье. 
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum DayOfWeekType {
    #[serde(rename = "MONDAY")]
    Monday,
    #[serde(rename = "TUESDAY")]
    Tuesday,
    #[serde(rename = "WEDNESDAY")]
    Wednesday,
    #[serde(rename = "THURSDAY")]
    Thursday,
    #[serde(rename = "FRIDAY")]
    Friday,
    #[serde(rename = "SATURDAY")]
    Saturday,
    #[serde(rename = "SUNDAY")]
    Sunday,
}

impl std::fmt::Display for DayOfWeekType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            DayOfWeekType::Monday => write!(f, "MONDAY"),
            DayOfWeekType::Tuesday => write!(f, "TUESDAY"),
            DayOfWeekType::Wednesday => write!(f, "WEDNESDAY"),
            DayOfWeekType::Thursday => write!(f, "THURSDAY"),
            DayOfWeekType::Friday => write!(f, "FRIDAY"),
            DayOfWeekType::Saturday => write!(f, "SATURDAY"),
            DayOfWeekType::Sunday => write!(f, "SUNDAY"),
        }
    }
}

impl std::str::FromStr for DayOfWeekType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "MONDAY" => std::result::Result::Ok(DayOfWeekType::Monday),
            "TUESDAY" => std::result::Result::Ok(DayOfWeekType::Tuesday),
            "WEDNESDAY" => std::result::Result::Ok(DayOfWeekType::Wednesday),
            "THURSDAY" => std::result::Result::Ok(DayOfWeekType::Thursday),
            "FRIDAY" => std::result::Result::Ok(DayOfWeekType::Friday),
            "SATURDAY" => std::result::Result::Ok(DayOfWeekType::Saturday),
            "SUNDAY" => std::result::Result::Ok(DayOfWeekType::Sunday),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Список товаров, которые не удалось удалить, потому что они не найдены или хранятся на складе Маркета.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct DeleteCampaignOffersDto {
    /// Список SKU.
    #[serde(rename = "notDeletedOfferIds")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub not_deleted_offer_ids: Option<swagger::Nullable<Vec<models::ShopSku>>>,

}


impl DeleteCampaignOffersDto {
    #[allow(clippy::new_without_default)]
    pub fn new() -> DeleteCampaignOffersDto {
        DeleteCampaignOffersDto {
            not_deleted_offer_ids: None,
        }
    }
}

/// Converts the DeleteCampaignOffersDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for DeleteCampaignOffersDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.not_deleted_offer_ids.as_ref().map(|not_deleted_offer_ids| {
                [
                    "notDeletedOfferIds".to_string(),
                    not_deleted_offer_ids.as_ref().map_or("null".to_string(), |x| x.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a DeleteCampaignOffersDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for DeleteCampaignOffersDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub not_deleted_offer_ids: Vec<Vec<models::ShopSku>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing DeleteCampaignOffersDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "notDeletedOfferIds" => return std::result::Result::Err("Parsing a container in this style is not supported in DeleteCampaignOffersDto".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing DeleteCampaignOffersDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(DeleteCampaignOffersDto {
            not_deleted_offer_ids: std::result::Result::Err("Nullable types not supported in DeleteCampaignOffersDto".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<DeleteCampaignOffersDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<DeleteCampaignOffersDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<DeleteCampaignOffersDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for DeleteCampaignOffersDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<DeleteCampaignOffersDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <DeleteCampaignOffersDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into DeleteCampaignOffersDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Фильтрации удаляемых товаров по offerIds. 
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct DeleteCampaignOffersRequest {
    /// Идентификаторы товаров в каталоге.
    #[serde(rename = "offerIds")]
    #[validate(
            length(min = 1, max = 500),
        )]
    pub offer_ids: Vec<models::ShopSku>,

}


impl DeleteCampaignOffersRequest {
    #[allow(clippy::new_without_default)]
    pub fn new(offer_ids: Vec<models::ShopSku>, ) -> DeleteCampaignOffersRequest {
        DeleteCampaignOffersRequest {
            offer_ids,
        }
    }
}

/// Converts the DeleteCampaignOffersRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for DeleteCampaignOffersRequest {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            Some("offerIds".to_string()),
            Some(self.offer_ids.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a DeleteCampaignOffersRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for DeleteCampaignOffersRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub offer_ids: Vec<Vec<models::ShopSku>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing DeleteCampaignOffersRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "offerIds" => return std::result::Result::Err("Parsing a container in this style is not supported in DeleteCampaignOffersRequest".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing DeleteCampaignOffersRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(DeleteCampaignOffersRequest {
            offer_ids: intermediate_rep.offer_ids.into_iter().next().ok_or_else(|| "offerIds missing in DeleteCampaignOffersRequest".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<DeleteCampaignOffersRequest> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<DeleteCampaignOffersRequest>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<DeleteCampaignOffersRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for DeleteCampaignOffersRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<DeleteCampaignOffersRequest> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <DeleteCampaignOffersRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into DeleteCampaignOffersRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Результат удаления товаров.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct DeleteCampaignOffersResponse {
    #[serde(rename = "status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<models::ApiResponseStatusType>,

    #[serde(rename = "result")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub result: Option<models::DeleteCampaignOffersDto>,

}


impl DeleteCampaignOffersResponse {
    #[allow(clippy::new_without_default)]
    pub fn new() -> DeleteCampaignOffersResponse {
        DeleteCampaignOffersResponse {
            status: None,
            result: None,
        }
    }
}

/// Converts the DeleteCampaignOffersResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for DeleteCampaignOffersResponse {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping status in query parameter serialization

            // Skipping result in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a DeleteCampaignOffersResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for DeleteCampaignOffersResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub status: Vec<models::ApiResponseStatusType>,
            pub result: Vec<models::DeleteCampaignOffersDto>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing DeleteCampaignOffersResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(<models::ApiResponseStatusType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "result" => intermediate_rep.result.push(<models::DeleteCampaignOffersDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing DeleteCampaignOffersResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(DeleteCampaignOffersResponse {
            status: intermediate_rep.status.into_iter().next(),
            result: intermediate_rep.result.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<DeleteCampaignOffersResponse> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<DeleteCampaignOffersResponse>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<DeleteCampaignOffersResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for DeleteCampaignOffersResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<DeleteCampaignOffersResponse> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <DeleteCampaignOffersResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into DeleteCampaignOffersResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Фильтр запроса отзывов по бизнесу. 
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct DeleteGoodsFeedbackCommentRequest {
    /// Идентификатор комментария к отзыву. 
    #[serde(rename = "id")]
    pub id: i64,

}


impl DeleteGoodsFeedbackCommentRequest {
    #[allow(clippy::new_without_default)]
    pub fn new(id: i64, ) -> DeleteGoodsFeedbackCommentRequest {
        DeleteGoodsFeedbackCommentRequest {
            id,
        }
    }
}

/// Converts the DeleteGoodsFeedbackCommentRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for DeleteGoodsFeedbackCommentRequest {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            Some("id".to_string()),
            Some(self.id.to_string()),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a DeleteGoodsFeedbackCommentRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for DeleteGoodsFeedbackCommentRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<i64>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing DeleteGoodsFeedbackCommentRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing DeleteGoodsFeedbackCommentRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(DeleteGoodsFeedbackCommentRequest {
            id: intermediate_rep.id.into_iter().next().ok_or_else(|| "id missing in DeleteGoodsFeedbackCommentRequest".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<DeleteGoodsFeedbackCommentRequest> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<DeleteGoodsFeedbackCommentRequest>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<DeleteGoodsFeedbackCommentRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for DeleteGoodsFeedbackCommentRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<DeleteGoodsFeedbackCommentRequest> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <DeleteGoodsFeedbackCommentRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into DeleteGoodsFeedbackCommentRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Запрос на возобновление показа оферов.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct DeleteHiddenOffersRequest {
    /// Список скрытых товаров. 
    #[serde(rename = "hiddenOffers")]
    #[validate(
            length(min = 1, max = 500),
        )]
    pub hidden_offers: Vec<models::HiddenOfferDto>,

}


impl DeleteHiddenOffersRequest {
    #[allow(clippy::new_without_default)]
    pub fn new(hidden_offers: Vec<models::HiddenOfferDto>, ) -> DeleteHiddenOffersRequest {
        DeleteHiddenOffersRequest {
            hidden_offers,
        }
    }
}

/// Converts the DeleteHiddenOffersRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for DeleteHiddenOffersRequest {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping hiddenOffers in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a DeleteHiddenOffersRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for DeleteHiddenOffersRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub hidden_offers: Vec<Vec<models::HiddenOfferDto>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing DeleteHiddenOffersRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "hiddenOffers" => return std::result::Result::Err("Parsing a container in this style is not supported in DeleteHiddenOffersRequest".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing DeleteHiddenOffersRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(DeleteHiddenOffersRequest {
            hidden_offers: intermediate_rep.hidden_offers.into_iter().next().ok_or_else(|| "hiddenOffers missing in DeleteHiddenOffersRequest".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<DeleteHiddenOffersRequest> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<DeleteHiddenOffersRequest>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<DeleteHiddenOffersRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for DeleteHiddenOffersRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<DeleteHiddenOffersRequest> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <DeleteHiddenOffersRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into DeleteHiddenOffersRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Список товаров, которые не удалось удалить, потому что они хранятся на складе Маркета.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct DeleteOffersDto {
    /// Список SKU товаров, которые не удалось удалить.
    #[serde(rename = "notDeletedOfferIds")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub not_deleted_offer_ids: Option<swagger::Nullable<Vec<models::ShopSku>>>,

}


impl DeleteOffersDto {
    #[allow(clippy::new_without_default)]
    pub fn new() -> DeleteOffersDto {
        DeleteOffersDto {
            not_deleted_offer_ids: None,
        }
    }
}

/// Converts the DeleteOffersDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for DeleteOffersDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.not_deleted_offer_ids.as_ref().map(|not_deleted_offer_ids| {
                [
                    "notDeletedOfferIds".to_string(),
                    not_deleted_offer_ids.as_ref().map_or("null".to_string(), |x| x.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a DeleteOffersDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for DeleteOffersDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub not_deleted_offer_ids: Vec<Vec<models::ShopSku>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing DeleteOffersDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "notDeletedOfferIds" => return std::result::Result::Err("Parsing a container in this style is not supported in DeleteOffersDto".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing DeleteOffersDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(DeleteOffersDto {
            not_deleted_offer_ids: std::result::Result::Err("Nullable types not supported in DeleteOffersDto".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<DeleteOffersDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<DeleteOffersDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<DeleteOffersDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for DeleteOffersDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<DeleteOffersDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <DeleteOffersDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into DeleteOffersDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Товары, которые не удалось восстановить из архива.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct DeleteOffersFromArchiveDto {
    /// Список товаров, которые не удалось восстановить из архива.
    #[serde(rename = "notUnarchivedOfferIds")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub not_unarchived_offer_ids: Option<swagger::Nullable<Vec<models::ShopSku>>>,

}


impl DeleteOffersFromArchiveDto {
    #[allow(clippy::new_without_default)]
    pub fn new() -> DeleteOffersFromArchiveDto {
        DeleteOffersFromArchiveDto {
            not_unarchived_offer_ids: None,
        }
    }
}

/// Converts the DeleteOffersFromArchiveDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for DeleteOffersFromArchiveDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.not_unarchived_offer_ids.as_ref().map(|not_unarchived_offer_ids| {
                [
                    "notUnarchivedOfferIds".to_string(),
                    not_unarchived_offer_ids.as_ref().map_or("null".to_string(), |x| x.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a DeleteOffersFromArchiveDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for DeleteOffersFromArchiveDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub not_unarchived_offer_ids: Vec<Vec<models::ShopSku>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing DeleteOffersFromArchiveDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "notUnarchivedOfferIds" => return std::result::Result::Err("Parsing a container in this style is not supported in DeleteOffersFromArchiveDto".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing DeleteOffersFromArchiveDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(DeleteOffersFromArchiveDto {
            not_unarchived_offer_ids: std::result::Result::Err("Nullable types not supported in DeleteOffersFromArchiveDto".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<DeleteOffersFromArchiveDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<DeleteOffersFromArchiveDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<DeleteOffersFromArchiveDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for DeleteOffersFromArchiveDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<DeleteOffersFromArchiveDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <DeleteOffersFromArchiveDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into DeleteOffersFromArchiveDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Товары, которые нужно восстановить из архива. 
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct DeleteOffersFromArchiveRequest {
    /// Список товаров, которые нужно восстановить из архива.
    #[serde(rename = "offerIds")]
    #[validate(
            length(min = 1, max = 200),
        )]
    pub offer_ids: Vec<models::ShopSku>,

}


impl DeleteOffersFromArchiveRequest {
    #[allow(clippy::new_without_default)]
    pub fn new(offer_ids: Vec<models::ShopSku>, ) -> DeleteOffersFromArchiveRequest {
        DeleteOffersFromArchiveRequest {
            offer_ids,
        }
    }
}

/// Converts the DeleteOffersFromArchiveRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for DeleteOffersFromArchiveRequest {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            Some("offerIds".to_string()),
            Some(self.offer_ids.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a DeleteOffersFromArchiveRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for DeleteOffersFromArchiveRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub offer_ids: Vec<Vec<models::ShopSku>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing DeleteOffersFromArchiveRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "offerIds" => return std::result::Result::Err("Parsing a container in this style is not supported in DeleteOffersFromArchiveRequest".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing DeleteOffersFromArchiveRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(DeleteOffersFromArchiveRequest {
            offer_ids: intermediate_rep.offer_ids.into_iter().next().ok_or_else(|| "offerIds missing in DeleteOffersFromArchiveRequest".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<DeleteOffersFromArchiveRequest> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<DeleteOffersFromArchiveRequest>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<DeleteOffersFromArchiveRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for DeleteOffersFromArchiveRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<DeleteOffersFromArchiveRequest> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <DeleteOffersFromArchiveRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into DeleteOffersFromArchiveRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Результат разархивации товаров.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct DeleteOffersFromArchiveResponse {
    #[serde(rename = "status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<models::ApiResponseStatusType>,

    #[serde(rename = "result")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub result: Option<models::DeleteOffersFromArchiveDto>,

}


impl DeleteOffersFromArchiveResponse {
    #[allow(clippy::new_without_default)]
    pub fn new() -> DeleteOffersFromArchiveResponse {
        DeleteOffersFromArchiveResponse {
            status: None,
            result: None,
        }
    }
}

/// Converts the DeleteOffersFromArchiveResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for DeleteOffersFromArchiveResponse {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping status in query parameter serialization

            // Skipping result in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a DeleteOffersFromArchiveResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for DeleteOffersFromArchiveResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub status: Vec<models::ApiResponseStatusType>,
            pub result: Vec<models::DeleteOffersFromArchiveDto>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing DeleteOffersFromArchiveResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(<models::ApiResponseStatusType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "result" => intermediate_rep.result.push(<models::DeleteOffersFromArchiveDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing DeleteOffersFromArchiveResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(DeleteOffersFromArchiveResponse {
            status: intermediate_rep.status.into_iter().next(),
            result: intermediate_rep.result.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<DeleteOffersFromArchiveResponse> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<DeleteOffersFromArchiveResponse>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<DeleteOffersFromArchiveResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for DeleteOffersFromArchiveResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<DeleteOffersFromArchiveResponse> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <DeleteOffersFromArchiveResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into DeleteOffersFromArchiveResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Фильтрации удаляемых товаров по offerIds. 
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct DeleteOffersRequest {
    /// Список SKU товаров, которые нужно удалить.
    #[serde(rename = "offerIds")]
    #[validate(
            length(min = 1, max = 500),
        )]
    pub offer_ids: Vec<models::ShopSku>,

}


impl DeleteOffersRequest {
    #[allow(clippy::new_without_default)]
    pub fn new(offer_ids: Vec<models::ShopSku>, ) -> DeleteOffersRequest {
        DeleteOffersRequest {
            offer_ids,
        }
    }
}

/// Converts the DeleteOffersRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for DeleteOffersRequest {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            Some("offerIds".to_string()),
            Some(self.offer_ids.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a DeleteOffersRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for DeleteOffersRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub offer_ids: Vec<Vec<models::ShopSku>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing DeleteOffersRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "offerIds" => return std::result::Result::Err("Parsing a container in this style is not supported in DeleteOffersRequest".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing DeleteOffersRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(DeleteOffersRequest {
            offer_ids: intermediate_rep.offer_ids.into_iter().next().ok_or_else(|| "offerIds missing in DeleteOffersRequest".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<DeleteOffersRequest> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<DeleteOffersRequest>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<DeleteOffersRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for DeleteOffersRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<DeleteOffersRequest> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <DeleteOffersRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into DeleteOffersRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Результат удаления товаров.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct DeleteOffersResponse {
    #[serde(rename = "status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<models::ApiResponseStatusType>,

    #[serde(rename = "result")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub result: Option<models::DeleteOffersDto>,

}


impl DeleteOffersResponse {
    #[allow(clippy::new_without_default)]
    pub fn new() -> DeleteOffersResponse {
        DeleteOffersResponse {
            status: None,
            result: None,
        }
    }
}

/// Converts the DeleteOffersResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for DeleteOffersResponse {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping status in query parameter serialization

            // Skipping result in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a DeleteOffersResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for DeleteOffersResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub status: Vec<models::ApiResponseStatusType>,
            pub result: Vec<models::DeleteOffersDto>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing DeleteOffersResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(<models::ApiResponseStatusType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "result" => intermediate_rep.result.push(<models::DeleteOffersDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing DeleteOffersResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(DeleteOffersResponse {
            status: intermediate_rep.status.into_iter().next(),
            result: intermediate_rep.result.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<DeleteOffersResponse> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<DeleteOffersResponse>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<DeleteOffersResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for DeleteOffersResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<DeleteOffersResponse> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <DeleteOffersResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into DeleteOffersResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Удаление товаров из акции.  Чтобы убрать:  * все товары из акции и больше не участвовать в ней, передайте значение `true` в параметре `deleteAllOffers`;  * часть товаров, передайте их идентификаторы в параметре `offersIds`. 
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct DeletePromoOffersRequest {
    /// Идентификатор акции.
    #[serde(rename = "promoId")]
    pub promo_id: String,

    /// Чтобы убрать все товары из акции и больше не участвовать в ней, передайте значение `true` и не передавайте параметр `offerIds`.
    #[serde(rename = "deleteAllOffers")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub delete_all_offers: Option<bool>,

    /// Товары, которые нужно убрать из акции.
    #[serde(rename = "offerIds")]
    #[validate(
            length(min = 1, max = 500),
        )]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub offer_ids: Option<swagger::Nullable<Vec<models::ShopSku>>>,

}


impl DeletePromoOffersRequest {
    #[allow(clippy::new_without_default)]
    pub fn new(promo_id: String, ) -> DeletePromoOffersRequest {
        DeletePromoOffersRequest {
            promo_id,
            delete_all_offers: None,
            offer_ids: None,
        }
    }
}

/// Converts the DeletePromoOffersRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for DeletePromoOffersRequest {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            Some("promoId".to_string()),
            Some(self.promo_id.to_string()),


            self.delete_all_offers.as_ref().map(|delete_all_offers| {
                [
                    "deleteAllOffers".to_string(),
                    delete_all_offers.to_string(),
                ].join(",")
            }),


            self.offer_ids.as_ref().map(|offer_ids| {
                [
                    "offerIds".to_string(),
                    offer_ids.as_ref().map_or("null".to_string(), |x| x.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a DeletePromoOffersRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for DeletePromoOffersRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub promo_id: Vec<String>,
            pub delete_all_offers: Vec<bool>,
            pub offer_ids: Vec<Vec<models::ShopSku>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing DeletePromoOffersRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "promoId" => intermediate_rep.promo_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "deleteAllOffers" => intermediate_rep.delete_all_offers.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "offerIds" => return std::result::Result::Err("Parsing a container in this style is not supported in DeletePromoOffersRequest".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing DeletePromoOffersRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(DeletePromoOffersRequest {
            promo_id: intermediate_rep.promo_id.into_iter().next().ok_or_else(|| "promoId missing in DeletePromoOffersRequest".to_string())?,
            delete_all_offers: intermediate_rep.delete_all_offers.into_iter().next(),
            offer_ids: std::result::Result::Err("Nullable types not supported in DeletePromoOffersRequest".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<DeletePromoOffersRequest> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<DeletePromoOffersRequest>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<DeletePromoOffersRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for DeletePromoOffersRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<DeletePromoOffersRequest> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <DeletePromoOffersRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into DeletePromoOffersRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Результат удаления товаров из акции.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct DeletePromoOffersResponse {
    #[serde(rename = "status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<models::ApiResponseStatusType>,

    #[serde(rename = "result")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub result: Option<models::DeletePromoOffersResultDto>,

}


impl DeletePromoOffersResponse {
    #[allow(clippy::new_without_default)]
    pub fn new() -> DeletePromoOffersResponse {
        DeletePromoOffersResponse {
            status: None,
            result: None,
        }
    }
}

/// Converts the DeletePromoOffersResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for DeletePromoOffersResponse {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping status in query parameter serialization

            // Skipping result in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a DeletePromoOffersResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for DeletePromoOffersResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub status: Vec<models::ApiResponseStatusType>,
            pub result: Vec<models::DeletePromoOffersResultDto>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing DeletePromoOffersResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(<models::ApiResponseStatusType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "result" => intermediate_rep.result.push(<models::DeletePromoOffersResultDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing DeletePromoOffersResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(DeletePromoOffersResponse {
            status: intermediate_rep.status.into_iter().next(),
            result: intermediate_rep.result.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<DeletePromoOffersResponse> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<DeletePromoOffersResponse>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<DeletePromoOffersResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for DeletePromoOffersResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<DeletePromoOffersResponse> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <DeletePromoOffersResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into DeletePromoOffersResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Результат удаления товаров из акции.  Возвращается, только если в запросе был передан параметр `offerIds`. 
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct DeletePromoOffersResultDto {
    /// Товары, при удалении которых появились ошибки.  Возвращается, только если есть такие товары. 
    #[serde(rename = "rejectedOffers")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub rejected_offers: Option<swagger::Nullable<Vec<models::RejectedPromoOfferDeleteDto>>>,

}


impl DeletePromoOffersResultDto {
    #[allow(clippy::new_without_default)]
    pub fn new() -> DeletePromoOffersResultDto {
        DeletePromoOffersResultDto {
            rejected_offers: None,
        }
    }
}

/// Converts the DeletePromoOffersResultDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for DeletePromoOffersResultDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping rejectedOffers in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a DeletePromoOffersResultDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for DeletePromoOffersResultDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub rejected_offers: Vec<Vec<models::RejectedPromoOfferDeleteDto>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing DeletePromoOffersResultDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "rejectedOffers" => return std::result::Result::Err("Parsing a container in this style is not supported in DeletePromoOffersResultDto".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing DeletePromoOffersResultDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(DeletePromoOffersResultDto {
            rejected_offers: std::result::Result::Err("Nullable types not supported in DeletePromoOffersResultDto".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<DeletePromoOffersResultDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<DeletePromoOffersResultDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<DeletePromoOffersResultDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for DeletePromoOffersResultDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<DeletePromoOffersResultDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <DeletePromoOffersResultDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into DeletePromoOffersResultDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Служба доставки.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct DeliveryServiceDto {
    /// Идентификатор службы доставки.
    #[serde(rename = "id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,

    /// Наименование службы доставки.
    #[serde(rename = "name")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

}


impl DeliveryServiceDto {
    #[allow(clippy::new_without_default)]
    pub fn new() -> DeliveryServiceDto {
        DeliveryServiceDto {
            id: None,
            name: None,
        }
    }
}

/// Converts the DeliveryServiceDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for DeliveryServiceDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.id.as_ref().map(|id| {
                [
                    "id".to_string(),
                    id.to_string(),
                ].join(",")
            }),


            self.name.as_ref().map(|name| {
                [
                    "name".to_string(),
                    name.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a DeliveryServiceDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for DeliveryServiceDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<i64>,
            pub name: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing DeliveryServiceDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing DeliveryServiceDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(DeliveryServiceDto {
            id: intermediate_rep.id.into_iter().next(),
            name: intermediate_rep.name.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<DeliveryServiceDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<DeliveryServiceDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<DeliveryServiceDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for DeliveryServiceDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<DeliveryServiceDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <DeliveryServiceDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into DeliveryServiceDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Информация о службе доставки.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct DeliveryServiceInfoDto {
    /// Идентификатор службы доставки.
    #[serde(rename = "id")]
    pub id: i64,

    /// Наименование службы доставки.
    #[serde(rename = "name")]
    pub name: String,

}


impl DeliveryServiceInfoDto {
    #[allow(clippy::new_without_default)]
    pub fn new(id: i64, name: String, ) -> DeliveryServiceInfoDto {
        DeliveryServiceInfoDto {
            id,
            name,
        }
    }
}

/// Converts the DeliveryServiceInfoDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for DeliveryServiceInfoDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            Some("id".to_string()),
            Some(self.id.to_string()),


            Some("name".to_string()),
            Some(self.name.to_string()),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a DeliveryServiceInfoDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for DeliveryServiceInfoDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<i64>,
            pub name: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing DeliveryServiceInfoDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing DeliveryServiceInfoDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(DeliveryServiceInfoDto {
            id: intermediate_rep.id.into_iter().next().ok_or_else(|| "id missing in DeliveryServiceInfoDto".to_string())?,
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "name missing in DeliveryServiceInfoDto".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<DeliveryServiceInfoDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<DeliveryServiceInfoDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<DeliveryServiceInfoDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for DeliveryServiceInfoDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<DeliveryServiceInfoDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <DeliveryServiceInfoDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into DeliveryServiceInfoDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Информация о службах доставки.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct DeliveryServicesDto {
    /// Информация о службе доставки.
    #[serde(rename = "deliveryService")]
    pub delivery_service: Vec<models::DeliveryServiceInfoDto>,

}


impl DeliveryServicesDto {
    #[allow(clippy::new_without_default)]
    pub fn new(delivery_service: Vec<models::DeliveryServiceInfoDto>, ) -> DeliveryServicesDto {
        DeliveryServicesDto {
            delivery_service,
        }
    }
}

/// Converts the DeliveryServicesDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for DeliveryServicesDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping deliveryService in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a DeliveryServicesDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for DeliveryServicesDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub delivery_service: Vec<Vec<models::DeliveryServiceInfoDto>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing DeliveryServicesDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "deliveryService" => return std::result::Result::Err("Parsing a container in this style is not supported in DeliveryServicesDto".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing DeliveryServicesDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(DeliveryServicesDto {
            delivery_service: intermediate_rep.delivery_service.into_iter().next().ok_or_else(|| "deliveryService missing in DeliveryServicesDto".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<DeliveryServicesDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<DeliveryServicesDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<DeliveryServicesDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for DeliveryServicesDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<DeliveryServicesDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <DeliveryServicesDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into DeliveryServicesDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Информация о документе.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct DocumentDto {
    #[serde(rename = "status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<models::OrderDocumentStatusType>,

    /// Номер документа.
    #[serde(rename = "number")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub number: Option<String>,

    /// Дата создания документа.
    #[serde(rename = "date")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub date: Option<chrono::naive::NaiveDate>,

}


impl DocumentDto {
    #[allow(clippy::new_without_default)]
    pub fn new() -> DocumentDto {
        DocumentDto {
            status: None,
            number: None,
            date: None,
        }
    }
}

/// Converts the DocumentDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for DocumentDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping status in query parameter serialization


            self.number.as_ref().map(|number| {
                [
                    "number".to_string(),
                    number.to_string(),
                ].join(",")
            }),

            // Skipping date in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a DocumentDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for DocumentDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub status: Vec<models::OrderDocumentStatusType>,
            pub number: Vec<String>,
            pub date: Vec<chrono::naive::NaiveDate>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing DocumentDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(<models::OrderDocumentStatusType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "number" => intermediate_rep.number.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "date" => intermediate_rep.date.push(<chrono::naive::NaiveDate as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing DocumentDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(DocumentDto {
            status: intermediate_rep.status.into_iter().next(),
            number: intermediate_rep.number.into_iter().next(),
            date: intermediate_rep.date.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<DocumentDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<DocumentDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<DocumentDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for DocumentDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<DocumentDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <DocumentDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into DocumentDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Результат выполнения запроса.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct EacVerificationResultDto {
    #[serde(rename = "verificationResult")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub verification_result: Option<models::EacVerificationStatusType>,

    /// Количество оставшихся попыток проверки кода.  Возвращается, если магазин отправил некорректный код.  Когда все попытки будут исчерпаны, код обновится. 
    #[serde(rename = "attemptsLeft")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub attempts_left: Option<i32>,

}


impl EacVerificationResultDto {
    #[allow(clippy::new_without_default)]
    pub fn new() -> EacVerificationResultDto {
        EacVerificationResultDto {
            verification_result: None,
            attempts_left: None,
        }
    }
}

/// Converts the EacVerificationResultDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for EacVerificationResultDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping verificationResult in query parameter serialization


            self.attempts_left.as_ref().map(|attempts_left| {
                [
                    "attemptsLeft".to_string(),
                    attempts_left.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a EacVerificationResultDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for EacVerificationResultDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub verification_result: Vec<models::EacVerificationStatusType>,
            pub attempts_left: Vec<i32>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing EacVerificationResultDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "verificationResult" => intermediate_rep.verification_result.push(<models::EacVerificationStatusType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "attemptsLeft" => intermediate_rep.attempts_left.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing EacVerificationResultDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(EacVerificationResultDto {
            verification_result: intermediate_rep.verification_result.into_iter().next(),
            attempts_left: intermediate_rep.attempts_left.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<EacVerificationResultDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<EacVerificationResultDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<EacVerificationResultDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for EacVerificationResultDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<EacVerificationResultDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <EacVerificationResultDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into EacVerificationResultDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Статус проверки кода подтверждения:  * `ACCEPTED` — код верный. * `REJECTED` — код неверный. * `NEED_UPDATE` — Маркет отправит новый код. Значение возвращается, если превышено количество попыток отправки кода. 
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum EacVerificationStatusType {
    #[serde(rename = "ACCEPTED")]
    Accepted,
    #[serde(rename = "REJECTED")]
    Rejected,
    #[serde(rename = "NEED_UPDATE")]
    NeedUpdate,
}

impl std::fmt::Display for EacVerificationStatusType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            EacVerificationStatusType::Accepted => write!(f, "ACCEPTED"),
            EacVerificationStatusType::Rejected => write!(f, "REJECTED"),
            EacVerificationStatusType::NeedUpdate => write!(f, "NEED_UPDATE"),
        }
    }
}

impl std::str::FromStr for EacVerificationStatusType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "ACCEPTED" => std::result::Result::Ok(EacVerificationStatusType::Accepted),
            "REJECTED" => std::result::Result::Ok(EacVerificationStatusType::Rejected),
            "NEED_UPDATE" => std::result::Result::Ok(EacVerificationStatusType::NeedUpdate),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Пустой ответ сервера.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct EmptyApiResponse {
    #[serde(rename = "status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<models::ApiResponseStatusType>,

}


impl EmptyApiResponse {
    #[allow(clippy::new_without_default)]
    pub fn new() -> EmptyApiResponse {
        EmptyApiResponse {
            status: None,
        }
    }
}

/// Converts the EmptyApiResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for EmptyApiResponse {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping status in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a EmptyApiResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for EmptyApiResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub status: Vec<models::ApiResponseStatusType>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing EmptyApiResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(<models::ApiResponseStatusType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing EmptyApiResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(EmptyApiResponse {
            status: intermediate_rep.status.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<EmptyApiResponse> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<EmptyApiResponse>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<EmptyApiResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for EmptyApiResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<EmptyApiResponse> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <EmptyApiResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into EmptyApiResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Информация о рекомендованных карточках товаров.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct EnrichedMappingsOfferDto {
    /// Составляйте название по схеме: тип + бренд или производитель + модель + особенности, если есть (например, цвет, размер или вес) и количество в упаковке.  Не включайте в название условия продажи (например, «скидка», «бесплатная доставка» и т. д.), эмоциональные характеристики («хит», «супер» и т. д.). Не пишите слова большими буквами — кроме устоявшихся названий брендов и моделей.  Оптимальная длина — 50–60 символов, максимальная — 256.  [Рекомендации и правила](https://yandex.ru/support/marketplace/assortment/fields/title.html) 
    #[serde(rename = "name")]
    #[validate(
            length(max = 256),
        )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

    /// Ваш SKU — идентификатор товара в вашей системе.  Разрешена любая последовательность длиной до 255 знаков.  Правила использования SKU:  * У каждого товара SKU должен быть свой.  * SKU товара нельзя менять — можно только удалить товар и добавить заново с новым SKU.  * Уже заданный SKU нельзя освободить и использовать заново для другого товара. Каждый товар должен получать новый идентификатор, до того никогда не использовавшийся в вашем каталоге.  [Что такое SKU и как его назначать](https://yandex.ru/support/marketplace/assortment/add/index.html#fields) 
    #[serde(rename = "shopSku")]
    #[validate(
            length(min = 1, max = 255),
           regex = "RE_ENRICHEDMAPPINGSOFFERDTO_SHOP_SKU",
        )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub shop_sku: Option<String>,

    /// Категория товара в вашем магазине. Значение будет использовано для определения категории товара на Маркете в случае, если вы не передали категорию в параметре `marketCategoryId`.  Указывайте конкретные категории — например, набор ножей лучше отнести к категории **Столовые приборы**, а не просто **Посуда**.  Выбирайте категории, которые описывают товар, а не абстрактный признак — например, **Духи**, а не **Подарки**.  Значение будет использовано для определения категории товара на Маркете в случае, если вы не передали категорию в параметре `marketCategoryId`. 
    #[serde(rename = "category")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub category: Option<String>,

    /// Название бренда или производителя. Должно быть записано так, как его пишет сам бренд.
    #[serde(rename = "vendor")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub vendor: Option<String>,

    /// Артикул товара от производителя.
    #[serde(rename = "vendorCode")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub vendor_code: Option<String>,

    /// Подробное описание товара: например, его преимущества и особенности.  Не давайте в описании инструкций по установке и сборке. Не используйте слова «скидка», «распродажа», «дешевый», «подарок» (кроме подарочных категорий), «бесплатно», «акция», «специальная цена», «новинка», «new», «аналог», «заказ», «хит». Не указывайте никакой контактной информации и не давайте ссылок.  Можно использовать теги:  * \\<h>, \\<h1>, \\<h2> и так далее — для заголовков; * \\<br> и \\<p> — для переноса строки; * \\<ol> — для нумерованного списка; * \\<ul> — для маркированного списка; * \\<li> — для создания элементов списка (должен находиться внутри \\<ol> или \\<ul>); * \\<div> — поддерживается, но не влияет на отображение текста.  Оптимальная длина — 400–600 символов, максимальная — 6000.  [Рекомендации и правила](https://yandex.ru/support/marketplace/assortment/fields/description.html) 
    #[serde(rename = "description")]
    #[validate(
            length(max = 6000),
        )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,

    /// Ваш SKU — идентификатор товара в вашей системе.  Разрешена любая последовательность длиной до 255 знаков.  Правила использования SKU:  * У каждого товара SKU должен быть свой.  * SKU товара нельзя менять — можно только удалить товар и добавить заново с новым SKU.  * Уже заданный SKU нельзя освободить и использовать заново для другого товара. Каждый товар должен получать новый идентификатор, до того никогда не использовавшийся в вашем каталоге.  [Что такое SKU и как его назначать](https://yandex.ru/support/marketplace/assortment/add/index.html#fields) 
    #[serde(rename = "id")]
    #[validate(
            length(min = 1, max = 255),
           regex = "RE_ENRICHEDMAPPINGSOFFERDTO_ID",
        )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

    /// Идентификатор фида.
    #[serde(rename = "feedId")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub feed_id: Option<i64>,

    /// Указывайте в виде последовательности цифр. Подойдут коды EAN-13, EAN-8, UPC-A, UPC-E или Code 128.  Для книг указывайте ISBN.  Для товаров [определенных категорий и торговых марок](https://yastatic.net/s3/doc-binary/src/support/market/ru/yandex-market-list-for-gtin.xlsx) штрихкод должен быть действительным кодом GTIN. Обратите внимание: внутренние штрихкоды, начинающиеся на 2 или 02, и коды формата Code 128 не являются GTIN.  [Что такое GTIN](*gtin)  
    #[serde(rename = "barcodes")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub barcodes: Option<swagger::Nullable<Vec<String>>>,

    /// URL фотографии товара или страницы с описанием на вашем сайте.  Переданные данные не будут отображаться на витрине, но они помогут специалистам Маркета найти карточку для вашего товара.  Должен содержать один вложенный параметр url. 
    #[serde(rename = "urls")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub urls: Option<swagger::Nullable<Vec<String>>>,

    /// Ссылки (URL) изображений товара в хорошем качестве.  Можно указать до 30 ссылок. При этом изображение по первой ссылке будет основным. Оно используется в качестве изображения товара в поиске Маркета и на карточке товара. Другие изображения товара доступны в режиме просмотра увеличенных изображений.  Обязательный параметр.  Должен содержать хотя бы один вложенный параметр `picture`. 
    #[serde(rename = "pictures")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub pictures: Option<swagger::Nullable<Vec<String>>>,

    /// Изготовитель товара: компания, которая произвела товар, ее адрес и регистрационный номер (если есть).  Необязательный параметр. 
    #[serde(rename = "manufacturer")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub manufacturer: Option<String>,

    /// Список стран, в которых произведен товар.  Обязательный параметр.  Должен содержать хотя бы одну, но не больше 5 стран. 
    #[serde(rename = "manufacturerCountries")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub manufacturer_countries: Option<swagger::Nullable<Vec<String>>>,

    /// Минимальное количество единиц товара, которое вы поставляете на склад.  Например, если вы поставляете детское питание партиями минимум по 10 коробок, а в каждой коробке по 6 баночек, укажите значение 60. 
    #[serde(rename = "minShipment")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub min_shipment: Option<i32>,

    /// Количество единиц товара в одной упаковке, которую вы поставляете на склад.  Например, если вы поставляете детское питание коробками по 6 баночек, укажите значение 6. 
    #[serde(rename = "transportUnitSize")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub transport_unit_size: Option<i32>,

    /// Добавочная партия: по сколько единиц товара можно добавлять к минимальному количеству minShipment.  Например, если вы поставляете детское питание партиями минимум по 10 коробок и хотите добавлять к минимальной партии по 2 коробки, а в каждой коробке по 6 баночек, укажите значение 12. 
    #[serde(rename = "quantumOfSupply")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub quantum_of_supply: Option<i32>,

    /// Срок, за который продавец поставляет товары на склад, в днях.
    #[serde(rename = "deliveryDurationDays")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub delivery_duration_days: Option<i32>,

    /// Сколько мест (если больше одного) занимает товар.  Параметр указывается, только если товар занимает больше одного места (например, кондиционер занимает два места: внешний и внутренний блоки в двух коробках). Если товар занимает одно место, не указывайте этот параметр. 
    #[serde(rename = "boxCount")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub box_count: Option<i32>,

    /// Список кодов товара в единой Товарной номенклатуре внешнеэкономической деятельности (ТН ВЭД).  Обязательный параметр, если товар подлежит особому учету (например, в системе «Меркурий» как продукция животного происхождения или в системе «Честный ЗНАК»).  Может содержать только один вложенный код ТН ВЭД. 
    #[serde(rename = "customsCommodityCodes")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub customs_commodity_codes: Option<swagger::Nullable<Vec<String>>>,

    #[serde(rename = "weightDimensions")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub weight_dimensions: Option<models::OfferWeightDimensionsDto>,

    /// Дни недели, в которые продавец поставляет товары на склад.
    #[serde(rename = "supplyScheduleDays")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub supply_schedule_days: Option<swagger::Nullable<Vec<models::DayOfWeekType>>>,

    /// {% note warning \"\" %}  Этот параметр устарел. Вместо него используйте `shelfLife`. Совместное использование обоих параметров приведет к ошибке.  {% endnote %}  Срок годности: через сколько дней товар станет непригоден для использования. 
    #[serde(rename = "shelfLifeDays")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub shelf_life_days: Option<i32>,

    /// {% note warning \"\" %}  Этот параметр устарел. Вместо него используйте `lifeTime`. Совместное использование обоих параметров приведет к ошибке.  {% endnote %}  Срок службы: сколько дней товар будет исправно выполнять свою функцию, а изготовитель — нести ответственность за его существенные недостатки. 
    #[serde(rename = "lifeTimeDays")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub life_time_days: Option<i32>,

    /// Гарантийный срок товара: сколько дней возможно обслуживание и ремонт товара или возврат денег, а изготовитель или продавец будет нести ответственность за недостатки товара. 
    #[serde(rename = "guaranteePeriodDays")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub guarantee_period_days: Option<i32>,

    #[serde(rename = "processingState")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub processing_state: Option<models::OfferProcessingStateDto>,

    #[serde(rename = "availability")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub availability: Option<models::OfferAvailabilityStatusType>,

    #[serde(rename = "shelfLife")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub shelf_life: Option<models::TimePeriodDto>,

    #[serde(rename = "lifeTime")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub life_time: Option<models::TimePeriodDto>,

    #[serde(rename = "guaranteePeriod")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub guarantee_period: Option<models::TimePeriodDto>,

    /// Номер документа на товар.  Перед указанием номера документ нужно загрузить в кабинете продавца на Маркете. [Инструкция](https://yandex.ru/support/marketplace/assortment/restrictions/certificates.html) 
    #[serde(rename = "certificate")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub certificate: Option<String>,

    /// Цена на товар в рублях.
    #[serde(rename = "price")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub price: Option<f64>,

    /// Идентификатор категории для рекомендованной карточки товара на Маркете.  Возвращается только вместе с параметром ##marketSku##. 
    #[serde(rename = "marketCategoryId")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub market_category_id: Option<i64>,

    /// Название категории для рекомендованной карточки товара на Маркете.  Может отсутствовать в ответе. 
    #[serde(rename = "marketCategoryName")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub market_category_name: Option<String>,

    /// Идентификатор модели для рекомендованной карточки товара на Маркете.  Может отсутствовать в ответе. 
    #[serde(rename = "marketModelId")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub market_model_id: Option<i64>,

    /// Название модели для рекомендованной карточки товара на Маркете.  Возвращается только вместе с параметром ##marketSku##. 
    #[serde(rename = "marketModelName")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub market_model_name: Option<String>,

    /// SKU на Маркете.
    #[serde(rename = "marketSku")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub market_sku: Option<i64>,

    /// Название товара с рекомендованной карточки на Маркете.  Может отсутствовать в ответе. 
    #[serde(rename = "marketSkuName")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub market_sku_name: Option<String>,

}

lazy_static::lazy_static! {
    static ref RE_ENRICHEDMAPPINGSOFFERDTO_SHOP_SKU: regex::Regex = regex::Regex::new(r"^[^\\x00-\\x08\\x0A-\\x1f\\x7f]{1,255}$").unwrap();
}
lazy_static::lazy_static! {
    static ref RE_ENRICHEDMAPPINGSOFFERDTO_ID: regex::Regex = regex::Regex::new(r"^[^\\x00-\\x08\\x0A-\\x1f\\x7f]{1,255}$").unwrap();
}

impl EnrichedMappingsOfferDto {
    #[allow(clippy::new_without_default)]
    pub fn new() -> EnrichedMappingsOfferDto {
        EnrichedMappingsOfferDto {
            name: None,
            shop_sku: None,
            category: None,
            vendor: None,
            vendor_code: None,
            description: None,
            id: None,
            feed_id: None,
            barcodes: None,
            urls: None,
            pictures: None,
            manufacturer: None,
            manufacturer_countries: None,
            min_shipment: None,
            transport_unit_size: None,
            quantum_of_supply: None,
            delivery_duration_days: None,
            box_count: None,
            customs_commodity_codes: None,
            weight_dimensions: None,
            supply_schedule_days: None,
            shelf_life_days: None,
            life_time_days: None,
            guarantee_period_days: None,
            processing_state: None,
            availability: None,
            shelf_life: None,
            life_time: None,
            guarantee_period: None,
            certificate: None,
            price: None,
            market_category_id: None,
            market_category_name: None,
            market_model_id: None,
            market_model_name: None,
            market_sku: None,
            market_sku_name: None,
        }
    }
}

/// Converts the EnrichedMappingsOfferDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for EnrichedMappingsOfferDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.name.as_ref().map(|name| {
                [
                    "name".to_string(),
                    name.to_string(),
                ].join(",")
            }),


            self.shop_sku.as_ref().map(|shop_sku| {
                [
                    "shopSku".to_string(),
                    shop_sku.to_string(),
                ].join(",")
            }),


            self.category.as_ref().map(|category| {
                [
                    "category".to_string(),
                    category.to_string(),
                ].join(",")
            }),


            self.vendor.as_ref().map(|vendor| {
                [
                    "vendor".to_string(),
                    vendor.to_string(),
                ].join(",")
            }),


            self.vendor_code.as_ref().map(|vendor_code| {
                [
                    "vendorCode".to_string(),
                    vendor_code.to_string(),
                ].join(",")
            }),


            self.description.as_ref().map(|description| {
                [
                    "description".to_string(),
                    description.to_string(),
                ].join(",")
            }),


            self.id.as_ref().map(|id| {
                [
                    "id".to_string(),
                    id.to_string(),
                ].join(",")
            }),


            self.feed_id.as_ref().map(|feed_id| {
                [
                    "feedId".to_string(),
                    feed_id.to_string(),
                ].join(",")
            }),


            self.barcodes.as_ref().map(|barcodes| {
                [
                    "barcodes".to_string(),
                    barcodes.as_ref().map_or("null".to_string(), |x| x.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),
                ].join(",")
            }),


            self.urls.as_ref().map(|urls| {
                [
                    "urls".to_string(),
                    urls.as_ref().map_or("null".to_string(), |x| x.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),
                ].join(",")
            }),


            self.pictures.as_ref().map(|pictures| {
                [
                    "pictures".to_string(),
                    pictures.as_ref().map_or("null".to_string(), |x| x.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),
                ].join(",")
            }),


            self.manufacturer.as_ref().map(|manufacturer| {
                [
                    "manufacturer".to_string(),
                    manufacturer.to_string(),
                ].join(",")
            }),


            self.manufacturer_countries.as_ref().map(|manufacturer_countries| {
                [
                    "manufacturerCountries".to_string(),
                    manufacturer_countries.as_ref().map_or("null".to_string(), |x| x.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),
                ].join(",")
            }),


            self.min_shipment.as_ref().map(|min_shipment| {
                [
                    "minShipment".to_string(),
                    min_shipment.to_string(),
                ].join(",")
            }),


            self.transport_unit_size.as_ref().map(|transport_unit_size| {
                [
                    "transportUnitSize".to_string(),
                    transport_unit_size.to_string(),
                ].join(",")
            }),


            self.quantum_of_supply.as_ref().map(|quantum_of_supply| {
                [
                    "quantumOfSupply".to_string(),
                    quantum_of_supply.to_string(),
                ].join(",")
            }),


            self.delivery_duration_days.as_ref().map(|delivery_duration_days| {
                [
                    "deliveryDurationDays".to_string(),
                    delivery_duration_days.to_string(),
                ].join(",")
            }),


            self.box_count.as_ref().map(|box_count| {
                [
                    "boxCount".to_string(),
                    box_count.to_string(),
                ].join(",")
            }),


            self.customs_commodity_codes.as_ref().map(|customs_commodity_codes| {
                [
                    "customsCommodityCodes".to_string(),
                    customs_commodity_codes.as_ref().map_or("null".to_string(), |x| x.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),
                ].join(",")
            }),

            // Skipping weightDimensions in query parameter serialization

            // Skipping supplyScheduleDays in query parameter serialization


            self.shelf_life_days.as_ref().map(|shelf_life_days| {
                [
                    "shelfLifeDays".to_string(),
                    shelf_life_days.to_string(),
                ].join(",")
            }),


            self.life_time_days.as_ref().map(|life_time_days| {
                [
                    "lifeTimeDays".to_string(),
                    life_time_days.to_string(),
                ].join(",")
            }),


            self.guarantee_period_days.as_ref().map(|guarantee_period_days| {
                [
                    "guaranteePeriodDays".to_string(),
                    guarantee_period_days.to_string(),
                ].join(",")
            }),

            // Skipping processingState in query parameter serialization

            // Skipping availability in query parameter serialization

            // Skipping shelfLife in query parameter serialization

            // Skipping lifeTime in query parameter serialization

            // Skipping guaranteePeriod in query parameter serialization


            self.certificate.as_ref().map(|certificate| {
                [
                    "certificate".to_string(),
                    certificate.to_string(),
                ].join(",")
            }),


            self.price.as_ref().map(|price| {
                [
                    "price".to_string(),
                    price.to_string(),
                ].join(",")
            }),


            self.market_category_id.as_ref().map(|market_category_id| {
                [
                    "marketCategoryId".to_string(),
                    market_category_id.to_string(),
                ].join(",")
            }),


            self.market_category_name.as_ref().map(|market_category_name| {
                [
                    "marketCategoryName".to_string(),
                    market_category_name.to_string(),
                ].join(",")
            }),


            self.market_model_id.as_ref().map(|market_model_id| {
                [
                    "marketModelId".to_string(),
                    market_model_id.to_string(),
                ].join(",")
            }),


            self.market_model_name.as_ref().map(|market_model_name| {
                [
                    "marketModelName".to_string(),
                    market_model_name.to_string(),
                ].join(",")
            }),


            self.market_sku.as_ref().map(|market_sku| {
                [
                    "marketSku".to_string(),
                    market_sku.to_string(),
                ].join(",")
            }),


            self.market_sku_name.as_ref().map(|market_sku_name| {
                [
                    "marketSkuName".to_string(),
                    market_sku_name.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a EnrichedMappingsOfferDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for EnrichedMappingsOfferDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub name: Vec<String>,
            pub shop_sku: Vec<String>,
            pub category: Vec<String>,
            pub vendor: Vec<String>,
            pub vendor_code: Vec<String>,
            pub description: Vec<String>,
            pub id: Vec<String>,
            pub feed_id: Vec<i64>,
            pub barcodes: Vec<Vec<String>>,
            pub urls: Vec<Vec<String>>,
            pub pictures: Vec<Vec<String>>,
            pub manufacturer: Vec<String>,
            pub manufacturer_countries: Vec<Vec<String>>,
            pub min_shipment: Vec<i32>,
            pub transport_unit_size: Vec<i32>,
            pub quantum_of_supply: Vec<i32>,
            pub delivery_duration_days: Vec<i32>,
            pub box_count: Vec<i32>,
            pub customs_commodity_codes: Vec<Vec<String>>,
            pub weight_dimensions: Vec<models::OfferWeightDimensionsDto>,
            pub supply_schedule_days: Vec<Vec<models::DayOfWeekType>>,
            pub shelf_life_days: Vec<i32>,
            pub life_time_days: Vec<i32>,
            pub guarantee_period_days: Vec<i32>,
            pub processing_state: Vec<models::OfferProcessingStateDto>,
            pub availability: Vec<models::OfferAvailabilityStatusType>,
            pub shelf_life: Vec<models::TimePeriodDto>,
            pub life_time: Vec<models::TimePeriodDto>,
            pub guarantee_period: Vec<models::TimePeriodDto>,
            pub certificate: Vec<String>,
            pub price: Vec<f64>,
            pub market_category_id: Vec<i64>,
            pub market_category_name: Vec<String>,
            pub market_model_id: Vec<i64>,
            pub market_model_name: Vec<String>,
            pub market_sku: Vec<i64>,
            pub market_sku_name: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing EnrichedMappingsOfferDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "shopSku" => intermediate_rep.shop_sku.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "category" => intermediate_rep.category.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "vendor" => intermediate_rep.vendor.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "vendorCode" => intermediate_rep.vendor_code.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "description" => intermediate_rep.description.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "feedId" => intermediate_rep.feed_id.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "barcodes" => return std::result::Result::Err("Parsing a container in this style is not supported in EnrichedMappingsOfferDto".to_string()),
                    "urls" => return std::result::Result::Err("Parsing a container in this style is not supported in EnrichedMappingsOfferDto".to_string()),
                    "pictures" => return std::result::Result::Err("Parsing a container in this style is not supported in EnrichedMappingsOfferDto".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "manufacturer" => intermediate_rep.manufacturer.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "manufacturerCountries" => return std::result::Result::Err("Parsing a container in this style is not supported in EnrichedMappingsOfferDto".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "minShipment" => intermediate_rep.min_shipment.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "transportUnitSize" => intermediate_rep.transport_unit_size.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "quantumOfSupply" => intermediate_rep.quantum_of_supply.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "deliveryDurationDays" => intermediate_rep.delivery_duration_days.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "boxCount" => intermediate_rep.box_count.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "customsCommodityCodes" => return std::result::Result::Err("Parsing a container in this style is not supported in EnrichedMappingsOfferDto".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "weightDimensions" => intermediate_rep.weight_dimensions.push(<models::OfferWeightDimensionsDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "supplyScheduleDays" => return std::result::Result::Err("Parsing a container in this style is not supported in EnrichedMappingsOfferDto".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "shelfLifeDays" => intermediate_rep.shelf_life_days.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "lifeTimeDays" => intermediate_rep.life_time_days.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "guaranteePeriodDays" => intermediate_rep.guarantee_period_days.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "processingState" => intermediate_rep.processing_state.push(<models::OfferProcessingStateDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "availability" => intermediate_rep.availability.push(<models::OfferAvailabilityStatusType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "shelfLife" => intermediate_rep.shelf_life.push(<models::TimePeriodDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "lifeTime" => intermediate_rep.life_time.push(<models::TimePeriodDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "guaranteePeriod" => intermediate_rep.guarantee_period.push(<models::TimePeriodDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "certificate" => intermediate_rep.certificate.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "price" => intermediate_rep.price.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "marketCategoryId" => intermediate_rep.market_category_id.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "marketCategoryName" => intermediate_rep.market_category_name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "marketModelId" => intermediate_rep.market_model_id.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "marketModelName" => intermediate_rep.market_model_name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "marketSku" => intermediate_rep.market_sku.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "marketSkuName" => intermediate_rep.market_sku_name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing EnrichedMappingsOfferDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(EnrichedMappingsOfferDto {
            name: intermediate_rep.name.into_iter().next(),
            shop_sku: intermediate_rep.shop_sku.into_iter().next(),
            category: intermediate_rep.category.into_iter().next(),
            vendor: intermediate_rep.vendor.into_iter().next(),
            vendor_code: intermediate_rep.vendor_code.into_iter().next(),
            description: intermediate_rep.description.into_iter().next(),
            id: intermediate_rep.id.into_iter().next(),
            feed_id: intermediate_rep.feed_id.into_iter().next(),
            barcodes: std::result::Result::Err("Nullable types not supported in EnrichedMappingsOfferDto".to_string())?,
            urls: std::result::Result::Err("Nullable types not supported in EnrichedMappingsOfferDto".to_string())?,
            pictures: std::result::Result::Err("Nullable types not supported in EnrichedMappingsOfferDto".to_string())?,
            manufacturer: intermediate_rep.manufacturer.into_iter().next(),
            manufacturer_countries: std::result::Result::Err("Nullable types not supported in EnrichedMappingsOfferDto".to_string())?,
            min_shipment: intermediate_rep.min_shipment.into_iter().next(),
            transport_unit_size: intermediate_rep.transport_unit_size.into_iter().next(),
            quantum_of_supply: intermediate_rep.quantum_of_supply.into_iter().next(),
            delivery_duration_days: intermediate_rep.delivery_duration_days.into_iter().next(),
            box_count: intermediate_rep.box_count.into_iter().next(),
            customs_commodity_codes: std::result::Result::Err("Nullable types not supported in EnrichedMappingsOfferDto".to_string())?,
            weight_dimensions: intermediate_rep.weight_dimensions.into_iter().next(),
            supply_schedule_days: std::result::Result::Err("Nullable types not supported in EnrichedMappingsOfferDto".to_string())?,
            shelf_life_days: intermediate_rep.shelf_life_days.into_iter().next(),
            life_time_days: intermediate_rep.life_time_days.into_iter().next(),
            guarantee_period_days: intermediate_rep.guarantee_period_days.into_iter().next(),
            processing_state: intermediate_rep.processing_state.into_iter().next(),
            availability: intermediate_rep.availability.into_iter().next(),
            shelf_life: intermediate_rep.shelf_life.into_iter().next(),
            life_time: intermediate_rep.life_time.into_iter().next(),
            guarantee_period: intermediate_rep.guarantee_period.into_iter().next(),
            certificate: intermediate_rep.certificate.into_iter().next(),
            price: intermediate_rep.price.into_iter().next(),
            market_category_id: intermediate_rep.market_category_id.into_iter().next(),
            market_category_name: intermediate_rep.market_category_name.into_iter().next(),
            market_model_id: intermediate_rep.market_model_id.into_iter().next(),
            market_model_name: intermediate_rep.market_model_name.into_iter().next(),
            market_sku: intermediate_rep.market_sku.into_iter().next(),
            market_sku_name: intermediate_rep.market_sku_name.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<EnrichedMappingsOfferDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<EnrichedMappingsOfferDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<EnrichedMappingsOfferDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for EnrichedMappingsOfferDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<EnrichedMappingsOfferDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <EnrichedMappingsOfferDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into EnrichedMappingsOfferDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Модель товара.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct EnrichedModelDto {
    /// Идентификатор модели товара.
    #[serde(rename = "id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,

    /// Название модели товара.
    #[serde(rename = "name")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

    #[serde(rename = "prices")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub prices: Option<models::ModelPriceDto>,

    /// Список первых десяти предложений, расположенных на карточке модели.  В ответе на запрос возвращаются предложения различных магазинов. Если есть несколько предложений от одного магазина, в ответе отображается только одно, наиболее релевантное из них. 
    #[serde(rename = "offers")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub offers: Option<swagger::Nullable<Vec<models::ModelOfferDto>>>,

    /// Суммарное количество предложений в розничных магазинах в регионе. Учитываются все предложения от каждого магазина.
    #[serde(rename = "offlineOffers")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub offline_offers: Option<i32>,

    /// Суммарное количество предложений в интернет-магазинах в регионе. Учитываются все предложения от каждого магазина.
    #[serde(rename = "onlineOffers")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub online_offers: Option<i32>,

}


impl EnrichedModelDto {
    #[allow(clippy::new_without_default)]
    pub fn new() -> EnrichedModelDto {
        EnrichedModelDto {
            id: None,
            name: None,
            prices: None,
            offers: None,
            offline_offers: None,
            online_offers: None,
        }
    }
}

/// Converts the EnrichedModelDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for EnrichedModelDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.id.as_ref().map(|id| {
                [
                    "id".to_string(),
                    id.to_string(),
                ].join(",")
            }),


            self.name.as_ref().map(|name| {
                [
                    "name".to_string(),
                    name.to_string(),
                ].join(",")
            }),

            // Skipping prices in query parameter serialization

            // Skipping offers in query parameter serialization


            self.offline_offers.as_ref().map(|offline_offers| {
                [
                    "offlineOffers".to_string(),
                    offline_offers.to_string(),
                ].join(",")
            }),


            self.online_offers.as_ref().map(|online_offers| {
                [
                    "onlineOffers".to_string(),
                    online_offers.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a EnrichedModelDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for EnrichedModelDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<i64>,
            pub name: Vec<String>,
            pub prices: Vec<models::ModelPriceDto>,
            pub offers: Vec<Vec<models::ModelOfferDto>>,
            pub offline_offers: Vec<i32>,
            pub online_offers: Vec<i32>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing EnrichedModelDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "prices" => intermediate_rep.prices.push(<models::ModelPriceDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "offers" => return std::result::Result::Err("Parsing a container in this style is not supported in EnrichedModelDto".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "offlineOffers" => intermediate_rep.offline_offers.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "onlineOffers" => intermediate_rep.online_offers.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing EnrichedModelDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(EnrichedModelDto {
            id: intermediate_rep.id.into_iter().next(),
            name: intermediate_rep.name.into_iter().next(),
            prices: intermediate_rep.prices.into_iter().next(),
            offers: std::result::Result::Err("Nullable types not supported in EnrichedModelDto".to_string())?,
            offline_offers: intermediate_rep.offline_offers.into_iter().next(),
            online_offers: intermediate_rep.online_offers.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<EnrichedModelDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<EnrichedModelDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<EnrichedModelDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for EnrichedModelDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<EnrichedModelDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <EnrichedModelDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into EnrichedModelDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Список моделей товаров.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct EnrichedModelsDto {
    /// Список моделей товаров.
    #[serde(rename = "models")]
    pub models: Vec<models::EnrichedModelDto>,

}


impl EnrichedModelsDto {
    #[allow(clippy::new_without_default)]
    pub fn new(models: Vec<models::EnrichedModelDto>, ) -> EnrichedModelsDto {
        EnrichedModelsDto {
            models,
        }
    }
}

/// Converts the EnrichedModelsDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for EnrichedModelsDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping models in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a EnrichedModelsDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for EnrichedModelsDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub models: Vec<Vec<models::EnrichedModelDto>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing EnrichedModelsDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "models" => return std::result::Result::Err("Parsing a container in this style is not supported in EnrichedModelsDto".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing EnrichedModelsDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(EnrichedModelsDto {
            models: intermediate_rep.models.into_iter().next().ok_or_else(|| "models missing in EnrichedModelsDto".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<EnrichedModelsDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<EnrichedModelsDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<EnrichedModelsDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for EnrichedModelsDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<EnrichedModelsDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <EnrichedModelsDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into EnrichedModelsDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Информация о коробке.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct EnrichedOrderBoxLayoutDto {
    /// Список товаров в коробке.  Если в коробке едет часть большого товара, в списке может быть только один пункт. 
    #[serde(rename = "items")]
    #[validate(
            length(min = 1),
        )]
    pub items: Vec<models::OrderBoxLayoutItemDto>,

    /// Идентификатор коробки.
    #[serde(rename = "boxId")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub box_id: Option<i64>,

}


impl EnrichedOrderBoxLayoutDto {
    #[allow(clippy::new_without_default)]
    pub fn new(items: Vec<models::OrderBoxLayoutItemDto>, ) -> EnrichedOrderBoxLayoutDto {
        EnrichedOrderBoxLayoutDto {
            items,
            box_id: None,
        }
    }
}

/// Converts the EnrichedOrderBoxLayoutDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for EnrichedOrderBoxLayoutDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping items in query parameter serialization


            self.box_id.as_ref().map(|box_id| {
                [
                    "boxId".to_string(),
                    box_id.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a EnrichedOrderBoxLayoutDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for EnrichedOrderBoxLayoutDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub items: Vec<Vec<models::OrderBoxLayoutItemDto>>,
            pub box_id: Vec<i64>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing EnrichedOrderBoxLayoutDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "items" => return std::result::Result::Err("Parsing a container in this style is not supported in EnrichedOrderBoxLayoutDto".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "boxId" => intermediate_rep.box_id.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing EnrichedOrderBoxLayoutDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(EnrichedOrderBoxLayoutDto {
            items: intermediate_rep.items.into_iter().next().ok_or_else(|| "items missing in EnrichedOrderBoxLayoutDto".to_string())?,
            box_id: intermediate_rep.box_id.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<EnrichedOrderBoxLayoutDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<EnrichedOrderBoxLayoutDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<EnrichedOrderBoxLayoutDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for EnrichedOrderBoxLayoutDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<EnrichedOrderBoxLayoutDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <EnrichedOrderBoxLayoutDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into EnrichedOrderBoxLayoutDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Информация об отгрузке.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ExtensionShipmentDto {
    #[serde(rename = "currentStatus")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub current_status: Option<models::ShipmentStatusChangeDto>,

    /// Доступные действия над отгрузкой.
    #[serde(rename = "availableActions")]
    #[validate(
        )]
    pub available_actions: Vec<models::ShipmentActionType>,

}


impl ExtensionShipmentDto {
    #[allow(clippy::new_without_default)]
    pub fn new(available_actions: Vec<models::ShipmentActionType>, ) -> ExtensionShipmentDto {
        ExtensionShipmentDto {
            current_status: None,
            available_actions,
        }
    }
}

/// Converts the ExtensionShipmentDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ExtensionShipmentDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping currentStatus in query parameter serialization

            // Skipping availableActions in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ExtensionShipmentDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ExtensionShipmentDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub current_status: Vec<models::ShipmentStatusChangeDto>,
            pub available_actions: Vec<Vec<models::ShipmentActionType>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ExtensionShipmentDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "currentStatus" => intermediate_rep.current_status.push(<models::ShipmentStatusChangeDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "availableActions" => return std::result::Result::Err("Parsing a container in this style is not supported in ExtensionShipmentDto".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing ExtensionShipmentDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ExtensionShipmentDto {
            current_status: intermediate_rep.current_status.into_iter().next(),
            available_actions: intermediate_rep.available_actions.into_iter().next().ok_or_else(|| "availableActions missing in ExtensionShipmentDto".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ExtensionShipmentDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<ExtensionShipmentDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ExtensionShipmentDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ExtensionShipmentDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<ExtensionShipmentDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ExtensionShipmentDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ExtensionShipmentDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Информация о проверке содержимого прайс-листа, загруженного на Маркет.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct FeedContentDto {
    /// Количество предложений, в которых найдены ошибки на этапе загрузки прайс-листа. Выводится, если параметр `content status=OK`. 
    #[serde(rename = "rejectedOffersCount")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub rejected_offers_count: Option<i64>,

    #[serde(rename = "status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<models::FeedStatusType>,

    /// Количество предложений в прайс-листе. Выводится, если параметр `content status=OK`. 
    #[serde(rename = "totalOffersCount")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub total_offers_count: Option<i64>,

    #[serde(rename = "error")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub error: Option<models::FeedContentErrorDto>,

}


impl FeedContentDto {
    #[allow(clippy::new_without_default)]
    pub fn new() -> FeedContentDto {
        FeedContentDto {
            rejected_offers_count: None,
            status: None,
            total_offers_count: None,
            error: None,
        }
    }
}

/// Converts the FeedContentDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for FeedContentDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.rejected_offers_count.as_ref().map(|rejected_offers_count| {
                [
                    "rejectedOffersCount".to_string(),
                    rejected_offers_count.to_string(),
                ].join(",")
            }),

            // Skipping status in query parameter serialization


            self.total_offers_count.as_ref().map(|total_offers_count| {
                [
                    "totalOffersCount".to_string(),
                    total_offers_count.to_string(),
                ].join(",")
            }),

            // Skipping error in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a FeedContentDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for FeedContentDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub rejected_offers_count: Vec<i64>,
            pub status: Vec<models::FeedStatusType>,
            pub total_offers_count: Vec<i64>,
            pub error: Vec<models::FeedContentErrorDto>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing FeedContentDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "rejectedOffersCount" => intermediate_rep.rejected_offers_count.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(<models::FeedStatusType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "totalOffersCount" => intermediate_rep.total_offers_count.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "error" => intermediate_rep.error.push(<models::FeedContentErrorDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing FeedContentDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(FeedContentDto {
            rejected_offers_count: intermediate_rep.rejected_offers_count.into_iter().next(),
            status: intermediate_rep.status.into_iter().next(),
            total_offers_count: intermediate_rep.total_offers_count.into_iter().next(),
            error: intermediate_rep.error.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<FeedContentDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<FeedContentDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<FeedContentDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for FeedContentDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<FeedContentDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <FeedContentDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into FeedContentDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Информация об ошибке в содержимом прайс-листа. Выводится, если параметр `content status=ERROR`. 
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct FeedContentErrorDto {
    #[serde(rename = "type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub r#type: Option<models::FeedContentErrorType>,

}


impl FeedContentErrorDto {
    #[allow(clippy::new_without_default)]
    pub fn new() -> FeedContentErrorDto {
        FeedContentErrorDto {
            r#type: None,
        }
    }
}

/// Converts the FeedContentErrorDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for FeedContentErrorDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping type in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a FeedContentErrorDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for FeedContentErrorDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub r#type: Vec<models::FeedContentErrorType>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing FeedContentErrorDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r#type.push(<models::FeedContentErrorType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing FeedContentErrorDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(FeedContentErrorDto {
            r#type: intermediate_rep.r#type.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<FeedContentErrorDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<FeedContentErrorDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<FeedContentErrorDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for FeedContentErrorDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<FeedContentErrorDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <FeedContentErrorDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into FeedContentErrorDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Тип ошибки в содержимом прайс-листа.  Возможные значения:  * `PARSE_ERROR` — ошибка при проверке прайс-листа, не связанная с форматом YML. Например, прайс-лист пустой или его не удалось разархивировать. * `PARSE_XML_ERROR` — несоответствие техническим требованиям формата YML. Например, элементы и их значения описаны некорректно. * `TOO_MANY_REJECTED_OFFERS` — более чем в половине предложений из прайс-листа найдены ошибки. Все предложения из прайс-листа не будут опубликованы на Маркете. 
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum FeedContentErrorType {
    #[serde(rename = "PARSE_ERROR")]
    ParseError,
    #[serde(rename = "PARSE_XML_ERROR")]
    ParseXmlError,
    #[serde(rename = "TOO_MANY_REJECTED_OFFERS")]
    TooManyRejectedOffers,
}

impl std::fmt::Display for FeedContentErrorType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            FeedContentErrorType::ParseError => write!(f, "PARSE_ERROR"),
            FeedContentErrorType::ParseXmlError => write!(f, "PARSE_XML_ERROR"),
            FeedContentErrorType::TooManyRejectedOffers => write!(f, "TOO_MANY_REJECTED_OFFERS"),
        }
    }
}

impl std::str::FromStr for FeedContentErrorType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "PARSE_ERROR" => std::result::Result::Ok(FeedContentErrorType::ParseError),
            "PARSE_XML_ERROR" => std::result::Result::Ok(FeedContentErrorType::ParseXmlError),
            "TOO_MANY_REJECTED_OFFERS" => std::result::Result::Ok(FeedContentErrorType::TooManyRejectedOffers),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Информация о последней загрузке прайс-листа.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct FeedDownloadDto {
    #[serde(rename = "status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<models::FeedStatusType>,

    #[serde(rename = "error")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub error: Option<models::FeedDownloadErrorDto>,

}


impl FeedDownloadDto {
    #[allow(clippy::new_without_default)]
    pub fn new() -> FeedDownloadDto {
        FeedDownloadDto {
            status: None,
            error: None,
        }
    }
}

/// Converts the FeedDownloadDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for FeedDownloadDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping status in query parameter serialization

            // Skipping error in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a FeedDownloadDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for FeedDownloadDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub status: Vec<models::FeedStatusType>,
            pub error: Vec<models::FeedDownloadErrorDto>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing FeedDownloadDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(<models::FeedStatusType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "error" => intermediate_rep.error.push(<models::FeedDownloadErrorDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing FeedDownloadDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(FeedDownloadDto {
            status: intermediate_rep.status.into_iter().next(),
            error: intermediate_rep.error.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<FeedDownloadDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<FeedDownloadDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<FeedDownloadDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for FeedDownloadDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<FeedDownloadDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <FeedDownloadDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into FeedDownloadDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Информация об ошибке при загрузке прайс-листа. Выводится, если параметр `download status=ERROR`. 
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct FeedDownloadErrorDto {
    /// HTTP-код ошибки индексации прайс-листа. Выводится, если `type=DOWNLOAD_HTTP_ERROR`. 
    #[serde(rename = "httpStatusCode")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub http_status_code: Option<i32>,

    #[serde(rename = "type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub r#type: Option<models::FeedDownloadErrorType>,

    /// Описание ошибки. Выводится, если `type=DOWNLOAD_ERROR`. 
    #[serde(rename = "description")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,

}


impl FeedDownloadErrorDto {
    #[allow(clippy::new_without_default)]
    pub fn new() -> FeedDownloadErrorDto {
        FeedDownloadErrorDto {
            http_status_code: None,
            r#type: None,
            description: None,
        }
    }
}

/// Converts the FeedDownloadErrorDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for FeedDownloadErrorDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.http_status_code.as_ref().map(|http_status_code| {
                [
                    "httpStatusCode".to_string(),
                    http_status_code.to_string(),
                ].join(",")
            }),

            // Skipping type in query parameter serialization


            self.description.as_ref().map(|description| {
                [
                    "description".to_string(),
                    description.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a FeedDownloadErrorDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for FeedDownloadErrorDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub http_status_code: Vec<i32>,
            pub r#type: Vec<models::FeedDownloadErrorType>,
            pub description: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing FeedDownloadErrorDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "httpStatusCode" => intermediate_rep.http_status_code.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r#type.push(<models::FeedDownloadErrorType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "description" => intermediate_rep.description.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing FeedDownloadErrorDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(FeedDownloadErrorDto {
            http_status_code: intermediate_rep.http_status_code.into_iter().next(),
            r#type: intermediate_rep.r#type.into_iter().next(),
            description: intermediate_rep.description.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<FeedDownloadErrorDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<FeedDownloadErrorDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<FeedDownloadErrorDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for FeedDownloadErrorDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<FeedDownloadErrorDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <FeedDownloadErrorDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into FeedDownloadErrorDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Тип ошибки загрузки прайс-листа.  Возможные значения:  * `DOWNLOAD_ERROR` — ошибка загрузки прайс-листа. Например, проблема с DNS-сервером или обрыв интернет-соединения.   Проблема описана в параметре `description`.  * `DOWNLOAD_HTTP_ERROR` — Яндекс Маркет передал запрос на получение прайс-листа и получил в ответ HTTP-код, отличный от 2xx.  HTTP-код выведен в параметре `httpStatusCode`. 
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum FeedDownloadErrorType {
    #[serde(rename = "DOWNLOAD_ERROR")]
    Error,
    #[serde(rename = "DOWNLOAD_HTTP_ERROR")]
    HttpError,
}

impl std::fmt::Display for FeedDownloadErrorType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            FeedDownloadErrorType::Error => write!(f, "DOWNLOAD_ERROR"),
            FeedDownloadErrorType::HttpError => write!(f, "DOWNLOAD_HTTP_ERROR"),
        }
    }
}

impl std::str::FromStr for FeedDownloadErrorType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "DOWNLOAD_ERROR" => std::result::Result::Ok(FeedDownloadErrorType::Error),
            "DOWNLOAD_HTTP_ERROR" => std::result::Result::Ok(FeedDownloadErrorType::HttpError),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Информация о прайс-листе.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct FeedDto {
    /// Идентификатор прайс-листа.
    #[serde(rename = "id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,

    /// Логин для авторизации при скачивании прайс-листа. Параметр выводится при размещении прайс-листа на сайте магазина и в случае ограничения доступа к нему. 
    #[serde(rename = "login")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub login: Option<String>,

    /// Имя файла, содержащего прайс-лист. Параметр выводится при размещении прайс-листа на сервере Маркета. 
    #[serde(rename = "name")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

    /// Пароль для авторизации при скачивании прайс-листа. Параметр выводится при размещении прайс-листа на сайте магазина и в случае ограничения доступа к нему. 
    #[serde(rename = "password")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub password: Option<String>,

    /// Дата загрузки прайс-листа на Маркет.  Формат даты: `ДД-ММ-ГГГГ`.  Параметр выводится при размещении прайс-листа на сервере Маркета. 
    #[serde(rename = "uploadDate")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub upload_date: Option<chrono::DateTime::<chrono::Utc>>,

    /// URL прайс-листа. Параметр выводится при размещении прайс-листа на сайте магазина. 
    #[serde(rename = "url")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,

    #[serde(rename = "content")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub content: Option<models::FeedContentDto>,

    #[serde(rename = "download")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub download: Option<models::FeedDownloadDto>,

    #[serde(rename = "placement")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub placement: Option<models::FeedPlacementDto>,

    #[serde(rename = "publication")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub publication: Option<models::FeedPublicationDto>,

}


impl FeedDto {
    #[allow(clippy::new_without_default)]
    pub fn new() -> FeedDto {
        FeedDto {
            id: None,
            login: None,
            name: None,
            password: None,
            upload_date: None,
            url: None,
            content: None,
            download: None,
            placement: None,
            publication: None,
        }
    }
}

/// Converts the FeedDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for FeedDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.id.as_ref().map(|id| {
                [
                    "id".to_string(),
                    id.to_string(),
                ].join(",")
            }),


            self.login.as_ref().map(|login| {
                [
                    "login".to_string(),
                    login.to_string(),
                ].join(",")
            }),


            self.name.as_ref().map(|name| {
                [
                    "name".to_string(),
                    name.to_string(),
                ].join(",")
            }),


            self.password.as_ref().map(|password| {
                [
                    "password".to_string(),
                    password.to_string(),
                ].join(",")
            }),

            // Skipping uploadDate in query parameter serialization


            self.url.as_ref().map(|url| {
                [
                    "url".to_string(),
                    url.to_string(),
                ].join(",")
            }),

            // Skipping content in query parameter serialization

            // Skipping download in query parameter serialization

            // Skipping placement in query parameter serialization

            // Skipping publication in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a FeedDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for FeedDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<i64>,
            pub login: Vec<String>,
            pub name: Vec<String>,
            pub password: Vec<String>,
            pub upload_date: Vec<chrono::DateTime::<chrono::Utc>>,
            pub url: Vec<String>,
            pub content: Vec<models::FeedContentDto>,
            pub download: Vec<models::FeedDownloadDto>,
            pub placement: Vec<models::FeedPlacementDto>,
            pub publication: Vec<models::FeedPublicationDto>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing FeedDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "login" => intermediate_rep.login.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "password" => intermediate_rep.password.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "uploadDate" => intermediate_rep.upload_date.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "url" => intermediate_rep.url.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "content" => intermediate_rep.content.push(<models::FeedContentDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "download" => intermediate_rep.download.push(<models::FeedDownloadDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "placement" => intermediate_rep.placement.push(<models::FeedPlacementDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "publication" => intermediate_rep.publication.push(<models::FeedPublicationDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing FeedDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(FeedDto {
            id: intermediate_rep.id.into_iter().next(),
            login: intermediate_rep.login.into_iter().next(),
            name: intermediate_rep.name.into_iter().next(),
            password: intermediate_rep.password.into_iter().next(),
            upload_date: intermediate_rep.upload_date.into_iter().next(),
            url: intermediate_rep.url.into_iter().next(),
            content: intermediate_rep.content.into_iter().next(),
            download: intermediate_rep.download.into_iter().next(),
            placement: intermediate_rep.placement.into_iter().next(),
            publication: intermediate_rep.publication.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<FeedDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<FeedDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<FeedDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for FeedDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<FeedDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <FeedDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into FeedDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Информация об ошибке, произошедшей во время индексации прайс-листа.  Выводится, если во время индексации произошли ошибки (`index-log-record status=ERROR`). 
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct FeedIndexLogsErrorDto {
    /// HTTP-код ошибки индексации прайс-листа.  Выводится, если `type=DOWNLOAD_HTTP_ERROR`. 
    #[serde(rename = "httpStatusCode")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub http_status_code: Option<i32>,

    #[serde(rename = "type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub r#type: Option<models::FeedIndexLogsErrorType>,

    /// Описание ошибки.  Выводится, если `type=DOWNLOAD_ERROR`. 
    #[serde(rename = "description")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,

}


impl FeedIndexLogsErrorDto {
    #[allow(clippy::new_without_default)]
    pub fn new() -> FeedIndexLogsErrorDto {
        FeedIndexLogsErrorDto {
            http_status_code: None,
            r#type: None,
            description: None,
        }
    }
}

/// Converts the FeedIndexLogsErrorDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for FeedIndexLogsErrorDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.http_status_code.as_ref().map(|http_status_code| {
                [
                    "httpStatusCode".to_string(),
                    http_status_code.to_string(),
                ].join(",")
            }),

            // Skipping type in query parameter serialization


            self.description.as_ref().map(|description| {
                [
                    "description".to_string(),
                    description.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a FeedIndexLogsErrorDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for FeedIndexLogsErrorDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub http_status_code: Vec<i32>,
            pub r#type: Vec<models::FeedIndexLogsErrorType>,
            pub description: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing FeedIndexLogsErrorDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "httpStatusCode" => intermediate_rep.http_status_code.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r#type.push(<models::FeedIndexLogsErrorType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "description" => intermediate_rep.description.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing FeedIndexLogsErrorDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(FeedIndexLogsErrorDto {
            http_status_code: intermediate_rep.http_status_code.into_iter().next(),
            r#type: intermediate_rep.r#type.into_iter().next(),
            description: intermediate_rep.description.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<FeedIndexLogsErrorDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<FeedIndexLogsErrorDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<FeedIndexLogsErrorDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for FeedIndexLogsErrorDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<FeedIndexLogsErrorDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <FeedIndexLogsErrorDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into FeedIndexLogsErrorDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Тип ошибки индексации прайс-листа.  Возможные значения:  * `DOWNLOAD_ERROR` — ошибка загрузки прайс-листа. Например, проблема с DNS-сервером или обрыв интернет-соединения.    Проблема описана в параметре `description`.  * `DOWNLOAD_HTTP_ERROR` — Маркет передал запрос на получение прайс-листа и получил в ответ HTTP-код, отличный от 2xx.    HTTP-код выведен в параметре `httpStatusCode`.  * `PARSE_ERROR` — ошибка при проверке прайс-листа, не связанная с форматом YML. Например, прайс-лист пустой или его не удалось разархивировать.  * `PARSE_XML_ERROR` — несоответствие техническим требованиям формата YML. Например, элементы и их значения описаны некорректно.  * `TOO_MANY_REJECTED_OFFERS` — более чем в половине предложений из прайс-листа найдены ошибки. Все предложения из прайс-листа не будут опубликованы на Маркете. 
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum FeedIndexLogsErrorType {
    #[serde(rename = "DOWNLOAD_ERROR")]
    DownloadError,
    #[serde(rename = "DOWNLOAD_HTTP_ERROR")]
    DownloadHttpError,
    #[serde(rename = "PARSE_ERROR")]
    ParseError,
    #[serde(rename = "PARSE_XML_ERROR")]
    ParseXmlError,
    #[serde(rename = "TOO_MANY_REJECTED_OFFERS")]
    TooManyRejectedOffers,
    #[serde(rename = "NOT_INDEXED")]
    NotIndexed,
}

impl std::fmt::Display for FeedIndexLogsErrorType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            FeedIndexLogsErrorType::DownloadError => write!(f, "DOWNLOAD_ERROR"),
            FeedIndexLogsErrorType::DownloadHttpError => write!(f, "DOWNLOAD_HTTP_ERROR"),
            FeedIndexLogsErrorType::ParseError => write!(f, "PARSE_ERROR"),
            FeedIndexLogsErrorType::ParseXmlError => write!(f, "PARSE_XML_ERROR"),
            FeedIndexLogsErrorType::TooManyRejectedOffers => write!(f, "TOO_MANY_REJECTED_OFFERS"),
            FeedIndexLogsErrorType::NotIndexed => write!(f, "NOT_INDEXED"),
        }
    }
}

impl std::str::FromStr for FeedIndexLogsErrorType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "DOWNLOAD_ERROR" => std::result::Result::Ok(FeedIndexLogsErrorType::DownloadError),
            "DOWNLOAD_HTTP_ERROR" => std::result::Result::Ok(FeedIndexLogsErrorType::DownloadHttpError),
            "PARSE_ERROR" => std::result::Result::Ok(FeedIndexLogsErrorType::ParseError),
            "PARSE_XML_ERROR" => std::result::Result::Ok(FeedIndexLogsErrorType::ParseXmlError),
            "TOO_MANY_REJECTED_OFFERS" => std::result::Result::Ok(FeedIndexLogsErrorType::TooManyRejectedOffers),
            "NOT_INDEXED" => std::result::Result::Ok(FeedIndexLogsErrorType::NotIndexed),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Информация о прайс-листе.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct FeedIndexLogsFeedDto {
    /// Идентификатор прайс-листа.
    #[serde(rename = "id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,

}


impl FeedIndexLogsFeedDto {
    #[allow(clippy::new_without_default)]
    pub fn new() -> FeedIndexLogsFeedDto {
        FeedIndexLogsFeedDto {
            id: None,
        }
    }
}

/// Converts the FeedIndexLogsFeedDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for FeedIndexLogsFeedDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.id.as_ref().map(|id| {
                [
                    "id".to_string(),
                    id.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a FeedIndexLogsFeedDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for FeedIndexLogsFeedDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<i64>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing FeedIndexLogsFeedDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing FeedIndexLogsFeedDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(FeedIndexLogsFeedDto {
            id: intermediate_rep.id.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<FeedIndexLogsFeedDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<FeedIndexLogsFeedDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<FeedIndexLogsFeedDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for FeedIndexLogsFeedDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<FeedIndexLogsFeedDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <FeedIndexLogsFeedDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into FeedIndexLogsFeedDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Тип обновления.  Возможные значения:  * `DIFF` — частичное обновление данных на Яндекс Маркете (например, обновление цен ранее опубликованных предложений и публикация новых). * `FAST_PRICE` — только обновление цен ранее опубликованных предложений. * `FULL` — полное обновление данных на Яндекс Маркете. 
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum FeedIndexLogsIndexType {
    #[serde(rename = "DIFF")]
    Diff,
    #[serde(rename = "FAST_PRICE")]
    FastPrice,
    #[serde(rename = "FULL")]
    Full,
}

impl std::fmt::Display for FeedIndexLogsIndexType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            FeedIndexLogsIndexType::Diff => write!(f, "DIFF"),
            FeedIndexLogsIndexType::FastPrice => write!(f, "FAST_PRICE"),
            FeedIndexLogsIndexType::Full => write!(f, "FULL"),
        }
    }
}

impl std::str::FromStr for FeedIndexLogsIndexType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "DIFF" => std::result::Result::Ok(FeedIndexLogsIndexType::Diff),
            "FAST_PRICE" => std::result::Result::Ok(FeedIndexLogsIndexType::FastPrice),
            "FULL" => std::result::Result::Ok(FeedIndexLogsIndexType::Full),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Информация о предложениях прайс-листа.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct FeedIndexLogsOffersDto {
    /// Количество предложений, который не опубликованы на Маркете из-за найденных ошибок.
    #[serde(rename = "rejectedCount")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub rejected_count: Option<i64>,

    /// Количество предложений в прайс-листе.
    #[serde(rename = "totalCount")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub total_count: Option<i64>,

}


impl FeedIndexLogsOffersDto {
    #[allow(clippy::new_without_default)]
    pub fn new() -> FeedIndexLogsOffersDto {
        FeedIndexLogsOffersDto {
            rejected_count: None,
            total_count: None,
        }
    }
}

/// Converts the FeedIndexLogsOffersDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for FeedIndexLogsOffersDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.rejected_count.as_ref().map(|rejected_count| {
                [
                    "rejectedCount".to_string(),
                    rejected_count.to_string(),
                ].join(",")
            }),


            self.total_count.as_ref().map(|total_count| {
                [
                    "totalCount".to_string(),
                    total_count.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a FeedIndexLogsOffersDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for FeedIndexLogsOffersDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub rejected_count: Vec<i64>,
            pub total_count: Vec<i64>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing FeedIndexLogsOffersDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "rejectedCount" => intermediate_rep.rejected_count.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "totalCount" => intermediate_rep.total_count.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing FeedIndexLogsOffersDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(FeedIndexLogsOffersDto {
            rejected_count: intermediate_rep.rejected_count.into_iter().next(),
            total_count: intermediate_rep.total_count.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<FeedIndexLogsOffersDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<FeedIndexLogsOffersDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<FeedIndexLogsOffersDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for FeedIndexLogsOffersDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<FeedIndexLogsOffersDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <FeedIndexLogsOffersDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into FeedIndexLogsOffersDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Список отчетов по индексации прайс-листа.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct FeedIndexLogsRecordDto {
    /// Дата и время загрузки прайс-листа.  Формат даты: ISO 8601 со смещением относительно UTC. Например, `2017-11-21T00:42:42+03:00`. 
    #[serde(rename = "downloadTime")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub download_time: Option<chrono::DateTime::<chrono::Utc>>,

    /// Дата и время, которые магазин указал в прайс-листе.  Формат даты: ISO 8601 со смещением относительно UTC. Например, `2017-11-21T00:42:42+03:00`. 
    #[serde(rename = "fileTime")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub file_time: Option<chrono::DateTime::<chrono::Utc>>,

    /// Идентификатор индексации.
    #[serde(rename = "generationId")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub generation_id: Option<i64>,

    #[serde(rename = "indexType")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub index_type: Option<models::FeedIndexLogsIndexType>,

    /// Дата и время публикации предложений из прайс-листа на Яндекс Маркете.  Формат даты: ISO 8601 со смещением относительно UTC. Например, `2017-11-21T00:42:42+03:00`. 
    #[serde(rename = "publishedTime")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub published_time: Option<chrono::DateTime::<chrono::Utc>>,

    #[serde(rename = "status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<models::FeedIndexLogsStatusType>,

    #[serde(rename = "error")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub error: Option<models::FeedIndexLogsErrorDto>,

    #[serde(rename = "offers")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub offers: Option<models::FeedIndexLogsOffersDto>,

}


impl FeedIndexLogsRecordDto {
    #[allow(clippy::new_without_default)]
    pub fn new() -> FeedIndexLogsRecordDto {
        FeedIndexLogsRecordDto {
            download_time: None,
            file_time: None,
            generation_id: None,
            index_type: None,
            published_time: None,
            status: None,
            error: None,
            offers: None,
        }
    }
}

/// Converts the FeedIndexLogsRecordDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for FeedIndexLogsRecordDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping downloadTime in query parameter serialization

            // Skipping fileTime in query parameter serialization


            self.generation_id.as_ref().map(|generation_id| {
                [
                    "generationId".to_string(),
                    generation_id.to_string(),
                ].join(",")
            }),

            // Skipping indexType in query parameter serialization

            // Skipping publishedTime in query parameter serialization

            // Skipping status in query parameter serialization

            // Skipping error in query parameter serialization

            // Skipping offers in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a FeedIndexLogsRecordDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for FeedIndexLogsRecordDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub download_time: Vec<chrono::DateTime::<chrono::Utc>>,
            pub file_time: Vec<chrono::DateTime::<chrono::Utc>>,
            pub generation_id: Vec<i64>,
            pub index_type: Vec<models::FeedIndexLogsIndexType>,
            pub published_time: Vec<chrono::DateTime::<chrono::Utc>>,
            pub status: Vec<models::FeedIndexLogsStatusType>,
            pub error: Vec<models::FeedIndexLogsErrorDto>,
            pub offers: Vec<models::FeedIndexLogsOffersDto>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing FeedIndexLogsRecordDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "downloadTime" => intermediate_rep.download_time.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "fileTime" => intermediate_rep.file_time.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "generationId" => intermediate_rep.generation_id.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "indexType" => intermediate_rep.index_type.push(<models::FeedIndexLogsIndexType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "publishedTime" => intermediate_rep.published_time.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(<models::FeedIndexLogsStatusType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "error" => intermediate_rep.error.push(<models::FeedIndexLogsErrorDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "offers" => intermediate_rep.offers.push(<models::FeedIndexLogsOffersDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing FeedIndexLogsRecordDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(FeedIndexLogsRecordDto {
            download_time: intermediate_rep.download_time.into_iter().next(),
            file_time: intermediate_rep.file_time.into_iter().next(),
            generation_id: intermediate_rep.generation_id.into_iter().next(),
            index_type: intermediate_rep.index_type.into_iter().next(),
            published_time: intermediate_rep.published_time.into_iter().next(),
            status: intermediate_rep.status.into_iter().next(),
            error: intermediate_rep.error.into_iter().next(),
            offers: intermediate_rep.offers.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<FeedIndexLogsRecordDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<FeedIndexLogsRecordDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<FeedIndexLogsRecordDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for FeedIndexLogsRecordDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<FeedIndexLogsRecordDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <FeedIndexLogsRecordDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into FeedIndexLogsRecordDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Результат выполнения запроса отчета по индексации прайс-листа.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct FeedIndexLogsResultDto {
    #[serde(rename = "feed")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub feed: Option<models::FeedIndexLogsFeedDto>,

    /// Список отчетов по индексации прайс-листа.
    #[serde(rename = "indexLogRecords")]
    pub index_log_records: Vec<models::FeedIndexLogsRecordDto>,

    /// Количество отчетов на всех страницах выходных данных.
    #[serde(rename = "total")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub total: Option<i64>,

}


impl FeedIndexLogsResultDto {
    #[allow(clippy::new_without_default)]
    pub fn new(index_log_records: Vec<models::FeedIndexLogsRecordDto>, ) -> FeedIndexLogsResultDto {
        FeedIndexLogsResultDto {
            feed: None,
            index_log_records,
            total: None,
        }
    }
}

/// Converts the FeedIndexLogsResultDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for FeedIndexLogsResultDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping feed in query parameter serialization

            // Skipping indexLogRecords in query parameter serialization


            self.total.as_ref().map(|total| {
                [
                    "total".to_string(),
                    total.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a FeedIndexLogsResultDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for FeedIndexLogsResultDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub feed: Vec<models::FeedIndexLogsFeedDto>,
            pub index_log_records: Vec<Vec<models::FeedIndexLogsRecordDto>>,
            pub total: Vec<i64>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing FeedIndexLogsResultDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "feed" => intermediate_rep.feed.push(<models::FeedIndexLogsFeedDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "indexLogRecords" => return std::result::Result::Err("Parsing a container in this style is not supported in FeedIndexLogsResultDto".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "total" => intermediate_rep.total.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing FeedIndexLogsResultDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(FeedIndexLogsResultDto {
            feed: intermediate_rep.feed.into_iter().next(),
            index_log_records: intermediate_rep.index_log_records.into_iter().next().ok_or_else(|| "indexLogRecords missing in FeedIndexLogsResultDto".to_string())?,
            total: intermediate_rep.total.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<FeedIndexLogsResultDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<FeedIndexLogsResultDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<FeedIndexLogsResultDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for FeedIndexLogsResultDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<FeedIndexLogsResultDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <FeedIndexLogsResultDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into FeedIndexLogsResultDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Статус индексации прайс-листа и проверки на соответствие техническим требованиям.  Возможные значения:  * `ERROR` — произошли ошибки. * `OK` — обработан без ошибок. * `WARNING` — наблюдались некритичные проблемы. 
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum FeedIndexLogsStatusType {
    #[serde(rename = "ERROR")]
    Error,
    #[serde(rename = "OK")]
    Ok,
    #[serde(rename = "WARNING")]
    Warning,
}

impl std::fmt::Display for FeedIndexLogsStatusType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            FeedIndexLogsStatusType::Error => write!(f, "ERROR"),
            FeedIndexLogsStatusType::Ok => write!(f, "OK"),
            FeedIndexLogsStatusType::Warning => write!(f, "WARNING"),
        }
    }
}

impl std::str::FromStr for FeedIndexLogsStatusType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "ERROR" => std::result::Result::Ok(FeedIndexLogsStatusType::Error),
            "OK" => std::result::Result::Ok(FeedIndexLogsStatusType::Ok),
            "WARNING" => std::result::Result::Ok(FeedIndexLogsStatusType::Warning),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Параметр прайс-листа.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct FeedParameterDto {
    /// Удалить ли значение параметра.  Возможное значение: * `true` — удалить значение параметра.  Используется вместе с параметром `name`. 
    #[serde(rename = "deleted")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub deleted: Option<bool>,

    /// Название параметра.  Возможное значение: - `reparseIntervalMinutes` — период скачивания прайс-листа. Маркет будет скачивать прайс-лист через количество минут, указанное в параметре `value`. Например, при `value=1440`, Маркет будет скачивать прайс-лист один раз в сутки.  {% note alert %}  Несмотря на установленное значение, Маркет скачает прайс-лист один раз в сутки.  {% endnote %}  Обязательный параметр. 
    #[serde(rename = "name")]
    pub name: String,

    /// Значения параметра.  Используется вместе с параметром `name`. 
    #[serde(rename = "values")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub values: Option<swagger::Nullable<Vec<i32>>>,

}


impl FeedParameterDto {
    #[allow(clippy::new_without_default)]
    pub fn new(name: String, ) -> FeedParameterDto {
        FeedParameterDto {
            deleted: None,
            name,
            values: None,
        }
    }
}

/// Converts the FeedParameterDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for FeedParameterDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.deleted.as_ref().map(|deleted| {
                [
                    "deleted".to_string(),
                    deleted.to_string(),
                ].join(",")
            }),


            Some("name".to_string()),
            Some(self.name.to_string()),


            self.values.as_ref().map(|values| {
                [
                    "values".to_string(),
                    values.as_ref().map_or("null".to_string(), |x| x.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a FeedParameterDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for FeedParameterDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub deleted: Vec<bool>,
            pub name: Vec<String>,
            pub values: Vec<Vec<i32>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing FeedParameterDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "deleted" => intermediate_rep.deleted.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "values" => return std::result::Result::Err("Parsing a container in this style is not supported in FeedParameterDto".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing FeedParameterDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(FeedParameterDto {
            deleted: intermediate_rep.deleted.into_iter().next(),
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "name missing in FeedParameterDto".to_string())?,
            values: std::result::Result::Err("Nullable types not supported in FeedParameterDto".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<FeedParameterDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<FeedParameterDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<FeedParameterDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for FeedParameterDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<FeedParameterDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <FeedParameterDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into FeedParameterDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Название параметра.  Возможное значение: - `reparseIntervalMinutes` — период скачивания прайс-листа. Маркет будет скачивать прайс-лист через количество минут, указанное в параметре `value`. Например, при `value=1440`, Маркет будет скачивать прайс-лист один раз в сутки.  {% note alert %}  Несмотря на установленное значение, Маркет скачает прайс-лист один раз в сутки.  {% endnote %}  Обязательный параметр. 
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct FeedParameterName(String);

impl std::convert::From<String> for FeedParameterName {
    fn from(x: String) -> Self {
        FeedParameterName(x)
    }
}

impl std::string::ToString for FeedParameterName {
    fn to_string(&self) -> String {
       self.0.to_string()
    }
}

impl std::str::FromStr for FeedParameterName {
    type Err = std::string::ParseError;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(FeedParameterName(x.to_string()))
    }
}

impl std::convert::From<FeedParameterName> for String {
    fn from(x: FeedParameterName) -> Self {
        x.0
    }
}

impl std::ops::Deref for FeedParameterName {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for FeedParameterName {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}


/// Информация о размещении предложений из прайс-листа на Маркете на момент выполнения запроса.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct FeedPlacementDto {
    #[serde(rename = "status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<models::FeedStatusType>,

    /// Количество предложений из прайс-листа, которые размещаются на Яндекс Маркете в момент выполнения запроса.
    #[serde(rename = "totalOffersCount")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub total_offers_count: Option<i32>,

}


impl FeedPlacementDto {
    #[allow(clippy::new_without_default)]
    pub fn new() -> FeedPlacementDto {
        FeedPlacementDto {
            status: None,
            total_offers_count: None,
        }
    }
}

/// Converts the FeedPlacementDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for FeedPlacementDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping status in query parameter serialization


            self.total_offers_count.as_ref().map(|total_offers_count| {
                [
                    "totalOffersCount".to_string(),
                    total_offers_count.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a FeedPlacementDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for FeedPlacementDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub status: Vec<models::FeedStatusType>,
            pub total_offers_count: Vec<i32>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing FeedPlacementDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(<models::FeedStatusType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "totalOffersCount" => intermediate_rep.total_offers_count.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing FeedPlacementDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(FeedPlacementDto {
            status: intermediate_rep.status.into_iter().next(),
            total_offers_count: intermediate_rep.total_offers_count.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<FeedPlacementDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<FeedPlacementDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<FeedPlacementDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for FeedPlacementDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<FeedPlacementDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <FeedPlacementDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into FeedPlacementDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Информация о последней публикации предложений из прайс-листа на Маркете.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct FeedPublicationDto {
    #[serde(rename = "status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<models::FeedStatusType>,

    #[serde(rename = "full")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub full: Option<models::FeedPublicationFullDto>,

    #[serde(rename = "priceAndStockUpdate")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub price_and_stock_update: Option<models::FeedPublicationPriceAndStockUpdateDto>,

}


impl FeedPublicationDto {
    #[allow(clippy::new_without_default)]
    pub fn new() -> FeedPublicationDto {
        FeedPublicationDto {
            status: None,
            full: None,
            price_and_stock_update: None,
        }
    }
}

/// Converts the FeedPublicationDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for FeedPublicationDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping status in query parameter serialization

            // Skipping full in query parameter serialization

            // Skipping priceAndStockUpdate in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a FeedPublicationDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for FeedPublicationDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub status: Vec<models::FeedStatusType>,
            pub full: Vec<models::FeedPublicationFullDto>,
            pub price_and_stock_update: Vec<models::FeedPublicationPriceAndStockUpdateDto>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing FeedPublicationDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(<models::FeedStatusType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "full" => intermediate_rep.full.push(<models::FeedPublicationFullDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "priceAndStockUpdate" => intermediate_rep.price_and_stock_update.push(<models::FeedPublicationPriceAndStockUpdateDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing FeedPublicationDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(FeedPublicationDto {
            status: intermediate_rep.status.into_iter().next(),
            full: intermediate_rep.full.into_iter().next(),
            price_and_stock_update: intermediate_rep.price_and_stock_update.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<FeedPublicationDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<FeedPublicationDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<FeedPublicationDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for FeedPublicationDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<FeedPublicationDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <FeedPublicationDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into FeedPublicationDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Информация о последней публикации предложений из прайс-листа на Маркете. 
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct FeedPublicationFullDto {
    /// Дата и время, которые магазин указал в прайс-листе.  Формат даты: ISO 8601 со смещением относительно UTC. Например, `2017-11-21T00:42:42+03:00`. 
    #[serde(rename = "fileTime")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub file_time: Option<chrono::DateTime::<chrono::Utc>>,

    /// Дата и время публикации предложений из прайс-листа на Маркете.  Формат даты: ISO 8601 со смещением относительно UTC. Например, `2017-11-21T00:42:42+03:00`. 
    #[serde(rename = "publishedTime")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub published_time: Option<chrono::DateTime::<chrono::Utc>>,

}


impl FeedPublicationFullDto {
    #[allow(clippy::new_without_default)]
    pub fn new() -> FeedPublicationFullDto {
        FeedPublicationFullDto {
            file_time: None,
            published_time: None,
        }
    }
}

/// Converts the FeedPublicationFullDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for FeedPublicationFullDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping fileTime in query parameter serialization

            // Skipping publishedTime in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a FeedPublicationFullDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for FeedPublicationFullDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub file_time: Vec<chrono::DateTime::<chrono::Utc>>,
            pub published_time: Vec<chrono::DateTime::<chrono::Utc>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing FeedPublicationFullDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "fileTime" => intermediate_rep.file_time.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "publishedTime" => intermediate_rep.published_time.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing FeedPublicationFullDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(FeedPublicationFullDto {
            file_time: intermediate_rep.file_time.into_iter().next(),
            published_time: intermediate_rep.published_time.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<FeedPublicationFullDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<FeedPublicationFullDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<FeedPublicationFullDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for FeedPublicationFullDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<FeedPublicationFullDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <FeedPublicationFullDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into FeedPublicationFullDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Последнее обновление цен и наличия товаров на Маркете. Если последнее по времени обновление было полным, в параметре выводятся те же данные, что и в параметре `full`. Выводится, если параметр `publication status=OK`. 
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct FeedPublicationPriceAndStockUpdateDto {
    /// Дата и время, которые магазин указал в прайс-листе.  Формат даты: ISO 8601 со смещением относительно UTC. Например, `2017-11-21T00:42:42+03:00`. 
    #[serde(rename = "fileTime")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub file_time: Option<chrono::DateTime::<chrono::Utc>>,

    /// Дата и время публикации предложений из прайс-листа на Маркете.  Формат даты: ISO 8601 со смещением относительно UTC. Например, `2017-11-21T00:42:42+03:00`. 
    #[serde(rename = "publishedTime")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub published_time: Option<chrono::DateTime::<chrono::Utc>>,

}


impl FeedPublicationPriceAndStockUpdateDto {
    #[allow(clippy::new_without_default)]
    pub fn new() -> FeedPublicationPriceAndStockUpdateDto {
        FeedPublicationPriceAndStockUpdateDto {
            file_time: None,
            published_time: None,
        }
    }
}

/// Converts the FeedPublicationPriceAndStockUpdateDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for FeedPublicationPriceAndStockUpdateDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping fileTime in query parameter serialization

            // Skipping publishedTime in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a FeedPublicationPriceAndStockUpdateDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for FeedPublicationPriceAndStockUpdateDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub file_time: Vec<chrono::DateTime::<chrono::Utc>>,
            pub published_time: Vec<chrono::DateTime::<chrono::Utc>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing FeedPublicationPriceAndStockUpdateDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "fileTime" => intermediate_rep.file_time.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "publishedTime" => intermediate_rep.published_time.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing FeedPublicationPriceAndStockUpdateDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(FeedPublicationPriceAndStockUpdateDto {
            file_time: intermediate_rep.file_time.into_iter().next(),
            published_time: intermediate_rep.published_time.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<FeedPublicationPriceAndStockUpdateDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<FeedPublicationPriceAndStockUpdateDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<FeedPublicationPriceAndStockUpdateDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for FeedPublicationPriceAndStockUpdateDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<FeedPublicationPriceAndStockUpdateDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <FeedPublicationPriceAndStockUpdateDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into FeedPublicationPriceAndStockUpdateDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Статус прайс-листа.  Возможные значения:    * `ERROR` — найдены ошибки.   * `NA` — прайс-лист не загружался более семи дней или на этапе загрузки произошла ошибка.   * `OK` — ошибок не найдено. 
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum FeedStatusType {
    #[serde(rename = "ERROR")]
    Error,
    #[serde(rename = "NA")]
    Na,
    #[serde(rename = "OK")]
    Ok,
}

impl std::fmt::Display for FeedStatusType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            FeedStatusType::Error => write!(f, "ERROR"),
            FeedStatusType::Na => write!(f, "NA"),
            FeedStatusType::Ok => write!(f, "OK"),
        }
    }
}

impl std::str::FromStr for FeedStatusType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "ERROR" => std::result::Result::Ok(FeedStatusType::Error),
            "NA" => std::result::Result::Ok(FeedStatusType::Na),
            "OK" => std::result::Result::Ok(FeedStatusType::Ok),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Информация об авторе отзыва.  Если отзыв оставлен анонимно, параметр не возвращается. 
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct FeedbackAuthorDto {
    /// Имя автора отзыва.
    #[serde(rename = "name")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

    #[serde(rename = "region")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub region: Option<models::RegionDto>,

}


impl FeedbackAuthorDto {
    #[allow(clippy::new_without_default)]
    pub fn new() -> FeedbackAuthorDto {
        FeedbackAuthorDto {
            name: None,
            region: None,
        }
    }
}

/// Converts the FeedbackAuthorDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for FeedbackAuthorDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.name.as_ref().map(|name| {
                [
                    "name".to_string(),
                    name.to_string(),
                ].join(",")
            }),

            // Skipping region in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a FeedbackAuthorDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for FeedbackAuthorDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub name: Vec<String>,
            pub region: Vec<models::RegionDto>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing FeedbackAuthorDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "region" => intermediate_rep.region.push(<models::RegionDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing FeedbackAuthorDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(FeedbackAuthorDto {
            name: intermediate_rep.name.into_iter().next(),
            region: intermediate_rep.region.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<FeedbackAuthorDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<FeedbackAuthorDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<FeedbackAuthorDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for FeedbackAuthorDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<FeedbackAuthorDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <FeedbackAuthorDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into FeedbackAuthorDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Информация об авторе комментария.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct FeedbackCommentAuthorDto {
    #[serde(rename = "type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub r#type: Option<models::FeedbackCommentAuthorType>,

    /// Имя автора отзыва или название магазина.
    #[serde(rename = "name")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

}


impl FeedbackCommentAuthorDto {
    #[allow(clippy::new_without_default)]
    pub fn new() -> FeedbackCommentAuthorDto {
        FeedbackCommentAuthorDto {
            r#type: None,
            name: None,
        }
    }
}

/// Converts the FeedbackCommentAuthorDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for FeedbackCommentAuthorDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping type in query parameter serialization


            self.name.as_ref().map(|name| {
                [
                    "name".to_string(),
                    name.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a FeedbackCommentAuthorDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for FeedbackCommentAuthorDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub r#type: Vec<models::FeedbackCommentAuthorType>,
            pub name: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing FeedbackCommentAuthorDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r#type.push(<models::FeedbackCommentAuthorType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing FeedbackCommentAuthorDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(FeedbackCommentAuthorDto {
            r#type: intermediate_rep.r#type.into_iter().next(),
            name: intermediate_rep.name.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<FeedbackCommentAuthorDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<FeedbackCommentAuthorDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<FeedbackCommentAuthorDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for FeedbackCommentAuthorDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<FeedbackCommentAuthorDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <FeedbackCommentAuthorDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into FeedbackCommentAuthorDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Тип автора:  * `USER` — пользователь. * `SHOP` — магазин. 
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum FeedbackCommentAuthorType {
    #[serde(rename = "USER")]
    User,
    #[serde(rename = "SHOP")]
    Shop,
}

impl std::fmt::Display for FeedbackCommentAuthorType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            FeedbackCommentAuthorType::User => write!(f, "USER"),
            FeedbackCommentAuthorType::Shop => write!(f, "SHOP"),
        }
    }
}

impl std::str::FromStr for FeedbackCommentAuthorType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "USER" => std::result::Result::Ok(FeedbackCommentAuthorType::User),
            "SHOP" => std::result::Result::Ok(FeedbackCommentAuthorType::Shop),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Комментарий к отзыву на магазин.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct FeedbackCommentDto {
    /// Идентификатор ответа.
    #[serde(rename = "id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,

    /// Идентификатор родительского ответа.
    #[serde(rename = "parentId")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub parent_id: Option<i64>,

    /// Текст ответа.
    #[serde(rename = "body")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub body: Option<String>,

    /// Дата и время создания ответа.  Формат даты: ISO 8601 со смещением относительно UTC. Например, `2017-11-21T00:00:00+03:00`. 
    #[serde(rename = "createdAt")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime::<chrono::Utc>>,

    /// Дата и время изменения ответа.  Формат даты: ISO 8601 со смещением относительно UTC. Например, `2017-11-21T00:00:00+03:00`. 
    #[serde(rename = "updatedAt")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime::<chrono::Utc>>,

    #[serde(rename = "author")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub author: Option<models::FeedbackCommentAuthorDto>,

    /// Дочерние ответы.
    #[serde(rename = "children")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub children: Option<swagger::Nullable<Vec<models::FeedbackCommentDto>>>,

}


impl FeedbackCommentDto {
    #[allow(clippy::new_without_default)]
    pub fn new() -> FeedbackCommentDto {
        FeedbackCommentDto {
            id: None,
            parent_id: None,
            body: None,
            created_at: None,
            updated_at: None,
            author: None,
            children: None,
        }
    }
}

/// Converts the FeedbackCommentDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for FeedbackCommentDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.id.as_ref().map(|id| {
                [
                    "id".to_string(),
                    id.to_string(),
                ].join(",")
            }),


            self.parent_id.as_ref().map(|parent_id| {
                [
                    "parentId".to_string(),
                    parent_id.to_string(),
                ].join(",")
            }),


            self.body.as_ref().map(|body| {
                [
                    "body".to_string(),
                    body.to_string(),
                ].join(",")
            }),

            // Skipping createdAt in query parameter serialization

            // Skipping updatedAt in query parameter serialization

            // Skipping author in query parameter serialization

            // Skipping children in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a FeedbackCommentDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for FeedbackCommentDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<i64>,
            pub parent_id: Vec<i64>,
            pub body: Vec<String>,
            pub created_at: Vec<chrono::DateTime::<chrono::Utc>>,
            pub updated_at: Vec<chrono::DateTime::<chrono::Utc>>,
            pub author: Vec<models::FeedbackCommentAuthorDto>,
            pub children: Vec<Vec<models::FeedbackCommentDto>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing FeedbackCommentDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "parentId" => intermediate_rep.parent_id.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "body" => intermediate_rep.body.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "createdAt" => intermediate_rep.created_at.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "updatedAt" => intermediate_rep.updated_at.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "author" => intermediate_rep.author.push(<models::FeedbackCommentAuthorDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "children" => return std::result::Result::Err("Parsing a container in this style is not supported in FeedbackCommentDto".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing FeedbackCommentDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(FeedbackCommentDto {
            id: intermediate_rep.id.into_iter().next(),
            parent_id: intermediate_rep.parent_id.into_iter().next(),
            body: intermediate_rep.body.into_iter().next(),
            created_at: intermediate_rep.created_at.into_iter().next(),
            updated_at: intermediate_rep.updated_at.into_iter().next(),
            author: intermediate_rep.author.into_iter().next(),
            children: std::result::Result::Err("Nullable types not supported in FeedbackCommentDto".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<FeedbackCommentDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<FeedbackCommentDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<FeedbackCommentDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for FeedbackCommentDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<FeedbackCommentDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <FeedbackCommentDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into FeedbackCommentDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Способ покупки, указанный в отзыве:  * `DELIVERY` — доставка. * `PICKUP` — самовывоз. * `INSTORE` — в магазине. 
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum FeedbackDeliveryType {
    #[serde(rename = "DELIVERY")]
    Delivery,
    #[serde(rename = "PICKUP")]
    Pickup,
    #[serde(rename = "INSTORE")]
    Instore,
}

impl std::fmt::Display for FeedbackDeliveryType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            FeedbackDeliveryType::Delivery => write!(f, "DELIVERY"),
            FeedbackDeliveryType::Pickup => write!(f, "PICKUP"),
            FeedbackDeliveryType::Instore => write!(f, "INSTORE"),
        }
    }
}

impl std::str::FromStr for FeedbackDeliveryType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "DELIVERY" => std::result::Result::Ok(FeedbackDeliveryType::Delivery),
            "PICKUP" => std::result::Result::Ok(FeedbackDeliveryType::Pickup),
            "INSTORE" => std::result::Result::Ok(FeedbackDeliveryType::Instore),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Отзыв пользователя Яндекс Маркета об указанном магазине.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct FeedbackDto {
    /// Идентификатор отзыва.
    #[serde(rename = "id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,

    /// Дата и время создания отзыва.  Формат даты: ISO 8601 со смещением относительно UTC. Например, `2017-11-21T00:00:00+03:00`. 
    #[serde(rename = "createdAt")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime::<chrono::Utc>>,

    /// Комментарий автора отзыва.
    #[serde(rename = "text")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub text: Option<String>,

    #[serde(rename = "state")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub state: Option<models::FeedbackStateType>,

    #[serde(rename = "author")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub author: Option<models::FeedbackAuthorDto>,

    /// Достоинства магазина, описанные в отзыве.
    #[serde(rename = "pro")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub pro: Option<String>,

    /// Недостатки магазина, описанные в отзыве.
    #[serde(rename = "contra")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub contra: Option<String>,

    /// Переписка автора отзыва с магазином.
    #[serde(rename = "comments")]
    pub comments: Vec<models::FeedbackCommentDto>,

    #[serde(rename = "shop")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub shop: Option<models::FeedbackShopDto>,

    /// Решена ли проблема автора отзыва:  * `true` — да. * `false` — нет.  Если проблема решена, около отзыва на странице магазина появляется соответствующая надпись. 
    #[serde(rename = "resolved")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub resolved: Option<bool>,

    /// {% note warning \"\" %}  Этот параметр устарел. Не используйте его.  {% endnote %}  Является ли отзыв рекомендованным:  * `true` — да. * `false` — нет. 
    #[serde(rename = "verified")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub verified: Option<bool>,

    /// Купил бы автор отзыва в магазине снова:  * `true` — да. * `false` — нет. 
    #[serde(rename = "recommend")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub recommend: Option<bool>,

    #[serde(rename = "grades")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub grades: Option<models::FeedbackGradesDto>,

    #[serde(rename = "order")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub order: Option<models::FeedbackOrderDto>,

}


impl FeedbackDto {
    #[allow(clippy::new_without_default)]
    pub fn new(comments: Vec<models::FeedbackCommentDto>, ) -> FeedbackDto {
        FeedbackDto {
            id: None,
            created_at: None,
            text: None,
            state: None,
            author: None,
            pro: None,
            contra: None,
            comments,
            shop: None,
            resolved: None,
            verified: None,
            recommend: None,
            grades: None,
            order: None,
        }
    }
}

/// Converts the FeedbackDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for FeedbackDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.id.as_ref().map(|id| {
                [
                    "id".to_string(),
                    id.to_string(),
                ].join(",")
            }),

            // Skipping createdAt in query parameter serialization


            self.text.as_ref().map(|text| {
                [
                    "text".to_string(),
                    text.to_string(),
                ].join(",")
            }),

            // Skipping state in query parameter serialization

            // Skipping author in query parameter serialization


            self.pro.as_ref().map(|pro| {
                [
                    "pro".to_string(),
                    pro.to_string(),
                ].join(",")
            }),


            self.contra.as_ref().map(|contra| {
                [
                    "contra".to_string(),
                    contra.to_string(),
                ].join(",")
            }),

            // Skipping comments in query parameter serialization

            // Skipping shop in query parameter serialization


            self.resolved.as_ref().map(|resolved| {
                [
                    "resolved".to_string(),
                    resolved.to_string(),
                ].join(",")
            }),


            self.verified.as_ref().map(|verified| {
                [
                    "verified".to_string(),
                    verified.to_string(),
                ].join(",")
            }),


            self.recommend.as_ref().map(|recommend| {
                [
                    "recommend".to_string(),
                    recommend.to_string(),
                ].join(",")
            }),

            // Skipping grades in query parameter serialization

            // Skipping order in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a FeedbackDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for FeedbackDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<i64>,
            pub created_at: Vec<chrono::DateTime::<chrono::Utc>>,
            pub text: Vec<String>,
            pub state: Vec<models::FeedbackStateType>,
            pub author: Vec<models::FeedbackAuthorDto>,
            pub pro: Vec<String>,
            pub contra: Vec<String>,
            pub comments: Vec<Vec<models::FeedbackCommentDto>>,
            pub shop: Vec<models::FeedbackShopDto>,
            pub resolved: Vec<bool>,
            pub verified: Vec<bool>,
            pub recommend: Vec<bool>,
            pub grades: Vec<models::FeedbackGradesDto>,
            pub order: Vec<models::FeedbackOrderDto>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing FeedbackDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "createdAt" => intermediate_rep.created_at.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "text" => intermediate_rep.text.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "state" => intermediate_rep.state.push(<models::FeedbackStateType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "author" => intermediate_rep.author.push(<models::FeedbackAuthorDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "pro" => intermediate_rep.pro.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "contra" => intermediate_rep.contra.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "comments" => return std::result::Result::Err("Parsing a container in this style is not supported in FeedbackDto".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "shop" => intermediate_rep.shop.push(<models::FeedbackShopDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "resolved" => intermediate_rep.resolved.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "verified" => intermediate_rep.verified.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "recommend" => intermediate_rep.recommend.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "grades" => intermediate_rep.grades.push(<models::FeedbackGradesDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "order" => intermediate_rep.order.push(<models::FeedbackOrderDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing FeedbackDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(FeedbackDto {
            id: intermediate_rep.id.into_iter().next(),
            created_at: intermediate_rep.created_at.into_iter().next(),
            text: intermediate_rep.text.into_iter().next(),
            state: intermediate_rep.state.into_iter().next(),
            author: intermediate_rep.author.into_iter().next(),
            pro: intermediate_rep.pro.into_iter().next(),
            contra: intermediate_rep.contra.into_iter().next(),
            comments: intermediate_rep.comments.into_iter().next().ok_or_else(|| "comments missing in FeedbackDto".to_string())?,
            shop: intermediate_rep.shop.into_iter().next(),
            resolved: intermediate_rep.resolved.into_iter().next(),
            verified: intermediate_rep.verified.into_iter().next(),
            recommend: intermediate_rep.recommend.into_iter().next(),
            grades: intermediate_rep.grades.into_iter().next(),
            order: intermediate_rep.order.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<FeedbackDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<FeedbackDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<FeedbackDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for FeedbackDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<FeedbackDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <FeedbackDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into FeedbackDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Информация об оценках по параметрам, указанных в отзыве.  При создании отзыва автору предлагается поставить оценки магазину по нескольким параметрам: например, за скорость обработки заказа или удобство самовывоза. Набор параметров зависит от того, какой способ покупки (параметр `delivery`) указал автор. 
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct FeedbackFactorDto {
    /// Идентификатор параметра.
    #[serde(rename = "id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,

    /// Название параметра. Например, `Скорость обработки заказа`.
    #[serde(rename = "title")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub title: Option<String>,

    /// Описание параметра. Например, `Как быстро с вами связались для подтверждения заказа?`.
    #[serde(rename = "description")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,

    /// Оценка по параметру, указанная в отзыве: от `1` (низшая оценка) до `5` (высшая оценка). 
    #[serde(rename = "value")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub value: Option<i32>,

}


impl FeedbackFactorDto {
    #[allow(clippy::new_without_default)]
    pub fn new() -> FeedbackFactorDto {
        FeedbackFactorDto {
            id: None,
            title: None,
            description: None,
            value: None,
        }
    }
}

/// Converts the FeedbackFactorDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for FeedbackFactorDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.id.as_ref().map(|id| {
                [
                    "id".to_string(),
                    id.to_string(),
                ].join(",")
            }),


            self.title.as_ref().map(|title| {
                [
                    "title".to_string(),
                    title.to_string(),
                ].join(",")
            }),


            self.description.as_ref().map(|description| {
                [
                    "description".to_string(),
                    description.to_string(),
                ].join(",")
            }),


            self.value.as_ref().map(|value| {
                [
                    "value".to_string(),
                    value.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a FeedbackFactorDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for FeedbackFactorDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<i64>,
            pub title: Vec<String>,
            pub description: Vec<String>,
            pub value: Vec<i32>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing FeedbackFactorDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "title" => intermediate_rep.title.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "description" => intermediate_rep.description.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "value" => intermediate_rep.value.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing FeedbackFactorDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(FeedbackFactorDto {
            id: intermediate_rep.id.into_iter().next(),
            title: intermediate_rep.title.into_iter().next(),
            description: intermediate_rep.description.into_iter().next(),
            value: intermediate_rep.value.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<FeedbackFactorDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<FeedbackFactorDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<FeedbackFactorDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for FeedbackFactorDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<FeedbackFactorDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <FeedbackFactorDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into FeedbackFactorDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Информация об оценках, которые поставил автор отзыва магазину, и об оценках полезности отзыва от других пользователей Маркета.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct FeedbackGradesDto {
    /// Общая оценка, указанная в отзыве: от `1` («Ужасный магазин») до `5` («Отличный магазин»).
    #[serde(rename = "average")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub average: Option<f64>,

    /// Количество пользователей, считающих отзыв полезным.
    #[serde(rename = "agreeCount")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub agree_count: Option<i64>,

    /// Количество пользователей, считающих отзыв бесполезным.
    #[serde(rename = "rejectCount")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub reject_count: Option<i64>,

    /// Информация об оценках по параметрам, указанных в отзыве.  При создании отзыва автору предлагается поставить оценки магазину по нескольким параметрам: например, за скорость обработки заказа или удобство самовывоза. Набор параметров зависит от того, какой способ покупки (параметр `delivery`) указал автор. 
    #[serde(rename = "factors")]
    pub factors: Vec<models::FeedbackFactorDto>,

}


impl FeedbackGradesDto {
    #[allow(clippy::new_without_default)]
    pub fn new(factors: Vec<models::FeedbackFactorDto>, ) -> FeedbackGradesDto {
        FeedbackGradesDto {
            average: None,
            agree_count: None,
            reject_count: None,
            factors,
        }
    }
}

/// Converts the FeedbackGradesDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for FeedbackGradesDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.average.as_ref().map(|average| {
                [
                    "average".to_string(),
                    average.to_string(),
                ].join(",")
            }),


            self.agree_count.as_ref().map(|agree_count| {
                [
                    "agreeCount".to_string(),
                    agree_count.to_string(),
                ].join(",")
            }),


            self.reject_count.as_ref().map(|reject_count| {
                [
                    "rejectCount".to_string(),
                    reject_count.to_string(),
                ].join(",")
            }),

            // Skipping factors in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a FeedbackGradesDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for FeedbackGradesDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub average: Vec<f64>,
            pub agree_count: Vec<i64>,
            pub reject_count: Vec<i64>,
            pub factors: Vec<Vec<models::FeedbackFactorDto>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing FeedbackGradesDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "average" => intermediate_rep.average.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "agreeCount" => intermediate_rep.agree_count.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "rejectCount" => intermediate_rep.reject_count.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "factors" => return std::result::Result::Err("Parsing a container in this style is not supported in FeedbackGradesDto".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing FeedbackGradesDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(FeedbackGradesDto {
            average: intermediate_rep.average.into_iter().next(),
            agree_count: intermediate_rep.agree_count.into_iter().next(),
            reject_count: intermediate_rep.reject_count.into_iter().next(),
            factors: intermediate_rep.factors.into_iter().next().ok_or_else(|| "factors missing in FeedbackGradesDto".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<FeedbackGradesDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<FeedbackGradesDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<FeedbackGradesDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for FeedbackGradesDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<FeedbackGradesDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <FeedbackGradesDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into FeedbackGradesDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Отзывы пользователей Яндекс Маркета об указанном магазине.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct FeedbackListDto {
    #[serde(rename = "paging")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub paging: Option<models::ScrollingPagerDto>,

    /// Список отзывов.  Содержит не более 20 отзывов. 
    #[serde(rename = "feedbackList")]
    pub feedback_list: Vec<models::FeedbackDto>,

}


impl FeedbackListDto {
    #[allow(clippy::new_without_default)]
    pub fn new(feedback_list: Vec<models::FeedbackDto>, ) -> FeedbackListDto {
        FeedbackListDto {
            paging: None,
            feedback_list,
        }
    }
}

/// Converts the FeedbackListDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for FeedbackListDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping paging in query parameter serialization

            // Skipping feedbackList in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a FeedbackListDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for FeedbackListDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub paging: Vec<models::ScrollingPagerDto>,
            pub feedback_list: Vec<Vec<models::FeedbackDto>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing FeedbackListDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "paging" => intermediate_rep.paging.push(<models::ScrollingPagerDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "feedbackList" => return std::result::Result::Err("Parsing a container in this style is not supported in FeedbackListDto".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing FeedbackListDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(FeedbackListDto {
            paging: intermediate_rep.paging.into_iter().next(),
            feedback_list: intermediate_rep.feedback_list.into_iter().next().ok_or_else(|| "feedbackList missing in FeedbackListDto".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<FeedbackListDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<FeedbackListDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<FeedbackListDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for FeedbackListDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<FeedbackListDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <FeedbackListDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into FeedbackListDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Информация о заказе, указанная в отзыве.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct FeedbackOrderDto {
    /// Номер заказа, указанный в отзыве.
    #[serde(rename = "shopOrderId")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub shop_order_id: Option<String>,

    #[serde(rename = "delivery")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub delivery: Option<models::FeedbackDeliveryType>,

}


impl FeedbackOrderDto {
    #[allow(clippy::new_without_default)]
    pub fn new() -> FeedbackOrderDto {
        FeedbackOrderDto {
            shop_order_id: None,
            delivery: None,
        }
    }
}

/// Converts the FeedbackOrderDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for FeedbackOrderDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.shop_order_id.as_ref().map(|shop_order_id| {
                [
                    "shopOrderId".to_string(),
                    shop_order_id.to_string(),
                ].join(",")
            }),

            // Skipping delivery in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a FeedbackOrderDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for FeedbackOrderDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub shop_order_id: Vec<String>,
            pub delivery: Vec<models::FeedbackDeliveryType>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing FeedbackOrderDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "shopOrderId" => intermediate_rep.shop_order_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "delivery" => intermediate_rep.delivery.push(<models::FeedbackDeliveryType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing FeedbackOrderDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(FeedbackOrderDto {
            shop_order_id: intermediate_rep.shop_order_id.into_iter().next(),
            delivery: intermediate_rep.delivery.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<FeedbackOrderDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<FeedbackOrderDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<FeedbackOrderDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for FeedbackOrderDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<FeedbackOrderDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <FeedbackOrderDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into FeedbackOrderDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Статус реакции на отзыв:  * `ALL` — все отзывы.  * `NEED_REACTION` — отзывы, на которые нужно ответить. 
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum FeedbackReactionStatusType {
    #[serde(rename = "ALL")]
    All,
    #[serde(rename = "NEED_REACTION")]
    NeedReaction,
}

impl std::fmt::Display for FeedbackReactionStatusType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            FeedbackReactionStatusType::All => write!(f, "ALL"),
            FeedbackReactionStatusType::NeedReaction => write!(f, "NEED_REACTION"),
        }
    }
}

impl std::str::FromStr for FeedbackReactionStatusType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "ALL" => std::result::Result::Ok(FeedbackReactionStatusType::All),
            "NEED_REACTION" => std::result::Result::Ok(FeedbackReactionStatusType::NeedReaction),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Информация о магазине.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct FeedbackShopDto {
    /// Название магазина.
    #[serde(rename = "name")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

}


impl FeedbackShopDto {
    #[allow(clippy::new_without_default)]
    pub fn new() -> FeedbackShopDto {
        FeedbackShopDto {
            name: None,
        }
    }
}

/// Converts the FeedbackShopDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for FeedbackShopDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.name.as_ref().map(|name| {
                [
                    "name".to_string(),
                    name.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a FeedbackShopDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for FeedbackShopDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub name: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing FeedbackShopDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing FeedbackShopDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(FeedbackShopDto {
            name: intermediate_rep.name.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<FeedbackShopDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<FeedbackShopDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<FeedbackShopDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for FeedbackShopDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<FeedbackShopDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <FeedbackShopDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into FeedbackShopDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Статус отзыва:  * `LAST` — актуален. * `PREVIOUS` — устарел. * `DELETED` — удален. 
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum FeedbackStateType {
    #[serde(rename = "LAST")]
    Last,
    #[serde(rename = "PREVIOUS")]
    Previous,
    #[serde(rename = "DELETED")]
    Deleted,
}

impl std::fmt::Display for FeedbackStateType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            FeedbackStateType::Last => write!(f, "LAST"),
            FeedbackStateType::Previous => write!(f, "PREVIOUS"),
            FeedbackStateType::Deleted => write!(f, "DELETED"),
        }
    }
}

impl std::str::FromStr for FeedbackStateType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "LAST" => std::result::Result::Ok(FeedbackStateType::Last),
            "PREVIOUS" => std::result::Result::Ok(FeedbackStateType::Previous),
            "DELETED" => std::result::Result::Ok(FeedbackStateType::Deleted),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Фильтр по заполненности или незаполненности поля:  * `SPECIFIED` — вывести товары, у которых поле заполнено. * `EMPTY` — вывести товары, у которых поле не заполнено. 
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum FieldStateType {
    #[serde(rename = "SPECIFIED")]
    Specified,
    #[serde(rename = "EMPTY")]
    Empty,
}

impl std::fmt::Display for FieldStateType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            FieldStateType::Specified => write!(f, "SPECIFIED"),
            FieldStateType::Empty => write!(f, "EMPTY"),
        }
    }
}

impl std::str::FromStr for FieldStateType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "SPECIFIED" => std::result::Result::Ok(FieldStateType::Specified),
            "EMPTY" => std::result::Result::Ok(FieldStateType::Empty),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Модель для пагинации.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct FlippingPagerDto {
    /// Сколько всего найдено элементов.
    #[serde(rename = "total")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub total: Option<i32>,

    /// Начальный номер найденного элемента на странице.
    #[serde(rename = "from")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub from: Option<i32>,

    /// Конечный номер найденного элемента на странице.
    #[serde(rename = "to")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub to: Option<i32>,

    /// Текущая страница.
    #[serde(rename = "currentPage")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub current_page: Option<i32>,

    /// Общее количество страниц.
    #[serde(rename = "pagesCount")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub pages_count: Option<i32>,

    /// Размер страницы.
    #[serde(rename = "pageSize")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub page_size: Option<i32>,

}


impl FlippingPagerDto {
    #[allow(clippy::new_without_default)]
    pub fn new() -> FlippingPagerDto {
        FlippingPagerDto {
            total: None,
            from: None,
            to: None,
            current_page: None,
            pages_count: None,
            page_size: None,
        }
    }
}

/// Converts the FlippingPagerDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for FlippingPagerDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.total.as_ref().map(|total| {
                [
                    "total".to_string(),
                    total.to_string(),
                ].join(",")
            }),


            self.from.as_ref().map(|from| {
                [
                    "from".to_string(),
                    from.to_string(),
                ].join(",")
            }),


            self.to.as_ref().map(|to| {
                [
                    "to".to_string(),
                    to.to_string(),
                ].join(",")
            }),


            self.current_page.as_ref().map(|current_page| {
                [
                    "currentPage".to_string(),
                    current_page.to_string(),
                ].join(",")
            }),


            self.pages_count.as_ref().map(|pages_count| {
                [
                    "pagesCount".to_string(),
                    pages_count.to_string(),
                ].join(",")
            }),


            self.page_size.as_ref().map(|page_size| {
                [
                    "pageSize".to_string(),
                    page_size.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a FlippingPagerDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for FlippingPagerDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub total: Vec<i32>,
            pub from: Vec<i32>,
            pub to: Vec<i32>,
            pub current_page: Vec<i32>,
            pub pages_count: Vec<i32>,
            pub page_size: Vec<i32>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing FlippingPagerDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "total" => intermediate_rep.total.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "from" => intermediate_rep.from.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "to" => intermediate_rep.to.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "currentPage" => intermediate_rep.current_page.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "pagesCount" => intermediate_rep.pages_count.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "pageSize" => intermediate_rep.page_size.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing FlippingPagerDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(FlippingPagerDto {
            total: intermediate_rep.total.into_iter().next(),
            from: intermediate_rep.from.into_iter().next(),
            to: intermediate_rep.to.into_iter().next(),
            current_page: intermediate_rep.current_page.into_iter().next(),
            pages_count: intermediate_rep.pages_count.into_iter().next(),
            page_size: intermediate_rep.page_size.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<FlippingPagerDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<FlippingPagerDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<FlippingPagerDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for FlippingPagerDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<FlippingPagerDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <FlippingPagerDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into FlippingPagerDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Ссылка на следующую страницу. 
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ForwardScrollingPagerDto {
    /// Идентификатор следующей страницы результатов.
    #[serde(rename = "nextPageToken")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub next_page_token: Option<String>,

}


impl ForwardScrollingPagerDto {
    #[allow(clippy::new_without_default)]
    pub fn new() -> ForwardScrollingPagerDto {
        ForwardScrollingPagerDto {
            next_page_token: None,
        }
    }
}

/// Converts the ForwardScrollingPagerDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ForwardScrollingPagerDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.next_page_token.as_ref().map(|next_page_token| {
                [
                    "nextPageToken".to_string(),
                    next_page_token.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ForwardScrollingPagerDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ForwardScrollingPagerDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub next_page_token: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ForwardScrollingPagerDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "nextPageToken" => intermediate_rep.next_page_token.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ForwardScrollingPagerDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ForwardScrollingPagerDto {
            next_page_token: intermediate_rep.next_page_token.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ForwardScrollingPagerDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<ForwardScrollingPagerDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ForwardScrollingPagerDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ForwardScrollingPagerDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<ForwardScrollingPagerDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ForwardScrollingPagerDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ForwardScrollingPagerDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Склад Маркета (FBY).
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct FulfillmentWarehouseDto {
    /// Идентификатор склада.
    #[serde(rename = "id")]
    pub id: i64,

    /// Название склада.
    #[serde(rename = "name")]
    pub name: String,

    #[serde(rename = "address")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub address: Option<models::WarehouseAddressDto>,

}


impl FulfillmentWarehouseDto {
    #[allow(clippy::new_without_default)]
    pub fn new(id: i64, name: String, ) -> FulfillmentWarehouseDto {
        FulfillmentWarehouseDto {
            id,
            name,
            address: None,
        }
    }
}

/// Converts the FulfillmentWarehouseDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for FulfillmentWarehouseDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            Some("id".to_string()),
            Some(self.id.to_string()),


            Some("name".to_string()),
            Some(self.name.to_string()),

            // Skipping address in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a FulfillmentWarehouseDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for FulfillmentWarehouseDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<i64>,
            pub name: Vec<String>,
            pub address: Vec<models::WarehouseAddressDto>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing FulfillmentWarehouseDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "address" => intermediate_rep.address.push(<models::WarehouseAddressDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing FulfillmentWarehouseDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(FulfillmentWarehouseDto {
            id: intermediate_rep.id.into_iter().next().ok_or_else(|| "id missing in FulfillmentWarehouseDto".to_string())?,
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "name missing in FulfillmentWarehouseDto".to_string())?,
            address: intermediate_rep.address.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<FulfillmentWarehouseDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<FulfillmentWarehouseDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<FulfillmentWarehouseDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for FulfillmentWarehouseDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<FulfillmentWarehouseDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <FulfillmentWarehouseDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into FulfillmentWarehouseDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Список складов Маркета (FBY).
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct FulfillmentWarehousesDto {
    /// Список складов Маркета (FBY).
    #[serde(rename = "warehouses")]
    pub warehouses: Vec<models::FulfillmentWarehouseDto>,

}


impl FulfillmentWarehousesDto {
    #[allow(clippy::new_without_default)]
    pub fn new(warehouses: Vec<models::FulfillmentWarehouseDto>, ) -> FulfillmentWarehousesDto {
        FulfillmentWarehousesDto {
            warehouses,
        }
    }
}

/// Converts the FulfillmentWarehousesDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for FulfillmentWarehousesDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping warehouses in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a FulfillmentWarehousesDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for FulfillmentWarehousesDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub warehouses: Vec<Vec<models::FulfillmentWarehouseDto>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing FulfillmentWarehousesDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "warehouses" => return std::result::Result::Err("Parsing a container in this style is not supported in FulfillmentWarehousesDto".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing FulfillmentWarehousesDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(FulfillmentWarehousesDto {
            warehouses: intermediate_rep.warehouses.into_iter().next().ok_or_else(|| "warehouses missing in FulfillmentWarehousesDto".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<FulfillmentWarehousesDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<FulfillmentWarehousesDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<FulfillmentWarehousesDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for FulfillmentWarehousesDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<FulfillmentWarehousesDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <FulfillmentWarehousesDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into FulfillmentWarehousesDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Информация о точке продаж.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct FullOutletDto {
    /// Название точки продаж. 
    #[serde(rename = "name")]
    pub name: String,

    #[serde(rename = "type")]
    pub r#type: models::OutletType,

    /// Координаты точки продаж.  Формат: долгота, широта. Разделители: запятая и / или пробел. Например, `20.4522144, 54.7104264`.  Если параметр не передан, координаты будут определены по значениям параметров, вложенных в `address`. 
    #[serde(rename = "coords")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub coords: Option<String>,

    /// Признак основной точки продаж.  Возможные значения:  * `false` — неосновная точка продаж. * `true` — основная точка продаж. 
    #[serde(rename = "isMain")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub is_main: Option<bool>,

    /// Идентификатор точки продаж, присвоенный магазином.
    #[serde(rename = "shopOutletCode")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub shop_outlet_code: Option<String>,

    #[serde(rename = "visibility")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub visibility: Option<models::OutletVisibilityType>,

    #[serde(rename = "address")]
    pub address: models::OutletAddressDto,

    /// Номера телефонов точки продаж. Передавайте в формате: `+7 (999) 999-99-99`. 
    #[serde(rename = "phones")]
    #[validate(
            length(min = 1),
        )]
    pub phones: Vec<String>,

    #[serde(rename = "workingSchedule")]
    pub working_schedule: models::OutletWorkingScheduleDto,

    /// Информация об условиях доставки для данной точки продаж.  Обязательный параметр, если параметр `type=DEPOT` или `type=MIXED`. 
    #[serde(rename = "deliveryRules")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub delivery_rules: Option<swagger::Nullable<Vec<models::OutletDeliveryRuleDto>>>,

    /// Срок хранения заказа в собственном пункте выдачи заказов. Считается в днях.
    #[serde(rename = "storagePeriod")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub storage_period: Option<i64>,

    /// Идентификатор точки продаж, присвоенный Маркетом.
    #[serde(rename = "id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,

    #[serde(rename = "status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<models::OutletStatusType>,

    #[serde(rename = "region")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub region: Option<models::RegionDto>,

    /// Идентификатор точки продаж, заданный магазином.
    #[serde(rename = "shopOutletId")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub shop_outlet_id: Option<String>,

    /// Рабочее время.
    #[serde(rename = "workingTime")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub working_time: Option<String>,

    /// Статус модерации.
    #[serde(rename = "moderationReason")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub moderation_reason: Option<String>,

}


impl FullOutletDto {
    #[allow(clippy::new_without_default)]
    pub fn new(name: String, r#type: models::OutletType, address: models::OutletAddressDto, phones: Vec<String>, working_schedule: models::OutletWorkingScheduleDto, ) -> FullOutletDto {
        FullOutletDto {
            name,
            r#type,
            coords: None,
            is_main: None,
            shop_outlet_code: None,
            visibility: None,
            address,
            phones,
            working_schedule,
            delivery_rules: None,
            storage_period: None,
            id: None,
            status: None,
            region: None,
            shop_outlet_id: None,
            working_time: None,
            moderation_reason: None,
        }
    }
}

/// Converts the FullOutletDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for FullOutletDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            Some("name".to_string()),
            Some(self.name.to_string()),

            // Skipping type in query parameter serialization


            self.coords.as_ref().map(|coords| {
                [
                    "coords".to_string(),
                    coords.to_string(),
                ].join(",")
            }),


            self.is_main.as_ref().map(|is_main| {
                [
                    "isMain".to_string(),
                    is_main.to_string(),
                ].join(",")
            }),


            self.shop_outlet_code.as_ref().map(|shop_outlet_code| {
                [
                    "shopOutletCode".to_string(),
                    shop_outlet_code.to_string(),
                ].join(",")
            }),

            // Skipping visibility in query parameter serialization

            // Skipping address in query parameter serialization


            Some("phones".to_string()),
            Some(self.phones.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),

            // Skipping workingSchedule in query parameter serialization

            // Skipping deliveryRules in query parameter serialization


            self.storage_period.as_ref().map(|storage_period| {
                [
                    "storagePeriod".to_string(),
                    storage_period.to_string(),
                ].join(",")
            }),


            self.id.as_ref().map(|id| {
                [
                    "id".to_string(),
                    id.to_string(),
                ].join(",")
            }),

            // Skipping status in query parameter serialization

            // Skipping region in query parameter serialization


            self.shop_outlet_id.as_ref().map(|shop_outlet_id| {
                [
                    "shopOutletId".to_string(),
                    shop_outlet_id.to_string(),
                ].join(",")
            }),


            self.working_time.as_ref().map(|working_time| {
                [
                    "workingTime".to_string(),
                    working_time.to_string(),
                ].join(",")
            }),


            self.moderation_reason.as_ref().map(|moderation_reason| {
                [
                    "moderationReason".to_string(),
                    moderation_reason.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a FullOutletDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for FullOutletDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub name: Vec<String>,
            pub r#type: Vec<models::OutletType>,
            pub coords: Vec<String>,
            pub is_main: Vec<bool>,
            pub shop_outlet_code: Vec<String>,
            pub visibility: Vec<models::OutletVisibilityType>,
            pub address: Vec<models::OutletAddressDto>,
            pub phones: Vec<Vec<String>>,
            pub working_schedule: Vec<models::OutletWorkingScheduleDto>,
            pub delivery_rules: Vec<Vec<models::OutletDeliveryRuleDto>>,
            pub storage_period: Vec<i64>,
            pub id: Vec<i64>,
            pub status: Vec<models::OutletStatusType>,
            pub region: Vec<models::RegionDto>,
            pub shop_outlet_id: Vec<String>,
            pub working_time: Vec<String>,
            pub moderation_reason: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing FullOutletDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r#type.push(<models::OutletType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "coords" => intermediate_rep.coords.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "isMain" => intermediate_rep.is_main.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "shopOutletCode" => intermediate_rep.shop_outlet_code.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "visibility" => intermediate_rep.visibility.push(<models::OutletVisibilityType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "address" => intermediate_rep.address.push(<models::OutletAddressDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "phones" => return std::result::Result::Err("Parsing a container in this style is not supported in FullOutletDto".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "workingSchedule" => intermediate_rep.working_schedule.push(<models::OutletWorkingScheduleDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "deliveryRules" => return std::result::Result::Err("Parsing a container in this style is not supported in FullOutletDto".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "storagePeriod" => intermediate_rep.storage_period.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(<models::OutletStatusType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "region" => intermediate_rep.region.push(<models::RegionDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "shopOutletId" => intermediate_rep.shop_outlet_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "workingTime" => intermediate_rep.working_time.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "moderationReason" => intermediate_rep.moderation_reason.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing FullOutletDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(FullOutletDto {
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "name missing in FullOutletDto".to_string())?,
            r#type: intermediate_rep.r#type.into_iter().next().ok_or_else(|| "type missing in FullOutletDto".to_string())?,
            coords: intermediate_rep.coords.into_iter().next(),
            is_main: intermediate_rep.is_main.into_iter().next(),
            shop_outlet_code: intermediate_rep.shop_outlet_code.into_iter().next(),
            visibility: intermediate_rep.visibility.into_iter().next(),
            address: intermediate_rep.address.into_iter().next().ok_or_else(|| "address missing in FullOutletDto".to_string())?,
            phones: intermediate_rep.phones.into_iter().next().ok_or_else(|| "phones missing in FullOutletDto".to_string())?,
            working_schedule: intermediate_rep.working_schedule.into_iter().next().ok_or_else(|| "workingSchedule missing in FullOutletDto".to_string())?,
            delivery_rules: std::result::Result::Err("Nullable types not supported in FullOutletDto".to_string())?,
            storage_period: intermediate_rep.storage_period.into_iter().next(),
            id: intermediate_rep.id.into_iter().next(),
            status: intermediate_rep.status.into_iter().next(),
            region: intermediate_rep.region.into_iter().next(),
            shop_outlet_id: intermediate_rep.shop_outlet_id.into_iter().next(),
            working_time: intermediate_rep.working_time.into_iter().next(),
            moderation_reason: intermediate_rep.moderation_reason.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<FullOutletDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<FullOutletDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<FullOutletDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for FullOutletDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<FullOutletDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <FullOutletDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into FullOutletDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Информация о лицензии.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct FullOutletLicenseDto {
    /// Идентификатор лицензии.  Параметр указывается, только если нужно изменить информацию о существующей лицензии. Ее идентификатор можно узнать с помощью запроса [GET campaigns/{campaignId}/outlets/licenses](../../reference/outlets/getOutletLicenses.md). При передаче информации о новой лицензии указывать идентификатор не нужно.  Идентификатор лицензии присваивается Маркетом. Не путайте его с номером, указанным на лицензии: он передается в параметре `number`. 
    #[serde(rename = "id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,

    /// Идентификатор точки продаж, для которой действительна лицензия.
    #[serde(rename = "outletId")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub outlet_id: Option<i64>,

    #[serde(rename = "licenseType")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub license_type: Option<models::LicenseType>,

    /// Номер лицензии.
    #[serde(rename = "number")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub number: Option<String>,

    /// Дата выдачи лицензии.  Формат даты: ISO 8601 со смещением относительно UTC. Нужно передать дату, указанную на лицензии, время `00:00:00` и часовой пояс, соответствующий региону точки продаж. Например, если лицензия для точки продаж в Москве выдана 13 ноября 2017 года, то параметр должен иметь значение `2017-11-13T00:00:00+03:00`.  Обязательный параметр.  Не может быть позже даты окончания срока действия, указанной в параметре `dateOfExpiry`. 
    #[serde(rename = "dateOfIssue")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub date_of_issue: Option<chrono::DateTime::<chrono::Utc>>,

    /// Дата окончания действия лицензии.  Формат даты: ISO 8601 со смещением относительно UTC. Нужно передать дату, указанную на лицензии, время `00:00:00` и часовой пояс, соответствующий региону точки продаж. Например, если действие лицензии для точки продаж в Москве заканчивается 20 ноября 2022 года, то параметр должен иметь значение `2022-11-20T00:00:00+03:00`.  Обязательный параметр.  Не может быть раньше даты выдачи, указанной в параметре `dateOfIssue`. 
    #[serde(rename = "dateOfExpiry")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub date_of_expiry: Option<chrono::DateTime::<chrono::Utc>>,

    #[serde(rename = "checkStatus")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub check_status: Option<models::LicenseCheckStatusType>,

    /// Причина, по которой лицензия не прошла проверку.  Параметр возвращается, только если параметр `checkStatus` имеет значение `FAIL`. 
    #[serde(rename = "checkComment")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub check_comment: Option<String>,

}


impl FullOutletLicenseDto {
    #[allow(clippy::new_without_default)]
    pub fn new() -> FullOutletLicenseDto {
        FullOutletLicenseDto {
            id: None,
            outlet_id: None,
            license_type: None,
            number: None,
            date_of_issue: None,
            date_of_expiry: None,
            check_status: None,
            check_comment: None,
        }
    }
}

/// Converts the FullOutletLicenseDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for FullOutletLicenseDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.id.as_ref().map(|id| {
                [
                    "id".to_string(),
                    id.to_string(),
                ].join(",")
            }),


            self.outlet_id.as_ref().map(|outlet_id| {
                [
                    "outletId".to_string(),
                    outlet_id.to_string(),
                ].join(",")
            }),

            // Skipping licenseType in query parameter serialization


            self.number.as_ref().map(|number| {
                [
                    "number".to_string(),
                    number.to_string(),
                ].join(",")
            }),

            // Skipping dateOfIssue in query parameter serialization

            // Skipping dateOfExpiry in query parameter serialization

            // Skipping checkStatus in query parameter serialization


            self.check_comment.as_ref().map(|check_comment| {
                [
                    "checkComment".to_string(),
                    check_comment.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a FullOutletLicenseDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for FullOutletLicenseDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<i64>,
            pub outlet_id: Vec<i64>,
            pub license_type: Vec<models::LicenseType>,
            pub number: Vec<String>,
            pub date_of_issue: Vec<chrono::DateTime::<chrono::Utc>>,
            pub date_of_expiry: Vec<chrono::DateTime::<chrono::Utc>>,
            pub check_status: Vec<models::LicenseCheckStatusType>,
            pub check_comment: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing FullOutletLicenseDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "outletId" => intermediate_rep.outlet_id.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "licenseType" => intermediate_rep.license_type.push(<models::LicenseType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "number" => intermediate_rep.number.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "dateOfIssue" => intermediate_rep.date_of_issue.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "dateOfExpiry" => intermediate_rep.date_of_expiry.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "checkStatus" => intermediate_rep.check_status.push(<models::LicenseCheckStatusType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "checkComment" => intermediate_rep.check_comment.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing FullOutletLicenseDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(FullOutletLicenseDto {
            id: intermediate_rep.id.into_iter().next(),
            outlet_id: intermediate_rep.outlet_id.into_iter().next(),
            license_type: intermediate_rep.license_type.into_iter().next(),
            number: intermediate_rep.number.into_iter().next(),
            date_of_issue: intermediate_rep.date_of_issue.into_iter().next(),
            date_of_expiry: intermediate_rep.date_of_expiry.into_iter().next(),
            check_status: intermediate_rep.check_status.into_iter().next(),
            check_comment: intermediate_rep.check_comment.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<FullOutletLicenseDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<FullOutletLicenseDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<FullOutletLicenseDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for FullOutletLicenseDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<FullOutletLicenseDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <FullOutletLicenseDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into FullOutletLicenseDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Данные, необходимые для генерации отчета. 
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GenerateBoostConsolidatedRequest {
    /// Идентификатор бизнеса.
    #[serde(rename = "businessId")]
    pub business_id: i64,

    /// Начало периода, включительно.
    #[serde(rename = "dateFrom")]
    pub date_from: chrono::naive::NaiveDate,

    /// Конец периода, включительно.
    #[serde(rename = "dateTo")]
    pub date_to: chrono::naive::NaiveDate,

}


impl GenerateBoostConsolidatedRequest {
    #[allow(clippy::new_without_default)]
    pub fn new(business_id: i64, date_from: chrono::naive::NaiveDate, date_to: chrono::naive::NaiveDate, ) -> GenerateBoostConsolidatedRequest {
        GenerateBoostConsolidatedRequest {
            business_id,
            date_from,
            date_to,
        }
    }
}

/// Converts the GenerateBoostConsolidatedRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for GenerateBoostConsolidatedRequest {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            Some("businessId".to_string()),
            Some(self.business_id.to_string()),

            // Skipping dateFrom in query parameter serialization

            // Skipping dateTo in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GenerateBoostConsolidatedRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GenerateBoostConsolidatedRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub business_id: Vec<i64>,
            pub date_from: Vec<chrono::naive::NaiveDate>,
            pub date_to: Vec<chrono::naive::NaiveDate>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing GenerateBoostConsolidatedRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "businessId" => intermediate_rep.business_id.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "dateFrom" => intermediate_rep.date_from.push(<chrono::naive::NaiveDate as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "dateTo" => intermediate_rep.date_to.push(<chrono::naive::NaiveDate as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing GenerateBoostConsolidatedRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GenerateBoostConsolidatedRequest {
            business_id: intermediate_rep.business_id.into_iter().next().ok_or_else(|| "businessId missing in GenerateBoostConsolidatedRequest".to_string())?,
            date_from: intermediate_rep.date_from.into_iter().next().ok_or_else(|| "dateFrom missing in GenerateBoostConsolidatedRequest".to_string())?,
            date_to: intermediate_rep.date_to.into_iter().next().ok_or_else(|| "dateTo missing in GenerateBoostConsolidatedRequest".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GenerateBoostConsolidatedRequest> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<GenerateBoostConsolidatedRequest>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<GenerateBoostConsolidatedRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for GenerateBoostConsolidatedRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<GenerateBoostConsolidatedRequest> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GenerateBoostConsolidatedRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GenerateBoostConsolidatedRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Данные, необходимые для генерации отчета.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GenerateCompetitorsPositionReportRequest {
    /// Идентификатор бизнеса.
    #[serde(rename = "businessId")]
    pub business_id: i64,

    /// Идентификатор категории.
    #[serde(rename = "categoryId")]
    pub category_id: i64,

    /// Начало периода, включительно.
    #[serde(rename = "dateFrom")]
    pub date_from: chrono::naive::NaiveDate,

    /// Конец периода, включительно.
    #[serde(rename = "dateTo")]
    pub date_to: chrono::naive::NaiveDate,

}


impl GenerateCompetitorsPositionReportRequest {
    #[allow(clippy::new_without_default)]
    pub fn new(business_id: i64, category_id: i64, date_from: chrono::naive::NaiveDate, date_to: chrono::naive::NaiveDate, ) -> GenerateCompetitorsPositionReportRequest {
        GenerateCompetitorsPositionReportRequest {
            business_id,
            category_id,
            date_from,
            date_to,
        }
    }
}

/// Converts the GenerateCompetitorsPositionReportRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for GenerateCompetitorsPositionReportRequest {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            Some("businessId".to_string()),
            Some(self.business_id.to_string()),


            Some("categoryId".to_string()),
            Some(self.category_id.to_string()),

            // Skipping dateFrom in query parameter serialization

            // Skipping dateTo in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GenerateCompetitorsPositionReportRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GenerateCompetitorsPositionReportRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub business_id: Vec<i64>,
            pub category_id: Vec<i64>,
            pub date_from: Vec<chrono::naive::NaiveDate>,
            pub date_to: Vec<chrono::naive::NaiveDate>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing GenerateCompetitorsPositionReportRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "businessId" => intermediate_rep.business_id.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "categoryId" => intermediate_rep.category_id.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "dateFrom" => intermediate_rep.date_from.push(<chrono::naive::NaiveDate as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "dateTo" => intermediate_rep.date_to.push(<chrono::naive::NaiveDate as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing GenerateCompetitorsPositionReportRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GenerateCompetitorsPositionReportRequest {
            business_id: intermediate_rep.business_id.into_iter().next().ok_or_else(|| "businessId missing in GenerateCompetitorsPositionReportRequest".to_string())?,
            category_id: intermediate_rep.category_id.into_iter().next().ok_or_else(|| "categoryId missing in GenerateCompetitorsPositionReportRequest".to_string())?,
            date_from: intermediate_rep.date_from.into_iter().next().ok_or_else(|| "dateFrom missing in GenerateCompetitorsPositionReportRequest".to_string())?,
            date_to: intermediate_rep.date_to.into_iter().next().ok_or_else(|| "dateTo missing in GenerateCompetitorsPositionReportRequest".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GenerateCompetitorsPositionReportRequest> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<GenerateCompetitorsPositionReportRequest>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<GenerateCompetitorsPositionReportRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for GenerateCompetitorsPositionReportRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<GenerateCompetitorsPositionReportRequest> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GenerateCompetitorsPositionReportRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GenerateCompetitorsPositionReportRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Данные, необходимые для генерации отчета. 
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GenerateGoodsFeedbackRequest {
    /// Идентификатор бизнеса.
    #[serde(rename = "businessId")]
    pub business_id: i64,

}


impl GenerateGoodsFeedbackRequest {
    #[allow(clippy::new_without_default)]
    pub fn new(business_id: i64, ) -> GenerateGoodsFeedbackRequest {
        GenerateGoodsFeedbackRequest {
            business_id,
        }
    }
}

/// Converts the GenerateGoodsFeedbackRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for GenerateGoodsFeedbackRequest {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            Some("businessId".to_string()),
            Some(self.business_id.to_string()),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GenerateGoodsFeedbackRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GenerateGoodsFeedbackRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub business_id: Vec<i64>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing GenerateGoodsFeedbackRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "businessId" => intermediate_rep.business_id.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing GenerateGoodsFeedbackRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GenerateGoodsFeedbackRequest {
            business_id: intermediate_rep.business_id.into_iter().next().ok_or_else(|| "businessId missing in GenerateGoodsFeedbackRequest".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GenerateGoodsFeedbackRequest> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<GenerateGoodsFeedbackRequest>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<GenerateGoodsFeedbackRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for GenerateGoodsFeedbackRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<GenerateGoodsFeedbackRequest> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GenerateGoodsFeedbackRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GenerateGoodsFeedbackRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Данные, необходимые для генерации отчета.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GenerateGoodsMovementReportRequest {
    /// Идентификатор кампании.
    #[serde(rename = "campaignId")]
    pub campaign_id: i64,

    /// Начало периода, включительно.
    #[serde(rename = "dateFrom")]
    pub date_from: chrono::naive::NaiveDate,

    /// Конец периода, включительно.
    #[serde(rename = "dateTo")]
    pub date_to: chrono::naive::NaiveDate,

    /// Ваш SKU — идентификатор товара в вашей системе.  Разрешена любая последовательность длиной до 255 знаков.  Правила использования SKU:  * У каждого товара SKU должен быть свой.  * SKU товара нельзя менять — можно только удалить товар и добавить заново с новым SKU.  * Уже заданный SKU нельзя освободить и использовать заново для другого товара. Каждый товар должен получать новый идентификатор, до того никогда не использовавшийся в вашем каталоге.  [Что такое SKU и как его назначать](https://yandex.ru/support/marketplace/assortment/add/index.html#fields) 
    #[serde(rename = "shopSku")]
    #[validate(
            length(min = 1, max = 255),
           regex = "RE_GENERATEGOODSMOVEMENTREPORTREQUEST_SHOP_SKU",
        )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub shop_sku: Option<String>,

}

lazy_static::lazy_static! {
    static ref RE_GENERATEGOODSMOVEMENTREPORTREQUEST_SHOP_SKU: regex::Regex = regex::Regex::new(r"^[^\\x00-\\x08\\x0A-\\x1f\\x7f]{1,255}$").unwrap();
}

impl GenerateGoodsMovementReportRequest {
    #[allow(clippy::new_without_default)]
    pub fn new(campaign_id: i64, date_from: chrono::naive::NaiveDate, date_to: chrono::naive::NaiveDate, ) -> GenerateGoodsMovementReportRequest {
        GenerateGoodsMovementReportRequest {
            campaign_id,
            date_from,
            date_to,
            shop_sku: None,
        }
    }
}

/// Converts the GenerateGoodsMovementReportRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for GenerateGoodsMovementReportRequest {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            Some("campaignId".to_string()),
            Some(self.campaign_id.to_string()),

            // Skipping dateFrom in query parameter serialization

            // Skipping dateTo in query parameter serialization


            self.shop_sku.as_ref().map(|shop_sku| {
                [
                    "shopSku".to_string(),
                    shop_sku.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GenerateGoodsMovementReportRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GenerateGoodsMovementReportRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub campaign_id: Vec<i64>,
            pub date_from: Vec<chrono::naive::NaiveDate>,
            pub date_to: Vec<chrono::naive::NaiveDate>,
            pub shop_sku: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing GenerateGoodsMovementReportRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "campaignId" => intermediate_rep.campaign_id.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "dateFrom" => intermediate_rep.date_from.push(<chrono::naive::NaiveDate as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "dateTo" => intermediate_rep.date_to.push(<chrono::naive::NaiveDate as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "shopSku" => intermediate_rep.shop_sku.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing GenerateGoodsMovementReportRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GenerateGoodsMovementReportRequest {
            campaign_id: intermediate_rep.campaign_id.into_iter().next().ok_or_else(|| "campaignId missing in GenerateGoodsMovementReportRequest".to_string())?,
            date_from: intermediate_rep.date_from.into_iter().next().ok_or_else(|| "dateFrom missing in GenerateGoodsMovementReportRequest".to_string())?,
            date_to: intermediate_rep.date_to.into_iter().next().ok_or_else(|| "dateTo missing in GenerateGoodsMovementReportRequest".to_string())?,
            shop_sku: intermediate_rep.shop_sku.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GenerateGoodsMovementReportRequest> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<GenerateGoodsMovementReportRequest>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<GenerateGoodsMovementReportRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for GenerateGoodsMovementReportRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<GenerateGoodsMovementReportRequest> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GenerateGoodsMovementReportRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GenerateGoodsMovementReportRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Данные, необходимые для генерации отчета: идентификатор магазина и период, за который нужен отчет. 
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GenerateGoodsRealizationReportRequest {
    /// Идентификатор кампании.
    #[serde(rename = "campaignId")]
    pub campaign_id: i64,

    /// Год.
    #[serde(rename = "year")]
    pub year: i32,

    /// Номер месяца.
    #[serde(rename = "month")]
    #[validate(
            range(min = 1, max = 12),
        )]
    pub month: u32,

}


impl GenerateGoodsRealizationReportRequest {
    #[allow(clippy::new_without_default)]
    pub fn new(campaign_id: i64, year: i32, month: u32, ) -> GenerateGoodsRealizationReportRequest {
        GenerateGoodsRealizationReportRequest {
            campaign_id,
            year,
            month,
        }
    }
}

/// Converts the GenerateGoodsRealizationReportRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for GenerateGoodsRealizationReportRequest {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            Some("campaignId".to_string()),
            Some(self.campaign_id.to_string()),


            Some("year".to_string()),
            Some(self.year.to_string()),


            Some("month".to_string()),
            Some(self.month.to_string()),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GenerateGoodsRealizationReportRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GenerateGoodsRealizationReportRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub campaign_id: Vec<i64>,
            pub year: Vec<i32>,
            pub month: Vec<u32>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing GenerateGoodsRealizationReportRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "campaignId" => intermediate_rep.campaign_id.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "year" => intermediate_rep.year.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "month" => intermediate_rep.month.push(<u32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing GenerateGoodsRealizationReportRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GenerateGoodsRealizationReportRequest {
            campaign_id: intermediate_rep.campaign_id.into_iter().next().ok_or_else(|| "campaignId missing in GenerateGoodsRealizationReportRequest".to_string())?,
            year: intermediate_rep.year.into_iter().next().ok_or_else(|| "year missing in GenerateGoodsRealizationReportRequest".to_string())?,
            month: intermediate_rep.month.into_iter().next().ok_or_else(|| "month missing in GenerateGoodsRealizationReportRequest".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GenerateGoodsRealizationReportRequest> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<GenerateGoodsRealizationReportRequest>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<GenerateGoodsRealizationReportRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for GenerateGoodsRealizationReportRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<GenerateGoodsRealizationReportRequest> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GenerateGoodsRealizationReportRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GenerateGoodsRealizationReportRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Данные, необходимые для генерации отчета. 
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GenerateGoodsTurnoverRequest {
    /// Идентификатор кампании.
    #[serde(rename = "campaignId")]
    pub campaign_id: i64,

    /// Дата, за которую нужно рассчитать оборачиваемость. Если параметр не указан, используется текущая дата.
    #[serde(rename = "date")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub date: Option<chrono::naive::NaiveDate>,

}


impl GenerateGoodsTurnoverRequest {
    #[allow(clippy::new_without_default)]
    pub fn new(campaign_id: i64, ) -> GenerateGoodsTurnoverRequest {
        GenerateGoodsTurnoverRequest {
            campaign_id,
            date: None,
        }
    }
}

/// Converts the GenerateGoodsTurnoverRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for GenerateGoodsTurnoverRequest {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            Some("campaignId".to_string()),
            Some(self.campaign_id.to_string()),

            // Skipping date in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GenerateGoodsTurnoverRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GenerateGoodsTurnoverRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub campaign_id: Vec<i64>,
            pub date: Vec<chrono::naive::NaiveDate>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing GenerateGoodsTurnoverRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "campaignId" => intermediate_rep.campaign_id.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "date" => intermediate_rep.date.push(<chrono::naive::NaiveDate as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing GenerateGoodsTurnoverRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GenerateGoodsTurnoverRequest {
            campaign_id: intermediate_rep.campaign_id.into_iter().next().ok_or_else(|| "campaignId missing in GenerateGoodsTurnoverRequest".to_string())?,
            date: intermediate_rep.date.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GenerateGoodsTurnoverRequest> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<GenerateGoodsTurnoverRequest>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<GenerateGoodsTurnoverRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for GenerateGoodsTurnoverRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<GenerateGoodsTurnoverRequest> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GenerateGoodsTurnoverRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GenerateGoodsTurnoverRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Данные, необходимые для генерации файла. 
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GenerateMassOrderLabelsRequest {
    /// Идентификатор кабинета.
    #[serde(rename = "businessId")]
    pub business_id: i64,

    /// Список идентификаторов заказов.
    #[serde(rename = "orderIds")]
    #[validate(
            length(min = 1, max = 1000),
        )]
    pub order_ids: Vec<i64>,

}


impl GenerateMassOrderLabelsRequest {
    #[allow(clippy::new_without_default)]
    pub fn new(business_id: i64, order_ids: Vec<i64>, ) -> GenerateMassOrderLabelsRequest {
        GenerateMassOrderLabelsRequest {
            business_id,
            order_ids,
        }
    }
}

/// Converts the GenerateMassOrderLabelsRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for GenerateMassOrderLabelsRequest {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            Some("businessId".to_string()),
            Some(self.business_id.to_string()),


            Some("orderIds".to_string()),
            Some(self.order_ids.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GenerateMassOrderLabelsRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GenerateMassOrderLabelsRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub business_id: Vec<i64>,
            pub order_ids: Vec<Vec<i64>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing GenerateMassOrderLabelsRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "businessId" => intermediate_rep.business_id.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "orderIds" => return std::result::Result::Err("Parsing a container in this style is not supported in GenerateMassOrderLabelsRequest".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing GenerateMassOrderLabelsRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GenerateMassOrderLabelsRequest {
            business_id: intermediate_rep.business_id.into_iter().next().ok_or_else(|| "businessId missing in GenerateMassOrderLabelsRequest".to_string())?,
            order_ids: intermediate_rep.order_ids.into_iter().next().ok_or_else(|| "orderIds missing in GenerateMassOrderLabelsRequest".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GenerateMassOrderLabelsRequest> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<GenerateMassOrderLabelsRequest>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<GenerateMassOrderLabelsRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for GenerateMassOrderLabelsRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<GenerateMassOrderLabelsRequest> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GenerateMassOrderLabelsRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GenerateMassOrderLabelsRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Данные, необходимые для генерации отчета.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GeneratePricesReportRequest {
    /// Идентификатор бизнеса.  В большинстве случаев обязателен. Не указывается, если задан `campaignId`. 
    #[serde(rename = "businessId")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub business_id: Option<i64>,

    /// Идентификатор кампании.  Как правило, не используется. Передавайте только если в кабинете есть магазины с уникальными ценами и вы хотите получить отчет для них. В этом случае передавать `businessId` не нужно. 
    #[serde(rename = "campaignId")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub campaign_id: Option<i64>,

    /// Фильтр по категориям на Маркете.
    #[serde(rename = "categoryIds")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub category_ids: Option<swagger::Nullable<Vec<i64>>>,

    /// Фильтр по времени появления предложения — начало периода.  Формат даты: `ДД-ММ-ГГГГ`. 
    #[serde(rename = "creationDateFrom")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub creation_date_from: Option<chrono::naive::NaiveDate>,

    /// Фильтр по времени появления предложения — окончание периода.  Формат даты: `ДД-ММ-ГГГГ`. 
    #[serde(rename = "creationDateTo")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub creation_date_to: Option<chrono::naive::NaiveDate>,

}


impl GeneratePricesReportRequest {
    #[allow(clippy::new_without_default)]
    pub fn new() -> GeneratePricesReportRequest {
        GeneratePricesReportRequest {
            business_id: None,
            campaign_id: None,
            category_ids: None,
            creation_date_from: None,
            creation_date_to: None,
        }
    }
}

/// Converts the GeneratePricesReportRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for GeneratePricesReportRequest {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.business_id.as_ref().map(|business_id| {
                [
                    "businessId".to_string(),
                    business_id.to_string(),
                ].join(",")
            }),


            self.campaign_id.as_ref().map(|campaign_id| {
                [
                    "campaignId".to_string(),
                    campaign_id.to_string(),
                ].join(",")
            }),


            self.category_ids.as_ref().map(|category_ids| {
                [
                    "categoryIds".to_string(),
                    category_ids.as_ref().map_or("null".to_string(), |x| x.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),
                ].join(",")
            }),

            // Skipping creationDateFrom in query parameter serialization

            // Skipping creationDateTo in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GeneratePricesReportRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GeneratePricesReportRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub business_id: Vec<i64>,
            pub campaign_id: Vec<i64>,
            pub category_ids: Vec<Vec<i64>>,
            pub creation_date_from: Vec<chrono::naive::NaiveDate>,
            pub creation_date_to: Vec<chrono::naive::NaiveDate>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing GeneratePricesReportRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "businessId" => intermediate_rep.business_id.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "campaignId" => intermediate_rep.campaign_id.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "categoryIds" => return std::result::Result::Err("Parsing a container in this style is not supported in GeneratePricesReportRequest".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "creationDateFrom" => intermediate_rep.creation_date_from.push(<chrono::naive::NaiveDate as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "creationDateTo" => intermediate_rep.creation_date_to.push(<chrono::naive::NaiveDate as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing GeneratePricesReportRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GeneratePricesReportRequest {
            business_id: intermediate_rep.business_id.into_iter().next(),
            campaign_id: intermediate_rep.campaign_id.into_iter().next(),
            category_ids: std::result::Result::Err("Nullable types not supported in GeneratePricesReportRequest".to_string())?,
            creation_date_from: intermediate_rep.creation_date_from.into_iter().next(),
            creation_date_to: intermediate_rep.creation_date_to.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GeneratePricesReportRequest> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<GeneratePricesReportRequest>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<GeneratePricesReportRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for GeneratePricesReportRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<GeneratePricesReportRequest> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GeneratePricesReportRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GeneratePricesReportRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Идентификатор, который понадобится для отслеживания статуса генерации и получения готового отчета.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GenerateReportDto {
    /// Идентификатор, который понадобится для отслеживания статуса генерации и получения готового отчета.
    #[serde(rename = "reportId")]
    pub report_id: String,

    /// Ожидаемая продолжительность генерации в миллисекундах.
    #[serde(rename = "estimatedGenerationTime")]
    pub estimated_generation_time: i64,

}


impl GenerateReportDto {
    #[allow(clippy::new_without_default)]
    pub fn new(report_id: String, estimated_generation_time: i64, ) -> GenerateReportDto {
        GenerateReportDto {
            report_id,
            estimated_generation_time,
        }
    }
}

/// Converts the GenerateReportDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for GenerateReportDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            Some("reportId".to_string()),
            Some(self.report_id.to_string()),


            Some("estimatedGenerationTime".to_string()),
            Some(self.estimated_generation_time.to_string()),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GenerateReportDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GenerateReportDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub report_id: Vec<String>,
            pub estimated_generation_time: Vec<i64>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing GenerateReportDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "reportId" => intermediate_rep.report_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "estimatedGenerationTime" => intermediate_rep.estimated_generation_time.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing GenerateReportDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GenerateReportDto {
            report_id: intermediate_rep.report_id.into_iter().next().ok_or_else(|| "reportId missing in GenerateReportDto".to_string())?,
            estimated_generation_time: intermediate_rep.estimated_generation_time.into_iter().next().ok_or_else(|| "estimatedGenerationTime missing in GenerateReportDto".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GenerateReportDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<GenerateReportDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<GenerateReportDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for GenerateReportDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<GenerateReportDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GenerateReportDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GenerateReportDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Ответ на запрос генерации отчета.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GenerateReportResponse {
    #[serde(rename = "status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<models::ApiResponseStatusType>,

    #[serde(rename = "result")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub result: Option<models::GenerateReportDto>,

}


impl GenerateReportResponse {
    #[allow(clippy::new_without_default)]
    pub fn new() -> GenerateReportResponse {
        GenerateReportResponse {
            status: None,
            result: None,
        }
    }
}

/// Converts the GenerateReportResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for GenerateReportResponse {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping status in query parameter serialization

            // Skipping result in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GenerateReportResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GenerateReportResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub status: Vec<models::ApiResponseStatusType>,
            pub result: Vec<models::GenerateReportDto>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing GenerateReportResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(<models::ApiResponseStatusType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "result" => intermediate_rep.result.push(<models::GenerateReportDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing GenerateReportResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GenerateReportResponse {
            status: intermediate_rep.status.into_iter().next(),
            result: intermediate_rep.result.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GenerateReportResponse> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<GenerateReportResponse>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<GenerateReportResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for GenerateReportResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<GenerateReportResponse> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GenerateReportResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GenerateReportResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Данные, необходимые для генерации отчета. 
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GenerateShelfsStatisticsRequest {
    /// Идентификатор бизнеса.
    #[serde(rename = "businessId")]
    pub business_id: i64,

    /// Начало периода, включительно.
    #[serde(rename = "dateFrom")]
    pub date_from: chrono::naive::NaiveDate,

    /// Конец периода, включительно.
    #[serde(rename = "dateTo")]
    pub date_to: chrono::naive::NaiveDate,

    #[serde(rename = "attributionType")]
    pub attribution_type: models::ShelfsStatisticsAttributionType,

}


impl GenerateShelfsStatisticsRequest {
    #[allow(clippy::new_without_default)]
    pub fn new(business_id: i64, date_from: chrono::naive::NaiveDate, date_to: chrono::naive::NaiveDate, attribution_type: models::ShelfsStatisticsAttributionType, ) -> GenerateShelfsStatisticsRequest {
        GenerateShelfsStatisticsRequest {
            business_id,
            date_from,
            date_to,
            attribution_type,
        }
    }
}

/// Converts the GenerateShelfsStatisticsRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for GenerateShelfsStatisticsRequest {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            Some("businessId".to_string()),
            Some(self.business_id.to_string()),

            // Skipping dateFrom in query parameter serialization

            // Skipping dateTo in query parameter serialization

            // Skipping attributionType in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GenerateShelfsStatisticsRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GenerateShelfsStatisticsRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub business_id: Vec<i64>,
            pub date_from: Vec<chrono::naive::NaiveDate>,
            pub date_to: Vec<chrono::naive::NaiveDate>,
            pub attribution_type: Vec<models::ShelfsStatisticsAttributionType>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing GenerateShelfsStatisticsRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "businessId" => intermediate_rep.business_id.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "dateFrom" => intermediate_rep.date_from.push(<chrono::naive::NaiveDate as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "dateTo" => intermediate_rep.date_to.push(<chrono::naive::NaiveDate as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "attributionType" => intermediate_rep.attribution_type.push(<models::ShelfsStatisticsAttributionType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing GenerateShelfsStatisticsRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GenerateShelfsStatisticsRequest {
            business_id: intermediate_rep.business_id.into_iter().next().ok_or_else(|| "businessId missing in GenerateShelfsStatisticsRequest".to_string())?,
            date_from: intermediate_rep.date_from.into_iter().next().ok_or_else(|| "dateFrom missing in GenerateShelfsStatisticsRequest".to_string())?,
            date_to: intermediate_rep.date_to.into_iter().next().ok_or_else(|| "dateTo missing in GenerateShelfsStatisticsRequest".to_string())?,
            attribution_type: intermediate_rep.attribution_type.into_iter().next().ok_or_else(|| "attributionType missing in GenerateShelfsStatisticsRequest".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GenerateShelfsStatisticsRequest> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<GenerateShelfsStatisticsRequest>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<GenerateShelfsStatisticsRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for GenerateShelfsStatisticsRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<GenerateShelfsStatisticsRequest> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GenerateShelfsStatisticsRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GenerateShelfsStatisticsRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Данные, необходимые для генерации документа. 
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GenerateShipmentListDocumentReportRequest {
    /// Идентификатор кампании.
    #[serde(rename = "campaignId")]
    pub campaign_id: i64,

    /// Идентификатор отгрузки.
    #[serde(rename = "shipmentId")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub shipment_id: Option<i64>,

    /// Фильтр по идентификаторам заказа в отгрузке.
    #[serde(rename = "orderIds")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub order_ids: Option<swagger::Nullable<Vec<i64>>>,

}


impl GenerateShipmentListDocumentReportRequest {
    #[allow(clippy::new_without_default)]
    pub fn new(campaign_id: i64, ) -> GenerateShipmentListDocumentReportRequest {
        GenerateShipmentListDocumentReportRequest {
            campaign_id,
            shipment_id: None,
            order_ids: None,
        }
    }
}

/// Converts the GenerateShipmentListDocumentReportRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for GenerateShipmentListDocumentReportRequest {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            Some("campaignId".to_string()),
            Some(self.campaign_id.to_string()),


            self.shipment_id.as_ref().map(|shipment_id| {
                [
                    "shipmentId".to_string(),
                    shipment_id.to_string(),
                ].join(",")
            }),


            self.order_ids.as_ref().map(|order_ids| {
                [
                    "orderIds".to_string(),
                    order_ids.as_ref().map_or("null".to_string(), |x| x.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GenerateShipmentListDocumentReportRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GenerateShipmentListDocumentReportRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub campaign_id: Vec<i64>,
            pub shipment_id: Vec<i64>,
            pub order_ids: Vec<Vec<i64>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing GenerateShipmentListDocumentReportRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "campaignId" => intermediate_rep.campaign_id.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "shipmentId" => intermediate_rep.shipment_id.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "orderIds" => return std::result::Result::Err("Parsing a container in this style is not supported in GenerateShipmentListDocumentReportRequest".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing GenerateShipmentListDocumentReportRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GenerateShipmentListDocumentReportRequest {
            campaign_id: intermediate_rep.campaign_id.into_iter().next().ok_or_else(|| "campaignId missing in GenerateShipmentListDocumentReportRequest".to_string())?,
            shipment_id: intermediate_rep.shipment_id.into_iter().next(),
            order_ids: std::result::Result::Err("Nullable types not supported in GenerateShipmentListDocumentReportRequest".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GenerateShipmentListDocumentReportRequest> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<GenerateShipmentListDocumentReportRequest>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<GenerateShipmentListDocumentReportRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for GenerateShipmentListDocumentReportRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<GenerateShipmentListDocumentReportRequest> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GenerateShipmentListDocumentReportRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GenerateShipmentListDocumentReportRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Данные, необходимые для генерации отчета.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GenerateShowsSalesReportRequest {
    /// Идентификатор бизнеса.  Указывается, если нужно составить отчет по всем магазинам бизнеса. В запросе обязательно должен быть либо `businessID`, либо `campaignId`, но не оба сразу. 
    #[serde(rename = "businessId")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub business_id: Option<i64>,

    /// Идентификатор кампании.  Указывается, если нужно составить отчет по конкретному магазину. В запросе обязательно должен быть либо `businessID`, либо `campaignId`, но не оба сразу. 
    #[serde(rename = "campaignId")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub campaign_id: Option<i64>,

    /// Начало периода, включительно.
    #[serde(rename = "dateFrom")]
    pub date_from: chrono::naive::NaiveDate,

    /// Конец периода, включительно.
    #[serde(rename = "dateTo")]
    pub date_to: chrono::naive::NaiveDate,

    #[serde(rename = "grouping")]
    pub grouping: models::ShowsSalesGroupingType,

}


impl GenerateShowsSalesReportRequest {
    #[allow(clippy::new_without_default)]
    pub fn new(date_from: chrono::naive::NaiveDate, date_to: chrono::naive::NaiveDate, grouping: models::ShowsSalesGroupingType, ) -> GenerateShowsSalesReportRequest {
        GenerateShowsSalesReportRequest {
            business_id: None,
            campaign_id: None,
            date_from,
            date_to,
            grouping,
        }
    }
}

/// Converts the GenerateShowsSalesReportRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for GenerateShowsSalesReportRequest {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.business_id.as_ref().map(|business_id| {
                [
                    "businessId".to_string(),
                    business_id.to_string(),
                ].join(",")
            }),


            self.campaign_id.as_ref().map(|campaign_id| {
                [
                    "campaignId".to_string(),
                    campaign_id.to_string(),
                ].join(",")
            }),

            // Skipping dateFrom in query parameter serialization

            // Skipping dateTo in query parameter serialization

            // Skipping grouping in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GenerateShowsSalesReportRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GenerateShowsSalesReportRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub business_id: Vec<i64>,
            pub campaign_id: Vec<i64>,
            pub date_from: Vec<chrono::naive::NaiveDate>,
            pub date_to: Vec<chrono::naive::NaiveDate>,
            pub grouping: Vec<models::ShowsSalesGroupingType>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing GenerateShowsSalesReportRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "businessId" => intermediate_rep.business_id.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "campaignId" => intermediate_rep.campaign_id.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "dateFrom" => intermediate_rep.date_from.push(<chrono::naive::NaiveDate as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "dateTo" => intermediate_rep.date_to.push(<chrono::naive::NaiveDate as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "grouping" => intermediate_rep.grouping.push(<models::ShowsSalesGroupingType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing GenerateShowsSalesReportRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GenerateShowsSalesReportRequest {
            business_id: intermediate_rep.business_id.into_iter().next(),
            campaign_id: intermediate_rep.campaign_id.into_iter().next(),
            date_from: intermediate_rep.date_from.into_iter().next().ok_or_else(|| "dateFrom missing in GenerateShowsSalesReportRequest".to_string())?,
            date_to: intermediate_rep.date_to.into_iter().next().ok_or_else(|| "dateTo missing in GenerateShowsSalesReportRequest".to_string())?,
            grouping: intermediate_rep.grouping.into_iter().next().ok_or_else(|| "grouping missing in GenerateShowsSalesReportRequest".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GenerateShowsSalesReportRequest> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<GenerateShowsSalesReportRequest>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<GenerateShowsSalesReportRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for GenerateShowsSalesReportRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<GenerateShowsSalesReportRequest> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GenerateShowsSalesReportRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GenerateShowsSalesReportRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Данные, необходимые для генерации отчета. 
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GenerateStocksOnWarehousesReportRequest {
    /// Идентификатор магазина.
    #[serde(rename = "campaignId")]
    pub campaign_id: i64,

    /// Фильтр по идентификаторам складов (только модель FBY). Чтобы узнать идентификатор, воспользуйтесь запросом [GET warehouses](../../reference/warehouses/getFulfillmentWarehouses.md).
    #[serde(rename = "warehouseIds")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub warehouse_ids: Option<swagger::Nullable<Vec<i64>>>,

    /// Фильтр по дате (для модели FBY). В отчет попадут данные за **предшествующий** дате день.
    #[serde(rename = "reportDate")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub report_date: Option<chrono::naive::NaiveDate>,

    /// Фильтр по категориям на Маркете (кроме модели FBY).
    #[serde(rename = "categoryIds")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub category_ids: Option<swagger::Nullable<Vec<i64>>>,

    /// Фильтр по наличию остатков (кроме модели FBY).
    #[serde(rename = "hasStocks")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub has_stocks: Option<bool>,

}


impl GenerateStocksOnWarehousesReportRequest {
    #[allow(clippy::new_without_default)]
    pub fn new(campaign_id: i64, ) -> GenerateStocksOnWarehousesReportRequest {
        GenerateStocksOnWarehousesReportRequest {
            campaign_id,
            warehouse_ids: None,
            report_date: None,
            category_ids: None,
            has_stocks: None,
        }
    }
}

/// Converts the GenerateStocksOnWarehousesReportRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for GenerateStocksOnWarehousesReportRequest {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            Some("campaignId".to_string()),
            Some(self.campaign_id.to_string()),


            self.warehouse_ids.as_ref().map(|warehouse_ids| {
                [
                    "warehouseIds".to_string(),
                    warehouse_ids.as_ref().map_or("null".to_string(), |x| x.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),
                ].join(",")
            }),

            // Skipping reportDate in query parameter serialization


            self.category_ids.as_ref().map(|category_ids| {
                [
                    "categoryIds".to_string(),
                    category_ids.as_ref().map_or("null".to_string(), |x| x.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),
                ].join(",")
            }),


            self.has_stocks.as_ref().map(|has_stocks| {
                [
                    "hasStocks".to_string(),
                    has_stocks.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GenerateStocksOnWarehousesReportRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GenerateStocksOnWarehousesReportRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub campaign_id: Vec<i64>,
            pub warehouse_ids: Vec<Vec<i64>>,
            pub report_date: Vec<chrono::naive::NaiveDate>,
            pub category_ids: Vec<Vec<i64>>,
            pub has_stocks: Vec<bool>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing GenerateStocksOnWarehousesReportRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "campaignId" => intermediate_rep.campaign_id.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "warehouseIds" => return std::result::Result::Err("Parsing a container in this style is not supported in GenerateStocksOnWarehousesReportRequest".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "reportDate" => intermediate_rep.report_date.push(<chrono::naive::NaiveDate as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "categoryIds" => return std::result::Result::Err("Parsing a container in this style is not supported in GenerateStocksOnWarehousesReportRequest".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "hasStocks" => intermediate_rep.has_stocks.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing GenerateStocksOnWarehousesReportRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GenerateStocksOnWarehousesReportRequest {
            campaign_id: intermediate_rep.campaign_id.into_iter().next().ok_or_else(|| "campaignId missing in GenerateStocksOnWarehousesReportRequest".to_string())?,
            warehouse_ids: std::result::Result::Err("Nullable types not supported in GenerateStocksOnWarehousesReportRequest".to_string())?,
            report_date: intermediate_rep.report_date.into_iter().next(),
            category_ids: std::result::Result::Err("Nullable types not supported in GenerateStocksOnWarehousesReportRequest".to_string())?,
            has_stocks: intermediate_rep.has_stocks.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GenerateStocksOnWarehousesReportRequest> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<GenerateStocksOnWarehousesReportRequest>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<GenerateStocksOnWarehousesReportRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for GenerateStocksOnWarehousesReportRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<GenerateStocksOnWarehousesReportRequest> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GenerateStocksOnWarehousesReportRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GenerateStocksOnWarehousesReportRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Данные, необходимые для генерации отчета: идентификатор магазина, период, за который нужен отчет, а также фильтры. 
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GenerateUnitedMarketplaceServicesReportRequest {
    /// Идентификатор бизнеса.
    #[serde(rename = "businessId")]
    pub business_id: i64,

    /// {% note warning \"\" %}  Этот параметр устарел. Не используйте его.  {% endnote %}  Начало периода, включительно. 
    #[serde(rename = "dateTimeFrom")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub date_time_from: Option<chrono::DateTime::<chrono::Utc>>,

    /// {% note warning \"\" %}  Этот параметр устарел. Не используйте его.  {% endnote %}  Конец периода, включительно. Максимальный период — 1 год. 
    #[serde(rename = "dateTimeTo")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub date_time_to: Option<chrono::DateTime::<chrono::Utc>>,

    /// Начало периода, включительно.
    #[serde(rename = "dateFrom")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub date_from: Option<chrono::naive::NaiveDate>,

    /// Конец периода, включительно. Максимальный период — 1 год.
    #[serde(rename = "dateTo")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub date_to: Option<chrono::naive::NaiveDate>,

    /// Начальный год формирования акта.
    #[serde(rename = "yearFrom")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub year_from: Option<i32>,

    /// Начальный номер месяца формирования акта.
    #[serde(rename = "monthFrom")]
    #[validate(
            range(min = 1, max = 12),
        )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub month_from: Option<u32>,

    /// Конечный год формирования акта.
    #[serde(rename = "yearTo")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub year_to: Option<i32>,

    /// Конечный номер месяца формирования акта.
    #[serde(rename = "monthTo")]
    #[validate(
            range(min = 1, max = 12),
        )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub month_to: Option<u32>,

    /// Список моделей, которые нужны в отчете. 
    #[serde(rename = "placementPrograms")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub placement_programs: Option<swagger::Nullable<Vec<models::PlacementType>>>,

    /// Список ИНН, которые нужны в отчете.
    #[serde(rename = "inns")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub inns: Option<swagger::Nullable<Vec<String>>>,

    /// Список магазинов, которые нужны в отчете.
    #[serde(rename = "campaignIds")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub campaign_ids: Option<swagger::Nullable<Vec<i64>>>,

}


impl GenerateUnitedMarketplaceServicesReportRequest {
    #[allow(clippy::new_without_default)]
    pub fn new(business_id: i64, ) -> GenerateUnitedMarketplaceServicesReportRequest {
        GenerateUnitedMarketplaceServicesReportRequest {
            business_id,
            date_time_from: None,
            date_time_to: None,
            date_from: None,
            date_to: None,
            year_from: None,
            month_from: None,
            year_to: None,
            month_to: None,
            placement_programs: None,
            inns: None,
            campaign_ids: None,
        }
    }
}

/// Converts the GenerateUnitedMarketplaceServicesReportRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for GenerateUnitedMarketplaceServicesReportRequest {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            Some("businessId".to_string()),
            Some(self.business_id.to_string()),

            // Skipping dateTimeFrom in query parameter serialization

            // Skipping dateTimeTo in query parameter serialization

            // Skipping dateFrom in query parameter serialization

            // Skipping dateTo in query parameter serialization


            self.year_from.as_ref().map(|year_from| {
                [
                    "yearFrom".to_string(),
                    year_from.to_string(),
                ].join(",")
            }),


            self.month_from.as_ref().map(|month_from| {
                [
                    "monthFrom".to_string(),
                    month_from.to_string(),
                ].join(",")
            }),


            self.year_to.as_ref().map(|year_to| {
                [
                    "yearTo".to_string(),
                    year_to.to_string(),
                ].join(",")
            }),


            self.month_to.as_ref().map(|month_to| {
                [
                    "monthTo".to_string(),
                    month_to.to_string(),
                ].join(",")
            }),

            // Skipping placementPrograms in query parameter serialization


            self.inns.as_ref().map(|inns| {
                [
                    "inns".to_string(),
                    inns.as_ref().map_or("null".to_string(), |x| x.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),
                ].join(",")
            }),


            self.campaign_ids.as_ref().map(|campaign_ids| {
                [
                    "campaignIds".to_string(),
                    campaign_ids.as_ref().map_or("null".to_string(), |x| x.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GenerateUnitedMarketplaceServicesReportRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GenerateUnitedMarketplaceServicesReportRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub business_id: Vec<i64>,
            pub date_time_from: Vec<chrono::DateTime::<chrono::Utc>>,
            pub date_time_to: Vec<chrono::DateTime::<chrono::Utc>>,
            pub date_from: Vec<chrono::naive::NaiveDate>,
            pub date_to: Vec<chrono::naive::NaiveDate>,
            pub year_from: Vec<i32>,
            pub month_from: Vec<u32>,
            pub year_to: Vec<i32>,
            pub month_to: Vec<u32>,
            pub placement_programs: Vec<Vec<models::PlacementType>>,
            pub inns: Vec<Vec<String>>,
            pub campaign_ids: Vec<Vec<i64>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing GenerateUnitedMarketplaceServicesReportRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "businessId" => intermediate_rep.business_id.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "dateTimeFrom" => intermediate_rep.date_time_from.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "dateTimeTo" => intermediate_rep.date_time_to.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "dateFrom" => intermediate_rep.date_from.push(<chrono::naive::NaiveDate as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "dateTo" => intermediate_rep.date_to.push(<chrono::naive::NaiveDate as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "yearFrom" => intermediate_rep.year_from.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "monthFrom" => intermediate_rep.month_from.push(<u32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "yearTo" => intermediate_rep.year_to.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "monthTo" => intermediate_rep.month_to.push(<u32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "placementPrograms" => return std::result::Result::Err("Parsing a container in this style is not supported in GenerateUnitedMarketplaceServicesReportRequest".to_string()),
                    "inns" => return std::result::Result::Err("Parsing a container in this style is not supported in GenerateUnitedMarketplaceServicesReportRequest".to_string()),
                    "campaignIds" => return std::result::Result::Err("Parsing a container in this style is not supported in GenerateUnitedMarketplaceServicesReportRequest".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing GenerateUnitedMarketplaceServicesReportRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GenerateUnitedMarketplaceServicesReportRequest {
            business_id: intermediate_rep.business_id.into_iter().next().ok_or_else(|| "businessId missing in GenerateUnitedMarketplaceServicesReportRequest".to_string())?,
            date_time_from: intermediate_rep.date_time_from.into_iter().next(),
            date_time_to: intermediate_rep.date_time_to.into_iter().next(),
            date_from: intermediate_rep.date_from.into_iter().next(),
            date_to: intermediate_rep.date_to.into_iter().next(),
            year_from: intermediate_rep.year_from.into_iter().next(),
            month_from: intermediate_rep.month_from.into_iter().next(),
            year_to: intermediate_rep.year_to.into_iter().next(),
            month_to: intermediate_rep.month_to.into_iter().next(),
            placement_programs: std::result::Result::Err("Nullable types not supported in GenerateUnitedMarketplaceServicesReportRequest".to_string())?,
            inns: std::result::Result::Err("Nullable types not supported in GenerateUnitedMarketplaceServicesReportRequest".to_string())?,
            campaign_ids: std::result::Result::Err("Nullable types not supported in GenerateUnitedMarketplaceServicesReportRequest".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GenerateUnitedMarketplaceServicesReportRequest> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<GenerateUnitedMarketplaceServicesReportRequest>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<GenerateUnitedMarketplaceServicesReportRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for GenerateUnitedMarketplaceServicesReportRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<GenerateUnitedMarketplaceServicesReportRequest> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GenerateUnitedMarketplaceServicesReportRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GenerateUnitedMarketplaceServicesReportRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Данные, необходимые для генерации отчета: идентификатор магазина, период, за который нужен отчет, а также фильтры. 
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GenerateUnitedNettingReportRequest {
    /// Идентификатор бизнеса.
    #[serde(rename = "businessId")]
    pub business_id: i64,

    /// {% note warning \"\" %}  Этот параметр устарел. Не используйте его.  {% endnote %}  Начало периода, включительно. 
    #[serde(rename = "dateTimeFrom")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub date_time_from: Option<chrono::DateTime::<chrono::Utc>>,

    /// {% note warning \"\" %}  Этот параметр устарел. Не используйте его.  {% endnote %}  Конец периода, включительно. Максимальный период — 1 год. 
    #[serde(rename = "dateTimeTo")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub date_time_to: Option<chrono::DateTime::<chrono::Utc>>,

    /// Начало периода, включительно.
    #[serde(rename = "dateFrom")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub date_from: Option<chrono::naive::NaiveDate>,

    /// Конец периода, включительно. Максимальный период — 1 год.
    #[serde(rename = "dateTo")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub date_to: Option<chrono::naive::NaiveDate>,

    /// Номер платежного поручения.
    #[serde(rename = "bankOrderId")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub bank_order_id: Option<i64>,

    /// Дата платежного поручения.
    #[serde(rename = "bankOrderDateTime")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub bank_order_date_time: Option<chrono::DateTime::<chrono::Utc>>,

    /// Список моделей, которые нужны в отчете. 
    #[serde(rename = "placementPrograms")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub placement_programs: Option<swagger::Nullable<Vec<models::PlacementType>>>,

    /// Список ИНН, которые нужны в отчете.
    #[serde(rename = "inns")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub inns: Option<swagger::Nullable<Vec<String>>>,

    /// Список магазинов, которые нужны в отчете.
    #[serde(rename = "campaignIds")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub campaign_ids: Option<swagger::Nullable<Vec<i64>>>,

}


impl GenerateUnitedNettingReportRequest {
    #[allow(clippy::new_without_default)]
    pub fn new(business_id: i64, ) -> GenerateUnitedNettingReportRequest {
        GenerateUnitedNettingReportRequest {
            business_id,
            date_time_from: None,
            date_time_to: None,
            date_from: None,
            date_to: None,
            bank_order_id: None,
            bank_order_date_time: None,
            placement_programs: None,
            inns: None,
            campaign_ids: None,
        }
    }
}

/// Converts the GenerateUnitedNettingReportRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for GenerateUnitedNettingReportRequest {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            Some("businessId".to_string()),
            Some(self.business_id.to_string()),

            // Skipping dateTimeFrom in query parameter serialization

            // Skipping dateTimeTo in query parameter serialization

            // Skipping dateFrom in query parameter serialization

            // Skipping dateTo in query parameter serialization


            self.bank_order_id.as_ref().map(|bank_order_id| {
                [
                    "bankOrderId".to_string(),
                    bank_order_id.to_string(),
                ].join(",")
            }),

            // Skipping bankOrderDateTime in query parameter serialization

            // Skipping placementPrograms in query parameter serialization


            self.inns.as_ref().map(|inns| {
                [
                    "inns".to_string(),
                    inns.as_ref().map_or("null".to_string(), |x| x.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),
                ].join(",")
            }),


            self.campaign_ids.as_ref().map(|campaign_ids| {
                [
                    "campaignIds".to_string(),
                    campaign_ids.as_ref().map_or("null".to_string(), |x| x.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GenerateUnitedNettingReportRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GenerateUnitedNettingReportRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub business_id: Vec<i64>,
            pub date_time_from: Vec<chrono::DateTime::<chrono::Utc>>,
            pub date_time_to: Vec<chrono::DateTime::<chrono::Utc>>,
            pub date_from: Vec<chrono::naive::NaiveDate>,
            pub date_to: Vec<chrono::naive::NaiveDate>,
            pub bank_order_id: Vec<i64>,
            pub bank_order_date_time: Vec<chrono::DateTime::<chrono::Utc>>,
            pub placement_programs: Vec<Vec<models::PlacementType>>,
            pub inns: Vec<Vec<String>>,
            pub campaign_ids: Vec<Vec<i64>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing GenerateUnitedNettingReportRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "businessId" => intermediate_rep.business_id.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "dateTimeFrom" => intermediate_rep.date_time_from.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "dateTimeTo" => intermediate_rep.date_time_to.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "dateFrom" => intermediate_rep.date_from.push(<chrono::naive::NaiveDate as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "dateTo" => intermediate_rep.date_to.push(<chrono::naive::NaiveDate as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "bankOrderId" => intermediate_rep.bank_order_id.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "bankOrderDateTime" => intermediate_rep.bank_order_date_time.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "placementPrograms" => return std::result::Result::Err("Parsing a container in this style is not supported in GenerateUnitedNettingReportRequest".to_string()),
                    "inns" => return std::result::Result::Err("Parsing a container in this style is not supported in GenerateUnitedNettingReportRequest".to_string()),
                    "campaignIds" => return std::result::Result::Err("Parsing a container in this style is not supported in GenerateUnitedNettingReportRequest".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing GenerateUnitedNettingReportRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GenerateUnitedNettingReportRequest {
            business_id: intermediate_rep.business_id.into_iter().next().ok_or_else(|| "businessId missing in GenerateUnitedNettingReportRequest".to_string())?,
            date_time_from: intermediate_rep.date_time_from.into_iter().next(),
            date_time_to: intermediate_rep.date_time_to.into_iter().next(),
            date_from: intermediate_rep.date_from.into_iter().next(),
            date_to: intermediate_rep.date_to.into_iter().next(),
            bank_order_id: intermediate_rep.bank_order_id.into_iter().next(),
            bank_order_date_time: intermediate_rep.bank_order_date_time.into_iter().next(),
            placement_programs: std::result::Result::Err("Nullable types not supported in GenerateUnitedNettingReportRequest".to_string())?,
            inns: std::result::Result::Err("Nullable types not supported in GenerateUnitedNettingReportRequest".to_string())?,
            campaign_ids: std::result::Result::Err("Nullable types not supported in GenerateUnitedNettingReportRequest".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GenerateUnitedNettingReportRequest> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<GenerateUnitedNettingReportRequest>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<GenerateUnitedNettingReportRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for GenerateUnitedNettingReportRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<GenerateUnitedNettingReportRequest> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GenerateUnitedNettingReportRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GenerateUnitedNettingReportRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Данные, необходимые для генерации отчета. 
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GenerateUnitedOrdersRequest {
    /// Идентификатор бизнеса.
    #[serde(rename = "businessId")]
    pub business_id: i64,

    /// Начало периода, включительно.
    #[serde(rename = "dateFrom")]
    pub date_from: chrono::naive::NaiveDate,

    /// Конец периода, включительно. Максимальный период — 1 год.
    #[serde(rename = "dateTo")]
    pub date_to: chrono::naive::NaiveDate,

    /// Список магазинов, которые нужны в отчете.
    #[serde(rename = "campaignIds")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub campaign_ids: Option<swagger::Nullable<Vec<i64>>>,

    /// Идентификатор акции, товары из которой нужны в отчете.
    #[serde(rename = "promoId")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub promo_id: Option<String>,

}


impl GenerateUnitedOrdersRequest {
    #[allow(clippy::new_without_default)]
    pub fn new(business_id: i64, date_from: chrono::naive::NaiveDate, date_to: chrono::naive::NaiveDate, ) -> GenerateUnitedOrdersRequest {
        GenerateUnitedOrdersRequest {
            business_id,
            date_from,
            date_to,
            campaign_ids: None,
            promo_id: None,
        }
    }
}

/// Converts the GenerateUnitedOrdersRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for GenerateUnitedOrdersRequest {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            Some("businessId".to_string()),
            Some(self.business_id.to_string()),

            // Skipping dateFrom in query parameter serialization

            // Skipping dateTo in query parameter serialization


            self.campaign_ids.as_ref().map(|campaign_ids| {
                [
                    "campaignIds".to_string(),
                    campaign_ids.as_ref().map_or("null".to_string(), |x| x.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),
                ].join(",")
            }),


            self.promo_id.as_ref().map(|promo_id| {
                [
                    "promoId".to_string(),
                    promo_id.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GenerateUnitedOrdersRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GenerateUnitedOrdersRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub business_id: Vec<i64>,
            pub date_from: Vec<chrono::naive::NaiveDate>,
            pub date_to: Vec<chrono::naive::NaiveDate>,
            pub campaign_ids: Vec<Vec<i64>>,
            pub promo_id: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing GenerateUnitedOrdersRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "businessId" => intermediate_rep.business_id.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "dateFrom" => intermediate_rep.date_from.push(<chrono::naive::NaiveDate as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "dateTo" => intermediate_rep.date_to.push(<chrono::naive::NaiveDate as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "campaignIds" => return std::result::Result::Err("Parsing a container in this style is not supported in GenerateUnitedOrdersRequest".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "promoId" => intermediate_rep.promo_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing GenerateUnitedOrdersRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GenerateUnitedOrdersRequest {
            business_id: intermediate_rep.business_id.into_iter().next().ok_or_else(|| "businessId missing in GenerateUnitedOrdersRequest".to_string())?,
            date_from: intermediate_rep.date_from.into_iter().next().ok_or_else(|| "dateFrom missing in GenerateUnitedOrdersRequest".to_string())?,
            date_to: intermediate_rep.date_to.into_iter().next().ok_or_else(|| "dateTo missing in GenerateUnitedOrdersRequest".to_string())?,
            campaign_ids: std::result::Result::Err("Nullable types not supported in GenerateUnitedOrdersRequest".to_string())?,
            promo_id: intermediate_rep.promo_id.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GenerateUnitedOrdersRequest> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<GenerateUnitedOrdersRequest>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<GenerateUnitedOrdersRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for GenerateUnitedOrdersRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<GenerateUnitedOrdersRequest> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GenerateUnitedOrdersRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GenerateUnitedOrdersRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Список предложений.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetAllOffersResponse {
    /// Список предложений магазина.
    #[serde(rename = "offers")]
    pub offers: Vec<models::OfferDto>,

}


impl GetAllOffersResponse {
    #[allow(clippy::new_without_default)]
    pub fn new(offers: Vec<models::OfferDto>, ) -> GetAllOffersResponse {
        GetAllOffersResponse {
            offers,
        }
    }
}

/// Converts the GetAllOffersResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for GetAllOffersResponse {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping offers in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetAllOffersResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetAllOffersResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub offers: Vec<Vec<models::OfferDto>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing GetAllOffersResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "offers" => return std::result::Result::Err("Parsing a container in this style is not supported in GetAllOffersResponse".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing GetAllOffersResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetAllOffersResponse {
            offers: intermediate_rep.offers.into_iter().next().ok_or_else(|| "offers missing in GetAllOffersResponse".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetAllOffersResponse> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<GetAllOffersResponse>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<GetAllOffersResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for GetAllOffersResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<GetAllOffersResponse> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GetAllOffersResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GetAllOffersResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// description.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetBidsInfoRequest {
    /// Список товаров, для которых нужно получить значения ставок.  Если список не задан, постранично возвращаются все товары со ставками.  Если список задан, результаты возвращаются одной страницей, а параметры `page_token` и `limit` игнорируются. 
    #[serde(rename = "skus")]
    #[validate(
            length(min = 1, max = 1500),
        )]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub skus: Option<swagger::Nullable<Vec<models::ShopSku>>>,

}


impl GetBidsInfoRequest {
    #[allow(clippy::new_without_default)]
    pub fn new() -> GetBidsInfoRequest {
        GetBidsInfoRequest {
            skus: None,
        }
    }
}

/// Converts the GetBidsInfoRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for GetBidsInfoRequest {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.skus.as_ref().map(|skus| {
                [
                    "skus".to_string(),
                    skus.as_ref().map_or("null".to_string(), |x| x.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetBidsInfoRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetBidsInfoRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub skus: Vec<Vec<models::ShopSku>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing GetBidsInfoRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "skus" => return std::result::Result::Err("Parsing a container in this style is not supported in GetBidsInfoRequest".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing GetBidsInfoRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetBidsInfoRequest {
            skus: std::result::Result::Err("Nullable types not supported in GetBidsInfoRequest".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetBidsInfoRequest> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<GetBidsInfoRequest>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<GetBidsInfoRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for GetBidsInfoRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<GetBidsInfoRequest> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GetBidsInfoRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GetBidsInfoRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// description.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetBidsInfoResponse {
    #[serde(rename = "status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<models::ApiResponseStatusType>,

    #[serde(rename = "result")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub result: Option<models::GetBidsInfoResponseDto>,

}


impl GetBidsInfoResponse {
    #[allow(clippy::new_without_default)]
    pub fn new() -> GetBidsInfoResponse {
        GetBidsInfoResponse {
            status: None,
            result: None,
        }
    }
}

/// Converts the GetBidsInfoResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for GetBidsInfoResponse {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping status in query parameter serialization

            // Skipping result in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetBidsInfoResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetBidsInfoResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub status: Vec<models::ApiResponseStatusType>,
            pub result: Vec<models::GetBidsInfoResponseDto>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing GetBidsInfoResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(<models::ApiResponseStatusType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "result" => intermediate_rep.result.push(<models::GetBidsInfoResponseDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing GetBidsInfoResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetBidsInfoResponse {
            status: intermediate_rep.status.into_iter().next(),
            result: intermediate_rep.result.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetBidsInfoResponse> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<GetBidsInfoResponse>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<GetBidsInfoResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for GetBidsInfoResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<GetBidsInfoResponse> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GetBidsInfoResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GetBidsInfoResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Список товаров с указанными ставками.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetBidsInfoResponseDto {
    /// Страница списка товаров.
    #[serde(rename = "bids")]
    pub bids: Vec<models::SkuBidItemDto>,

    #[serde(rename = "paging")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub paging: Option<models::ForwardScrollingPagerDto>,

}


impl GetBidsInfoResponseDto {
    #[allow(clippy::new_without_default)]
    pub fn new(bids: Vec<models::SkuBidItemDto>, ) -> GetBidsInfoResponseDto {
        GetBidsInfoResponseDto {
            bids,
            paging: None,
        }
    }
}

/// Converts the GetBidsInfoResponseDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for GetBidsInfoResponseDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping bids in query parameter serialization

            // Skipping paging in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetBidsInfoResponseDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetBidsInfoResponseDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub bids: Vec<Vec<models::SkuBidItemDto>>,
            pub paging: Vec<models::ForwardScrollingPagerDto>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing GetBidsInfoResponseDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "bids" => return std::result::Result::Err("Parsing a container in this style is not supported in GetBidsInfoResponseDto".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "paging" => intermediate_rep.paging.push(<models::ForwardScrollingPagerDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing GetBidsInfoResponseDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetBidsInfoResponseDto {
            bids: intermediate_rep.bids.into_iter().next().ok_or_else(|| "bids missing in GetBidsInfoResponseDto".to_string())?,
            paging: intermediate_rep.paging.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetBidsInfoResponseDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<GetBidsInfoResponseDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<GetBidsInfoResponseDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for GetBidsInfoResponseDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<GetBidsInfoResponseDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GetBidsInfoResponseDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GetBidsInfoResponseDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// description.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetBidsRecommendationsRequest {
    /// Список товаров, для которых нужно получить рекомендации по ставкам. 
    #[serde(rename = "skus")]
    #[validate(
            length(min = 1, max = 1500),
        )]
    pub skus: Vec<models::ShopSku>,

}


impl GetBidsRecommendationsRequest {
    #[allow(clippy::new_without_default)]
    pub fn new(skus: Vec<models::ShopSku>, ) -> GetBidsRecommendationsRequest {
        GetBidsRecommendationsRequest {
            skus,
        }
    }
}

/// Converts the GetBidsRecommendationsRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for GetBidsRecommendationsRequest {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            Some("skus".to_string()),
            Some(self.skus.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetBidsRecommendationsRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetBidsRecommendationsRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub skus: Vec<Vec<models::ShopSku>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing GetBidsRecommendationsRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "skus" => return std::result::Result::Err("Parsing a container in this style is not supported in GetBidsRecommendationsRequest".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing GetBidsRecommendationsRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetBidsRecommendationsRequest {
            skus: intermediate_rep.skus.into_iter().next().ok_or_else(|| "skus missing in GetBidsRecommendationsRequest".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetBidsRecommendationsRequest> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<GetBidsRecommendationsRequest>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<GetBidsRecommendationsRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for GetBidsRecommendationsRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<GetBidsRecommendationsRequest> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GetBidsRecommendationsRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GetBidsRecommendationsRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// description.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetBidsRecommendationsResponse {
    #[serde(rename = "status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<models::ApiResponseStatusType>,

    #[serde(rename = "result")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub result: Option<models::GetBidsRecommendationsResponseDto>,

}


impl GetBidsRecommendationsResponse {
    #[allow(clippy::new_without_default)]
    pub fn new() -> GetBidsRecommendationsResponse {
        GetBidsRecommendationsResponse {
            status: None,
            result: None,
        }
    }
}

/// Converts the GetBidsRecommendationsResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for GetBidsRecommendationsResponse {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping status in query parameter serialization

            // Skipping result in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetBidsRecommendationsResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetBidsRecommendationsResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub status: Vec<models::ApiResponseStatusType>,
            pub result: Vec<models::GetBidsRecommendationsResponseDto>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing GetBidsRecommendationsResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(<models::ApiResponseStatusType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "result" => intermediate_rep.result.push(<models::GetBidsRecommendationsResponseDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing GetBidsRecommendationsResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetBidsRecommendationsResponse {
            status: intermediate_rep.status.into_iter().next(),
            result: intermediate_rep.result.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetBidsRecommendationsResponse> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<GetBidsRecommendationsResponse>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<GetBidsRecommendationsResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for GetBidsRecommendationsResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<GetBidsRecommendationsResponse> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GetBidsRecommendationsResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GetBidsRecommendationsResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Список товаров с рекомендованными ставками.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetBidsRecommendationsResponseDto {
    /// Список товаров с рекомендованными ставками.
    #[serde(rename = "recommendations")]
    pub recommendations: Vec<models::SkuBidRecommendationItemDto>,

}


impl GetBidsRecommendationsResponseDto {
    #[allow(clippy::new_without_default)]
    pub fn new(recommendations: Vec<models::SkuBidRecommendationItemDto>, ) -> GetBidsRecommendationsResponseDto {
        GetBidsRecommendationsResponseDto {
            recommendations,
        }
    }
}

/// Converts the GetBidsRecommendationsResponseDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for GetBidsRecommendationsResponseDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping recommendations in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetBidsRecommendationsResponseDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetBidsRecommendationsResponseDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub recommendations: Vec<Vec<models::SkuBidRecommendationItemDto>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing GetBidsRecommendationsResponseDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "recommendations" => return std::result::Result::Err("Parsing a container in this style is not supported in GetBidsRecommendationsResponseDto".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing GetBidsRecommendationsResponseDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetBidsRecommendationsResponseDto {
            recommendations: intermediate_rep.recommendations.into_iter().next().ok_or_else(|| "recommendations missing in GetBidsRecommendationsResponseDto".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetBidsRecommendationsResponseDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<GetBidsRecommendationsResponseDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<GetBidsRecommendationsResponseDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for GetBidsRecommendationsResponseDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<GetBidsRecommendationsResponseDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GetBidsRecommendationsResponseDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GetBidsRecommendationsResponseDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetBusinessBuyerInfoResponse {
    #[serde(rename = "status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<models::ApiResponseStatusType>,

    #[serde(rename = "result")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub result: Option<models::OrderBusinessBuyerDto>,

}


impl GetBusinessBuyerInfoResponse {
    #[allow(clippy::new_without_default)]
    pub fn new() -> GetBusinessBuyerInfoResponse {
        GetBusinessBuyerInfoResponse {
            status: None,
            result: None,
        }
    }
}

/// Converts the GetBusinessBuyerInfoResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for GetBusinessBuyerInfoResponse {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping status in query parameter serialization

            // Skipping result in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetBusinessBuyerInfoResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetBusinessBuyerInfoResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub status: Vec<models::ApiResponseStatusType>,
            pub result: Vec<models::OrderBusinessBuyerDto>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing GetBusinessBuyerInfoResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(<models::ApiResponseStatusType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "result" => intermediate_rep.result.push(<models::OrderBusinessBuyerDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing GetBusinessBuyerInfoResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetBusinessBuyerInfoResponse {
            status: intermediate_rep.status.into_iter().next(),
            result: intermediate_rep.result.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetBusinessBuyerInfoResponse> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<GetBusinessBuyerInfoResponse>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<GetBusinessBuyerInfoResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for GetBusinessBuyerInfoResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<GetBusinessBuyerInfoResponse> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GetBusinessBuyerInfoResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GetBusinessBuyerInfoResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetBusinessDocumentsInfoResponse {
    #[serde(rename = "status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<models::ApiResponseStatusType>,

    #[serde(rename = "result")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub result: Option<models::OrderBusinessDocumentsDto>,

}


impl GetBusinessDocumentsInfoResponse {
    #[allow(clippy::new_without_default)]
    pub fn new() -> GetBusinessDocumentsInfoResponse {
        GetBusinessDocumentsInfoResponse {
            status: None,
            result: None,
        }
    }
}

/// Converts the GetBusinessDocumentsInfoResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for GetBusinessDocumentsInfoResponse {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping status in query parameter serialization

            // Skipping result in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetBusinessDocumentsInfoResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetBusinessDocumentsInfoResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub status: Vec<models::ApiResponseStatusType>,
            pub result: Vec<models::OrderBusinessDocumentsDto>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing GetBusinessDocumentsInfoResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(<models::ApiResponseStatusType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "result" => intermediate_rep.result.push(<models::OrderBusinessDocumentsDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing GetBusinessDocumentsInfoResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetBusinessDocumentsInfoResponse {
            status: intermediate_rep.status.into_iter().next(),
            result: intermediate_rep.result.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetBusinessDocumentsInfoResponse> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<GetBusinessDocumentsInfoResponse>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<GetBusinessDocumentsInfoResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for GetBusinessDocumentsInfoResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<GetBusinessDocumentsInfoResponse> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GetBusinessDocumentsInfoResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GetBusinessDocumentsInfoResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Информация о кабинете и его настройках.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetBusinessSettingsInfoDto {
    #[serde(rename = "info")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub info: Option<models::BusinessDto>,

    #[serde(rename = "settings")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub settings: Option<models::BusinessSettingsDto>,

}


impl GetBusinessSettingsInfoDto {
    #[allow(clippy::new_without_default)]
    pub fn new() -> GetBusinessSettingsInfoDto {
        GetBusinessSettingsInfoDto {
            info: None,
            settings: None,
        }
    }
}

/// Converts the GetBusinessSettingsInfoDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for GetBusinessSettingsInfoDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping info in query parameter serialization

            // Skipping settings in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetBusinessSettingsInfoDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetBusinessSettingsInfoDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub info: Vec<models::BusinessDto>,
            pub settings: Vec<models::BusinessSettingsDto>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing GetBusinessSettingsInfoDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "info" => intermediate_rep.info.push(<models::BusinessDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "settings" => intermediate_rep.settings.push(<models::BusinessSettingsDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing GetBusinessSettingsInfoDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetBusinessSettingsInfoDto {
            info: intermediate_rep.info.into_iter().next(),
            settings: intermediate_rep.settings.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetBusinessSettingsInfoDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<GetBusinessSettingsInfoDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<GetBusinessSettingsInfoDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for GetBusinessSettingsInfoDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<GetBusinessSettingsInfoDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GetBusinessSettingsInfoDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GetBusinessSettingsInfoDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Ответ на запрос настроек кабинета.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetBusinessSettingsResponse {
    #[serde(rename = "status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<models::ApiResponseStatusType>,

    #[serde(rename = "result")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub result: Option<models::GetBusinessSettingsInfoDto>,

}


impl GetBusinessSettingsResponse {
    #[allow(clippy::new_without_default)]
    pub fn new() -> GetBusinessSettingsResponse {
        GetBusinessSettingsResponse {
            status: None,
            result: None,
        }
    }
}

/// Converts the GetBusinessSettingsResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for GetBusinessSettingsResponse {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping status in query parameter serialization

            // Skipping result in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetBusinessSettingsResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetBusinessSettingsResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub status: Vec<models::ApiResponseStatusType>,
            pub result: Vec<models::GetBusinessSettingsInfoDto>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing GetBusinessSettingsResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(<models::ApiResponseStatusType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "result" => intermediate_rep.result.push(<models::GetBusinessSettingsInfoDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing GetBusinessSettingsResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetBusinessSettingsResponse {
            status: intermediate_rep.status.into_iter().next(),
            result: intermediate_rep.result.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetBusinessSettingsResponse> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<GetBusinessSettingsResponse>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<GetBusinessSettingsResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for GetBusinessSettingsResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<GetBusinessSettingsResponse> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GetBusinessSettingsResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GetBusinessSettingsResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Ответ на запрос списка логинов, связанных с магазином.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetCampaignLoginsResponse {
    /// Список логинов.
    #[serde(rename = "logins")]
    pub logins: Vec<String>,

}


impl GetCampaignLoginsResponse {
    #[allow(clippy::new_without_default)]
    pub fn new(logins: Vec<String>, ) -> GetCampaignLoginsResponse {
        GetCampaignLoginsResponse {
            logins,
        }
    }
}

/// Converts the GetCampaignLoginsResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for GetCampaignLoginsResponse {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            Some("logins".to_string()),
            Some(self.logins.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetCampaignLoginsResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetCampaignLoginsResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub logins: Vec<Vec<String>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing GetCampaignLoginsResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "logins" => return std::result::Result::Err("Parsing a container in this style is not supported in GetCampaignLoginsResponse".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing GetCampaignLoginsResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetCampaignLoginsResponse {
            logins: intermediate_rep.logins.into_iter().next().ok_or_else(|| "logins missing in GetCampaignLoginsResponse".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetCampaignLoginsResponse> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<GetCampaignLoginsResponse>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<GetCampaignLoginsResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for GetCampaignLoginsResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<GetCampaignLoginsResponse> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GetCampaignLoginsResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GetCampaignLoginsResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Параметры размещения товара в магазине.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetCampaignOfferDto {
    /// Ваш SKU — идентификатор товара в вашей системе.  Разрешена любая последовательность длиной до 255 знаков.  Правила использования SKU:  * У каждого товара SKU должен быть свой.  * SKU товара нельзя менять — можно только удалить товар и добавить заново с новым SKU.  * Уже заданный SKU нельзя освободить и использовать заново для другого товара. Каждый товар должен получать новый идентификатор, до того никогда не использовавшийся в вашем каталоге.  [Что такое SKU и как его назначать](https://yandex.ru/support/marketplace/assortment/add/index.html#fields) 
    #[serde(rename = "offerId")]
    #[validate(
            length(min = 1, max = 255),
           regex = "RE_GETCAMPAIGNOFFERDTO_OFFER_ID",
        )]
    pub offer_id: String,

    #[serde(rename = "quantum")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub quantum: Option<models::QuantumDto>,

    /// Есть ли товар в продаже. 
    #[serde(rename = "available")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub available: Option<bool>,

    #[serde(rename = "basicPrice")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub basic_price: Option<models::GetPriceWithDiscountDto>,

    #[serde(rename = "campaignPrice")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub campaign_price: Option<models::GetPriceWithVatDto>,

    #[serde(rename = "status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<models::OfferCampaignStatusType>,

    /// Ошибки, препятствующие размещению товара на витрине. 
    #[serde(rename = "errors")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub errors: Option<swagger::Nullable<Vec<models::OfferErrorDto>>>,

    /// Предупреждения, не препятствующие размещению товара на витрине. 
    #[serde(rename = "warnings")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub warnings: Option<swagger::Nullable<Vec<models::OfferErrorDto>>>,

}

lazy_static::lazy_static! {
    static ref RE_GETCAMPAIGNOFFERDTO_OFFER_ID: regex::Regex = regex::Regex::new(r"^[^\\x00-\\x08\\x0A-\\x1f\\x7f]{1,255}$").unwrap();
}

impl GetCampaignOfferDto {
    #[allow(clippy::new_without_default)]
    pub fn new(offer_id: String, ) -> GetCampaignOfferDto {
        GetCampaignOfferDto {
            offer_id,
            quantum: None,
            available: None,
            basic_price: None,
            campaign_price: None,
            status: None,
            errors: None,
            warnings: None,
        }
    }
}

/// Converts the GetCampaignOfferDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for GetCampaignOfferDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            Some("offerId".to_string()),
            Some(self.offer_id.to_string()),

            // Skipping quantum in query parameter serialization


            self.available.as_ref().map(|available| {
                [
                    "available".to_string(),
                    available.to_string(),
                ].join(",")
            }),

            // Skipping basicPrice in query parameter serialization

            // Skipping campaignPrice in query parameter serialization

            // Skipping status in query parameter serialization

            // Skipping errors in query parameter serialization

            // Skipping warnings in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetCampaignOfferDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetCampaignOfferDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub offer_id: Vec<String>,
            pub quantum: Vec<models::QuantumDto>,
            pub available: Vec<bool>,
            pub basic_price: Vec<models::GetPriceWithDiscountDto>,
            pub campaign_price: Vec<models::GetPriceWithVatDto>,
            pub status: Vec<models::OfferCampaignStatusType>,
            pub errors: Vec<Vec<models::OfferErrorDto>>,
            pub warnings: Vec<Vec<models::OfferErrorDto>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing GetCampaignOfferDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "offerId" => intermediate_rep.offer_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "quantum" => intermediate_rep.quantum.push(<models::QuantumDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "available" => intermediate_rep.available.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "basicPrice" => intermediate_rep.basic_price.push(<models::GetPriceWithDiscountDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "campaignPrice" => intermediate_rep.campaign_price.push(<models::GetPriceWithVatDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(<models::OfferCampaignStatusType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "errors" => return std::result::Result::Err("Parsing a container in this style is not supported in GetCampaignOfferDto".to_string()),
                    "warnings" => return std::result::Result::Err("Parsing a container in this style is not supported in GetCampaignOfferDto".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing GetCampaignOfferDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetCampaignOfferDto {
            offer_id: intermediate_rep.offer_id.into_iter().next().ok_or_else(|| "offerId missing in GetCampaignOfferDto".to_string())?,
            quantum: intermediate_rep.quantum.into_iter().next(),
            available: intermediate_rep.available.into_iter().next(),
            basic_price: intermediate_rep.basic_price.into_iter().next(),
            campaign_price: intermediate_rep.campaign_price.into_iter().next(),
            status: intermediate_rep.status.into_iter().next(),
            errors: std::result::Result::Err("Nullable types not supported in GetCampaignOfferDto".to_string())?,
            warnings: std::result::Result::Err("Nullable types not supported in GetCampaignOfferDto".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetCampaignOfferDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<GetCampaignOfferDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<GetCampaignOfferDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for GetCampaignOfferDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<GetCampaignOfferDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GetCampaignOfferDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GetCampaignOfferDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Фильтрации товаров  В запросе можно указать либо фильтр offerIds, либо любые другие фильтры товаров. Совместное использование фильтра offerIds с другими фильтрациями приведет к ошибке. 
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetCampaignOffersRequest {
    /// Идентификаторы товаров, информация о которых нужна.  {% note warning \"Такой список возвращается только целиком\" %}  Не используйте это поле одновременно с фильтрами по статусам карточек, категориям, брендам или тегам. Если вы хотите воспользоваться фильтрами, оставьте поле пустым.  Если вы запрашиваете информацию по конкретным SKU, не заполняйте:  * `page_token` * `limit`  {% endnote %}    
    #[serde(rename = "offerIds")]
    #[validate(
            length(max = 200),
        )]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub offer_ids: Option<swagger::Nullable<Vec<models::ShopSku>>>,

    /// Фильтр по статусам товаров. 
    #[serde(rename = "statuses")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub statuses: Option<swagger::Nullable<Vec<models::OfferCampaignStatusType>>>,

    /// Фильтр по категориям на Маркете.
    #[serde(rename = "categoryIds")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub category_ids: Option<swagger::Nullable<Vec<i32>>>,

    /// Фильтр по брендам.
    #[serde(rename = "vendorNames")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub vendor_names: Option<swagger::Nullable<Vec<String>>>,

    /// Фильтр по тегам.
    #[serde(rename = "tags")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub tags: Option<swagger::Nullable<Vec<String>>>,

}


impl GetCampaignOffersRequest {
    #[allow(clippy::new_without_default)]
    pub fn new() -> GetCampaignOffersRequest {
        GetCampaignOffersRequest {
            offer_ids: None,
            statuses: None,
            category_ids: None,
            vendor_names: None,
            tags: None,
        }
    }
}

/// Converts the GetCampaignOffersRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for GetCampaignOffersRequest {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.offer_ids.as_ref().map(|offer_ids| {
                [
                    "offerIds".to_string(),
                    offer_ids.as_ref().map_or("null".to_string(), |x| x.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),
                ].join(",")
            }),

            // Skipping statuses in query parameter serialization


            self.category_ids.as_ref().map(|category_ids| {
                [
                    "categoryIds".to_string(),
                    category_ids.as_ref().map_or("null".to_string(), |x| x.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),
                ].join(",")
            }),


            self.vendor_names.as_ref().map(|vendor_names| {
                [
                    "vendorNames".to_string(),
                    vendor_names.as_ref().map_or("null".to_string(), |x| x.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),
                ].join(",")
            }),


            self.tags.as_ref().map(|tags| {
                [
                    "tags".to_string(),
                    tags.as_ref().map_or("null".to_string(), |x| x.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetCampaignOffersRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetCampaignOffersRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub offer_ids: Vec<Vec<models::ShopSku>>,
            pub statuses: Vec<Vec<models::OfferCampaignStatusType>>,
            pub category_ids: Vec<Vec<i32>>,
            pub vendor_names: Vec<Vec<String>>,
            pub tags: Vec<Vec<String>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing GetCampaignOffersRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "offerIds" => return std::result::Result::Err("Parsing a container in this style is not supported in GetCampaignOffersRequest".to_string()),
                    "statuses" => return std::result::Result::Err("Parsing a container in this style is not supported in GetCampaignOffersRequest".to_string()),
                    "categoryIds" => return std::result::Result::Err("Parsing a container in this style is not supported in GetCampaignOffersRequest".to_string()),
                    "vendorNames" => return std::result::Result::Err("Parsing a container in this style is not supported in GetCampaignOffersRequest".to_string()),
                    "tags" => return std::result::Result::Err("Parsing a container in this style is not supported in GetCampaignOffersRequest".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing GetCampaignOffersRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetCampaignOffersRequest {
            offer_ids: std::result::Result::Err("Nullable types not supported in GetCampaignOffersRequest".to_string())?,
            statuses: std::result::Result::Err("Nullable types not supported in GetCampaignOffersRequest".to_string())?,
            category_ids: std::result::Result::Err("Nullable types not supported in GetCampaignOffersRequest".to_string())?,
            vendor_names: std::result::Result::Err("Nullable types not supported in GetCampaignOffersRequest".to_string())?,
            tags: std::result::Result::Err("Nullable types not supported in GetCampaignOffersRequest".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetCampaignOffersRequest> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<GetCampaignOffersRequest>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<GetCampaignOffersRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for GetCampaignOffersRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<GetCampaignOffersRequest> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GetCampaignOffersRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GetCampaignOffersRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Ответ на запрос списка товаров в магазине.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetCampaignOffersResponse {
    #[serde(rename = "status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<models::ApiResponseStatusType>,

    #[serde(rename = "result")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub result: Option<models::GetCampaignOffersResultDto>,

}


impl GetCampaignOffersResponse {
    #[allow(clippy::new_without_default)]
    pub fn new() -> GetCampaignOffersResponse {
        GetCampaignOffersResponse {
            status: None,
            result: None,
        }
    }
}

/// Converts the GetCampaignOffersResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for GetCampaignOffersResponse {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping status in query parameter serialization

            // Skipping result in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetCampaignOffersResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetCampaignOffersResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub status: Vec<models::ApiResponseStatusType>,
            pub result: Vec<models::GetCampaignOffersResultDto>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing GetCampaignOffersResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(<models::ApiResponseStatusType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "result" => intermediate_rep.result.push(<models::GetCampaignOffersResultDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing GetCampaignOffersResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetCampaignOffersResponse {
            status: intermediate_rep.status.into_iter().next(),
            result: intermediate_rep.result.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetCampaignOffersResponse> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<GetCampaignOffersResponse>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<GetCampaignOffersResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for GetCampaignOffersResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<GetCampaignOffersResponse> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GetCampaignOffersResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GetCampaignOffersResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Список товаров в заданном магазине.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetCampaignOffersResultDto {
    #[serde(rename = "paging")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub paging: Option<models::ScrollingPagerDto>,

    /// Страница списка товаров.
    #[serde(rename = "offers")]
    pub offers: Vec<models::GetCampaignOfferDto>,

}


impl GetCampaignOffersResultDto {
    #[allow(clippy::new_without_default)]
    pub fn new(offers: Vec<models::GetCampaignOfferDto>, ) -> GetCampaignOffersResultDto {
        GetCampaignOffersResultDto {
            paging: None,
            offers,
        }
    }
}

/// Converts the GetCampaignOffersResultDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for GetCampaignOffersResultDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping paging in query parameter serialization

            // Skipping offers in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetCampaignOffersResultDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetCampaignOffersResultDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub paging: Vec<models::ScrollingPagerDto>,
            pub offers: Vec<Vec<models::GetCampaignOfferDto>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing GetCampaignOffersResultDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "paging" => intermediate_rep.paging.push(<models::ScrollingPagerDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "offers" => return std::result::Result::Err("Parsing a container in this style is not supported in GetCampaignOffersResultDto".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing GetCampaignOffersResultDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetCampaignOffersResultDto {
            paging: intermediate_rep.paging.into_iter().next(),
            offers: intermediate_rep.offers.into_iter().next().ok_or_else(|| "offers missing in GetCampaignOffersResultDto".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetCampaignOffersResultDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<GetCampaignOffersResultDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<GetCampaignOffersResultDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for GetCampaignOffersResultDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<GetCampaignOffersResultDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GetCampaignOffersResultDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GetCampaignOffersResultDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Ответ на запрос региона магазина.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetCampaignRegionResponse {
    #[serde(rename = "region")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub region: Option<models::RegionDto>,

}


impl GetCampaignRegionResponse {
    #[allow(clippy::new_without_default)]
    pub fn new() -> GetCampaignRegionResponse {
        GetCampaignRegionResponse {
            region: None,
        }
    }
}

/// Converts the GetCampaignRegionResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for GetCampaignRegionResponse {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping region in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetCampaignRegionResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetCampaignRegionResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub region: Vec<models::RegionDto>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing GetCampaignRegionResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "region" => intermediate_rep.region.push(<models::RegionDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing GetCampaignRegionResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetCampaignRegionResponse {
            region: intermediate_rep.region.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetCampaignRegionResponse> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<GetCampaignRegionResponse>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<GetCampaignRegionResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for GetCampaignRegionResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<GetCampaignRegionResponse> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GetCampaignRegionResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GetCampaignRegionResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Информация о магазине к данным идентификатора кампании.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetCampaignResponse {
    #[serde(rename = "campaign")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub campaign: Option<models::CampaignDto>,

}


impl GetCampaignResponse {
    #[allow(clippy::new_without_default)]
    pub fn new() -> GetCampaignResponse {
        GetCampaignResponse {
            campaign: None,
        }
    }
}

/// Converts the GetCampaignResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for GetCampaignResponse {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping campaign in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetCampaignResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetCampaignResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub campaign: Vec<models::CampaignDto>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing GetCampaignResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "campaign" => intermediate_rep.campaign.push(<models::CampaignDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing GetCampaignResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetCampaignResponse {
            campaign: intermediate_rep.campaign.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetCampaignResponse> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<GetCampaignResponse>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<GetCampaignResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for GetCampaignResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<GetCampaignResponse> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GetCampaignResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GetCampaignResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Ответ на запрос настроек магазина.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetCampaignSettingsResponse {
    #[serde(rename = "settings")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub settings: Option<models::CampaignSettingsDto>,

}


impl GetCampaignSettingsResponse {
    #[allow(clippy::new_without_default)]
    pub fn new() -> GetCampaignSettingsResponse {
        GetCampaignSettingsResponse {
            settings: None,
        }
    }
}

/// Converts the GetCampaignSettingsResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for GetCampaignSettingsResponse {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping settings in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetCampaignSettingsResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetCampaignSettingsResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub settings: Vec<models::CampaignSettingsDto>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing GetCampaignSettingsResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "settings" => intermediate_rep.settings.push(<models::CampaignSettingsDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing GetCampaignSettingsResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetCampaignSettingsResponse {
            settings: intermediate_rep.settings.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetCampaignSettingsResponse> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<GetCampaignSettingsResponse>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<GetCampaignSettingsResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for GetCampaignSettingsResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<GetCampaignSettingsResponse> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GetCampaignSettingsResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GetCampaignSettingsResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Результаты поиска магазинов.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetCampaignsResponse {
    /// Список с информацией по каждому магазину.
    #[serde(rename = "campaigns")]
    pub campaigns: Vec<models::CampaignDto>,

    #[serde(rename = "pager")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub pager: Option<models::FlippingPagerDto>,

}


impl GetCampaignsResponse {
    #[allow(clippy::new_without_default)]
    pub fn new(campaigns: Vec<models::CampaignDto>, ) -> GetCampaignsResponse {
        GetCampaignsResponse {
            campaigns,
            pager: None,
        }
    }
}

/// Converts the GetCampaignsResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for GetCampaignsResponse {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping campaigns in query parameter serialization

            // Skipping pager in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetCampaignsResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetCampaignsResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub campaigns: Vec<Vec<models::CampaignDto>>,
            pub pager: Vec<models::FlippingPagerDto>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing GetCampaignsResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "campaigns" => return std::result::Result::Err("Parsing a container in this style is not supported in GetCampaignsResponse".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "pager" => intermediate_rep.pager.push(<models::FlippingPagerDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing GetCampaignsResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetCampaignsResponse {
            campaigns: intermediate_rep.campaigns.into_iter().next().ok_or_else(|| "campaigns missing in GetCampaignsResponse".to_string())?,
            pager: intermediate_rep.pager.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetCampaignsResponse> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<GetCampaignsResponse>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<GetCampaignsResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for GetCampaignsResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<GetCampaignsResponse> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GetCampaignsResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GetCampaignsResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Категории и лимит на установку кванта и минимального количества товаров.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetCategoriesMaxSaleQuantumDto {
    /// Категории и лимит на установку кванта и минимального количества товаров.
    #[serde(rename = "results")]
    pub results: Vec<models::MaxSaleQuantumDto>,

    /// Ошибки, которые появились из-за переданных категорий.
    #[serde(rename = "errors")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub errors: Option<swagger::Nullable<Vec<models::CategoryErrorDto>>>,

}


impl GetCategoriesMaxSaleQuantumDto {
    #[allow(clippy::new_without_default)]
    pub fn new(results: Vec<models::MaxSaleQuantumDto>, ) -> GetCategoriesMaxSaleQuantumDto {
        GetCategoriesMaxSaleQuantumDto {
            results,
            errors: None,
        }
    }
}

/// Converts the GetCategoriesMaxSaleQuantumDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for GetCategoriesMaxSaleQuantumDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping results in query parameter serialization

            // Skipping errors in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetCategoriesMaxSaleQuantumDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetCategoriesMaxSaleQuantumDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub results: Vec<Vec<models::MaxSaleQuantumDto>>,
            pub errors: Vec<Vec<models::CategoryErrorDto>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing GetCategoriesMaxSaleQuantumDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "results" => return std::result::Result::Err("Parsing a container in this style is not supported in GetCategoriesMaxSaleQuantumDto".to_string()),
                    "errors" => return std::result::Result::Err("Parsing a container in this style is not supported in GetCategoriesMaxSaleQuantumDto".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing GetCategoriesMaxSaleQuantumDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetCategoriesMaxSaleQuantumDto {
            results: intermediate_rep.results.into_iter().next().ok_or_else(|| "results missing in GetCategoriesMaxSaleQuantumDto".to_string())?,
            errors: std::result::Result::Err("Nullable types not supported in GetCategoriesMaxSaleQuantumDto".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetCategoriesMaxSaleQuantumDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<GetCategoriesMaxSaleQuantumDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<GetCategoriesMaxSaleQuantumDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for GetCategoriesMaxSaleQuantumDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<GetCategoriesMaxSaleQuantumDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GetCategoriesMaxSaleQuantumDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GetCategoriesMaxSaleQuantumDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Список категорий, для которых нужно вернуть лимит на установку кванта и минимального количества товаров. 
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetCategoriesMaxSaleQuantumRequest {
    /// Идентификаторы листовых категории на Маркете — тех, у которых нет дочерних категорий.
    #[serde(rename = "marketCategoryIds")]
    #[validate(
            length(min = 1, max = 1500),
        )]
    pub market_category_ids: Vec<i64>,

}


impl GetCategoriesMaxSaleQuantumRequest {
    #[allow(clippy::new_without_default)]
    pub fn new(market_category_ids: Vec<i64>, ) -> GetCategoriesMaxSaleQuantumRequest {
        GetCategoriesMaxSaleQuantumRequest {
            market_category_ids,
        }
    }
}

/// Converts the GetCategoriesMaxSaleQuantumRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for GetCategoriesMaxSaleQuantumRequest {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            Some("marketCategoryIds".to_string()),
            Some(self.market_category_ids.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetCategoriesMaxSaleQuantumRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetCategoriesMaxSaleQuantumRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub market_category_ids: Vec<Vec<i64>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing GetCategoriesMaxSaleQuantumRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "marketCategoryIds" => return std::result::Result::Err("Parsing a container in this style is not supported in GetCategoriesMaxSaleQuantumRequest".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing GetCategoriesMaxSaleQuantumRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetCategoriesMaxSaleQuantumRequest {
            market_category_ids: intermediate_rep.market_category_ids.into_iter().next().ok_or_else(|| "marketCategoryIds missing in GetCategoriesMaxSaleQuantumRequest".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetCategoriesMaxSaleQuantumRequest> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<GetCategoriesMaxSaleQuantumRequest>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<GetCategoriesMaxSaleQuantumRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for GetCategoriesMaxSaleQuantumRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<GetCategoriesMaxSaleQuantumRequest> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GetCategoriesMaxSaleQuantumRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GetCategoriesMaxSaleQuantumRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetCategoriesMaxSaleQuantumResponse {
    #[serde(rename = "status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<models::ApiResponseStatusType>,

    /// Категории и лимит на установку кванта и минимального количества товаров.
    #[serde(rename = "results")]
    pub results: Vec<models::MaxSaleQuantumDto>,

    /// Ошибки, которые появились из-за переданных категорий.
    #[serde(rename = "errors")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub errors: Option<swagger::Nullable<Vec<models::CategoryErrorDto>>>,

}


impl GetCategoriesMaxSaleQuantumResponse {
    #[allow(clippy::new_without_default)]
    pub fn new(results: Vec<models::MaxSaleQuantumDto>, ) -> GetCategoriesMaxSaleQuantumResponse {
        GetCategoriesMaxSaleQuantumResponse {
            status: None,
            results,
            errors: None,
        }
    }
}

/// Converts the GetCategoriesMaxSaleQuantumResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for GetCategoriesMaxSaleQuantumResponse {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping status in query parameter serialization

            // Skipping results in query parameter serialization

            // Skipping errors in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetCategoriesMaxSaleQuantumResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetCategoriesMaxSaleQuantumResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub status: Vec<models::ApiResponseStatusType>,
            pub results: Vec<Vec<models::MaxSaleQuantumDto>>,
            pub errors: Vec<Vec<models::CategoryErrorDto>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing GetCategoriesMaxSaleQuantumResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(<models::ApiResponseStatusType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "results" => return std::result::Result::Err("Parsing a container in this style is not supported in GetCategoriesMaxSaleQuantumResponse".to_string()),
                    "errors" => return std::result::Result::Err("Parsing a container in this style is not supported in GetCategoriesMaxSaleQuantumResponse".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing GetCategoriesMaxSaleQuantumResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetCategoriesMaxSaleQuantumResponse {
            status: intermediate_rep.status.into_iter().next(),
            results: intermediate_rep.results.into_iter().next().ok_or_else(|| "results missing in GetCategoriesMaxSaleQuantumResponse".to_string())?,
            errors: std::result::Result::Err("Nullable types not supported in GetCategoriesMaxSaleQuantumResponse".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetCategoriesMaxSaleQuantumResponse> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<GetCategoriesMaxSaleQuantumResponse>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<GetCategoriesMaxSaleQuantumResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for GetCategoriesMaxSaleQuantumResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<GetCategoriesMaxSaleQuantumResponse> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GetCategoriesMaxSaleQuantumResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GetCategoriesMaxSaleQuantumResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Параметры запроса категорий. 
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetCategoriesRequest {
    #[serde(rename = "language")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub language: Option<models::LanguageType>,

}


impl GetCategoriesRequest {
    #[allow(clippy::new_without_default)]
    pub fn new() -> GetCategoriesRequest {
        GetCategoriesRequest {
            language: None,
        }
    }
}

/// Converts the GetCategoriesRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for GetCategoriesRequest {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping language in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetCategoriesRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetCategoriesRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub language: Vec<models::LanguageType>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing GetCategoriesRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "language" => intermediate_rep.language.push(<models::LanguageType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing GetCategoriesRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetCategoriesRequest {
            language: intermediate_rep.language.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetCategoriesRequest> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<GetCategoriesRequest>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<GetCategoriesRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for GetCategoriesRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<GetCategoriesRequest> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GetCategoriesRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GetCategoriesRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetCategoriesResponse {
    #[serde(rename = "status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<models::ApiResponseStatusType>,

    #[serde(rename = "result")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub result: Option<models::CategoryDto>,

}


impl GetCategoriesResponse {
    #[allow(clippy::new_without_default)]
    pub fn new() -> GetCategoriesResponse {
        GetCategoriesResponse {
            status: None,
            result: None,
        }
    }
}

/// Converts the GetCategoriesResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for GetCategoriesResponse {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping status in query parameter serialization

            // Skipping result in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetCategoriesResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetCategoriesResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub status: Vec<models::ApiResponseStatusType>,
            pub result: Vec<models::CategoryDto>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing GetCategoriesResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(<models::ApiResponseStatusType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "result" => intermediate_rep.result.push(<models::CategoryDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing GetCategoriesResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetCategoriesResponse {
            status: intermediate_rep.status.into_iter().next(),
            result: intermediate_rep.result.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetCategoriesResponse> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<GetCategoriesResponse>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<GetCategoriesResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for GetCategoriesResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<GetCategoriesResponse> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GetCategoriesResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GetCategoriesResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Ответ со списком характеристик для категории и их допустимыми значениями.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetCategoryContentParametersResponse {
    #[serde(rename = "status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<models::ApiResponseStatusType>,

    #[serde(rename = "result")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub result: Option<models::CategoryContentParametersDto>,

}


impl GetCategoryContentParametersResponse {
    #[allow(clippy::new_without_default)]
    pub fn new() -> GetCategoryContentParametersResponse {
        GetCategoryContentParametersResponse {
            status: None,
            result: None,
        }
    }
}

/// Converts the GetCategoryContentParametersResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for GetCategoryContentParametersResponse {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping status in query parameter serialization

            // Skipping result in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetCategoryContentParametersResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetCategoryContentParametersResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub status: Vec<models::ApiResponseStatusType>,
            pub result: Vec<models::CategoryContentParametersDto>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing GetCategoryContentParametersResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(<models::ApiResponseStatusType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "result" => intermediate_rep.result.push(<models::CategoryContentParametersDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing GetCategoryContentParametersResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetCategoryContentParametersResponse {
            status: intermediate_rep.status.into_iter().next(),
            result: intermediate_rep.result.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetCategoryContentParametersResponse> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<GetCategoryContentParametersResponse>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<GetCategoryContentParametersResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for GetCategoryContentParametersResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<GetCategoryContentParametersResponse> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GetCategoryContentParametersResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GetCategoryContentParametersResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Историю какого чата нужно получить — и начиная с какого сообщения. 
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetChatHistoryRequest {
    /// Идентификатор сообщения, начиная с которого нужно получить все последующие сообщения.
    #[serde(rename = "messageIdFrom")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub message_id_from: Option<i64>,

}


impl GetChatHistoryRequest {
    #[allow(clippy::new_without_default)]
    pub fn new() -> GetChatHistoryRequest {
        GetChatHistoryRequest {
            message_id_from: None,
        }
    }
}

/// Converts the GetChatHistoryRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for GetChatHistoryRequest {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.message_id_from.as_ref().map(|message_id_from| {
                [
                    "messageIdFrom".to_string(),
                    message_id_from.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetChatHistoryRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetChatHistoryRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub message_id_from: Vec<i64>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing GetChatHistoryRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "messageIdFrom" => intermediate_rep.message_id_from.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing GetChatHistoryRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetChatHistoryRequest {
            message_id_from: intermediate_rep.message_id_from.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetChatHistoryRequest> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<GetChatHistoryRequest>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<GetChatHistoryRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for GetChatHistoryRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<GetChatHistoryRequest> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GetChatHistoryRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GetChatHistoryRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetChatHistoryResponse {
    #[serde(rename = "status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<models::ApiResponseStatusType>,

    #[serde(rename = "result")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub result: Option<models::ChatMessagesResultDto>,

}


impl GetChatHistoryResponse {
    #[allow(clippy::new_without_default)]
    pub fn new() -> GetChatHistoryResponse {
        GetChatHistoryResponse {
            status: None,
            result: None,
        }
    }
}

/// Converts the GetChatHistoryResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for GetChatHistoryResponse {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping status in query parameter serialization

            // Skipping result in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetChatHistoryResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetChatHistoryResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub status: Vec<models::ApiResponseStatusType>,
            pub result: Vec<models::ChatMessagesResultDto>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing GetChatHistoryResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(<models::ApiResponseStatusType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "result" => intermediate_rep.result.push(<models::ChatMessagesResultDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing GetChatHistoryResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetChatHistoryResponse {
            status: intermediate_rep.status.into_iter().next(),
            result: intermediate_rep.result.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetChatHistoryResponse> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<GetChatHistoryResponse>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<GetChatHistoryResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for GetChatHistoryResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<GetChatHistoryResponse> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GetChatHistoryResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GetChatHistoryResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Информация о чатах.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetChatInfoDto {
    /// Идентификатор чата.
    #[serde(rename = "chatId")]
    pub chat_id: i64,

    /// Идентификатор заказа.
    #[serde(rename = "orderId")]
    pub order_id: i64,

    #[serde(rename = "type")]
    pub r#type: models::ChatType,

    #[serde(rename = "status")]
    pub status: models::ChatStatusType,

    /// Дата и время создания чата.  Формат даты: ISO 8601 со смещением относительно UTC. Например, `2017-11-21T00:00:00+03:00`. 
    #[serde(rename = "createdAt")]
    pub created_at: chrono::DateTime::<chrono::Utc>,

    /// Дата и время последнего сообщения в чате.
    #[serde(rename = "updatedAt")]
    pub updated_at: chrono::DateTime::<chrono::Utc>,

}


impl GetChatInfoDto {
    #[allow(clippy::new_without_default)]
    pub fn new(chat_id: i64, order_id: i64, r#type: models::ChatType, status: models::ChatStatusType, created_at: chrono::DateTime::<chrono::Utc>, updated_at: chrono::DateTime::<chrono::Utc>, ) -> GetChatInfoDto {
        GetChatInfoDto {
            chat_id,
            order_id,
            r#type,
            status,
            created_at,
            updated_at,
        }
    }
}

/// Converts the GetChatInfoDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for GetChatInfoDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            Some("chatId".to_string()),
            Some(self.chat_id.to_string()),


            Some("orderId".to_string()),
            Some(self.order_id.to_string()),

            // Skipping type in query parameter serialization

            // Skipping status in query parameter serialization

            // Skipping createdAt in query parameter serialization

            // Skipping updatedAt in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetChatInfoDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetChatInfoDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub chat_id: Vec<i64>,
            pub order_id: Vec<i64>,
            pub r#type: Vec<models::ChatType>,
            pub status: Vec<models::ChatStatusType>,
            pub created_at: Vec<chrono::DateTime::<chrono::Utc>>,
            pub updated_at: Vec<chrono::DateTime::<chrono::Utc>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing GetChatInfoDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "chatId" => intermediate_rep.chat_id.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "orderId" => intermediate_rep.order_id.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r#type.push(<models::ChatType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(<models::ChatStatusType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "createdAt" => intermediate_rep.created_at.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "updatedAt" => intermediate_rep.updated_at.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing GetChatInfoDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetChatInfoDto {
            chat_id: intermediate_rep.chat_id.into_iter().next().ok_or_else(|| "chatId missing in GetChatInfoDto".to_string())?,
            order_id: intermediate_rep.order_id.into_iter().next().ok_or_else(|| "orderId missing in GetChatInfoDto".to_string())?,
            r#type: intermediate_rep.r#type.into_iter().next().ok_or_else(|| "type missing in GetChatInfoDto".to_string())?,
            status: intermediate_rep.status.into_iter().next().ok_or_else(|| "status missing in GetChatInfoDto".to_string())?,
            created_at: intermediate_rep.created_at.into_iter().next().ok_or_else(|| "createdAt missing in GetChatInfoDto".to_string())?,
            updated_at: intermediate_rep.updated_at.into_iter().next().ok_or_else(|| "updatedAt missing in GetChatInfoDto".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetChatInfoDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<GetChatInfoDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<GetChatInfoDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for GetChatInfoDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<GetChatInfoDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GetChatInfoDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GetChatInfoDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Список чатов.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetChatsInfoDto {
    /// Информация о чатах.
    #[serde(rename = "chats")]
    pub chats: Vec<models::GetChatInfoDto>,

    #[serde(rename = "paging")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub paging: Option<models::ForwardScrollingPagerDto>,

}


impl GetChatsInfoDto {
    #[allow(clippy::new_without_default)]
    pub fn new(chats: Vec<models::GetChatInfoDto>, ) -> GetChatsInfoDto {
        GetChatsInfoDto {
            chats,
            paging: None,
        }
    }
}

/// Converts the GetChatsInfoDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for GetChatsInfoDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping chats in query parameter serialization

            // Skipping paging in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetChatsInfoDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetChatsInfoDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub chats: Vec<Vec<models::GetChatInfoDto>>,
            pub paging: Vec<models::ForwardScrollingPagerDto>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing GetChatsInfoDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "chats" => return std::result::Result::Err("Parsing a container in this style is not supported in GetChatsInfoDto".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "paging" => intermediate_rep.paging.push(<models::ForwardScrollingPagerDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing GetChatsInfoDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetChatsInfoDto {
            chats: intermediate_rep.chats.into_iter().next().ok_or_else(|| "chats missing in GetChatsInfoDto".to_string())?,
            paging: intermediate_rep.paging.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetChatsInfoDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<GetChatsInfoDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<GetChatsInfoDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for GetChatsInfoDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<GetChatsInfoDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GetChatsInfoDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GetChatsInfoDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Фильтры по чатам, которые нужно вернуть. 
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetChatsRequest {
    /// Фильтр по идентификаторам заказов на Маркете.
    #[serde(rename = "orderIds")]
    #[validate(
            length(min = 1),
        )]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub order_ids: Option<swagger::Nullable<Vec<i64>>>,

    /// Фильтр по типам чатов.
    #[serde(rename = "types")]
    #[validate(
            length(min = 1),
        )]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub types: Option<swagger::Nullable<Vec<models::ChatType>>>,

    /// Фильтр по статусам чатов.
    #[serde(rename = "statuses")]
    #[validate(
            length(min = 1),
        )]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub statuses: Option<swagger::Nullable<Vec<models::ChatStatusType>>>,

}


impl GetChatsRequest {
    #[allow(clippy::new_without_default)]
    pub fn new() -> GetChatsRequest {
        GetChatsRequest {
            order_ids: None,
            types: None,
            statuses: None,
        }
    }
}

/// Converts the GetChatsRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for GetChatsRequest {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.order_ids.as_ref().map(|order_ids| {
                [
                    "orderIds".to_string(),
                    order_ids.as_ref().map_or("null".to_string(), |x| x.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),
                ].join(",")
            }),

            // Skipping types in query parameter serialization

            // Skipping statuses in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetChatsRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetChatsRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub order_ids: Vec<Vec<i64>>,
            pub types: Vec<Vec<models::ChatType>>,
            pub statuses: Vec<Vec<models::ChatStatusType>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing GetChatsRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "orderIds" => return std::result::Result::Err("Parsing a container in this style is not supported in GetChatsRequest".to_string()),
                    "types" => return std::result::Result::Err("Parsing a container in this style is not supported in GetChatsRequest".to_string()),
                    "statuses" => return std::result::Result::Err("Parsing a container in this style is not supported in GetChatsRequest".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing GetChatsRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetChatsRequest {
            order_ids: std::result::Result::Err("Nullable types not supported in GetChatsRequest".to_string())?,
            types: std::result::Result::Err("Nullable types not supported in GetChatsRequest".to_string())?,
            statuses: std::result::Result::Err("Nullable types not supported in GetChatsRequest".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetChatsRequest> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<GetChatsRequest>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<GetChatsRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for GetChatsRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<GetChatsRequest> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GetChatsRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GetChatsRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetChatsResponse {
    #[serde(rename = "status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<models::ApiResponseStatusType>,

    #[serde(rename = "result")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub result: Option<models::GetChatsInfoDto>,

}


impl GetChatsResponse {
    #[allow(clippy::new_without_default)]
    pub fn new() -> GetChatsResponse {
        GetChatsResponse {
            status: None,
            result: None,
        }
    }
}

/// Converts the GetChatsResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for GetChatsResponse {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping status in query parameter serialization

            // Skipping result in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetChatsResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetChatsResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub status: Vec<models::ApiResponseStatusType>,
            pub result: Vec<models::GetChatsInfoDto>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing GetChatsResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(<models::ApiResponseStatusType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "result" => intermediate_rep.result.push(<models::GetChatsInfoDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing GetChatsResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetChatsResponse {
            status: intermediate_rep.status.into_iter().next(),
            result: intermediate_rep.result.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetChatsResponse> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<GetChatsResponse>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<GetChatsResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for GetChatsResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<GetChatsResponse> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GetChatsResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GetChatsResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Ответ на запрос списка служб доставки.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetDeliveryServicesResponse {
    #[serde(rename = "result")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub result: Option<models::DeliveryServicesDto>,

}


impl GetDeliveryServicesResponse {
    #[allow(clippy::new_without_default)]
    pub fn new() -> GetDeliveryServicesResponse {
        GetDeliveryServicesResponse {
            result: None,
        }
    }
}

/// Converts the GetDeliveryServicesResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for GetDeliveryServicesResponse {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping result in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetDeliveryServicesResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetDeliveryServicesResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub result: Vec<models::DeliveryServicesDto>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing GetDeliveryServicesResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "result" => intermediate_rep.result.push(<models::DeliveryServicesDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing GetDeliveryServicesResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetDeliveryServicesResponse {
            result: intermediate_rep.result.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetDeliveryServicesResponse> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<GetDeliveryServicesResponse>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<GetDeliveryServicesResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for GetDeliveryServicesResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<GetDeliveryServicesResponse> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GetDeliveryServicesResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GetDeliveryServicesResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetFeedIndexLogsResponse {
    #[serde(rename = "status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<models::ApiResponseStatusType>,

    #[serde(rename = "result")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub result: Option<models::FeedIndexLogsResultDto>,

}


impl GetFeedIndexLogsResponse {
    #[allow(clippy::new_without_default)]
    pub fn new() -> GetFeedIndexLogsResponse {
        GetFeedIndexLogsResponse {
            status: None,
            result: None,
        }
    }
}

/// Converts the GetFeedIndexLogsResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for GetFeedIndexLogsResponse {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping status in query parameter serialization

            // Skipping result in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetFeedIndexLogsResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetFeedIndexLogsResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub status: Vec<models::ApiResponseStatusType>,
            pub result: Vec<models::FeedIndexLogsResultDto>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing GetFeedIndexLogsResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(<models::ApiResponseStatusType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "result" => intermediate_rep.result.push(<models::FeedIndexLogsResultDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing GetFeedIndexLogsResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetFeedIndexLogsResponse {
            status: intermediate_rep.status.into_iter().next(),
            result: intermediate_rep.result.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetFeedIndexLogsResponse> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<GetFeedIndexLogsResponse>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<GetFeedIndexLogsResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for GetFeedIndexLogsResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<GetFeedIndexLogsResponse> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GetFeedIndexLogsResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GetFeedIndexLogsResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Ответ на запрос информации о прайс-листе.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetFeedResponse {
    #[serde(rename = "feed")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub feed: Option<models::FeedDto>,

}


impl GetFeedResponse {
    #[allow(clippy::new_without_default)]
    pub fn new() -> GetFeedResponse {
        GetFeedResponse {
            feed: None,
        }
    }
}

/// Converts the GetFeedResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for GetFeedResponse {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping feed in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetFeedResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetFeedResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub feed: Vec<models::FeedDto>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing GetFeedResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "feed" => intermediate_rep.feed.push(<models::FeedDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing GetFeedResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetFeedResponse {
            feed: intermediate_rep.feed.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetFeedResponse> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<GetFeedResponse>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<GetFeedResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for GetFeedResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<GetFeedResponse> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GetFeedResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GetFeedResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetFeedbackListResponse {
    #[serde(rename = "status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<models::ApiResponseStatusType>,

    #[serde(rename = "result")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub result: Option<models::FeedbackListDto>,

}


impl GetFeedbackListResponse {
    #[allow(clippy::new_without_default)]
    pub fn new() -> GetFeedbackListResponse {
        GetFeedbackListResponse {
            status: None,
            result: None,
        }
    }
}

/// Converts the GetFeedbackListResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for GetFeedbackListResponse {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping status in query parameter serialization

            // Skipping result in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetFeedbackListResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetFeedbackListResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub status: Vec<models::ApiResponseStatusType>,
            pub result: Vec<models::FeedbackListDto>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing GetFeedbackListResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(<models::ApiResponseStatusType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "result" => intermediate_rep.result.push(<models::FeedbackListDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing GetFeedbackListResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetFeedbackListResponse {
            status: intermediate_rep.status.into_iter().next(),
            result: intermediate_rep.result.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetFeedbackListResponse> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<GetFeedbackListResponse>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<GetFeedbackListResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for GetFeedbackListResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<GetFeedbackListResponse> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GetFeedbackListResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GetFeedbackListResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Ответ на запрос списка прайс-листов.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetFeedsResponse {
    /// Список прайс-листов.
    #[serde(rename = "feeds")]
    pub feeds: Vec<models::FeedDto>,

}


impl GetFeedsResponse {
    #[allow(clippy::new_without_default)]
    pub fn new(feeds: Vec<models::FeedDto>, ) -> GetFeedsResponse {
        GetFeedsResponse {
            feeds,
        }
    }
}

/// Converts the GetFeedsResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for GetFeedsResponse {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping feeds in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetFeedsResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetFeedsResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub feeds: Vec<Vec<models::FeedDto>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing GetFeedsResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "feeds" => return std::result::Result::Err("Parsing a container in this style is not supported in GetFeedsResponse".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing GetFeedsResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetFeedsResponse {
            feeds: intermediate_rep.feeds.into_iter().next().ok_or_else(|| "feeds missing in GetFeedsResponse".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetFeedsResponse> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<GetFeedsResponse>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<GetFeedsResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for GetFeedsResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<GetFeedsResponse> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GetFeedsResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GetFeedsResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetFulfillmentWarehousesResponse {
    #[serde(rename = "status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<models::ApiResponseStatusType>,

    #[serde(rename = "result")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub result: Option<models::FulfillmentWarehousesDto>,

}


impl GetFulfillmentWarehousesResponse {
    #[allow(clippy::new_without_default)]
    pub fn new() -> GetFulfillmentWarehousesResponse {
        GetFulfillmentWarehousesResponse {
            status: None,
            result: None,
        }
    }
}

/// Converts the GetFulfillmentWarehousesResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for GetFulfillmentWarehousesResponse {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping status in query parameter serialization

            // Skipping result in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetFulfillmentWarehousesResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetFulfillmentWarehousesResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub status: Vec<models::ApiResponseStatusType>,
            pub result: Vec<models::FulfillmentWarehousesDto>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing GetFulfillmentWarehousesResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(<models::ApiResponseStatusType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "result" => intermediate_rep.result.push(<models::FulfillmentWarehousesDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing GetFulfillmentWarehousesResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetFulfillmentWarehousesResponse {
            status: intermediate_rep.status.into_iter().next(),
            result: intermediate_rep.result.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetFulfillmentWarehousesResponse> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<GetFulfillmentWarehousesResponse>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<GetFulfillmentWarehousesResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for GetFulfillmentWarehousesResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<GetFulfillmentWarehousesResponse> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GetFulfillmentWarehousesResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GetFulfillmentWarehousesResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Фильтр запроса комментариев отзыва. 
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetGoodsFeedbackCommentsRequest {
    /// Идентификатор отзыва. 
    #[serde(rename = "feedbackId")]
    pub feedback_id: i64,

}


impl GetGoodsFeedbackCommentsRequest {
    #[allow(clippy::new_without_default)]
    pub fn new(feedback_id: i64, ) -> GetGoodsFeedbackCommentsRequest {
        GetGoodsFeedbackCommentsRequest {
            feedback_id,
        }
    }
}

/// Converts the GetGoodsFeedbackCommentsRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for GetGoodsFeedbackCommentsRequest {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            Some("feedbackId".to_string()),
            Some(self.feedback_id.to_string()),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetGoodsFeedbackCommentsRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetGoodsFeedbackCommentsRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub feedback_id: Vec<i64>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing GetGoodsFeedbackCommentsRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "feedbackId" => intermediate_rep.feedback_id.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing GetGoodsFeedbackCommentsRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetGoodsFeedbackCommentsRequest {
            feedback_id: intermediate_rep.feedback_id.into_iter().next().ok_or_else(|| "feedbackId missing in GetGoodsFeedbackCommentsRequest".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetGoodsFeedbackCommentsRequest> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<GetGoodsFeedbackCommentsRequest>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<GetGoodsFeedbackCommentsRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for GetGoodsFeedbackCommentsRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<GetGoodsFeedbackCommentsRequest> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GetGoodsFeedbackCommentsRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GetGoodsFeedbackCommentsRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetGoodsFeedbackCommentsResponse {
    #[serde(rename = "status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<models::ApiResponseStatusType>,

    #[serde(rename = "result")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub result: Option<models::GoodsFeedbackCommentListDto>,

}


impl GetGoodsFeedbackCommentsResponse {
    #[allow(clippy::new_without_default)]
    pub fn new() -> GetGoodsFeedbackCommentsResponse {
        GetGoodsFeedbackCommentsResponse {
            status: None,
            result: None,
        }
    }
}

/// Converts the GetGoodsFeedbackCommentsResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for GetGoodsFeedbackCommentsResponse {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping status in query parameter serialization

            // Skipping result in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetGoodsFeedbackCommentsResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetGoodsFeedbackCommentsResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub status: Vec<models::ApiResponseStatusType>,
            pub result: Vec<models::GoodsFeedbackCommentListDto>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing GetGoodsFeedbackCommentsResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(<models::ApiResponseStatusType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "result" => intermediate_rep.result.push(<models::GoodsFeedbackCommentListDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing GetGoodsFeedbackCommentsResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetGoodsFeedbackCommentsResponse {
            status: intermediate_rep.status.into_iter().next(),
            result: intermediate_rep.result.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetGoodsFeedbackCommentsResponse> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<GetGoodsFeedbackCommentsResponse>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<GetGoodsFeedbackCommentsResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for GetGoodsFeedbackCommentsResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<GetGoodsFeedbackCommentsResponse> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GetGoodsFeedbackCommentsResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GetGoodsFeedbackCommentsResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Фильтр запроса отзывов в кабинете. 
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetGoodsFeedbackRequest {
    /// Начало периода. Не включительно.  Если параметр не указан, возвращается информация за 6 месяцев до указанной в `dateTimeTo` даты. 
    #[serde(rename = "dateTimeFrom")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub date_time_from: Option<chrono::DateTime::<chrono::Utc>>,

    /// Конец периода. Не включительно.  Если параметр не указан, используется текущая дата. 
    #[serde(rename = "dateTimeTo")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub date_time_to: Option<chrono::DateTime::<chrono::Utc>>,

    #[serde(rename = "reactionStatus")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub reaction_status: Option<models::FeedbackReactionStatusType>,

    /// Оценка товара.
    #[serde(rename = "ratingValues")]
    #[validate(
            length(max = 5),
        )]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub rating_values: Option<swagger::Nullable<Vec<i32>>>,

    /// Фильтр по идентификатору модели товара.  Получить идентификатор модели можно с помощью одного из запросов:  * [POST businesses/{businessId}/offer-mappings](../../reference/business-assortment/getOfferMappings.md);  * [POST businesses/{businessId}/offer-cards](../../reference/content/getOfferCardsContentStatus.md);  * [POST models](../../reference/models/getModels.md). 
    #[serde(rename = "modelIds")]
    #[validate(
            length(max = 20),
        )]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub model_ids: Option<swagger::Nullable<Vec<i64>>>,

    /// Фильтр отзывов за баллы Плюса.
    #[serde(rename = "paid")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub paid: Option<bool>,

}


impl GetGoodsFeedbackRequest {
    #[allow(clippy::new_without_default)]
    pub fn new() -> GetGoodsFeedbackRequest {
        GetGoodsFeedbackRequest {
            date_time_from: None,
            date_time_to: None,
            reaction_status: None,
            rating_values: None,
            model_ids: None,
            paid: None,
        }
    }
}

/// Converts the GetGoodsFeedbackRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for GetGoodsFeedbackRequest {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping dateTimeFrom in query parameter serialization

            // Skipping dateTimeTo in query parameter serialization

            // Skipping reactionStatus in query parameter serialization


            self.rating_values.as_ref().map(|rating_values| {
                [
                    "ratingValues".to_string(),
                    rating_values.as_ref().map_or("null".to_string(), |x| x.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),
                ].join(",")
            }),


            self.model_ids.as_ref().map(|model_ids| {
                [
                    "modelIds".to_string(),
                    model_ids.as_ref().map_or("null".to_string(), |x| x.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),
                ].join(",")
            }),


            self.paid.as_ref().map(|paid| {
                [
                    "paid".to_string(),
                    paid.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetGoodsFeedbackRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetGoodsFeedbackRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub date_time_from: Vec<chrono::DateTime::<chrono::Utc>>,
            pub date_time_to: Vec<chrono::DateTime::<chrono::Utc>>,
            pub reaction_status: Vec<models::FeedbackReactionStatusType>,
            pub rating_values: Vec<Vec<i32>>,
            pub model_ids: Vec<Vec<i64>>,
            pub paid: Vec<bool>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing GetGoodsFeedbackRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "dateTimeFrom" => intermediate_rep.date_time_from.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "dateTimeTo" => intermediate_rep.date_time_to.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "reactionStatus" => intermediate_rep.reaction_status.push(<models::FeedbackReactionStatusType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "ratingValues" => return std::result::Result::Err("Parsing a container in this style is not supported in GetGoodsFeedbackRequest".to_string()),
                    "modelIds" => return std::result::Result::Err("Parsing a container in this style is not supported in GetGoodsFeedbackRequest".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "paid" => intermediate_rep.paid.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing GetGoodsFeedbackRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetGoodsFeedbackRequest {
            date_time_from: intermediate_rep.date_time_from.into_iter().next(),
            date_time_to: intermediate_rep.date_time_to.into_iter().next(),
            reaction_status: intermediate_rep.reaction_status.into_iter().next(),
            rating_values: std::result::Result::Err("Nullable types not supported in GetGoodsFeedbackRequest".to_string())?,
            model_ids: std::result::Result::Err("Nullable types not supported in GetGoodsFeedbackRequest".to_string())?,
            paid: intermediate_rep.paid.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetGoodsFeedbackRequest> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<GetGoodsFeedbackRequest>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<GetGoodsFeedbackRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for GetGoodsFeedbackRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<GetGoodsFeedbackRequest> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GetGoodsFeedbackRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GetGoodsFeedbackRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetGoodsFeedbackResponse {
    #[serde(rename = "status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<models::ApiResponseStatusType>,

    #[serde(rename = "result")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub result: Option<models::GoodsFeedbackListDto>,

}


impl GetGoodsFeedbackResponse {
    #[allow(clippy::new_without_default)]
    pub fn new() -> GetGoodsFeedbackResponse {
        GetGoodsFeedbackResponse {
            status: None,
            result: None,
        }
    }
}

/// Converts the GetGoodsFeedbackResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for GetGoodsFeedbackResponse {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping status in query parameter serialization

            // Skipping result in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetGoodsFeedbackResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetGoodsFeedbackResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub status: Vec<models::ApiResponseStatusType>,
            pub result: Vec<models::GoodsFeedbackListDto>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing GetGoodsFeedbackResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(<models::ApiResponseStatusType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "result" => intermediate_rep.result.push(<models::GoodsFeedbackListDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing GetGoodsFeedbackResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetGoodsFeedbackResponse {
            status: intermediate_rep.status.into_iter().next(),
            result: intermediate_rep.result.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetGoodsFeedbackResponse> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<GetGoodsFeedbackResponse>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<GetGoodsFeedbackResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for GetGoodsFeedbackResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<GetGoodsFeedbackResponse> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GetGoodsFeedbackResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GetGoodsFeedbackResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Запрос отчета по товарам.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetGoodsStatsRequest {
    /// Список ваших идентификаторов SKU. 
    #[serde(rename = "shopSkus")]
    #[validate(
            length(min = 1, max = 500),
        )]
    pub shop_skus: Vec<models::ShopSku>,

}


impl GetGoodsStatsRequest {
    #[allow(clippy::new_without_default)]
    pub fn new(shop_skus: Vec<models::ShopSku>, ) -> GetGoodsStatsRequest {
        GetGoodsStatsRequest {
            shop_skus,
        }
    }
}

/// Converts the GetGoodsStatsRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for GetGoodsStatsRequest {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            Some("shopSkus".to_string()),
            Some(self.shop_skus.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetGoodsStatsRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetGoodsStatsRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub shop_skus: Vec<Vec<models::ShopSku>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing GetGoodsStatsRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "shopSkus" => return std::result::Result::Err("Parsing a container in this style is not supported in GetGoodsStatsRequest".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing GetGoodsStatsRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetGoodsStatsRequest {
            shop_skus: intermediate_rep.shop_skus.into_iter().next().ok_or_else(|| "shopSkus missing in GetGoodsStatsRequest".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetGoodsStatsRequest> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<GetGoodsStatsRequest>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<GetGoodsStatsRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for GetGoodsStatsRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<GetGoodsStatsRequest> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GetGoodsStatsRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GetGoodsStatsRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Ответ на запрос отчета по товарам.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetGoodsStatsResponse {
    #[serde(rename = "status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<models::ApiResponseStatusType>,

    #[serde(rename = "result")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub result: Option<models::GoodsStatsDto>,

}


impl GetGoodsStatsResponse {
    #[allow(clippy::new_without_default)]
    pub fn new() -> GetGoodsStatsResponse {
        GetGoodsStatsResponse {
            status: None,
            result: None,
        }
    }
}

/// Converts the GetGoodsStatsResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for GetGoodsStatsResponse {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping status in query parameter serialization

            // Skipping result in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetGoodsStatsResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetGoodsStatsResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub status: Vec<models::ApiResponseStatusType>,
            pub result: Vec<models::GoodsStatsDto>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing GetGoodsStatsResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(<models::ApiResponseStatusType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "result" => intermediate_rep.result.push(<models::GoodsStatsDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing GetGoodsStatsResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetGoodsStatsResponse {
            status: intermediate_rep.status.into_iter().next(),
            result: intermediate_rep.result.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetGoodsStatsResponse> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<GetGoodsStatsResponse>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<GetGoodsStatsResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for GetGoodsStatsResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<GetGoodsStatsResponse> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GetGoodsStatsResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GetGoodsStatsResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Ответ на запрос списка скрытий.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetHiddenOffersResponse {
    #[serde(rename = "status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<models::ApiResponseStatusType>,

    #[serde(rename = "result")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub result: Option<models::GetHiddenOffersResultDto>,

}


impl GetHiddenOffersResponse {
    #[allow(clippy::new_without_default)]
    pub fn new() -> GetHiddenOffersResponse {
        GetHiddenOffersResponse {
            status: None,
            result: None,
        }
    }
}

/// Converts the GetHiddenOffersResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for GetHiddenOffersResponse {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping status in query parameter serialization

            // Skipping result in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetHiddenOffersResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetHiddenOffersResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub status: Vec<models::ApiResponseStatusType>,
            pub result: Vec<models::GetHiddenOffersResultDto>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing GetHiddenOffersResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(<models::ApiResponseStatusType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "result" => intermediate_rep.result.push(<models::GetHiddenOffersResultDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing GetHiddenOffersResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetHiddenOffersResponse {
            status: intermediate_rep.status.into_iter().next(),
            result: intermediate_rep.result.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetHiddenOffersResponse> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<GetHiddenOffersResponse>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<GetHiddenOffersResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for GetHiddenOffersResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<GetHiddenOffersResponse> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GetHiddenOffersResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GetHiddenOffersResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Список скрытых вами товаров. 
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetHiddenOffersResultDto {
    #[serde(rename = "paging")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub paging: Option<models::ScrollingPagerDto>,

    /// Список скрытых товаров.
    #[serde(rename = "hiddenOffers")]
    pub hidden_offers: Vec<models::HiddenOfferDto>,

}


impl GetHiddenOffersResultDto {
    #[allow(clippy::new_without_default)]
    pub fn new(hidden_offers: Vec<models::HiddenOfferDto>, ) -> GetHiddenOffersResultDto {
        GetHiddenOffersResultDto {
            paging: None,
            hidden_offers,
        }
    }
}

/// Converts the GetHiddenOffersResultDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for GetHiddenOffersResultDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping paging in query parameter serialization

            // Skipping hiddenOffers in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetHiddenOffersResultDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetHiddenOffersResultDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub paging: Vec<models::ScrollingPagerDto>,
            pub hidden_offers: Vec<Vec<models::HiddenOfferDto>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing GetHiddenOffersResultDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "paging" => intermediate_rep.paging.push(<models::ScrollingPagerDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "hiddenOffers" => return std::result::Result::Err("Parsing a container in this style is not supported in GetHiddenOffersResultDto".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing GetHiddenOffersResultDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetHiddenOffersResultDto {
            paging: intermediate_rep.paging.into_iter().next(),
            hidden_offers: intermediate_rep.hidden_offers.into_iter().next().ok_or_else(|| "hiddenOffers missing in GetHiddenOffersResultDto".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetHiddenOffersResultDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<GetHiddenOffersResultDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<GetHiddenOffersResultDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for GetHiddenOffersResultDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<GetHiddenOffersResultDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GetHiddenOffersResultDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GetHiddenOffersResultDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Информация о товарах в каталоге. 
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetMappingDto {
    /// SKU на Маркете.
    #[serde(rename = "marketSku")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub market_sku: Option<i64>,

    /// Название карточки товара.  Может отсутствовать в ответе, если товар еще не привязан к карточке. 
    #[serde(rename = "marketSkuName")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub market_sku_name: Option<String>,

    /// Идентификатор модели на Маркете.  Может отсутствовать в ответе, если товар еще не привязан к карточке. 
    #[serde(rename = "marketModelId")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub market_model_id: Option<i64>,

    /// Название модели на Маркете.  Может отсутствовать в ответе, если товар еще не привязан к карточке. 
    #[serde(rename = "marketModelName")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub market_model_name: Option<String>,

    /// Идентификатор категории на Маркете, в которую попал товар.  Может отсутствовать в ответе, если Маркет еще не определил категорию товара. 
    #[serde(rename = "marketCategoryId")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub market_category_id: Option<i64>,

    /// Название категории карточки на Маркете.  Может отсутствовать в ответе, если Маркет еще не определил категорию товара. 
    #[serde(rename = "marketCategoryName")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub market_category_name: Option<String>,

}


impl GetMappingDto {
    #[allow(clippy::new_without_default)]
    pub fn new() -> GetMappingDto {
        GetMappingDto {
            market_sku: None,
            market_sku_name: None,
            market_model_id: None,
            market_model_name: None,
            market_category_id: None,
            market_category_name: None,
        }
    }
}

/// Converts the GetMappingDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for GetMappingDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.market_sku.as_ref().map(|market_sku| {
                [
                    "marketSku".to_string(),
                    market_sku.to_string(),
                ].join(",")
            }),


            self.market_sku_name.as_ref().map(|market_sku_name| {
                [
                    "marketSkuName".to_string(),
                    market_sku_name.to_string(),
                ].join(",")
            }),


            self.market_model_id.as_ref().map(|market_model_id| {
                [
                    "marketModelId".to_string(),
                    market_model_id.to_string(),
                ].join(",")
            }),


            self.market_model_name.as_ref().map(|market_model_name| {
                [
                    "marketModelName".to_string(),
                    market_model_name.to_string(),
                ].join(",")
            }),


            self.market_category_id.as_ref().map(|market_category_id| {
                [
                    "marketCategoryId".to_string(),
                    market_category_id.to_string(),
                ].join(",")
            }),


            self.market_category_name.as_ref().map(|market_category_name| {
                [
                    "marketCategoryName".to_string(),
                    market_category_name.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetMappingDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetMappingDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub market_sku: Vec<i64>,
            pub market_sku_name: Vec<String>,
            pub market_model_id: Vec<i64>,
            pub market_model_name: Vec<String>,
            pub market_category_id: Vec<i64>,
            pub market_category_name: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing GetMappingDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "marketSku" => intermediate_rep.market_sku.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "marketSkuName" => intermediate_rep.market_sku_name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "marketModelId" => intermediate_rep.market_model_id.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "marketModelName" => intermediate_rep.market_model_name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "marketCategoryId" => intermediate_rep.market_category_id.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "marketCategoryName" => intermediate_rep.market_category_name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing GetMappingDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetMappingDto {
            market_sku: intermediate_rep.market_sku.into_iter().next(),
            market_sku_name: intermediate_rep.market_sku_name.into_iter().next(),
            market_model_id: intermediate_rep.market_model_id.into_iter().next(),
            market_model_name: intermediate_rep.market_model_name.into_iter().next(),
            market_category_id: intermediate_rep.market_category_id.into_iter().next(),
            market_category_name: intermediate_rep.market_category_name.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetMappingDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<GetMappingDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<GetMappingDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for GetMappingDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<GetMappingDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GetMappingDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GetMappingDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Ответ на запрос списка предложений для моделей.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetModelsOffersResponse {
    /// Список моделей товаров.
    #[serde(rename = "models")]
    pub models: Vec<models::EnrichedModelDto>,

    #[serde(rename = "currency")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub currency: Option<models::CurrencyType>,

    /// Идентификатор региона, для которого выводится информация о предложениях модели (доставляемых в этот регион).  Информацию о регионе по идентификатору можно получить с помощью запроса [GET regions/{regionId}](../../reference/regions/searchRegionsById.md). 
    #[serde(rename = "regionId")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub region_id: Option<i64>,

}


impl GetModelsOffersResponse {
    #[allow(clippy::new_without_default)]
    pub fn new(models: Vec<models::EnrichedModelDto>, ) -> GetModelsOffersResponse {
        GetModelsOffersResponse {
            models,
            currency: None,
            region_id: None,
        }
    }
}

/// Converts the GetModelsOffersResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for GetModelsOffersResponse {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping models in query parameter serialization

            // Skipping currency in query parameter serialization


            self.region_id.as_ref().map(|region_id| {
                [
                    "regionId".to_string(),
                    region_id.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetModelsOffersResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetModelsOffersResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub models: Vec<Vec<models::EnrichedModelDto>>,
            pub currency: Vec<models::CurrencyType>,
            pub region_id: Vec<i64>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing GetModelsOffersResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "models" => return std::result::Result::Err("Parsing a container in this style is not supported in GetModelsOffersResponse".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "currency" => intermediate_rep.currency.push(<models::CurrencyType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "regionId" => intermediate_rep.region_id.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing GetModelsOffersResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetModelsOffersResponse {
            models: intermediate_rep.models.into_iter().next().ok_or_else(|| "models missing in GetModelsOffersResponse".to_string())?,
            currency: intermediate_rep.currency.into_iter().next(),
            region_id: intermediate_rep.region_id.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetModelsOffersResponse> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<GetModelsOffersResponse>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<GetModelsOffersResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for GetModelsOffersResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<GetModelsOffersResponse> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GetModelsOffersResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GetModelsOffersResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Запрос информации о моделях.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetModelsRequest {
    /// Список моделей.
    #[serde(rename = "models")]
    #[validate(
            length(min = 1),
        )]
    pub models: Vec<i64>,

}


impl GetModelsRequest {
    #[allow(clippy::new_without_default)]
    pub fn new(models: Vec<i64>, ) -> GetModelsRequest {
        GetModelsRequest {
            models,
        }
    }
}

/// Converts the GetModelsRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for GetModelsRequest {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            Some("models".to_string()),
            Some(self.models.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetModelsRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetModelsRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub models: Vec<Vec<i64>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing GetModelsRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "models" => return std::result::Result::Err("Parsing a container in this style is not supported in GetModelsRequest".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing GetModelsRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetModelsRequest {
            models: intermediate_rep.models.into_iter().next().ok_or_else(|| "models missing in GetModelsRequest".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetModelsRequest> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<GetModelsRequest>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<GetModelsRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for GetModelsRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<GetModelsRequest> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GetModelsRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GetModelsRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Ответ на запрос информации о моделях.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetModelsResponse {
    /// Список моделей товаров.
    #[serde(rename = "models")]
    pub models: Vec<models::ModelDto>,

    #[serde(rename = "currency")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub currency: Option<models::CurrencyType>,

    /// Идентификатор региона, для которого выводится информация о предложениях модели (доставляемых в этот регион).  Информацию о регионе по идентификатору можно получить с помощью запроса [GET regions/{regionId}](../../reference/regions/searchRegionsById.md). 
    #[serde(rename = "regionId")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub region_id: Option<i64>,

}


impl GetModelsResponse {
    #[allow(clippy::new_without_default)]
    pub fn new(models: Vec<models::ModelDto>, ) -> GetModelsResponse {
        GetModelsResponse {
            models,
            currency: None,
            region_id: None,
        }
    }
}

/// Converts the GetModelsResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for GetModelsResponse {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping models in query parameter serialization

            // Skipping currency in query parameter serialization


            self.region_id.as_ref().map(|region_id| {
                [
                    "regionId".to_string(),
                    region_id.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetModelsResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetModelsResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub models: Vec<Vec<models::ModelDto>>,
            pub currency: Vec<models::CurrencyType>,
            pub region_id: Vec<i64>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing GetModelsResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "models" => return std::result::Result::Err("Parsing a container in this style is not supported in GetModelsResponse".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "currency" => intermediate_rep.currency.push(<models::CurrencyType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "regionId" => intermediate_rep.region_id.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing GetModelsResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetModelsResponse {
            models: intermediate_rep.models.into_iter().next().ok_or_else(|| "models missing in GetModelsResponse".to_string())?,
            currency: intermediate_rep.currency.into_iter().next(),
            region_id: intermediate_rep.region_id.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetModelsResponse> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<GetModelsResponse>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<GetModelsResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for GetModelsResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<GetModelsResponse> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GetModelsResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GetModelsResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetOfferCardsContentStatusRequest {
    /// Идентификаторы товаров, информация о которых нужна. <br><br> ⚠️ Не используйте это поле одновременно с фильтрами по статусам карточек, категориям, брендам или тегам. Если вы хотите воспользоваться фильтрами, оставьте поле пустым. 
    #[serde(rename = "offerIds")]
    #[validate(
            length(max = 200),
        )]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub offer_ids: Option<swagger::Nullable<Vec<models::ShopSku>>>,

    /// Фильтр по статусам карточек.  [Что такое карточка товара](https://yandex.ru/support/marketplace/assortment/content/index.html) 
    #[serde(rename = "cardStatuses")]
    #[validate(
        )]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub card_statuses: Option<swagger::Nullable<Vec<models::OfferCardStatusType>>>,

    /// Фильтр по категориям на Маркете.
    #[serde(rename = "categoryIds")]
    #[validate(
            length(max = 200),
        )]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub category_ids: Option<swagger::Nullable<Vec<models::CategoryId>>>,

}


impl GetOfferCardsContentStatusRequest {
    #[allow(clippy::new_without_default)]
    pub fn new() -> GetOfferCardsContentStatusRequest {
        GetOfferCardsContentStatusRequest {
            offer_ids: None,
            card_statuses: None,
            category_ids: None,
        }
    }
}

/// Converts the GetOfferCardsContentStatusRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for GetOfferCardsContentStatusRequest {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.offer_ids.as_ref().map(|offer_ids| {
                [
                    "offerIds".to_string(),
                    offer_ids.as_ref().map_or("null".to_string(), |x| x.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),
                ].join(",")
            }),

            // Skipping cardStatuses in query parameter serialization


            self.category_ids.as_ref().map(|category_ids| {
                [
                    "categoryIds".to_string(),
                    category_ids.as_ref().map_or("null".to_string(), |x| x.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetOfferCardsContentStatusRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetOfferCardsContentStatusRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub offer_ids: Vec<Vec<models::ShopSku>>,
            pub card_statuses: Vec<Vec<models::OfferCardStatusType>>,
            pub category_ids: Vec<Vec<models::CategoryId>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing GetOfferCardsContentStatusRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "offerIds" => return std::result::Result::Err("Parsing a container in this style is not supported in GetOfferCardsContentStatusRequest".to_string()),
                    "cardStatuses" => return std::result::Result::Err("Parsing a container in this style is not supported in GetOfferCardsContentStatusRequest".to_string()),
                    "categoryIds" => return std::result::Result::Err("Parsing a container in this style is not supported in GetOfferCardsContentStatusRequest".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing GetOfferCardsContentStatusRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetOfferCardsContentStatusRequest {
            offer_ids: std::result::Result::Err("Nullable types not supported in GetOfferCardsContentStatusRequest".to_string())?,
            card_statuses: std::result::Result::Err("Nullable types not supported in GetOfferCardsContentStatusRequest".to_string())?,
            category_ids: std::result::Result::Err("Nullable types not supported in GetOfferCardsContentStatusRequest".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetOfferCardsContentStatusRequest> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<GetOfferCardsContentStatusRequest>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<GetOfferCardsContentStatusRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for GetOfferCardsContentStatusRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<GetOfferCardsContentStatusRequest> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GetOfferCardsContentStatusRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GetOfferCardsContentStatusRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Ответ со списком состояний товаров и пагинацией.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetOfferCardsContentStatusResponse {
    #[serde(rename = "status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<models::ApiResponseStatusType>,

    #[serde(rename = "result")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub result: Option<models::OfferCardsContentStatusDto>,

}


impl GetOfferCardsContentStatusResponse {
    #[allow(clippy::new_without_default)]
    pub fn new() -> GetOfferCardsContentStatusResponse {
        GetOfferCardsContentStatusResponse {
            status: None,
            result: None,
        }
    }
}

/// Converts the GetOfferCardsContentStatusResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for GetOfferCardsContentStatusResponse {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping status in query parameter serialization

            // Skipping result in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetOfferCardsContentStatusResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetOfferCardsContentStatusResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub status: Vec<models::ApiResponseStatusType>,
            pub result: Vec<models::OfferCardsContentStatusDto>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing GetOfferCardsContentStatusResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(<models::ApiResponseStatusType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "result" => intermediate_rep.result.push(<models::OfferCardsContentStatusDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing GetOfferCardsContentStatusResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetOfferCardsContentStatusResponse {
            status: intermediate_rep.status.into_iter().next(),
            result: intermediate_rep.result.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetOfferCardsContentStatusResponse> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<GetOfferCardsContentStatusResponse>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<GetOfferCardsContentStatusResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for GetOfferCardsContentStatusResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<GetOfferCardsContentStatusResponse> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GetOfferCardsContentStatusResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GetOfferCardsContentStatusResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Параметры товара.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetOfferDto {
    /// Ваш SKU — идентификатор товара в вашей системе.  Разрешена любая последовательность длиной до 255 знаков.  Правила использования SKU:  * У каждого товара SKU должен быть свой.  * SKU товара нельзя менять — можно только удалить товар и добавить заново с новым SKU.  * Уже заданный SKU нельзя освободить и использовать заново для другого товара. Каждый товар должен получать новый идентификатор, до того никогда не использовавшийся в вашем каталоге.  [Что такое SKU и как его назначать](https://yandex.ru/support/marketplace/assortment/add/index.html#fields) 
    #[serde(rename = "offerId")]
    #[validate(
            length(min = 1, max = 255),
           regex = "RE_GETOFFERDTO_OFFER_ID",
        )]
    pub offer_id: String,

    /// Составляйте название по схеме: тип + бренд или производитель + модель + особенности, если есть (например, цвет, размер или вес) и количество в упаковке.  Не включайте в название условия продажи (например, «скидка», «бесплатная доставка» и т. д.), эмоциональные характеристики («хит», «супер» и т. д.). Не пишите слова большими буквами — кроме устоявшихся названий брендов и моделей.  Оптимальная длина — 50–60 символов, максимальная — 256.  [Рекомендации и правила](https://yandex.ru/support/marketplace/assortment/fields/title.html) 
    #[serde(rename = "name")]
    #[validate(
            length(max = 256),
        )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

    /// Идентификатор категории на Маркете, к которой вы относите свой товар.  Если не указать `marketCategoryId`, то маркетная категория будет определена автоматически.  При изменении информации о товаре передавайте тот же идентификатор категории. Если вы укажете другой, категория товара не поменяется. Изменить ее можно только в кабинете продавца на Маркете.  Список категорий Маркета можно получить с помощью запроса  [POST categories/tree](../../reference/categories/getCategoriesTree.md). 
    #[serde(rename = "marketCategoryId")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub market_category_id: Option<i64>,

    /// Категория товара в вашем магазине. Значение будет использовано для определения категории товара на Маркете в случае, если вы не передали категорию в параметре `marketCategoryId`.  Указывайте конкретные категории — например, набор ножей лучше отнести к категории **Столовые приборы**, а не просто **Посуда**.  Выбирайте категории, которые описывают товар, а не абстрактный признак — например, **Духи**, а не **Подарки**.  Значение будет использовано для определения категории товара на Маркете в случае, если вы не передали категорию в параметре `marketCategoryId`. 
    #[serde(rename = "category")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub category: Option<String>,

    /// Ссылки на изображения товара. Изображение по первой ссылке считается основным, остальные дополнительными.  **Требования к ссылкам**  * Ссылок может быть до 30. * Указывайте ссылку целиком, включая протокол http или https. * Максимальная длина — 512 символов. * Русские буквы в URL можно. * Можно использовать прямые ссылки на изображения и на Яндекс Диск. Ссылки на Яндекс Диске нужно копировать с помощью функции **Поделиться**. Относительные ссылки и ссылки на другие облачные хранилища — не работают.  ✅ `https://example-shop.ru/images/sku12345.jpg`  ✅ `https://yadi.sk/i/NaBoRsimVOLov`  ❌ `/images/sku12345.jpg`  ❌ `https://www.dropbox.com/s/818f/tovar.jpg`  Ссылки на изображение должны быть постоянными. Нельзя использовать динамические ссылки, меняющиеся от выгрузки к выгрузке.  Если нужно заменить изображение, выложите новое изображение по новой ссылке, а ссылку на старое удалите. Если просто заменить изображение по старой ссылке, оно не обновится.  [Требования к изображениям](https://yandex.ru/support/marketplace/assortment/fields/images.html) 
    #[serde(rename = "pictures")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub pictures: Option<swagger::Nullable<Vec<String>>>,

    /// Ссылка (URL) на видео товара.  Максимальное количество ссылок — 6.  **Требования к ссылке**  * Указывайте ссылку целиком, включая протокол http или https. * Максимальная длина — 512 символов. * Русские буквы в URL можно. * Можно использовать прямые ссылки на видео и на Яндекс Диск. Ссылки на Яндекс Диске нужно копировать с помощью функции **Поделиться**. Относительные ссылки и ссылки на другие облачные хранилища — не работают.  ✅ `https://example-shop.ru/video/sku12345.avi`  ✅ `https://yadi.sk/i/NaBoRsimVOLov`  ❌ `/video/sku12345.avi`  ❌ `https://www.dropbox.com/s/818f/super-tovar.avi`  Ссылки на видео должны быть постоянными. Нельзя использовать динамические ссылки, меняющиеся от выгрузки к выгрузке.  Если нужно заменить видео, выложите новое видео по новой ссылке, а ссылку на старое удалите. Если просто заменить видео по старой ссылке, оно не обновится.  [Требования к видео](https://yandex.ru/support/marketplace/assortment/fields/video.html) 
    #[serde(rename = "videos")]
    #[validate(
            length(max = 6),
        )]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub videos: Option<swagger::Nullable<Vec<String>>>,

    /// Список инструкций по использованию товара.  Максимальное количество инструкций — 6.  Если вы передадите пустое поле `manuals`, загруженные ранее инструкции удалятся. 
    #[serde(rename = "manuals")]
    #[validate(
            length(max = 6),
        )]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub manuals: Option<swagger::Nullable<Vec<models::OfferManualDto>>>,

    /// Название бренда или производителя. Должно быть записано так, как его пишет сам бренд.
    #[serde(rename = "vendor")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub vendor: Option<String>,

    /// Указывайте в виде последовательности цифр. Подойдут коды EAN-13, EAN-8, UPC-A, UPC-E или Code 128.  Для книг указывайте ISBN.  Для товаров [определенных категорий и торговых марок](https://yastatic.net/s3/doc-binary/src/support/market/ru/yandex-market-list-for-gtin.xlsx) штрихкод должен быть действительным кодом GTIN. Обратите внимание: внутренние штрихкоды, начинающиеся на 2 или 02, и коды формата Code 128 не являются GTIN.  [Что такое GTIN](*gtin)  
    #[serde(rename = "barcodes")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub barcodes: Option<swagger::Nullable<Vec<String>>>,

    /// Подробное описание товара: например, его преимущества и особенности.  Не давайте в описании инструкций по установке и сборке. Не используйте слова «скидка», «распродажа», «дешевый», «подарок» (кроме подарочных категорий), «бесплатно», «акция», «специальная цена», «новинка», «new», «аналог», «заказ», «хит». Не указывайте никакой контактной информации и не давайте ссылок.  Можно использовать теги:  * \\<h>, \\<h1>, \\<h2> и так далее — для заголовков; * \\<br> и \\<p> — для переноса строки; * \\<ol> — для нумерованного списка; * \\<ul> — для маркированного списка; * \\<li> — для создания элементов списка (должен находиться внутри \\<ol> или \\<ul>); * \\<div> — поддерживается, но не влияет на отображение текста.  Оптимальная длина — 400–600 символов, максимальная — 6000.  [Рекомендации и правила](https://yandex.ru/support/marketplace/assortment/fields/description.html) 
    #[serde(rename = "description")]
    #[validate(
            length(max = 6000),
        )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,

    /// Страна, где был произведен товар.  Записывайте названия стран так, как они записаны в [списке](https://yastatic.net/s3/doc-binary/src/support/market/ru/countries.xlsx). 
    #[serde(rename = "manufacturerCountries")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub manufacturer_countries: Option<swagger::Nullable<Vec<String>>>,

    #[serde(rename = "weightDimensions")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub weight_dimensions: Option<models::OfferWeightDimensionsDto>,

    /// Артикул товара от производителя.
    #[serde(rename = "vendorCode")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub vendor_code: Option<String>,

    /// Метки товара, используемые магазином. Покупателям теги не видны. По тегам можно группировать и фильтровать разные товары в каталоге — например, товары одной серии, коллекции или линейки.  Максимальная длина тега 20 символов. У одного товара может быть максимум 10 тегов. Всего можно создать не больше 50 разных тегов. 
    #[serde(rename = "tags")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub tags: Option<swagger::Nullable<Vec<String>>>,

    #[serde(rename = "shelfLife")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub shelf_life: Option<models::TimePeriodDto>,

    #[serde(rename = "lifeTime")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub life_time: Option<models::TimePeriodDto>,

    #[serde(rename = "guaranteePeriod")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub guarantee_period: Option<models::TimePeriodDto>,

    /// Код товара в единой Товарной номенклатуре внешнеэкономической деятельности (ТН ВЭД) — 10 или 14 цифр без пробелов.  Обязательно укажите, если он есть. 
    #[serde(rename = "customsCommodityCode")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub customs_commodity_code: Option<String>,

    /// Номера документов на товар: сертификата, декларации соответствия и т. п.  Передавать можно только номера документов, сканы которого загружены в кабинете продавца по [инструкции](https://yandex.ru/support/marketplace/assortment/restrictions/certificates.html). 
    #[serde(rename = "certificates")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub certificates: Option<swagger::Nullable<Vec<String>>>,

    /// Количество грузовых мест.  Параметр используется, если товар представляет собой несколько коробок, упаковок и так далее. Например, кондиционер занимает два места — внешний и внутренний блоки в двух коробках.  Для товаров, занимающих одно место, не передавайте этот параметр. 
    #[serde(rename = "boxCount")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub box_count: Option<i32>,

    #[serde(rename = "condition")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub condition: Option<models::OfferConditionDto>,

    #[serde(rename = "type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub r#type: Option<models::OfferType>,

    /// Признак цифрового товара. Укажите `true`, если товар доставляется по электронной почте.  [Как работать с цифровыми товарами](../../step-by-step/digital.md) 
    #[serde(rename = "downloadable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub downloadable: Option<bool>,

    /// Параметр включает для товара пометку 18+. Устанавливайте ее только для товаров, которые относятся к удовлетворению сексуальных потребностей. 
    #[serde(rename = "adult")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub adult: Option<bool>,

    #[serde(rename = "age")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub age: Option<models::AgeDto>,

    /// {% note warning \"\" %}  Этот параметр устарел. При передаче характеристик используйте `parameterValues`.  {% endnote %}  Характеристики, которые есть только у товаров конкретной категории — например, диаметр колес велосипеда или материал подошвы обуви. 
    #[serde(rename = "params")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub params: Option<swagger::Nullable<Vec<models::OfferParamDto>>>,

    #[serde(rename = "basicPrice")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub basic_price: Option<models::GetPriceWithDiscountDto>,

    #[serde(rename = "purchasePrice")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub purchase_price: Option<models::GetPriceDto>,

    #[serde(rename = "additionalExpenses")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub additional_expenses: Option<models::GetPriceDto>,

    #[serde(rename = "cofinancePrice")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub cofinance_price: Option<models::GetPriceDto>,

    #[serde(rename = "cardStatus")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub card_status: Option<models::OfferCardStatusType>,

    /// Список магазинов, в которых размещен товар. 
    #[serde(rename = "campaigns")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub campaigns: Option<swagger::Nullable<Vec<models::OfferCampaignStatusDto>>>,

    /// Информация о том, какие для товара доступны модели размещения. 
    #[serde(rename = "sellingPrograms")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub selling_programs: Option<swagger::Nullable<Vec<models::OfferSellingProgramDto>>>,

    /// Товар помещен в архив. 
    #[serde(rename = "archived")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub archived: Option<bool>,

}

lazy_static::lazy_static! {
    static ref RE_GETOFFERDTO_OFFER_ID: regex::Regex = regex::Regex::new(r"^[^\\x00-\\x08\\x0A-\\x1f\\x7f]{1,255}$").unwrap();
}

impl GetOfferDto {
    #[allow(clippy::new_without_default)]
    pub fn new(offer_id: String, ) -> GetOfferDto {
        GetOfferDto {
            offer_id,
            name: None,
            market_category_id: None,
            category: None,
            pictures: None,
            videos: None,
            manuals: None,
            vendor: None,
            barcodes: None,
            description: None,
            manufacturer_countries: None,
            weight_dimensions: None,
            vendor_code: None,
            tags: None,
            shelf_life: None,
            life_time: None,
            guarantee_period: None,
            customs_commodity_code: None,
            certificates: None,
            box_count: None,
            condition: None,
            r#type: None,
            downloadable: None,
            adult: None,
            age: None,
            params: None,
            basic_price: None,
            purchase_price: None,
            additional_expenses: None,
            cofinance_price: None,
            card_status: None,
            campaigns: None,
            selling_programs: None,
            archived: None,
        }
    }
}

/// Converts the GetOfferDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for GetOfferDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            Some("offerId".to_string()),
            Some(self.offer_id.to_string()),


            self.name.as_ref().map(|name| {
                [
                    "name".to_string(),
                    name.to_string(),
                ].join(",")
            }),


            self.market_category_id.as_ref().map(|market_category_id| {
                [
                    "marketCategoryId".to_string(),
                    market_category_id.to_string(),
                ].join(",")
            }),


            self.category.as_ref().map(|category| {
                [
                    "category".to_string(),
                    category.to_string(),
                ].join(",")
            }),


            self.pictures.as_ref().map(|pictures| {
                [
                    "pictures".to_string(),
                    pictures.as_ref().map_or("null".to_string(), |x| x.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),
                ].join(",")
            }),


            self.videos.as_ref().map(|videos| {
                [
                    "videos".to_string(),
                    videos.as_ref().map_or("null".to_string(), |x| x.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),
                ].join(",")
            }),

            // Skipping manuals in query parameter serialization


            self.vendor.as_ref().map(|vendor| {
                [
                    "vendor".to_string(),
                    vendor.to_string(),
                ].join(",")
            }),


            self.barcodes.as_ref().map(|barcodes| {
                [
                    "barcodes".to_string(),
                    barcodes.as_ref().map_or("null".to_string(), |x| x.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),
                ].join(",")
            }),


            self.description.as_ref().map(|description| {
                [
                    "description".to_string(),
                    description.to_string(),
                ].join(",")
            }),


            self.manufacturer_countries.as_ref().map(|manufacturer_countries| {
                [
                    "manufacturerCountries".to_string(),
                    manufacturer_countries.as_ref().map_or("null".to_string(), |x| x.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),
                ].join(",")
            }),

            // Skipping weightDimensions in query parameter serialization


            self.vendor_code.as_ref().map(|vendor_code| {
                [
                    "vendorCode".to_string(),
                    vendor_code.to_string(),
                ].join(",")
            }),


            self.tags.as_ref().map(|tags| {
                [
                    "tags".to_string(),
                    tags.as_ref().map_or("null".to_string(), |x| x.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),
                ].join(",")
            }),

            // Skipping shelfLife in query parameter serialization

            // Skipping lifeTime in query parameter serialization

            // Skipping guaranteePeriod in query parameter serialization


            self.customs_commodity_code.as_ref().map(|customs_commodity_code| {
                [
                    "customsCommodityCode".to_string(),
                    customs_commodity_code.to_string(),
                ].join(",")
            }),


            self.certificates.as_ref().map(|certificates| {
                [
                    "certificates".to_string(),
                    certificates.as_ref().map_or("null".to_string(), |x| x.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),
                ].join(",")
            }),


            self.box_count.as_ref().map(|box_count| {
                [
                    "boxCount".to_string(),
                    box_count.to_string(),
                ].join(",")
            }),

            // Skipping condition in query parameter serialization

            // Skipping type in query parameter serialization


            self.downloadable.as_ref().map(|downloadable| {
                [
                    "downloadable".to_string(),
                    downloadable.to_string(),
                ].join(",")
            }),


            self.adult.as_ref().map(|adult| {
                [
                    "adult".to_string(),
                    adult.to_string(),
                ].join(",")
            }),

            // Skipping age in query parameter serialization

            // Skipping params in query parameter serialization

            // Skipping basicPrice in query parameter serialization

            // Skipping purchasePrice in query parameter serialization

            // Skipping additionalExpenses in query parameter serialization

            // Skipping cofinancePrice in query parameter serialization

            // Skipping cardStatus in query parameter serialization

            // Skipping campaigns in query parameter serialization

            // Skipping sellingPrograms in query parameter serialization


            self.archived.as_ref().map(|archived| {
                [
                    "archived".to_string(),
                    archived.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetOfferDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetOfferDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub offer_id: Vec<String>,
            pub name: Vec<String>,
            pub market_category_id: Vec<i64>,
            pub category: Vec<String>,
            pub pictures: Vec<Vec<String>>,
            pub videos: Vec<Vec<String>>,
            pub manuals: Vec<Vec<models::OfferManualDto>>,
            pub vendor: Vec<String>,
            pub barcodes: Vec<Vec<String>>,
            pub description: Vec<String>,
            pub manufacturer_countries: Vec<Vec<String>>,
            pub weight_dimensions: Vec<models::OfferWeightDimensionsDto>,
            pub vendor_code: Vec<String>,
            pub tags: Vec<Vec<String>>,
            pub shelf_life: Vec<models::TimePeriodDto>,
            pub life_time: Vec<models::TimePeriodDto>,
            pub guarantee_period: Vec<models::TimePeriodDto>,
            pub customs_commodity_code: Vec<String>,
            pub certificates: Vec<Vec<String>>,
            pub box_count: Vec<i32>,
            pub condition: Vec<models::OfferConditionDto>,
            pub r#type: Vec<models::OfferType>,
            pub downloadable: Vec<bool>,
            pub adult: Vec<bool>,
            pub age: Vec<models::AgeDto>,
            pub params: Vec<Vec<models::OfferParamDto>>,
            pub basic_price: Vec<models::GetPriceWithDiscountDto>,
            pub purchase_price: Vec<models::GetPriceDto>,
            pub additional_expenses: Vec<models::GetPriceDto>,
            pub cofinance_price: Vec<models::GetPriceDto>,
            pub card_status: Vec<models::OfferCardStatusType>,
            pub campaigns: Vec<Vec<models::OfferCampaignStatusDto>>,
            pub selling_programs: Vec<Vec<models::OfferSellingProgramDto>>,
            pub archived: Vec<bool>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing GetOfferDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "offerId" => intermediate_rep.offer_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "marketCategoryId" => intermediate_rep.market_category_id.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "category" => intermediate_rep.category.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "pictures" => return std::result::Result::Err("Parsing a container in this style is not supported in GetOfferDto".to_string()),
                    "videos" => return std::result::Result::Err("Parsing a container in this style is not supported in GetOfferDto".to_string()),
                    "manuals" => return std::result::Result::Err("Parsing a container in this style is not supported in GetOfferDto".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "vendor" => intermediate_rep.vendor.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "barcodes" => return std::result::Result::Err("Parsing a container in this style is not supported in GetOfferDto".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "description" => intermediate_rep.description.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "manufacturerCountries" => return std::result::Result::Err("Parsing a container in this style is not supported in GetOfferDto".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "weightDimensions" => intermediate_rep.weight_dimensions.push(<models::OfferWeightDimensionsDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "vendorCode" => intermediate_rep.vendor_code.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "tags" => return std::result::Result::Err("Parsing a container in this style is not supported in GetOfferDto".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "shelfLife" => intermediate_rep.shelf_life.push(<models::TimePeriodDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "lifeTime" => intermediate_rep.life_time.push(<models::TimePeriodDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "guaranteePeriod" => intermediate_rep.guarantee_period.push(<models::TimePeriodDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "customsCommodityCode" => intermediate_rep.customs_commodity_code.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "certificates" => return std::result::Result::Err("Parsing a container in this style is not supported in GetOfferDto".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "boxCount" => intermediate_rep.box_count.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "condition" => intermediate_rep.condition.push(<models::OfferConditionDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r#type.push(<models::OfferType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "downloadable" => intermediate_rep.downloadable.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "adult" => intermediate_rep.adult.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "age" => intermediate_rep.age.push(<models::AgeDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "params" => return std::result::Result::Err("Parsing a container in this style is not supported in GetOfferDto".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "basicPrice" => intermediate_rep.basic_price.push(<models::GetPriceWithDiscountDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "purchasePrice" => intermediate_rep.purchase_price.push(<models::GetPriceDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "additionalExpenses" => intermediate_rep.additional_expenses.push(<models::GetPriceDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "cofinancePrice" => intermediate_rep.cofinance_price.push(<models::GetPriceDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "cardStatus" => intermediate_rep.card_status.push(<models::OfferCardStatusType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "campaigns" => return std::result::Result::Err("Parsing a container in this style is not supported in GetOfferDto".to_string()),
                    "sellingPrograms" => return std::result::Result::Err("Parsing a container in this style is not supported in GetOfferDto".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "archived" => intermediate_rep.archived.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing GetOfferDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetOfferDto {
            offer_id: intermediate_rep.offer_id.into_iter().next().ok_or_else(|| "offerId missing in GetOfferDto".to_string())?,
            name: intermediate_rep.name.into_iter().next(),
            market_category_id: intermediate_rep.market_category_id.into_iter().next(),
            category: intermediate_rep.category.into_iter().next(),
            pictures: std::result::Result::Err("Nullable types not supported in GetOfferDto".to_string())?,
            videos: std::result::Result::Err("Nullable types not supported in GetOfferDto".to_string())?,
            manuals: std::result::Result::Err("Nullable types not supported in GetOfferDto".to_string())?,
            vendor: intermediate_rep.vendor.into_iter().next(),
            barcodes: std::result::Result::Err("Nullable types not supported in GetOfferDto".to_string())?,
            description: intermediate_rep.description.into_iter().next(),
            manufacturer_countries: std::result::Result::Err("Nullable types not supported in GetOfferDto".to_string())?,
            weight_dimensions: intermediate_rep.weight_dimensions.into_iter().next(),
            vendor_code: intermediate_rep.vendor_code.into_iter().next(),
            tags: std::result::Result::Err("Nullable types not supported in GetOfferDto".to_string())?,
            shelf_life: intermediate_rep.shelf_life.into_iter().next(),
            life_time: intermediate_rep.life_time.into_iter().next(),
            guarantee_period: intermediate_rep.guarantee_period.into_iter().next(),
            customs_commodity_code: intermediate_rep.customs_commodity_code.into_iter().next(),
            certificates: std::result::Result::Err("Nullable types not supported in GetOfferDto".to_string())?,
            box_count: intermediate_rep.box_count.into_iter().next(),
            condition: intermediate_rep.condition.into_iter().next(),
            r#type: intermediate_rep.r#type.into_iter().next(),
            downloadable: intermediate_rep.downloadable.into_iter().next(),
            adult: intermediate_rep.adult.into_iter().next(),
            age: intermediate_rep.age.into_iter().next(),
            params: std::result::Result::Err("Nullable types not supported in GetOfferDto".to_string())?,
            basic_price: intermediate_rep.basic_price.into_iter().next(),
            purchase_price: intermediate_rep.purchase_price.into_iter().next(),
            additional_expenses: intermediate_rep.additional_expenses.into_iter().next(),
            cofinance_price: intermediate_rep.cofinance_price.into_iter().next(),
            card_status: intermediate_rep.card_status.into_iter().next(),
            campaigns: std::result::Result::Err("Nullable types not supported in GetOfferDto".to_string())?,
            selling_programs: std::result::Result::Err("Nullable types not supported in GetOfferDto".to_string())?,
            archived: intermediate_rep.archived.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetOfferDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<GetOfferDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<GetOfferDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for GetOfferDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<GetOfferDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GetOfferDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GetOfferDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Информация о товаре.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetOfferMappingDto {
    #[serde(rename = "offer")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub offer: Option<models::GetOfferDto>,

    #[serde(rename = "mapping")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub mapping: Option<models::GetMappingDto>,

}


impl GetOfferMappingDto {
    #[allow(clippy::new_without_default)]
    pub fn new() -> GetOfferMappingDto {
        GetOfferMappingDto {
            offer: None,
            mapping: None,
        }
    }
}

/// Converts the GetOfferMappingDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for GetOfferMappingDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping offer in query parameter serialization

            // Skipping mapping in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetOfferMappingDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetOfferMappingDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub offer: Vec<models::GetOfferDto>,
            pub mapping: Vec<models::GetMappingDto>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing GetOfferMappingDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "offer" => intermediate_rep.offer.push(<models::GetOfferDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "mapping" => intermediate_rep.mapping.push(<models::GetMappingDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing GetOfferMappingDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetOfferMappingDto {
            offer: intermediate_rep.offer.into_iter().next(),
            mapping: intermediate_rep.mapping.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetOfferMappingDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<GetOfferMappingDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<GetOfferMappingDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for GetOfferMappingDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<GetOfferMappingDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GetOfferMappingDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GetOfferMappingDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Ответ на запрос списка товаров в каталоге.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetOfferMappingEntriesResponse {
    #[serde(rename = "status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<models::ApiResponseStatusType>,

    #[serde(rename = "result")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub result: Option<models::OfferMappingEntriesDto>,

}


impl GetOfferMappingEntriesResponse {
    #[allow(clippy::new_without_default)]
    pub fn new() -> GetOfferMappingEntriesResponse {
        GetOfferMappingEntriesResponse {
            status: None,
            result: None,
        }
    }
}

/// Converts the GetOfferMappingEntriesResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for GetOfferMappingEntriesResponse {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping status in query parameter serialization

            // Skipping result in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetOfferMappingEntriesResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetOfferMappingEntriesResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub status: Vec<models::ApiResponseStatusType>,
            pub result: Vec<models::OfferMappingEntriesDto>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing GetOfferMappingEntriesResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(<models::ApiResponseStatusType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "result" => intermediate_rep.result.push(<models::OfferMappingEntriesDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing GetOfferMappingEntriesResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetOfferMappingEntriesResponse {
            status: intermediate_rep.status.into_iter().next(),
            result: intermediate_rep.result.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetOfferMappingEntriesResponse> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<GetOfferMappingEntriesResponse>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<GetOfferMappingEntriesResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for GetOfferMappingEntriesResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<GetOfferMappingEntriesResponse> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GetOfferMappingEntriesResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GetOfferMappingEntriesResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetOfferMappingsRequest {
    /// Идентификаторы товаров, информация о которых нужна.  {% note warning \"Такой список возвращается только целиком\" %}  Если вы запрашиваете информацию по конкретным SKU, не заполняйте: * `page_token`; * `limit`; * `cardStatuses`; * `categoryIds`; * `vendorNames`; * `tags`; * `archived`.  {% endnote %}    
    #[serde(rename = "offerIds")]
    #[validate(
            length(min = 1, max = 200),
        )]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub offer_ids: Option<swagger::Nullable<Vec<models::ShopSku>>>,

    /// Фильтр по статусам карточек.  [Что такое карточка товара](https://yandex.ru/support/marketplace/assortment/content/index.html) 
    #[serde(rename = "cardStatuses")]
    #[validate(
            length(min = 1),
        )]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub card_statuses: Option<swagger::Nullable<Vec<models::OfferCardStatusType>>>,

    /// Фильтр по категориям на Маркете.
    #[serde(rename = "categoryIds")]
    #[validate(
            length(min = 1),
        )]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub category_ids: Option<swagger::Nullable<Vec<i32>>>,

    /// Фильтр по брендам.
    #[serde(rename = "vendorNames")]
    #[validate(
            length(min = 1),
        )]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub vendor_names: Option<swagger::Nullable<Vec<String>>>,

    /// Фильтр по тегам.
    #[serde(rename = "tags")]
    #[validate(
            length(min = 1),
        )]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub tags: Option<swagger::Nullable<Vec<String>>>,

    /// Фильтр по нахождению в архиве.  Передайте `true`, чтобы получить товары, находящиеся в архиве. Если фильтр не заполнен или передано `false`, в ответе возвращаются товары, не находящиеся в архиве. 
    #[serde(rename = "archived")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub archived: Option<bool>,

}


impl GetOfferMappingsRequest {
    #[allow(clippy::new_without_default)]
    pub fn new() -> GetOfferMappingsRequest {
        GetOfferMappingsRequest {
            offer_ids: None,
            card_statuses: None,
            category_ids: None,
            vendor_names: None,
            tags: None,
            archived: None,
        }
    }
}

/// Converts the GetOfferMappingsRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for GetOfferMappingsRequest {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.offer_ids.as_ref().map(|offer_ids| {
                [
                    "offerIds".to_string(),
                    offer_ids.as_ref().map_or("null".to_string(), |x| x.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),
                ].join(",")
            }),

            // Skipping cardStatuses in query parameter serialization


            self.category_ids.as_ref().map(|category_ids| {
                [
                    "categoryIds".to_string(),
                    category_ids.as_ref().map_or("null".to_string(), |x| x.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),
                ].join(",")
            }),


            self.vendor_names.as_ref().map(|vendor_names| {
                [
                    "vendorNames".to_string(),
                    vendor_names.as_ref().map_or("null".to_string(), |x| x.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),
                ].join(",")
            }),


            self.tags.as_ref().map(|tags| {
                [
                    "tags".to_string(),
                    tags.as_ref().map_or("null".to_string(), |x| x.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),
                ].join(",")
            }),


            self.archived.as_ref().map(|archived| {
                [
                    "archived".to_string(),
                    archived.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetOfferMappingsRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetOfferMappingsRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub offer_ids: Vec<Vec<models::ShopSku>>,
            pub card_statuses: Vec<Vec<models::OfferCardStatusType>>,
            pub category_ids: Vec<Vec<i32>>,
            pub vendor_names: Vec<Vec<String>>,
            pub tags: Vec<Vec<String>>,
            pub archived: Vec<bool>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing GetOfferMappingsRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "offerIds" => return std::result::Result::Err("Parsing a container in this style is not supported in GetOfferMappingsRequest".to_string()),
                    "cardStatuses" => return std::result::Result::Err("Parsing a container in this style is not supported in GetOfferMappingsRequest".to_string()),
                    "categoryIds" => return std::result::Result::Err("Parsing a container in this style is not supported in GetOfferMappingsRequest".to_string()),
                    "vendorNames" => return std::result::Result::Err("Parsing a container in this style is not supported in GetOfferMappingsRequest".to_string()),
                    "tags" => return std::result::Result::Err("Parsing a container in this style is not supported in GetOfferMappingsRequest".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "archived" => intermediate_rep.archived.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing GetOfferMappingsRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetOfferMappingsRequest {
            offer_ids: std::result::Result::Err("Nullable types not supported in GetOfferMappingsRequest".to_string())?,
            card_statuses: std::result::Result::Err("Nullable types not supported in GetOfferMappingsRequest".to_string())?,
            category_ids: std::result::Result::Err("Nullable types not supported in GetOfferMappingsRequest".to_string())?,
            vendor_names: std::result::Result::Err("Nullable types not supported in GetOfferMappingsRequest".to_string())?,
            tags: std::result::Result::Err("Nullable types not supported in GetOfferMappingsRequest".to_string())?,
            archived: intermediate_rep.archived.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetOfferMappingsRequest> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<GetOfferMappingsRequest>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<GetOfferMappingsRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for GetOfferMappingsRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<GetOfferMappingsRequest> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GetOfferMappingsRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GetOfferMappingsRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetOfferMappingsResponse {
    #[serde(rename = "status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<models::ApiResponseStatusType>,

    #[serde(rename = "result")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub result: Option<models::GetOfferMappingsResultDto>,

}


impl GetOfferMappingsResponse {
    #[allow(clippy::new_without_default)]
    pub fn new() -> GetOfferMappingsResponse {
        GetOfferMappingsResponse {
            status: None,
            result: None,
        }
    }
}

/// Converts the GetOfferMappingsResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for GetOfferMappingsResponse {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping status in query parameter serialization

            // Skipping result in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetOfferMappingsResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetOfferMappingsResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub status: Vec<models::ApiResponseStatusType>,
            pub result: Vec<models::GetOfferMappingsResultDto>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing GetOfferMappingsResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(<models::ApiResponseStatusType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "result" => intermediate_rep.result.push(<models::GetOfferMappingsResultDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing GetOfferMappingsResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetOfferMappingsResponse {
            status: intermediate_rep.status.into_iter().next(),
            result: intermediate_rep.result.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetOfferMappingsResponse> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<GetOfferMappingsResponse>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<GetOfferMappingsResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for GetOfferMappingsResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<GetOfferMappingsResponse> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GetOfferMappingsResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GetOfferMappingsResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Информация о товарах.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetOfferMappingsResultDto {
    #[serde(rename = "paging")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub paging: Option<models::ScrollingPagerDto>,

    /// Информация о товарах.
    #[serde(rename = "offerMappings")]
    pub offer_mappings: Vec<models::GetOfferMappingDto>,

}


impl GetOfferMappingsResultDto {
    #[allow(clippy::new_without_default)]
    pub fn new(offer_mappings: Vec<models::GetOfferMappingDto>, ) -> GetOfferMappingsResultDto {
        GetOfferMappingsResultDto {
            paging: None,
            offer_mappings,
        }
    }
}

/// Converts the GetOfferMappingsResultDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for GetOfferMappingsResultDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping paging in query parameter serialization

            // Skipping offerMappings in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetOfferMappingsResultDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetOfferMappingsResultDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub paging: Vec<models::ScrollingPagerDto>,
            pub offer_mappings: Vec<Vec<models::GetOfferMappingDto>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing GetOfferMappingsResultDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "paging" => intermediate_rep.paging.push(<models::ScrollingPagerDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "offerMappings" => return std::result::Result::Err("Parsing a container in this style is not supported in GetOfferMappingsResultDto".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing GetOfferMappingsResultDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetOfferMappingsResultDto {
            paging: intermediate_rep.paging.into_iter().next(),
            offer_mappings: intermediate_rep.offer_mappings.into_iter().next().ok_or_else(|| "offerMappings missing in GetOfferMappingsResultDto".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetOfferMappingsResultDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<GetOfferMappingsResultDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<GetOfferMappingsResultDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for GetOfferMappingsResultDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<GetOfferMappingsResultDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GetOfferMappingsResultDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GetOfferMappingsResultDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetOfferRecommendationsRequest {
    /// Идентификаторы товаров, информация о которых нужна. ⚠️ Не используйте это поле одновременно с остальными фильтрами. Если вы хотите воспользоваться фильтрами, оставьте поле пустым.
    #[serde(rename = "offerIds")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub offer_ids: Option<swagger::Nullable<Vec<models::ShopSku>>>,

    #[serde(rename = "cofinancePriceFilter")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub cofinance_price_filter: Option<models::FieldStateType>,

    #[serde(rename = "recommendedCofinancePriceFilter")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub recommended_cofinance_price_filter: Option<models::FieldStateType>,

    #[serde(rename = "competitivenessFilter")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub competitiveness_filter: Option<models::PriceCompetitivenessType>,

}


impl GetOfferRecommendationsRequest {
    #[allow(clippy::new_without_default)]
    pub fn new() -> GetOfferRecommendationsRequest {
        GetOfferRecommendationsRequest {
            offer_ids: None,
            cofinance_price_filter: None,
            recommended_cofinance_price_filter: None,
            competitiveness_filter: None,
        }
    }
}

/// Converts the GetOfferRecommendationsRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for GetOfferRecommendationsRequest {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.offer_ids.as_ref().map(|offer_ids| {
                [
                    "offerIds".to_string(),
                    offer_ids.as_ref().map_or("null".to_string(), |x| x.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),
                ].join(",")
            }),

            // Skipping cofinancePriceFilter in query parameter serialization

            // Skipping recommendedCofinancePriceFilter in query parameter serialization

            // Skipping competitivenessFilter in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetOfferRecommendationsRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetOfferRecommendationsRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub offer_ids: Vec<Vec<models::ShopSku>>,
            pub cofinance_price_filter: Vec<models::FieldStateType>,
            pub recommended_cofinance_price_filter: Vec<models::FieldStateType>,
            pub competitiveness_filter: Vec<models::PriceCompetitivenessType>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing GetOfferRecommendationsRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "offerIds" => return std::result::Result::Err("Parsing a container in this style is not supported in GetOfferRecommendationsRequest".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "cofinancePriceFilter" => intermediate_rep.cofinance_price_filter.push(<models::FieldStateType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "recommendedCofinancePriceFilter" => intermediate_rep.recommended_cofinance_price_filter.push(<models::FieldStateType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "competitivenessFilter" => intermediate_rep.competitiveness_filter.push(<models::PriceCompetitivenessType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing GetOfferRecommendationsRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetOfferRecommendationsRequest {
            offer_ids: std::result::Result::Err("Nullable types not supported in GetOfferRecommendationsRequest".to_string())?,
            cofinance_price_filter: intermediate_rep.cofinance_price_filter.into_iter().next(),
            recommended_cofinance_price_filter: intermediate_rep.recommended_cofinance_price_filter.into_iter().next(),
            competitiveness_filter: intermediate_rep.competitiveness_filter.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetOfferRecommendationsRequest> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<GetOfferRecommendationsRequest>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<GetOfferRecommendationsRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for GetOfferRecommendationsRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<GetOfferRecommendationsRequest> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GetOfferRecommendationsRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GetOfferRecommendationsRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetOfferRecommendationsResponse {
    #[serde(rename = "status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<models::ApiResponseStatusType>,

    #[serde(rename = "result")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub result: Option<models::OfferRecommendationsResultDto>,

}


impl GetOfferRecommendationsResponse {
    #[allow(clippy::new_without_default)]
    pub fn new() -> GetOfferRecommendationsResponse {
        GetOfferRecommendationsResponse {
            status: None,
            result: None,
        }
    }
}

/// Converts the GetOfferRecommendationsResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for GetOfferRecommendationsResponse {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping status in query parameter serialization

            // Skipping result in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetOfferRecommendationsResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetOfferRecommendationsResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub status: Vec<models::ApiResponseStatusType>,
            pub result: Vec<models::OfferRecommendationsResultDto>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing GetOfferRecommendationsResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(<models::ApiResponseStatusType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "result" => intermediate_rep.result.push(<models::OfferRecommendationsResultDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing GetOfferRecommendationsResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetOfferRecommendationsResponse {
            status: intermediate_rep.status.into_iter().next(),
            result: intermediate_rep.result.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetOfferRecommendationsResponse> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<GetOfferRecommendationsResponse>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<GetOfferRecommendationsResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for GetOfferRecommendationsResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<GetOfferRecommendationsResponse> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GetOfferRecommendationsResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GetOfferRecommendationsResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Список предложений с пагинатором.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetOffersResponse {
    /// Список предложений магазина.
    #[serde(rename = "offers")]
    pub offers: Vec<models::OfferDto>,

    #[serde(rename = "pager")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub pager: Option<models::FlippingPagerDto>,

}


impl GetOffersResponse {
    #[allow(clippy::new_without_default)]
    pub fn new(offers: Vec<models::OfferDto>, ) -> GetOffersResponse {
        GetOffersResponse {
            offers,
            pager: None,
        }
    }
}

/// Converts the GetOffersResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for GetOffersResponse {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping offers in query parameter serialization

            // Skipping pager in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetOffersResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetOffersResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub offers: Vec<Vec<models::OfferDto>>,
            pub pager: Vec<models::FlippingPagerDto>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing GetOffersResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "offers" => return std::result::Result::Err("Parsing a container in this style is not supported in GetOffersResponse".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "pager" => intermediate_rep.pager.push(<models::FlippingPagerDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing GetOffersResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetOffersResponse {
            offers: intermediate_rep.offers.into_iter().next().ok_or_else(|| "offers missing in GetOffersResponse".to_string())?,
            pager: intermediate_rep.pager.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetOffersResponse> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<GetOffersResponse>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<GetOffersResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for GetOffersResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<GetOffersResponse> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GetOffersResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GetOffersResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetOrderBuyerInfoResponse {
    #[serde(rename = "status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<models::ApiResponseStatusType>,

    #[serde(rename = "result")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub result: Option<models::OrderBuyerInfoDto>,

}


impl GetOrderBuyerInfoResponse {
    #[allow(clippy::new_without_default)]
    pub fn new() -> GetOrderBuyerInfoResponse {
        GetOrderBuyerInfoResponse {
            status: None,
            result: None,
        }
    }
}

/// Converts the GetOrderBuyerInfoResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for GetOrderBuyerInfoResponse {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping status in query parameter serialization

            // Skipping result in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetOrderBuyerInfoResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetOrderBuyerInfoResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub status: Vec<models::ApiResponseStatusType>,
            pub result: Vec<models::OrderBuyerInfoDto>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing GetOrderBuyerInfoResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(<models::ApiResponseStatusType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "result" => intermediate_rep.result.push(<models::OrderBuyerInfoDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing GetOrderBuyerInfoResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetOrderBuyerInfoResponse {
            status: intermediate_rep.status.into_iter().next(),
            result: intermediate_rep.result.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetOrderBuyerInfoResponse> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<GetOrderBuyerInfoResponse>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<GetOrderBuyerInfoResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for GetOrderBuyerInfoResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<GetOrderBuyerInfoResponse> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GetOrderBuyerInfoResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GetOrderBuyerInfoResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Ответ с информацией для печати ярлыков.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetOrderLabelsDataResponse {
    #[serde(rename = "status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<models::ApiResponseStatusType>,

    #[serde(rename = "result")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub result: Option<models::OrderLabelDto>,

}


impl GetOrderLabelsDataResponse {
    #[allow(clippy::new_without_default)]
    pub fn new() -> GetOrderLabelsDataResponse {
        GetOrderLabelsDataResponse {
            status: None,
            result: None,
        }
    }
}

/// Converts the GetOrderLabelsDataResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for GetOrderLabelsDataResponse {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping status in query parameter serialization

            // Skipping result in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetOrderLabelsDataResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetOrderLabelsDataResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub status: Vec<models::ApiResponseStatusType>,
            pub result: Vec<models::OrderLabelDto>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing GetOrderLabelsDataResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(<models::ApiResponseStatusType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "result" => intermediate_rep.result.push(<models::OrderLabelDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing GetOrderLabelsDataResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetOrderLabelsDataResponse {
            status: intermediate_rep.status.into_iter().next(),
            result: intermediate_rep.result.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetOrderLabelsDataResponse> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<GetOrderLabelsDataResponse>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<GetOrderLabelsDataResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for GetOrderLabelsDataResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<GetOrderLabelsDataResponse> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GetOrderLabelsDataResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GetOrderLabelsDataResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetOrderResponse {
    #[serde(rename = "order")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub order: Option<models::OrderDto>,

}


impl GetOrderResponse {
    #[allow(clippy::new_without_default)]
    pub fn new() -> GetOrderResponse {
        GetOrderResponse {
            order: None,
        }
    }
}

/// Converts the GetOrderResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for GetOrderResponse {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping order in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetOrderResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetOrderResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub order: Vec<models::OrderDto>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing GetOrderResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "order" => intermediate_rep.order.push(<models::OrderDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing GetOrderResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetOrderResponse {
            order: intermediate_rep.order.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetOrderResponse> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<GetOrderResponse>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<GetOrderResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for GetOrderResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<GetOrderResponse> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GetOrderResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GetOrderResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Модель для ответа API списка информации по заказам.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetOrdersResponse {
    #[serde(rename = "pager")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub pager: Option<models::FlippingPagerDto>,

    /// Модель заказа. 
    #[serde(rename = "orders")]
    pub orders: Vec<models::OrderDto>,

    #[serde(rename = "paging")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub paging: Option<models::ForwardScrollingPagerDto>,

}


impl GetOrdersResponse {
    #[allow(clippy::new_without_default)]
    pub fn new(orders: Vec<models::OrderDto>, ) -> GetOrdersResponse {
        GetOrdersResponse {
            pager: None,
            orders,
            paging: None,
        }
    }
}

/// Converts the GetOrdersResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for GetOrdersResponse {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping pager in query parameter serialization

            // Skipping orders in query parameter serialization

            // Skipping paging in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetOrdersResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetOrdersResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub pager: Vec<models::FlippingPagerDto>,
            pub orders: Vec<Vec<models::OrderDto>>,
            pub paging: Vec<models::ForwardScrollingPagerDto>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing GetOrdersResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "pager" => intermediate_rep.pager.push(<models::FlippingPagerDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "orders" => return std::result::Result::Err("Parsing a container in this style is not supported in GetOrdersResponse".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "paging" => intermediate_rep.paging.push(<models::ForwardScrollingPagerDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing GetOrdersResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetOrdersResponse {
            pager: intermediate_rep.pager.into_iter().next(),
            orders: intermediate_rep.orders.into_iter().next().ok_or_else(|| "orders missing in GetOrdersResponse".to_string())?,
            paging: intermediate_rep.paging.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetOrdersResponse> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<GetOrdersResponse>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<GetOrdersResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for GetOrdersResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<GetOrdersResponse> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GetOrdersResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GetOrdersResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Запрос информации по заказам.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetOrdersStatsRequest {
    /// Начальная дата, когда заказ был сформирован.  Формат даты: `ГГГГ‑ММ‑ДД`.  Нельзя использовать вместе с параметрами `updateFrom` и `updateTo`. 
    #[serde(rename = "dateFrom")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub date_from: Option<chrono::naive::NaiveDate>,

    /// Конечная дата, когда заказ был сформирован.  Формат даты: `ГГГГ‑ММ‑ДД`.  Нельзя использовать вместе с параметрами `updateFrom` и `updateTo`. 
    #[serde(rename = "dateTo")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub date_to: Option<chrono::naive::NaiveDate>,

    /// Начальная дата периода, за который были изменения статуса заказа.  Формат даты: `ГГГГ‑ММ‑ДД`.  Нельзя использовать вместе с параметрами `dateFrom` и `dateTo`. 
    #[serde(rename = "updateFrom")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub update_from: Option<chrono::naive::NaiveDate>,

    /// Конечная дата периода, за который были изменения статуса заказа.  Формат даты: `ГГГГ‑ММ‑ДД`.  Нельзя использовать вместе с параметрами `dateFrom` и `dateTo`. 
    #[serde(rename = "updateTo")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub update_to: Option<chrono::naive::NaiveDate>,

    /// Список идентификаторов заказов.
    #[serde(rename = "orders")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub orders: Option<swagger::Nullable<Vec<i64>>>,

    /// Список статусов заказов.
    #[serde(rename = "statuses")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub statuses: Option<swagger::Nullable<Vec<models::OrderStatsStatusType>>>,

    /// Нужно ли вернуть только те заказы, в составе которых есть хотя бы один товар с кодом идентификации [в системе «Честный ЗНАК»](https://честныйзнак.рф/):  * `true` — да. * `false` — нет. Такие коды присваиваются товарам, которые подлежат маркировке и относятся к определенным категориям. 
    #[serde(rename = "hasCis")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub has_cis: Option<bool>,

}


impl GetOrdersStatsRequest {
    #[allow(clippy::new_without_default)]
    pub fn new() -> GetOrdersStatsRequest {
        GetOrdersStatsRequest {
            date_from: None,
            date_to: None,
            update_from: None,
            update_to: None,
            orders: None,
            statuses: None,
            has_cis: None,
        }
    }
}

/// Converts the GetOrdersStatsRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for GetOrdersStatsRequest {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping dateFrom in query parameter serialization

            // Skipping dateTo in query parameter serialization

            // Skipping updateFrom in query parameter serialization

            // Skipping updateTo in query parameter serialization


            self.orders.as_ref().map(|orders| {
                [
                    "orders".to_string(),
                    orders.as_ref().map_or("null".to_string(), |x| x.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),
                ].join(",")
            }),

            // Skipping statuses in query parameter serialization


            self.has_cis.as_ref().map(|has_cis| {
                [
                    "hasCis".to_string(),
                    has_cis.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetOrdersStatsRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetOrdersStatsRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub date_from: Vec<chrono::naive::NaiveDate>,
            pub date_to: Vec<chrono::naive::NaiveDate>,
            pub update_from: Vec<chrono::naive::NaiveDate>,
            pub update_to: Vec<chrono::naive::NaiveDate>,
            pub orders: Vec<Vec<i64>>,
            pub statuses: Vec<Vec<models::OrderStatsStatusType>>,
            pub has_cis: Vec<bool>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing GetOrdersStatsRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "dateFrom" => intermediate_rep.date_from.push(<chrono::naive::NaiveDate as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "dateTo" => intermediate_rep.date_to.push(<chrono::naive::NaiveDate as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "updateFrom" => intermediate_rep.update_from.push(<chrono::naive::NaiveDate as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "updateTo" => intermediate_rep.update_to.push(<chrono::naive::NaiveDate as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "orders" => return std::result::Result::Err("Parsing a container in this style is not supported in GetOrdersStatsRequest".to_string()),
                    "statuses" => return std::result::Result::Err("Parsing a container in this style is not supported in GetOrdersStatsRequest".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "hasCis" => intermediate_rep.has_cis.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing GetOrdersStatsRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetOrdersStatsRequest {
            date_from: intermediate_rep.date_from.into_iter().next(),
            date_to: intermediate_rep.date_to.into_iter().next(),
            update_from: intermediate_rep.update_from.into_iter().next(),
            update_to: intermediate_rep.update_to.into_iter().next(),
            orders: std::result::Result::Err("Nullable types not supported in GetOrdersStatsRequest".to_string())?,
            statuses: std::result::Result::Err("Nullable types not supported in GetOrdersStatsRequest".to_string())?,
            has_cis: intermediate_rep.has_cis.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetOrdersStatsRequest> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<GetOrdersStatsRequest>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<GetOrdersStatsRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for GetOrdersStatsRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<GetOrdersStatsRequest> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GetOrdersStatsRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GetOrdersStatsRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Ответ на запрос информации по заказам.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetOrdersStatsResponse {
    #[serde(rename = "status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<models::ApiResponseStatusType>,

    #[serde(rename = "result")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub result: Option<models::OrdersStatsDto>,

}


impl GetOrdersStatsResponse {
    #[allow(clippy::new_without_default)]
    pub fn new() -> GetOrdersStatsResponse {
        GetOrdersStatsResponse {
            status: None,
            result: None,
        }
    }
}

/// Converts the GetOrdersStatsResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for GetOrdersStatsResponse {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping status in query parameter serialization

            // Skipping result in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetOrdersStatsResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetOrdersStatsResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub status: Vec<models::ApiResponseStatusType>,
            pub result: Vec<models::OrdersStatsDto>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing GetOrdersStatsResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(<models::ApiResponseStatusType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "result" => intermediate_rep.result.push(<models::OrdersStatsDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing GetOrdersStatsResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetOrdersStatsResponse {
            status: intermediate_rep.status.into_iter().next(),
            result: intermediate_rep.result.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetOrdersStatsResponse> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<GetOrdersStatsResponse>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<GetOrdersStatsResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for GetOrdersStatsResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<GetOrdersStatsResponse> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GetOrdersStatsResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GetOrdersStatsResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetOutletLicensesResponse {
    #[serde(rename = "status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<models::ApiResponseStatusType>,

    #[serde(rename = "result")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub result: Option<models::OutletLicensesResponseDto>,

}


impl GetOutletLicensesResponse {
    #[allow(clippy::new_without_default)]
    pub fn new() -> GetOutletLicensesResponse {
        GetOutletLicensesResponse {
            status: None,
            result: None,
        }
    }
}

/// Converts the GetOutletLicensesResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for GetOutletLicensesResponse {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping status in query parameter serialization

            // Skipping result in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetOutletLicensesResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetOutletLicensesResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub status: Vec<models::ApiResponseStatusType>,
            pub result: Vec<models::OutletLicensesResponseDto>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing GetOutletLicensesResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(<models::ApiResponseStatusType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "result" => intermediate_rep.result.push(<models::OutletLicensesResponseDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing GetOutletLicensesResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetOutletLicensesResponse {
            status: intermediate_rep.status.into_iter().next(),
            result: intermediate_rep.result.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetOutletLicensesResponse> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<GetOutletLicensesResponse>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<GetOutletLicensesResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for GetOutletLicensesResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<GetOutletLicensesResponse> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GetOutletLicensesResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GetOutletLicensesResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Ответ на запрос информации о точке продаж.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetOutletResponse {
    #[serde(rename = "outlet")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub outlet: Option<models::FullOutletDto>,

}


impl GetOutletResponse {
    #[allow(clippy::new_without_default)]
    pub fn new() -> GetOutletResponse {
        GetOutletResponse {
            outlet: None,
        }
    }
}

/// Converts the GetOutletResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for GetOutletResponse {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping outlet in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetOutletResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetOutletResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub outlet: Vec<models::FullOutletDto>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing GetOutletResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "outlet" => intermediate_rep.outlet.push(<models::FullOutletDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing GetOutletResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetOutletResponse {
            outlet: intermediate_rep.outlet.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetOutletResponse> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<GetOutletResponse>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<GetOutletResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for GetOutletResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<GetOutletResponse> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GetOutletResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GetOutletResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Ответ на запрос информации о точках продаж.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetOutletsResponse {
    /// Информация о точках продаж.
    #[serde(rename = "outlets")]
    pub outlets: Vec<models::FullOutletDto>,

    #[serde(rename = "paging")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub paging: Option<models::ScrollingPagerDto>,

    #[serde(rename = "pager")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub pager: Option<models::FlippingPagerDto>,

}


impl GetOutletsResponse {
    #[allow(clippy::new_without_default)]
    pub fn new(outlets: Vec<models::FullOutletDto>, ) -> GetOutletsResponse {
        GetOutletsResponse {
            outlets,
            paging: None,
            pager: None,
        }
    }
}

/// Converts the GetOutletsResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for GetOutletsResponse {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping outlets in query parameter serialization

            // Skipping paging in query parameter serialization

            // Skipping pager in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetOutletsResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetOutletsResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub outlets: Vec<Vec<models::FullOutletDto>>,
            pub paging: Vec<models::ScrollingPagerDto>,
            pub pager: Vec<models::FlippingPagerDto>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing GetOutletsResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "outlets" => return std::result::Result::Err("Parsing a container in this style is not supported in GetOutletsResponse".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "paging" => intermediate_rep.paging.push(<models::ScrollingPagerDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "pager" => intermediate_rep.pager.push(<models::FlippingPagerDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing GetOutletsResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetOutletsResponse {
            outlets: intermediate_rep.outlets.into_iter().next().ok_or_else(|| "outlets missing in GetOutletsResponse".to_string())?,
            paging: intermediate_rep.paging.into_iter().next(),
            pager: intermediate_rep.pager.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetOutletsResponse> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<GetOutletsResponse>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<GetOutletsResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for GetOutletsResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<GetOutletsResponse> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GetOutletsResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GetOutletsResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Цена с указанием времени последнего обновления.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetPriceDto {
    /// Значение.
    #[serde(rename = "value")]
    #[validate(
            range(min = 0),
        )]
    pub value: f64,

    #[serde(rename = "currencyId")]
    pub currency_id: models::CurrencyType,

    /// Время последнего обновления.
    #[serde(rename = "updatedAt")]
    pub updated_at: chrono::DateTime::<chrono::Utc>,

}


impl GetPriceDto {
    #[allow(clippy::new_without_default)]
    pub fn new(value: f64, currency_id: models::CurrencyType, updated_at: chrono::DateTime::<chrono::Utc>, ) -> GetPriceDto {
        GetPriceDto {
            value,
            currency_id,
            updated_at,
        }
    }
}

/// Converts the GetPriceDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for GetPriceDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            Some("value".to_string()),
            Some(self.value.to_string()),

            // Skipping currencyId in query parameter serialization

            // Skipping updatedAt in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetPriceDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetPriceDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub value: Vec<f64>,
            pub currency_id: Vec<models::CurrencyType>,
            pub updated_at: Vec<chrono::DateTime::<chrono::Utc>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing GetPriceDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "value" => intermediate_rep.value.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "currencyId" => intermediate_rep.currency_id.push(<models::CurrencyType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "updatedAt" => intermediate_rep.updated_at.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing GetPriceDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetPriceDto {
            value: intermediate_rep.value.into_iter().next().ok_or_else(|| "value missing in GetPriceDto".to_string())?,
            currency_id: intermediate_rep.currency_id.into_iter().next().ok_or_else(|| "currencyId missing in GetPriceDto".to_string())?,
            updated_at: intermediate_rep.updated_at.into_iter().next().ok_or_else(|| "updatedAt missing in GetPriceDto".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetPriceDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<GetPriceDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<GetPriceDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for GetPriceDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<GetPriceDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GetPriceDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GetPriceDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Цена с указанием скидки и времени последнего обновления.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetPriceWithDiscountDto {
    /// Значение.
    #[serde(rename = "value")]
    #[validate(
            range(min = 0),
        )]
    pub value: f64,

    #[serde(rename = "currencyId")]
    pub currency_id: models::CurrencyType,

    /// Цена до скидки.  Число должно быть целым. Вы можете указать цену со скидкой от 5 до 99%.  Передавайте этот параметр при каждом обновлении цены, если предоставляете скидку на товар. 
    #[serde(rename = "discountBase")]
    #[validate(
            range(min = 0),
        )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub discount_base: Option<f64>,

    /// Время последнего обновления.
    #[serde(rename = "updatedAt")]
    pub updated_at: chrono::DateTime::<chrono::Utc>,

}


impl GetPriceWithDiscountDto {
    #[allow(clippy::new_without_default)]
    pub fn new(value: f64, currency_id: models::CurrencyType, updated_at: chrono::DateTime::<chrono::Utc>, ) -> GetPriceWithDiscountDto {
        GetPriceWithDiscountDto {
            value,
            currency_id,
            discount_base: None,
            updated_at,
        }
    }
}

/// Converts the GetPriceWithDiscountDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for GetPriceWithDiscountDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            Some("value".to_string()),
            Some(self.value.to_string()),

            // Skipping currencyId in query parameter serialization


            self.discount_base.as_ref().map(|discount_base| {
                [
                    "discountBase".to_string(),
                    discount_base.to_string(),
                ].join(",")
            }),

            // Skipping updatedAt in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetPriceWithDiscountDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetPriceWithDiscountDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub value: Vec<f64>,
            pub currency_id: Vec<models::CurrencyType>,
            pub discount_base: Vec<f64>,
            pub updated_at: Vec<chrono::DateTime::<chrono::Utc>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing GetPriceWithDiscountDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "value" => intermediate_rep.value.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "currencyId" => intermediate_rep.currency_id.push(<models::CurrencyType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "discountBase" => intermediate_rep.discount_base.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "updatedAt" => intermediate_rep.updated_at.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing GetPriceWithDiscountDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetPriceWithDiscountDto {
            value: intermediate_rep.value.into_iter().next().ok_or_else(|| "value missing in GetPriceWithDiscountDto".to_string())?,
            currency_id: intermediate_rep.currency_id.into_iter().next().ok_or_else(|| "currencyId missing in GetPriceWithDiscountDto".to_string())?,
            discount_base: intermediate_rep.discount_base.into_iter().next(),
            updated_at: intermediate_rep.updated_at.into_iter().next().ok_or_else(|| "updatedAt missing in GetPriceWithDiscountDto".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetPriceWithDiscountDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<GetPriceWithDiscountDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<GetPriceWithDiscountDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for GetPriceWithDiscountDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<GetPriceWithDiscountDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GetPriceWithDiscountDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GetPriceWithDiscountDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Цена с указанием ставки НДС и времени последнего обновления.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetPriceWithVatDto {
    /// Цена на товар.
    #[serde(rename = "value")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub value: Option<f64>,

    /// Цена на товар без скидки.  Число должно быть целым. Вы можете указать цену со скидкой от 5 до 99%.  Передавайте этот параметр при каждом обновлении цены, если предоставляете скидку на товар. 
    #[serde(rename = "discountBase")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub discount_base: Option<f64>,

    #[serde(rename = "currencyId")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub currency_id: Option<models::CurrencyType>,

    /// Идентификатор ставки НДС, применяемой для товара:  * `2` — 10%. * `5` — 0%. * `6` — не облагается НДС. * `7` — 20%.  Если параметр не указан, используется ставка НДС, установленная в кабинете. 
    #[serde(rename = "vat")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub vat: Option<i32>,

    /// Время последнего обновления.
    #[serde(rename = "updatedAt")]
    pub updated_at: chrono::DateTime::<chrono::Utc>,

}


impl GetPriceWithVatDto {
    #[allow(clippy::new_without_default)]
    pub fn new(updated_at: chrono::DateTime::<chrono::Utc>, ) -> GetPriceWithVatDto {
        GetPriceWithVatDto {
            value: None,
            discount_base: None,
            currency_id: None,
            vat: None,
            updated_at,
        }
    }
}

/// Converts the GetPriceWithVatDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for GetPriceWithVatDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.value.as_ref().map(|value| {
                [
                    "value".to_string(),
                    value.to_string(),
                ].join(",")
            }),


            self.discount_base.as_ref().map(|discount_base| {
                [
                    "discountBase".to_string(),
                    discount_base.to_string(),
                ].join(",")
            }),

            // Skipping currencyId in query parameter serialization


            self.vat.as_ref().map(|vat| {
                [
                    "vat".to_string(),
                    vat.to_string(),
                ].join(",")
            }),

            // Skipping updatedAt in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetPriceWithVatDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetPriceWithVatDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub value: Vec<f64>,
            pub discount_base: Vec<f64>,
            pub currency_id: Vec<models::CurrencyType>,
            pub vat: Vec<i32>,
            pub updated_at: Vec<chrono::DateTime::<chrono::Utc>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing GetPriceWithVatDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "value" => intermediate_rep.value.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "discountBase" => intermediate_rep.discount_base.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "currencyId" => intermediate_rep.currency_id.push(<models::CurrencyType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "vat" => intermediate_rep.vat.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "updatedAt" => intermediate_rep.updated_at.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing GetPriceWithVatDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetPriceWithVatDto {
            value: intermediate_rep.value.into_iter().next(),
            discount_base: intermediate_rep.discount_base.into_iter().next(),
            currency_id: intermediate_rep.currency_id.into_iter().next(),
            vat: intermediate_rep.vat.into_iter().next(),
            updated_at: intermediate_rep.updated_at.into_iter().next().ok_or_else(|| "updatedAt missing in GetPriceWithVatDto".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetPriceWithVatDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<GetPriceWithVatDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<GetPriceWithVatDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for GetPriceWithVatDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<GetPriceWithVatDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GetPriceWithVatDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GetPriceWithVatDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Запрос списка цен.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetPricesByOfferIdsRequest {
    /// Список SKU.  {% note warning \"Такой список возвращается только целиком\" %}  Если вы запрашиваете информацию по конкретным SKU, не заполняйте:  * `page_token` * `limit`  {% endnote %}    
    #[serde(rename = "offerIds")]
    #[validate(
            length(min = 1, max = 2000),
        )]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub offer_ids: Option<swagger::Nullable<Vec<models::ShopSku>>>,

}


impl GetPricesByOfferIdsRequest {
    #[allow(clippy::new_without_default)]
    pub fn new() -> GetPricesByOfferIdsRequest {
        GetPricesByOfferIdsRequest {
            offer_ids: None,
        }
    }
}

/// Converts the GetPricesByOfferIdsRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for GetPricesByOfferIdsRequest {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.offer_ids.as_ref().map(|offer_ids| {
                [
                    "offerIds".to_string(),
                    offer_ids.as_ref().map_or("null".to_string(), |x| x.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetPricesByOfferIdsRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetPricesByOfferIdsRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub offer_ids: Vec<Vec<models::ShopSku>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing GetPricesByOfferIdsRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "offerIds" => return std::result::Result::Err("Parsing a container in this style is not supported in GetPricesByOfferIdsRequest".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing GetPricesByOfferIdsRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetPricesByOfferIdsRequest {
            offer_ids: std::result::Result::Err("Nullable types not supported in GetPricesByOfferIdsRequest".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetPricesByOfferIdsRequest> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<GetPricesByOfferIdsRequest>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<GetPricesByOfferIdsRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for GetPricesByOfferIdsRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<GetPricesByOfferIdsRequest> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GetPricesByOfferIdsRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GetPricesByOfferIdsRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Ответ на запрос списка цен.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetPricesByOfferIdsResponse {
    #[serde(rename = "status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<models::ApiResponseStatusType>,

    #[serde(rename = "result")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub result: Option<models::OfferPriceByOfferIdsListResponseDto>,

}


impl GetPricesByOfferIdsResponse {
    #[allow(clippy::new_without_default)]
    pub fn new() -> GetPricesByOfferIdsResponse {
        GetPricesByOfferIdsResponse {
            status: None,
            result: None,
        }
    }
}

/// Converts the GetPricesByOfferIdsResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for GetPricesByOfferIdsResponse {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping status in query parameter serialization

            // Skipping result in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetPricesByOfferIdsResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetPricesByOfferIdsResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub status: Vec<models::ApiResponseStatusType>,
            pub result: Vec<models::OfferPriceByOfferIdsListResponseDto>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing GetPricesByOfferIdsResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(<models::ApiResponseStatusType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "result" => intermediate_rep.result.push(<models::OfferPriceByOfferIdsListResponseDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing GetPricesByOfferIdsResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetPricesByOfferIdsResponse {
            status: intermediate_rep.status.into_iter().next(),
            result: intermediate_rep.result.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetPricesByOfferIdsResponse> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<GetPricesByOfferIdsResponse>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<GetPricesByOfferIdsResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for GetPricesByOfferIdsResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<GetPricesByOfferIdsResponse> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GetPricesByOfferIdsResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GetPricesByOfferIdsResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Ответ на запрос списка цен.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetPricesResponse {
    #[serde(rename = "status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<models::ApiResponseStatusType>,

    #[serde(rename = "result")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub result: Option<models::OfferPriceListResponseDto>,

}


impl GetPricesResponse {
    #[allow(clippy::new_without_default)]
    pub fn new() -> GetPricesResponse {
        GetPricesResponse {
            status: None,
            result: None,
        }
    }
}

/// Converts the GetPricesResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for GetPricesResponse {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping status in query parameter serialization

            // Skipping result in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetPricesResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetPricesResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub status: Vec<models::ApiResponseStatusType>,
            pub result: Vec<models::OfferPriceListResponseDto>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing GetPricesResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(<models::ApiResponseStatusType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "result" => intermediate_rep.result.push(<models::OfferPriceListResponseDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing GetPricesResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetPricesResponse {
            status: intermediate_rep.status.into_iter().next(),
            result: intermediate_rep.result.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetPricesResponse> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<GetPricesResponse>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<GetPricesResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for GetPricesResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<GetPricesResponse> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GetPricesResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GetPricesResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Информация о товарах в акции.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetPromoAssortmentInfoDto {
    /// Количество товаров, которые участвуют или участвовали в акции.  Учитываются только товары, которые были добавлены вручную.  Об автоматическом и ручном добавлении товаров в акцию читайте [в Справке Маркета для продавцов](https://yandex.ru/support2/marketplace/ru/marketing/promos/market/index). 
    #[serde(rename = "activeOffers")]
    pub active_offers: i32,

    /// Количество доступных товаров в акции.  Параметр возвращается только для текущих и будущих акций. 
    #[serde(rename = "potentialOffers")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub potential_offers: Option<i32>,

    /// Есть ли изменения в ассортименте, которые еще не применились. Сохранение изменений занимает некоторое время.  Параметр возвращается только для текущих и будущих акций. 
    #[serde(rename = "processing")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub processing: Option<bool>,

}


impl GetPromoAssortmentInfoDto {
    #[allow(clippy::new_without_default)]
    pub fn new(active_offers: i32, ) -> GetPromoAssortmentInfoDto {
        GetPromoAssortmentInfoDto {
            active_offers,
            potential_offers: None,
            processing: None,
        }
    }
}

/// Converts the GetPromoAssortmentInfoDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for GetPromoAssortmentInfoDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            Some("activeOffers".to_string()),
            Some(self.active_offers.to_string()),


            self.potential_offers.as_ref().map(|potential_offers| {
                [
                    "potentialOffers".to_string(),
                    potential_offers.to_string(),
                ].join(",")
            }),


            self.processing.as_ref().map(|processing| {
                [
                    "processing".to_string(),
                    processing.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetPromoAssortmentInfoDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetPromoAssortmentInfoDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub active_offers: Vec<i32>,
            pub potential_offers: Vec<i32>,
            pub processing: Vec<bool>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing GetPromoAssortmentInfoDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "activeOffers" => intermediate_rep.active_offers.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "potentialOffers" => intermediate_rep.potential_offers.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "processing" => intermediate_rep.processing.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing GetPromoAssortmentInfoDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetPromoAssortmentInfoDto {
            active_offers: intermediate_rep.active_offers.into_iter().next().ok_or_else(|| "activeOffers missing in GetPromoAssortmentInfoDto".to_string())?,
            potential_offers: intermediate_rep.potential_offers.into_iter().next(),
            processing: intermediate_rep.processing.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetPromoAssortmentInfoDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<GetPromoAssortmentInfoDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<GetPromoAssortmentInfoDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for GetPromoAssortmentInfoDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<GetPromoAssortmentInfoDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GetPromoAssortmentInfoDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GetPromoAssortmentInfoDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Информация об акции «Бестселлеры Маркета».
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetPromoBestsellerInfoDto {
    /// Является ли акция «Бестселлером Маркета». Подробнее об этой акции читайте [в Справке Маркета для продавцов](https://yandex.ru/support2/marketplace/ru/marketing/promos/market/bestsellers).
    #[serde(rename = "bestseller")]
    pub bestseller: bool,

    /// До какой даты можно добавить товар в акцию «Бестселлеры Маркета».  Параметр возвращается только для текущих и будущих акций «Бестселлеры Маркета». 
    #[serde(rename = "entryDeadline")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub entry_deadline: Option<chrono::DateTime::<chrono::Utc>>,

}


impl GetPromoBestsellerInfoDto {
    #[allow(clippy::new_without_default)]
    pub fn new(bestseller: bool, ) -> GetPromoBestsellerInfoDto {
        GetPromoBestsellerInfoDto {
            bestseller,
            entry_deadline: None,
        }
    }
}

/// Converts the GetPromoBestsellerInfoDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for GetPromoBestsellerInfoDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            Some("bestseller".to_string()),
            Some(self.bestseller.to_string()),

            // Skipping entryDeadline in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetPromoBestsellerInfoDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetPromoBestsellerInfoDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub bestseller: Vec<bool>,
            pub entry_deadline: Vec<chrono::DateTime::<chrono::Utc>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing GetPromoBestsellerInfoDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "bestseller" => intermediate_rep.bestseller.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "entryDeadline" => intermediate_rep.entry_deadline.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing GetPromoBestsellerInfoDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetPromoBestsellerInfoDto {
            bestseller: intermediate_rep.bestseller.into_iter().next().ok_or_else(|| "bestseller missing in GetPromoBestsellerInfoDto".to_string())?,
            entry_deadline: intermediate_rep.entry_deadline.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetPromoBestsellerInfoDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<GetPromoBestsellerInfoDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<GetPromoBestsellerInfoDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for GetPromoBestsellerInfoDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<GetPromoBestsellerInfoDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GetPromoBestsellerInfoDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GetPromoBestsellerInfoDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Ограничения в акции.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetPromoConstraintsDto {
    /// Идентификаторы складов, для которых действует акция. Товары, которые лежат на других складах, не будут продаваться по акции.  Параметр возвращается, только если в условиях акции есть ограничение по складу. 
    #[serde(rename = "warehouseIds")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub warehouse_ids: Option<swagger::Nullable<Vec<i64>>>,

}


impl GetPromoConstraintsDto {
    #[allow(clippy::new_without_default)]
    pub fn new() -> GetPromoConstraintsDto {
        GetPromoConstraintsDto {
            warehouse_ids: None,
        }
    }
}

/// Converts the GetPromoConstraintsDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for GetPromoConstraintsDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.warehouse_ids.as_ref().map(|warehouse_ids| {
                [
                    "warehouseIds".to_string(),
                    warehouse_ids.as_ref().map_or("null".to_string(), |x| x.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetPromoConstraintsDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetPromoConstraintsDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub warehouse_ids: Vec<Vec<i64>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing GetPromoConstraintsDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "warehouseIds" => return std::result::Result::Err("Parsing a container in this style is not supported in GetPromoConstraintsDto".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing GetPromoConstraintsDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetPromoConstraintsDto {
            warehouse_ids: std::result::Result::Err("Nullable types not supported in GetPromoConstraintsDto".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetPromoConstraintsDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<GetPromoConstraintsDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<GetPromoConstraintsDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for GetPromoConstraintsDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<GetPromoConstraintsDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GetPromoConstraintsDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GetPromoConstraintsDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Информация об акции.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetPromoDto {
    /// Идентификатор акции.
    #[serde(rename = "id")]
    pub id: String,

    /// Название акции.
    #[serde(rename = "name")]
    pub name: String,

    #[serde(rename = "period")]
    pub period: models::PromoPeriodDto,

    /// Участвует или участвовал ли продавец в этой акции.  Для текущих и будущих акций возвращается со значением `true`, если в акции есть товары, которые были добавлены вручную. Если товары не участвуют в акции или добавлены в нее автоматически, параметр возвращается со значением `false`.  Для прошедших акций всегда возвращается со значением `true`.  Об автоматическом и ручном добавлении товаров в акцию читайте [в Справке Маркета для продавцов](https://yandex.ru/support2/marketplace/ru/marketing/promos/market/index). 
    #[serde(rename = "participating")]
    pub participating: bool,

    #[serde(rename = "assortmentInfo")]
    pub assortment_info: models::GetPromoAssortmentInfoDto,

    #[serde(rename = "mechanicsInfo")]
    pub mechanics_info: models::GetPromoMechanicsInfoDto,

    #[serde(rename = "bestsellerInfo")]
    pub bestseller_info: models::GetPromoBestsellerInfoDto,

    /// Список каналов продвижения товаров.
    #[serde(rename = "channels")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub channels: Option<swagger::Nullable<Vec<models::ChannelType>>>,

    #[serde(rename = "constraints")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub constraints: Option<models::GetPromoConstraintsDto>,

}


impl GetPromoDto {
    #[allow(clippy::new_without_default)]
    pub fn new(id: String, name: String, period: models::PromoPeriodDto, participating: bool, assortment_info: models::GetPromoAssortmentInfoDto, mechanics_info: models::GetPromoMechanicsInfoDto, bestseller_info: models::GetPromoBestsellerInfoDto, ) -> GetPromoDto {
        GetPromoDto {
            id,
            name,
            period,
            participating,
            assortment_info,
            mechanics_info,
            bestseller_info,
            channels: None,
            constraints: None,
        }
    }
}

/// Converts the GetPromoDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for GetPromoDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            Some("id".to_string()),
            Some(self.id.to_string()),


            Some("name".to_string()),
            Some(self.name.to_string()),

            // Skipping period in query parameter serialization


            Some("participating".to_string()),
            Some(self.participating.to_string()),

            // Skipping assortmentInfo in query parameter serialization

            // Skipping mechanicsInfo in query parameter serialization

            // Skipping bestsellerInfo in query parameter serialization

            // Skipping channels in query parameter serialization

            // Skipping constraints in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetPromoDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetPromoDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub name: Vec<String>,
            pub period: Vec<models::PromoPeriodDto>,
            pub participating: Vec<bool>,
            pub assortment_info: Vec<models::GetPromoAssortmentInfoDto>,
            pub mechanics_info: Vec<models::GetPromoMechanicsInfoDto>,
            pub bestseller_info: Vec<models::GetPromoBestsellerInfoDto>,
            pub channels: Vec<Vec<models::ChannelType>>,
            pub constraints: Vec<models::GetPromoConstraintsDto>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing GetPromoDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "period" => intermediate_rep.period.push(<models::PromoPeriodDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "participating" => intermediate_rep.participating.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "assortmentInfo" => intermediate_rep.assortment_info.push(<models::GetPromoAssortmentInfoDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "mechanicsInfo" => intermediate_rep.mechanics_info.push(<models::GetPromoMechanicsInfoDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "bestsellerInfo" => intermediate_rep.bestseller_info.push(<models::GetPromoBestsellerInfoDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "channels" => return std::result::Result::Err("Parsing a container in this style is not supported in GetPromoDto".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "constraints" => intermediate_rep.constraints.push(<models::GetPromoConstraintsDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing GetPromoDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetPromoDto {
            id: intermediate_rep.id.into_iter().next().ok_or_else(|| "id missing in GetPromoDto".to_string())?,
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "name missing in GetPromoDto".to_string())?,
            period: intermediate_rep.period.into_iter().next().ok_or_else(|| "period missing in GetPromoDto".to_string())?,
            participating: intermediate_rep.participating.into_iter().next().ok_or_else(|| "participating missing in GetPromoDto".to_string())?,
            assortment_info: intermediate_rep.assortment_info.into_iter().next().ok_or_else(|| "assortmentInfo missing in GetPromoDto".to_string())?,
            mechanics_info: intermediate_rep.mechanics_info.into_iter().next().ok_or_else(|| "mechanicsInfo missing in GetPromoDto".to_string())?,
            bestseller_info: intermediate_rep.bestseller_info.into_iter().next().ok_or_else(|| "bestsellerInfo missing in GetPromoDto".to_string())?,
            channels: std::result::Result::Err("Nullable types not supported in GetPromoDto".to_string())?,
            constraints: intermediate_rep.constraints.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetPromoDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<GetPromoDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<GetPromoDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for GetPromoDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<GetPromoDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GetPromoDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GetPromoDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Информация о типе акции.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetPromoMechanicsInfoDto {
    #[serde(rename = "type")]
    pub r#type: models::MechanicsType,

    #[serde(rename = "promocodeInfo")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub promocode_info: Option<models::GetPromoPromocodeInfoDto>,

}


impl GetPromoMechanicsInfoDto {
    #[allow(clippy::new_without_default)]
    pub fn new(r#type: models::MechanicsType, ) -> GetPromoMechanicsInfoDto {
        GetPromoMechanicsInfoDto {
            r#type,
            promocode_info: None,
        }
    }
}

/// Converts the GetPromoMechanicsInfoDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for GetPromoMechanicsInfoDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping type in query parameter serialization

            // Skipping promocodeInfo in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetPromoMechanicsInfoDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetPromoMechanicsInfoDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub r#type: Vec<models::MechanicsType>,
            pub promocode_info: Vec<models::GetPromoPromocodeInfoDto>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing GetPromoMechanicsInfoDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r#type.push(<models::MechanicsType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "promocodeInfo" => intermediate_rep.promocode_info.push(<models::GetPromoPromocodeInfoDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing GetPromoMechanicsInfoDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetPromoMechanicsInfoDto {
            r#type: intermediate_rep.r#type.into_iter().next().ok_or_else(|| "type missing in GetPromoMechanicsInfoDto".to_string())?,
            promocode_info: intermediate_rep.promocode_info.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetPromoMechanicsInfoDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<GetPromoMechanicsInfoDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<GetPromoMechanicsInfoDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for GetPromoMechanicsInfoDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<GetPromoMechanicsInfoDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GetPromoMechanicsInfoDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GetPromoMechanicsInfoDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Товар, который участвует или может участвовать в акции.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetPromoOfferDto {
    /// Ваш SKU — идентификатор товара в вашей системе.  Разрешена любая последовательность длиной до 255 знаков.  Правила использования SKU:  * У каждого товара SKU должен быть свой.  * SKU товара нельзя менять — можно только удалить товар и добавить заново с новым SKU.  * Уже заданный SKU нельзя освободить и использовать заново для другого товара. Каждый товар должен получать новый идентификатор, до того никогда не использовавшийся в вашем каталоге.  [Что такое SKU и как его назначать](https://yandex.ru/support/marketplace/assortment/add/index.html#fields) 
    #[serde(rename = "offerId")]
    #[validate(
            length(min = 1, max = 255),
           regex = "RE_GETPROMOOFFERDTO_OFFER_ID",
        )]
    pub offer_id: String,

    #[serde(rename = "status")]
    pub status: models::PromoOfferParticipationStatusType,

    #[serde(rename = "params")]
    pub params: models::PromoOfferParamsDto,

    #[serde(rename = "autoParticipatingDetails")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub auto_participating_details: Option<models::PromoOfferAutoParticipatingDetailsDto>,

}

lazy_static::lazy_static! {
    static ref RE_GETPROMOOFFERDTO_OFFER_ID: regex::Regex = regex::Regex::new(r"^[^\\x00-\\x08\\x0A-\\x1f\\x7f]{1,255}$").unwrap();
}

impl GetPromoOfferDto {
    #[allow(clippy::new_without_default)]
    pub fn new(offer_id: String, status: models::PromoOfferParticipationStatusType, params: models::PromoOfferParamsDto, ) -> GetPromoOfferDto {
        GetPromoOfferDto {
            offer_id,
            status,
            params,
            auto_participating_details: None,
        }
    }
}

/// Converts the GetPromoOfferDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for GetPromoOfferDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            Some("offerId".to_string()),
            Some(self.offer_id.to_string()),

            // Skipping status in query parameter serialization

            // Skipping params in query parameter serialization

            // Skipping autoParticipatingDetails in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetPromoOfferDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetPromoOfferDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub offer_id: Vec<String>,
            pub status: Vec<models::PromoOfferParticipationStatusType>,
            pub params: Vec<models::PromoOfferParamsDto>,
            pub auto_participating_details: Vec<models::PromoOfferAutoParticipatingDetailsDto>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing GetPromoOfferDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "offerId" => intermediate_rep.offer_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(<models::PromoOfferParticipationStatusType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "params" => intermediate_rep.params.push(<models::PromoOfferParamsDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "autoParticipatingDetails" => intermediate_rep.auto_participating_details.push(<models::PromoOfferAutoParticipatingDetailsDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing GetPromoOfferDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetPromoOfferDto {
            offer_id: intermediate_rep.offer_id.into_iter().next().ok_or_else(|| "offerId missing in GetPromoOfferDto".to_string())?,
            status: intermediate_rep.status.into_iter().next().ok_or_else(|| "status missing in GetPromoOfferDto".to_string())?,
            params: intermediate_rep.params.into_iter().next().ok_or_else(|| "params missing in GetPromoOfferDto".to_string())?,
            auto_participating_details: intermediate_rep.auto_participating_details.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetPromoOfferDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<GetPromoOfferDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<GetPromoOfferDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for GetPromoOfferDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<GetPromoOfferDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GetPromoOfferDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GetPromoOfferDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Получение списка товаров, которые участвуют или могут участвовать в акции.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetPromoOffersRequest {
    /// Идентификатор акции.
    #[serde(rename = "promoId")]
    pub promo_id: String,

    #[serde(rename = "statusType")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub status_type: Option<models::PromoOfferParticipationStatusFilterType>,

}


impl GetPromoOffersRequest {
    #[allow(clippy::new_without_default)]
    pub fn new(promo_id: String, ) -> GetPromoOffersRequest {
        GetPromoOffersRequest {
            promo_id,
            status_type: None,
        }
    }
}

/// Converts the GetPromoOffersRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for GetPromoOffersRequest {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            Some("promoId".to_string()),
            Some(self.promo_id.to_string()),

            // Skipping statusType in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetPromoOffersRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetPromoOffersRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub promo_id: Vec<String>,
            pub status_type: Vec<models::PromoOfferParticipationStatusFilterType>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing GetPromoOffersRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "promoId" => intermediate_rep.promo_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "statusType" => intermediate_rep.status_type.push(<models::PromoOfferParticipationStatusFilterType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing GetPromoOffersRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetPromoOffersRequest {
            promo_id: intermediate_rep.promo_id.into_iter().next().ok_or_else(|| "promoId missing in GetPromoOffersRequest".to_string())?,
            status_type: intermediate_rep.status_type.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetPromoOffersRequest> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<GetPromoOffersRequest>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<GetPromoOffersRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for GetPromoOffersRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<GetPromoOffersRequest> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GetPromoOffersRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GetPromoOffersRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetPromoOffersResponse {
    #[serde(rename = "status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<models::ApiResponseStatusType>,

    #[serde(rename = "result")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub result: Option<models::GetPromoOffersResultDto>,

}


impl GetPromoOffersResponse {
    #[allow(clippy::new_without_default)]
    pub fn new() -> GetPromoOffersResponse {
        GetPromoOffersResponse {
            status: None,
            result: None,
        }
    }
}

/// Converts the GetPromoOffersResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for GetPromoOffersResponse {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping status in query parameter serialization

            // Skipping result in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetPromoOffersResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetPromoOffersResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub status: Vec<models::ApiResponseStatusType>,
            pub result: Vec<models::GetPromoOffersResultDto>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing GetPromoOffersResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(<models::ApiResponseStatusType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "result" => intermediate_rep.result.push(<models::GetPromoOffersResultDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing GetPromoOffersResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetPromoOffersResponse {
            status: intermediate_rep.status.into_iter().next(),
            result: intermediate_rep.result.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetPromoOffersResponse> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<GetPromoOffersResponse>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<GetPromoOffersResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for GetPromoOffersResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<GetPromoOffersResponse> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GetPromoOffersResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GetPromoOffersResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Список товаров, которые участвуют или могут участвовать в акции.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetPromoOffersResultDto {
    /// Товары, которые участвуют или могут участвовать в акции.
    #[serde(rename = "offers")]
    pub offers: Vec<models::GetPromoOfferDto>,

    #[serde(rename = "paging")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub paging: Option<models::ForwardScrollingPagerDto>,

}


impl GetPromoOffersResultDto {
    #[allow(clippy::new_without_default)]
    pub fn new(offers: Vec<models::GetPromoOfferDto>, ) -> GetPromoOffersResultDto {
        GetPromoOffersResultDto {
            offers,
            paging: None,
        }
    }
}

/// Converts the GetPromoOffersResultDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for GetPromoOffersResultDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping offers in query parameter serialization

            // Skipping paging in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetPromoOffersResultDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetPromoOffersResultDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub offers: Vec<Vec<models::GetPromoOfferDto>>,
            pub paging: Vec<models::ForwardScrollingPagerDto>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing GetPromoOffersResultDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "offers" => return std::result::Result::Err("Parsing a container in this style is not supported in GetPromoOffersResultDto".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "paging" => intermediate_rep.paging.push(<models::ForwardScrollingPagerDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing GetPromoOffersResultDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetPromoOffersResultDto {
            offers: intermediate_rep.offers.into_iter().next().ok_or_else(|| "offers missing in GetPromoOffersResultDto".to_string())?,
            paging: intermediate_rep.paging.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetPromoOffersResultDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<GetPromoOffersResultDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<GetPromoOffersResultDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for GetPromoOffersResultDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<GetPromoOffersResultDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GetPromoOffersResultDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GetPromoOffersResultDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Информация для типа `MARKET_PROMOCODE`.  Параметр заполняется только для этого типа акции. 
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetPromoPromocodeInfoDto {
    /// Промокод.
    #[serde(rename = "promocode")]
    pub promocode: String,

    /// Процент скидки по промокоду.
    #[serde(rename = "discount")]
    pub discount: i32,

}


impl GetPromoPromocodeInfoDto {
    #[allow(clippy::new_without_default)]
    pub fn new(promocode: String, discount: i32, ) -> GetPromoPromocodeInfoDto {
        GetPromoPromocodeInfoDto {
            promocode,
            discount,
        }
    }
}

/// Converts the GetPromoPromocodeInfoDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for GetPromoPromocodeInfoDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            Some("promocode".to_string()),
            Some(self.promocode.to_string()),


            Some("discount".to_string()),
            Some(self.discount.to_string()),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetPromoPromocodeInfoDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetPromoPromocodeInfoDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub promocode: Vec<String>,
            pub discount: Vec<i32>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing GetPromoPromocodeInfoDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "promocode" => intermediate_rep.promocode.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "discount" => intermediate_rep.discount.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing GetPromoPromocodeInfoDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetPromoPromocodeInfoDto {
            promocode: intermediate_rep.promocode.into_iter().next().ok_or_else(|| "promocode missing in GetPromoPromocodeInfoDto".to_string())?,
            discount: intermediate_rep.discount.into_iter().next().ok_or_else(|| "discount missing in GetPromoPromocodeInfoDto".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetPromoPromocodeInfoDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<GetPromoPromocodeInfoDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<GetPromoPromocodeInfoDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for GetPromoPromocodeInfoDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<GetPromoPromocodeInfoDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GetPromoPromocodeInfoDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GetPromoPromocodeInfoDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Фильтры для получения списка акций.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetPromosRequest {
    #[serde(rename = "participation")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub participation: Option<models::PromoParticipationType>,

    #[serde(rename = "mechanics")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub mechanics: Option<models::MechanicsType>,

}


impl GetPromosRequest {
    #[allow(clippy::new_without_default)]
    pub fn new() -> GetPromosRequest {
        GetPromosRequest {
            participation: None,
            mechanics: None,
        }
    }
}

/// Converts the GetPromosRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for GetPromosRequest {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping participation in query parameter serialization

            // Skipping mechanics in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetPromosRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetPromosRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub participation: Vec<models::PromoParticipationType>,
            pub mechanics: Vec<models::MechanicsType>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing GetPromosRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "participation" => intermediate_rep.participation.push(<models::PromoParticipationType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "mechanics" => intermediate_rep.mechanics.push(<models::MechanicsType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing GetPromosRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetPromosRequest {
            participation: intermediate_rep.participation.into_iter().next(),
            mechanics: intermediate_rep.mechanics.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetPromosRequest> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<GetPromosRequest>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<GetPromosRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for GetPromosRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<GetPromosRequest> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GetPromosRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GetPromosRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetPromosResponse {
    #[serde(rename = "status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<models::ApiResponseStatusType>,

    #[serde(rename = "result")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub result: Option<models::GetPromosResultDto>,

}


impl GetPromosResponse {
    #[allow(clippy::new_without_default)]
    pub fn new() -> GetPromosResponse {
        GetPromosResponse {
            status: None,
            result: None,
        }
    }
}

/// Converts the GetPromosResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for GetPromosResponse {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping status in query parameter serialization

            // Skipping result in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetPromosResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetPromosResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub status: Vec<models::ApiResponseStatusType>,
            pub result: Vec<models::GetPromosResultDto>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing GetPromosResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(<models::ApiResponseStatusType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "result" => intermediate_rep.result.push(<models::GetPromosResultDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing GetPromosResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetPromosResponse {
            status: intermediate_rep.status.into_iter().next(),
            result: intermediate_rep.result.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetPromosResponse> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<GetPromosResponse>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<GetPromosResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for GetPromosResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<GetPromosResponse> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GetPromosResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GetPromosResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Информация об акциях Маркета.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetPromosResultDto {
    /// Акции Маркета.
    #[serde(rename = "promos")]
    pub promos: Vec<models::GetPromoDto>,

}


impl GetPromosResultDto {
    #[allow(clippy::new_without_default)]
    pub fn new(promos: Vec<models::GetPromoDto>, ) -> GetPromosResultDto {
        GetPromosResultDto {
            promos,
        }
    }
}

/// Converts the GetPromosResultDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for GetPromosResultDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping promos in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetPromosResultDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetPromosResultDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub promos: Vec<Vec<models::GetPromoDto>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing GetPromosResultDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "promos" => return std::result::Result::Err("Parsing a container in this style is not supported in GetPromosResultDto".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing GetPromosResultDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetPromosResultDto {
            promos: intermediate_rep.promos.into_iter().next().ok_or_else(|| "promos missing in GetPromosResultDto".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetPromosResultDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<GetPromosResultDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<GetPromosResultDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for GetPromosResultDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<GetPromosResultDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GetPromosResultDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GetPromosResultDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetQualityRatingDetailsResponse {
    #[serde(rename = "status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<models::ApiResponseStatusType>,

    #[serde(rename = "result")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub result: Option<models::QualityRatingDetailsDto>,

}


impl GetQualityRatingDetailsResponse {
    #[allow(clippy::new_without_default)]
    pub fn new() -> GetQualityRatingDetailsResponse {
        GetQualityRatingDetailsResponse {
            status: None,
            result: None,
        }
    }
}

/// Converts the GetQualityRatingDetailsResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for GetQualityRatingDetailsResponse {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping status in query parameter serialization

            // Skipping result in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetQualityRatingDetailsResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetQualityRatingDetailsResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub status: Vec<models::ApiResponseStatusType>,
            pub result: Vec<models::QualityRatingDetailsDto>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing GetQualityRatingDetailsResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(<models::ApiResponseStatusType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "result" => intermediate_rep.result.push(<models::QualityRatingDetailsDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing GetQualityRatingDetailsResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetQualityRatingDetailsResponse {
            status: intermediate_rep.status.into_iter().next(),
            result: intermediate_rep.result.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetQualityRatingDetailsResponse> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<GetQualityRatingDetailsResponse>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<GetQualityRatingDetailsResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for GetQualityRatingDetailsResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<GetQualityRatingDetailsResponse> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GetQualityRatingDetailsResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GetQualityRatingDetailsResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Запрос информации по индексу качества.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetQualityRatingRequest {
    /// Начало периода.  Формат даты: `ГГГГ‑ММ‑ДД`.  Не может быть раньше 30 дней от текущей даты. 
    #[serde(rename = "dateFrom")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub date_from: Option<chrono::naive::NaiveDate>,

    /// Конец периода.  Формат даты: `ГГГГ‑ММ‑ДД`.  Не может быть позже текущей даты. 
    #[serde(rename = "dateTo")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub date_to: Option<chrono::naive::NaiveDate>,

    /// Список идентификаторов магазинов.
    #[serde(rename = "campaignIds")]
    #[validate(
            length(min = 1, max = 50),
        )]
    pub campaign_ids: Vec<i64>,

}


impl GetQualityRatingRequest {
    #[allow(clippy::new_without_default)]
    pub fn new(campaign_ids: Vec<i64>, ) -> GetQualityRatingRequest {
        GetQualityRatingRequest {
            date_from: None,
            date_to: None,
            campaign_ids,
        }
    }
}

/// Converts the GetQualityRatingRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for GetQualityRatingRequest {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping dateFrom in query parameter serialization

            // Skipping dateTo in query parameter serialization


            Some("campaignIds".to_string()),
            Some(self.campaign_ids.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetQualityRatingRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetQualityRatingRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub date_from: Vec<chrono::naive::NaiveDate>,
            pub date_to: Vec<chrono::naive::NaiveDate>,
            pub campaign_ids: Vec<Vec<i64>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing GetQualityRatingRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "dateFrom" => intermediate_rep.date_from.push(<chrono::naive::NaiveDate as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "dateTo" => intermediate_rep.date_to.push(<chrono::naive::NaiveDate as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "campaignIds" => return std::result::Result::Err("Parsing a container in this style is not supported in GetQualityRatingRequest".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing GetQualityRatingRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetQualityRatingRequest {
            date_from: intermediate_rep.date_from.into_iter().next(),
            date_to: intermediate_rep.date_to.into_iter().next(),
            campaign_ids: intermediate_rep.campaign_ids.into_iter().next().ok_or_else(|| "campaignIds missing in GetQualityRatingRequest".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetQualityRatingRequest> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<GetQualityRatingRequest>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<GetQualityRatingRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for GetQualityRatingRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<GetQualityRatingRequest> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GetQualityRatingRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GetQualityRatingRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Информация об индексе качества магазинов.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetQualityRatingResponse {
    #[serde(rename = "status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<models::ApiResponseStatusType>,

    #[serde(rename = "result")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub result: Option<models::CampaignsQualityRatingDto>,

}


impl GetQualityRatingResponse {
    #[allow(clippy::new_without_default)]
    pub fn new() -> GetQualityRatingResponse {
        GetQualityRatingResponse {
            status: None,
            result: None,
        }
    }
}

/// Converts the GetQualityRatingResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for GetQualityRatingResponse {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping status in query parameter serialization

            // Skipping result in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetQualityRatingResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetQualityRatingResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub status: Vec<models::ApiResponseStatusType>,
            pub result: Vec<models::CampaignsQualityRatingDto>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing GetQualityRatingResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(<models::ApiResponseStatusType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "result" => intermediate_rep.result.push(<models::CampaignsQualityRatingDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing GetQualityRatingResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetQualityRatingResponse {
            status: intermediate_rep.status.into_iter().next(),
            result: intermediate_rep.result.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetQualityRatingResponse> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<GetQualityRatingResponse>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<GetQualityRatingResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for GetQualityRatingResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<GetQualityRatingResponse> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GetQualityRatingResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GetQualityRatingResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Фильтрации товаров  В запросе можно указать либо фильтр offerIds, либо любые другие фильтры товаров. Совместное использование фильтра offerIds с другими фильтрациями приведет к ошибке. 
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetQuarantineOffersRequest {
    /// Идентификаторы товаров, информация о которых нужна. <br><br> ⚠️ Не используйте это поле одновременно с фильтрами по статусам карточек, категориям, брендам или тегам. Если вы хотите воспользоваться фильтрами, оставьте поле пустым. 
    #[serde(rename = "offerIds")]
    #[validate(
            length(min = 1, max = 500),
        )]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub offer_ids: Option<swagger::Nullable<Vec<models::ShopSku>>>,

    /// Фильтр по статусам карточек.  [Что такое карточка товара](https://yandex.ru/support/marketplace/assortment/content/index.html) 
    #[serde(rename = "cardStatuses")]
    #[validate(
            length(min = 1),
        )]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub card_statuses: Option<swagger::Nullable<Vec<models::OfferCardStatusType>>>,

    /// Фильтр по категориям на Маркете.
    #[serde(rename = "categoryIds")]
    #[validate(
            length(min = 1),
        )]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub category_ids: Option<swagger::Nullable<Vec<i32>>>,

    /// Фильтр по брендам.
    #[serde(rename = "vendorNames")]
    #[validate(
            length(min = 1),
        )]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub vendor_names: Option<swagger::Nullable<Vec<String>>>,

    /// Фильтр по тегам.
    #[serde(rename = "tags")]
    #[validate(
            length(min = 1),
        )]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub tags: Option<swagger::Nullable<Vec<String>>>,

}


impl GetQuarantineOffersRequest {
    #[allow(clippy::new_without_default)]
    pub fn new() -> GetQuarantineOffersRequest {
        GetQuarantineOffersRequest {
            offer_ids: None,
            card_statuses: None,
            category_ids: None,
            vendor_names: None,
            tags: None,
        }
    }
}

/// Converts the GetQuarantineOffersRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for GetQuarantineOffersRequest {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.offer_ids.as_ref().map(|offer_ids| {
                [
                    "offerIds".to_string(),
                    offer_ids.as_ref().map_or("null".to_string(), |x| x.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),
                ].join(",")
            }),

            // Skipping cardStatuses in query parameter serialization


            self.category_ids.as_ref().map(|category_ids| {
                [
                    "categoryIds".to_string(),
                    category_ids.as_ref().map_or("null".to_string(), |x| x.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),
                ].join(",")
            }),


            self.vendor_names.as_ref().map(|vendor_names| {
                [
                    "vendorNames".to_string(),
                    vendor_names.as_ref().map_or("null".to_string(), |x| x.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),
                ].join(",")
            }),


            self.tags.as_ref().map(|tags| {
                [
                    "tags".to_string(),
                    tags.as_ref().map_or("null".to_string(), |x| x.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetQuarantineOffersRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetQuarantineOffersRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub offer_ids: Vec<Vec<models::ShopSku>>,
            pub card_statuses: Vec<Vec<models::OfferCardStatusType>>,
            pub category_ids: Vec<Vec<i32>>,
            pub vendor_names: Vec<Vec<String>>,
            pub tags: Vec<Vec<String>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing GetQuarantineOffersRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "offerIds" => return std::result::Result::Err("Parsing a container in this style is not supported in GetQuarantineOffersRequest".to_string()),
                    "cardStatuses" => return std::result::Result::Err("Parsing a container in this style is not supported in GetQuarantineOffersRequest".to_string()),
                    "categoryIds" => return std::result::Result::Err("Parsing a container in this style is not supported in GetQuarantineOffersRequest".to_string()),
                    "vendorNames" => return std::result::Result::Err("Parsing a container in this style is not supported in GetQuarantineOffersRequest".to_string()),
                    "tags" => return std::result::Result::Err("Parsing a container in this style is not supported in GetQuarantineOffersRequest".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing GetQuarantineOffersRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetQuarantineOffersRequest {
            offer_ids: std::result::Result::Err("Nullable types not supported in GetQuarantineOffersRequest".to_string())?,
            card_statuses: std::result::Result::Err("Nullable types not supported in GetQuarantineOffersRequest".to_string())?,
            category_ids: std::result::Result::Err("Nullable types not supported in GetQuarantineOffersRequest".to_string())?,
            vendor_names: std::result::Result::Err("Nullable types not supported in GetQuarantineOffersRequest".to_string())?,
            tags: std::result::Result::Err("Nullable types not supported in GetQuarantineOffersRequest".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetQuarantineOffersRequest> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<GetQuarantineOffersRequest>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<GetQuarantineOffersRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for GetQuarantineOffersRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<GetQuarantineOffersRequest> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GetQuarantineOffersRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GetQuarantineOffersRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Ответ на запрос списка товаров в карантине.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetQuarantineOffersResponse {
    #[serde(rename = "status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<models::ApiResponseStatusType>,

    #[serde(rename = "result")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub result: Option<models::GetQuarantineOffersResultDto>,

}


impl GetQuarantineOffersResponse {
    #[allow(clippy::new_without_default)]
    pub fn new() -> GetQuarantineOffersResponse {
        GetQuarantineOffersResponse {
            status: None,
            result: None,
        }
    }
}

/// Converts the GetQuarantineOffersResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for GetQuarantineOffersResponse {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping status in query parameter serialization

            // Skipping result in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetQuarantineOffersResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetQuarantineOffersResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub status: Vec<models::ApiResponseStatusType>,
            pub result: Vec<models::GetQuarantineOffersResultDto>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing GetQuarantineOffersResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(<models::ApiResponseStatusType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "result" => intermediate_rep.result.push(<models::GetQuarantineOffersResultDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing GetQuarantineOffersResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetQuarantineOffersResponse {
            status: intermediate_rep.status.into_iter().next(),
            result: intermediate_rep.result.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetQuarantineOffersResponse> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<GetQuarantineOffersResponse>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<GetQuarantineOffersResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for GetQuarantineOffersResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<GetQuarantineOffersResponse> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GetQuarantineOffersResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GetQuarantineOffersResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Список товаров в карантине.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetQuarantineOffersResultDto {
    #[serde(rename = "paging")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub paging: Option<models::ScrollingPagerDto>,

    /// Страница списка товаров в карантине.
    #[serde(rename = "offers")]
    pub offers: Vec<models::QuarantineOfferDto>,

}


impl GetQuarantineOffersResultDto {
    #[allow(clippy::new_without_default)]
    pub fn new(offers: Vec<models::QuarantineOfferDto>, ) -> GetQuarantineOffersResultDto {
        GetQuarantineOffersResultDto {
            paging: None,
            offers,
        }
    }
}

/// Converts the GetQuarantineOffersResultDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for GetQuarantineOffersResultDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping paging in query parameter serialization

            // Skipping offers in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetQuarantineOffersResultDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetQuarantineOffersResultDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub paging: Vec<models::ScrollingPagerDto>,
            pub offers: Vec<Vec<models::QuarantineOfferDto>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing GetQuarantineOffersResultDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "paging" => intermediate_rep.paging.push(<models::ScrollingPagerDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "offers" => return std::result::Result::Err("Parsing a container in this style is not supported in GetQuarantineOffersResultDto".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing GetQuarantineOffersResultDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetQuarantineOffersResultDto {
            paging: intermediate_rep.paging.into_iter().next(),
            offers: intermediate_rep.offers.into_iter().next().ok_or_else(|| "offers missing in GetQuarantineOffersResultDto".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetQuarantineOffersResultDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<GetQuarantineOffersResultDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<GetQuarantineOffersResultDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for GetQuarantineOffersResultDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<GetQuarantineOffersResultDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GetQuarantineOffersResultDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GetQuarantineOffersResultDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetRegionWithChildrenResponse {
    #[serde(rename = "pager")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub pager: Option<models::FlippingPagerDto>,

    #[serde(rename = "regions")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub regions: Option<models::RegionDto>,

}


impl GetRegionWithChildrenResponse {
    #[allow(clippy::new_without_default)]
    pub fn new() -> GetRegionWithChildrenResponse {
        GetRegionWithChildrenResponse {
            pager: None,
            regions: None,
        }
    }
}

/// Converts the GetRegionWithChildrenResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for GetRegionWithChildrenResponse {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping pager in query parameter serialization

            // Skipping regions in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetRegionWithChildrenResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetRegionWithChildrenResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub pager: Vec<models::FlippingPagerDto>,
            pub regions: Vec<models::RegionDto>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing GetRegionWithChildrenResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "pager" => intermediate_rep.pager.push(<models::FlippingPagerDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "regions" => intermediate_rep.regions.push(<models::RegionDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing GetRegionWithChildrenResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetRegionWithChildrenResponse {
            pager: intermediate_rep.pager.into_iter().next(),
            regions: intermediate_rep.regions.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetRegionWithChildrenResponse> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<GetRegionWithChildrenResponse>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<GetRegionWithChildrenResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for GetRegionWithChildrenResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<GetRegionWithChildrenResponse> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GetRegionWithChildrenResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GetRegionWithChildrenResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetRegionsResponse {
    /// Регион доставки.
    #[serde(rename = "regions")]
    pub regions: Vec<models::RegionDto>,

    #[serde(rename = "paging")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub paging: Option<models::ForwardScrollingPagerDto>,

}


impl GetRegionsResponse {
    #[allow(clippy::new_without_default)]
    pub fn new(regions: Vec<models::RegionDto>, ) -> GetRegionsResponse {
        GetRegionsResponse {
            regions,
            paging: None,
        }
    }
}

/// Converts the GetRegionsResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for GetRegionsResponse {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping regions in query parameter serialization

            // Skipping paging in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetRegionsResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetRegionsResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub regions: Vec<Vec<models::RegionDto>>,
            pub paging: Vec<models::ForwardScrollingPagerDto>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing GetRegionsResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "regions" => return std::result::Result::Err("Parsing a container in this style is not supported in GetRegionsResponse".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "paging" => intermediate_rep.paging.push(<models::ForwardScrollingPagerDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing GetRegionsResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetRegionsResponse {
            regions: intermediate_rep.regions.into_iter().next().ok_or_else(|| "regions missing in GetRegionsResponse".to_string())?,
            paging: intermediate_rep.paging.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetRegionsResponse> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<GetRegionsResponse>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<GetRegionsResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for GetRegionsResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<GetRegionsResponse> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GetRegionsResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GetRegionsResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Ответ на запрос информации об отчете.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetReportInfoResponse {
    #[serde(rename = "status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<models::ApiResponseStatusType>,

    #[serde(rename = "result")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub result: Option<models::ReportInfoDto>,

}


impl GetReportInfoResponse {
    #[allow(clippy::new_without_default)]
    pub fn new() -> GetReportInfoResponse {
        GetReportInfoResponse {
            status: None,
            result: None,
        }
    }
}

/// Converts the GetReportInfoResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for GetReportInfoResponse {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping status in query parameter serialization

            // Skipping result in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetReportInfoResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetReportInfoResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub status: Vec<models::ApiResponseStatusType>,
            pub result: Vec<models::ReportInfoDto>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing GetReportInfoResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(<models::ApiResponseStatusType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "result" => intermediate_rep.result.push(<models::ReportInfoDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing GetReportInfoResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetReportInfoResponse {
            status: intermediate_rep.status.into_iter().next(),
            result: intermediate_rep.result.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetReportInfoResponse> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<GetReportInfoResponse>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<GetReportInfoResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for GetReportInfoResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<GetReportInfoResponse> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GetReportInfoResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GetReportInfoResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetReturnResponse {
    #[serde(rename = "status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<models::ApiResponseStatusType>,

    #[serde(rename = "result")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub result: Option<models::ReturnDto>,

}


impl GetReturnResponse {
    #[allow(clippy::new_without_default)]
    pub fn new() -> GetReturnResponse {
        GetReturnResponse {
            status: None,
            result: None,
        }
    }
}

/// Converts the GetReturnResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for GetReturnResponse {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping status in query parameter serialization

            // Skipping result in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetReturnResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetReturnResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub status: Vec<models::ApiResponseStatusType>,
            pub result: Vec<models::ReturnDto>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing GetReturnResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(<models::ApiResponseStatusType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "result" => intermediate_rep.result.push(<models::ReturnDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing GetReturnResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetReturnResponse {
            status: intermediate_rep.status.into_iter().next(),
            result: intermediate_rep.result.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetReturnResponse> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<GetReturnResponse>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<GetReturnResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for GetReturnResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<GetReturnResponse> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GetReturnResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GetReturnResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetReturnsResponse {
    #[serde(rename = "status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<models::ApiResponseStatusType>,

    #[serde(rename = "result")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub result: Option<models::PagedReturnsDto>,

}


impl GetReturnsResponse {
    #[allow(clippy::new_without_default)]
    pub fn new() -> GetReturnsResponse {
        GetReturnsResponse {
            status: None,
            result: None,
        }
    }
}

/// Converts the GetReturnsResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for GetReturnsResponse {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping status in query parameter serialization

            // Skipping result in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetReturnsResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetReturnsResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub status: Vec<models::ApiResponseStatusType>,
            pub result: Vec<models::PagedReturnsDto>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing GetReturnsResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(<models::ApiResponseStatusType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "result" => intermediate_rep.result.push(<models::PagedReturnsDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing GetReturnsResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetReturnsResponse {
            status: intermediate_rep.status.into_iter().next(),
            result: intermediate_rep.result.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetReturnsResponse> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<GetReturnsResponse>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<GetReturnsResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for GetReturnsResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<GetReturnsResponse> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GetReturnsResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GetReturnsResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetShipmentOrdersInfoResponse {
    #[serde(rename = "status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<models::ApiResponseStatusType>,

    #[serde(rename = "result")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub result: Option<models::OrdersShipmentInfoDto>,

}


impl GetShipmentOrdersInfoResponse {
    #[allow(clippy::new_without_default)]
    pub fn new() -> GetShipmentOrdersInfoResponse {
        GetShipmentOrdersInfoResponse {
            status: None,
            result: None,
        }
    }
}

/// Converts the GetShipmentOrdersInfoResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for GetShipmentOrdersInfoResponse {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping status in query parameter serialization

            // Skipping result in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetShipmentOrdersInfoResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetShipmentOrdersInfoResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub status: Vec<models::ApiResponseStatusType>,
            pub result: Vec<models::OrdersShipmentInfoDto>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing GetShipmentOrdersInfoResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(<models::ApiResponseStatusType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "result" => intermediate_rep.result.push(<models::OrdersShipmentInfoDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing GetShipmentOrdersInfoResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetShipmentOrdersInfoResponse {
            status: intermediate_rep.status.into_iter().next(),
            result: intermediate_rep.result.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetShipmentOrdersInfoResponse> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<GetShipmentOrdersInfoResponse>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<GetShipmentOrdersInfoResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for GetShipmentOrdersInfoResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<GetShipmentOrdersInfoResponse> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GetShipmentOrdersInfoResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GetShipmentOrdersInfoResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetShipmentResponse {
    #[serde(rename = "status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<models::ApiResponseStatusType>,

    #[serde(rename = "result")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub result: Option<models::ShipmentDto>,

}


impl GetShipmentResponse {
    #[allow(clippy::new_without_default)]
    pub fn new() -> GetShipmentResponse {
        GetShipmentResponse {
            status: None,
            result: None,
        }
    }
}

/// Converts the GetShipmentResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for GetShipmentResponse {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping status in query parameter serialization

            // Skipping result in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetShipmentResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetShipmentResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub status: Vec<models::ApiResponseStatusType>,
            pub result: Vec<models::ShipmentDto>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing GetShipmentResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(<models::ApiResponseStatusType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "result" => intermediate_rep.result.push(<models::ShipmentDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing GetShipmentResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetShipmentResponse {
            status: intermediate_rep.status.into_iter().next(),
            result: intermediate_rep.result.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetShipmentResponse> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<GetShipmentResponse>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<GetShipmentResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for GetShipmentResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<GetShipmentResponse> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GetShipmentResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GetShipmentResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Запрос рекомендованных карточек товара.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetSuggestedOfferMappingEntriesRequest {
    /// Список товаров.
    #[serde(rename = "offers")]
    #[validate(
            length(min = 1, max = 500),
        )]
    pub offers: Vec<models::MappingsOfferDto>,

}


impl GetSuggestedOfferMappingEntriesRequest {
    #[allow(clippy::new_without_default)]
    pub fn new(offers: Vec<models::MappingsOfferDto>, ) -> GetSuggestedOfferMappingEntriesRequest {
        GetSuggestedOfferMappingEntriesRequest {
            offers,
        }
    }
}

/// Converts the GetSuggestedOfferMappingEntriesRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for GetSuggestedOfferMappingEntriesRequest {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping offers in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetSuggestedOfferMappingEntriesRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetSuggestedOfferMappingEntriesRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub offers: Vec<Vec<models::MappingsOfferDto>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing GetSuggestedOfferMappingEntriesRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "offers" => return std::result::Result::Err("Parsing a container in this style is not supported in GetSuggestedOfferMappingEntriesRequest".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing GetSuggestedOfferMappingEntriesRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetSuggestedOfferMappingEntriesRequest {
            offers: intermediate_rep.offers.into_iter().next().ok_or_else(|| "offers missing in GetSuggestedOfferMappingEntriesRequest".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetSuggestedOfferMappingEntriesRequest> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<GetSuggestedOfferMappingEntriesRequest>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<GetSuggestedOfferMappingEntriesRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for GetSuggestedOfferMappingEntriesRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<GetSuggestedOfferMappingEntriesRequest> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GetSuggestedOfferMappingEntriesRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GetSuggestedOfferMappingEntriesRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Ответ со списком рекомендованных карточек товара.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetSuggestedOfferMappingEntriesResponse {
    #[serde(rename = "status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<models::ApiResponseStatusType>,

    #[serde(rename = "result")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub result: Option<models::OfferMappingSuggestionsListDto>,

}


impl GetSuggestedOfferMappingEntriesResponse {
    #[allow(clippy::new_without_default)]
    pub fn new() -> GetSuggestedOfferMappingEntriesResponse {
        GetSuggestedOfferMappingEntriesResponse {
            status: None,
            result: None,
        }
    }
}

/// Converts the GetSuggestedOfferMappingEntriesResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for GetSuggestedOfferMappingEntriesResponse {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping status in query parameter serialization

            // Skipping result in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetSuggestedOfferMappingEntriesResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetSuggestedOfferMappingEntriesResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub status: Vec<models::ApiResponseStatusType>,
            pub result: Vec<models::OfferMappingSuggestionsListDto>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing GetSuggestedOfferMappingEntriesResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(<models::ApiResponseStatusType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "result" => intermediate_rep.result.push(<models::OfferMappingSuggestionsListDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing GetSuggestedOfferMappingEntriesResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetSuggestedOfferMappingEntriesResponse {
            status: intermediate_rep.status.into_iter().next(),
            result: intermediate_rep.result.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetSuggestedOfferMappingEntriesResponse> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<GetSuggestedOfferMappingEntriesResponse>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<GetSuggestedOfferMappingEntriesResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for GetSuggestedOfferMappingEntriesResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<GetSuggestedOfferMappingEntriesResponse> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GetSuggestedOfferMappingEntriesResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GetSuggestedOfferMappingEntriesResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetSuggestedOfferMappingsRequest {
    /// Список товаров.
    #[serde(rename = "offers")]
    #[validate(
            length(min = 1, max = 500),
        )]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub offers: Option<swagger::Nullable<Vec<models::SuggestedOfferDto>>>,

}


impl GetSuggestedOfferMappingsRequest {
    #[allow(clippy::new_without_default)]
    pub fn new() -> GetSuggestedOfferMappingsRequest {
        GetSuggestedOfferMappingsRequest {
            offers: None,
        }
    }
}

/// Converts the GetSuggestedOfferMappingsRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for GetSuggestedOfferMappingsRequest {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping offers in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetSuggestedOfferMappingsRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetSuggestedOfferMappingsRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub offers: Vec<Vec<models::SuggestedOfferDto>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing GetSuggestedOfferMappingsRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "offers" => return std::result::Result::Err("Parsing a container in this style is not supported in GetSuggestedOfferMappingsRequest".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing GetSuggestedOfferMappingsRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetSuggestedOfferMappingsRequest {
            offers: std::result::Result::Err("Nullable types not supported in GetSuggestedOfferMappingsRequest".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetSuggestedOfferMappingsRequest> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<GetSuggestedOfferMappingsRequest>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<GetSuggestedOfferMappingsRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for GetSuggestedOfferMappingsRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<GetSuggestedOfferMappingsRequest> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GetSuggestedOfferMappingsRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GetSuggestedOfferMappingsRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetSuggestedOfferMappingsResponse {
    #[serde(rename = "status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<models::ApiResponseStatusType>,

    #[serde(rename = "result")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub result: Option<models::GetSuggestedOfferMappingsResultDto>,

}


impl GetSuggestedOfferMappingsResponse {
    #[allow(clippy::new_without_default)]
    pub fn new() -> GetSuggestedOfferMappingsResponse {
        GetSuggestedOfferMappingsResponse {
            status: None,
            result: None,
        }
    }
}

/// Converts the GetSuggestedOfferMappingsResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for GetSuggestedOfferMappingsResponse {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping status in query parameter serialization

            // Skipping result in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetSuggestedOfferMappingsResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetSuggestedOfferMappingsResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub status: Vec<models::ApiResponseStatusType>,
            pub result: Vec<models::GetSuggestedOfferMappingsResultDto>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing GetSuggestedOfferMappingsResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(<models::ApiResponseStatusType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "result" => intermediate_rep.result.push(<models::GetSuggestedOfferMappingsResultDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing GetSuggestedOfferMappingsResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetSuggestedOfferMappingsResponse {
            status: intermediate_rep.status.into_iter().next(),
            result: intermediate_rep.result.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetSuggestedOfferMappingsResponse> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<GetSuggestedOfferMappingsResponse>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<GetSuggestedOfferMappingsResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for GetSuggestedOfferMappingsResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<GetSuggestedOfferMappingsResponse> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GetSuggestedOfferMappingsResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GetSuggestedOfferMappingsResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Подобранные карточки на Маркете.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetSuggestedOfferMappingsResultDto {
    /// Список товаров.
    #[serde(rename = "offers")]
    pub offers: Vec<models::SuggestedOfferMappingDto>,

}


impl GetSuggestedOfferMappingsResultDto {
    #[allow(clippy::new_without_default)]
    pub fn new(offers: Vec<models::SuggestedOfferMappingDto>, ) -> GetSuggestedOfferMappingsResultDto {
        GetSuggestedOfferMappingsResultDto {
            offers,
        }
    }
}

/// Converts the GetSuggestedOfferMappingsResultDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for GetSuggestedOfferMappingsResultDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping offers in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetSuggestedOfferMappingsResultDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetSuggestedOfferMappingsResultDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub offers: Vec<Vec<models::SuggestedOfferMappingDto>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing GetSuggestedOfferMappingsResultDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "offers" => return std::result::Result::Err("Parsing a container in this style is not supported in GetSuggestedOfferMappingsResultDto".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing GetSuggestedOfferMappingsResultDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetSuggestedOfferMappingsResultDto {
            offers: intermediate_rep.offers.into_iter().next().ok_or_else(|| "offers missing in GetSuggestedOfferMappingsResultDto".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetSuggestedOfferMappingsResultDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<GetSuggestedOfferMappingsResultDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<GetSuggestedOfferMappingsResultDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for GetSuggestedOfferMappingsResultDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<GetSuggestedOfferMappingsResultDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GetSuggestedOfferMappingsResultDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GetSuggestedOfferMappingsResultDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Список складов с информацией об остатках на каждом из них.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetWarehouseStocksDto {
    #[serde(rename = "paging")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub paging: Option<models::ScrollingPagerDto>,

    /// Страница списка складов.
    #[serde(rename = "warehouses")]
    pub warehouses: Vec<models::WarehouseOffersDto>,

}


impl GetWarehouseStocksDto {
    #[allow(clippy::new_without_default)]
    pub fn new(warehouses: Vec<models::WarehouseOffersDto>, ) -> GetWarehouseStocksDto {
        GetWarehouseStocksDto {
            paging: None,
            warehouses,
        }
    }
}

/// Converts the GetWarehouseStocksDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for GetWarehouseStocksDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping paging in query parameter serialization

            // Skipping warehouses in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetWarehouseStocksDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetWarehouseStocksDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub paging: Vec<models::ScrollingPagerDto>,
            pub warehouses: Vec<Vec<models::WarehouseOffersDto>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing GetWarehouseStocksDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "paging" => intermediate_rep.paging.push(<models::ScrollingPagerDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "warehouses" => return std::result::Result::Err("Parsing a container in this style is not supported in GetWarehouseStocksDto".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing GetWarehouseStocksDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetWarehouseStocksDto {
            paging: intermediate_rep.paging.into_iter().next(),
            warehouses: intermediate_rep.warehouses.into_iter().next().ok_or_else(|| "warehouses missing in GetWarehouseStocksDto".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetWarehouseStocksDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<GetWarehouseStocksDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<GetWarehouseStocksDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for GetWarehouseStocksDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<GetWarehouseStocksDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GetWarehouseStocksDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GetWarehouseStocksDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Фильтры для запроса остатков. 
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetWarehouseStocksRequest {
    /// **Только для модели FBY**  Возвращать ли информацию по оборачиваемости.  Значение по умолчанию — `false`. Если информация нужна, передайте значение `true`. 
    #[serde(rename = "withTurnover")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub with_turnover: Option<bool>,

    /// Фильтр по нахождению в архиве.  Передайте `true`, чтобы получить информацию об остатках товаров, которые находятся в архиве. Если фильтр не заполнен или передано `false`, в ответе возвращается информация о товарах, которые не находятся в архиве. 
    #[serde(rename = "archived")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub archived: Option<bool>,

    /// Фильтр по вашим SKU товаров.  Возвращается информация об остатках всех переданных SKU, включая товары в архиве.  {% note warning \"Такой список возвращается только целиком\" %}  Если вы запрашиваете информацию по конкретным SKU, не заполняйте:  * `page_token` * `limit` * `archived`  {% endnote %}    
    #[serde(rename = "offerIds")]
    #[validate(
            length(max = 500),
        )]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub offer_ids: Option<swagger::Nullable<Vec<models::ShopSku>>>,

}


impl GetWarehouseStocksRequest {
    #[allow(clippy::new_without_default)]
    pub fn new() -> GetWarehouseStocksRequest {
        GetWarehouseStocksRequest {
            with_turnover: Some(false),
            archived: None,
            offer_ids: None,
        }
    }
}

/// Converts the GetWarehouseStocksRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for GetWarehouseStocksRequest {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.with_turnover.as_ref().map(|with_turnover| {
                [
                    "withTurnover".to_string(),
                    with_turnover.to_string(),
                ].join(",")
            }),


            self.archived.as_ref().map(|archived| {
                [
                    "archived".to_string(),
                    archived.to_string(),
                ].join(",")
            }),


            self.offer_ids.as_ref().map(|offer_ids| {
                [
                    "offerIds".to_string(),
                    offer_ids.as_ref().map_or("null".to_string(), |x| x.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetWarehouseStocksRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetWarehouseStocksRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub with_turnover: Vec<bool>,
            pub archived: Vec<bool>,
            pub offer_ids: Vec<Vec<models::ShopSku>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing GetWarehouseStocksRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "withTurnover" => intermediate_rep.with_turnover.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "archived" => intermediate_rep.archived.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "offerIds" => return std::result::Result::Err("Parsing a container in this style is not supported in GetWarehouseStocksRequest".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing GetWarehouseStocksRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetWarehouseStocksRequest {
            with_turnover: intermediate_rep.with_turnover.into_iter().next(),
            archived: intermediate_rep.archived.into_iter().next(),
            offer_ids: std::result::Result::Err("Nullable types not supported in GetWarehouseStocksRequest".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetWarehouseStocksRequest> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<GetWarehouseStocksRequest>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<GetWarehouseStocksRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for GetWarehouseStocksRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<GetWarehouseStocksRequest> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GetWarehouseStocksRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GetWarehouseStocksRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetWarehouseStocksResponse {
    #[serde(rename = "status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<models::ApiResponseStatusType>,

    #[serde(rename = "result")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub result: Option<models::GetWarehouseStocksDto>,

}


impl GetWarehouseStocksResponse {
    #[allow(clippy::new_without_default)]
    pub fn new() -> GetWarehouseStocksResponse {
        GetWarehouseStocksResponse {
            status: None,
            result: None,
        }
    }
}

/// Converts the GetWarehouseStocksResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for GetWarehouseStocksResponse {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping status in query parameter serialization

            // Skipping result in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetWarehouseStocksResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetWarehouseStocksResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub status: Vec<models::ApiResponseStatusType>,
            pub result: Vec<models::GetWarehouseStocksDto>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing GetWarehouseStocksResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(<models::ApiResponseStatusType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "result" => intermediate_rep.result.push(<models::GetWarehouseStocksDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing GetWarehouseStocksResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetWarehouseStocksResponse {
            status: intermediate_rep.status.into_iter().next(),
            result: intermediate_rep.result.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetWarehouseStocksResponse> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<GetWarehouseStocksResponse>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<GetWarehouseStocksResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for GetWarehouseStocksResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<GetWarehouseStocksResponse> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GetWarehouseStocksResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GetWarehouseStocksResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetWarehousesResponse {
    #[serde(rename = "status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<models::ApiResponseStatusType>,

    #[serde(rename = "result")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub result: Option<models::WarehousesDto>,

}


impl GetWarehousesResponse {
    #[allow(clippy::new_without_default)]
    pub fn new() -> GetWarehousesResponse {
        GetWarehousesResponse {
            status: None,
            result: None,
        }
    }
}

/// Converts the GetWarehousesResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for GetWarehousesResponse {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping status in query parameter serialization

            // Skipping result in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetWarehousesResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetWarehousesResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub status: Vec<models::ApiResponseStatusType>,
            pub result: Vec<models::WarehousesDto>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing GetWarehousesResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(<models::ApiResponseStatusType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "result" => intermediate_rep.result.push(<models::WarehousesDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing GetWarehousesResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetWarehousesResponse {
            status: intermediate_rep.status.into_iter().next(),
            result: intermediate_rep.result.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetWarehousesResponse> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<GetWarehousesResponse>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<GetWarehousesResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for GetWarehousesResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<GetWarehousesResponse> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GetWarehousesResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GetWarehousesResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Информация об авторе комментария.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GoodsFeedbackCommentAuthorDto {
    #[serde(rename = "type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub r#type: Option<models::GoodsFeedbackCommentAuthorType>,

    /// Имя автора или название кабинета.
    #[serde(rename = "name")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

}


impl GoodsFeedbackCommentAuthorDto {
    #[allow(clippy::new_without_default)]
    pub fn new() -> GoodsFeedbackCommentAuthorDto {
        GoodsFeedbackCommentAuthorDto {
            r#type: None,
            name: None,
        }
    }
}

/// Converts the GoodsFeedbackCommentAuthorDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for GoodsFeedbackCommentAuthorDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping type in query parameter serialization


            self.name.as_ref().map(|name| {
                [
                    "name".to_string(),
                    name.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GoodsFeedbackCommentAuthorDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GoodsFeedbackCommentAuthorDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub r#type: Vec<models::GoodsFeedbackCommentAuthorType>,
            pub name: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing GoodsFeedbackCommentAuthorDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r#type.push(<models::GoodsFeedbackCommentAuthorType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing GoodsFeedbackCommentAuthorDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GoodsFeedbackCommentAuthorDto {
            r#type: intermediate_rep.r#type.into_iter().next(),
            name: intermediate_rep.name.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GoodsFeedbackCommentAuthorDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<GoodsFeedbackCommentAuthorDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<GoodsFeedbackCommentAuthorDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for GoodsFeedbackCommentAuthorDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<GoodsFeedbackCommentAuthorDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GoodsFeedbackCommentAuthorDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GoodsFeedbackCommentAuthorDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Тип автора:  * `USER` — пользователь. * `BUSINESS` — кабинет. 
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum GoodsFeedbackCommentAuthorType {
    #[serde(rename = "USER")]
    User,
    #[serde(rename = "BUSINESS")]
    Business,
}

impl std::fmt::Display for GoodsFeedbackCommentAuthorType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            GoodsFeedbackCommentAuthorType::User => write!(f, "USER"),
            GoodsFeedbackCommentAuthorType::Business => write!(f, "BUSINESS"),
        }
    }
}

impl std::str::FromStr for GoodsFeedbackCommentAuthorType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "USER" => std::result::Result::Ok(GoodsFeedbackCommentAuthorType::User),
            "BUSINESS" => std::result::Result::Ok(GoodsFeedbackCommentAuthorType::Business),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Комментарий к отзыву.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GoodsFeedbackCommentDto {
    /// Идентификатор комментария к отзыву. 
    #[serde(rename = "id")]
    pub id: i64,

    /// Текст комментария.
    #[serde(rename = "text")]
    #[validate(
            length(min = 1, max = 4096),
        )]
    pub text: String,

    /// Может ли продавец изменять комментарий или удалять его.
    #[serde(rename = "canModify")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub can_modify: Option<bool>,

    /// Идентификатор комментария к отзыву. 
    #[serde(rename = "parentId")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub parent_id: Option<i64>,

    #[serde(rename = "author")]
    pub author: models::GoodsFeedbackCommentAuthorDto,

    #[serde(rename = "status")]
    pub status: models::GoodsFeedbackCommentStatusType,

}


impl GoodsFeedbackCommentDto {
    #[allow(clippy::new_without_default)]
    pub fn new(id: i64, text: String, author: models::GoodsFeedbackCommentAuthorDto, status: models::GoodsFeedbackCommentStatusType, ) -> GoodsFeedbackCommentDto {
        GoodsFeedbackCommentDto {
            id,
            text,
            can_modify: None,
            parent_id: None,
            author,
            status,
        }
    }
}

/// Converts the GoodsFeedbackCommentDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for GoodsFeedbackCommentDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            Some("id".to_string()),
            Some(self.id.to_string()),


            Some("text".to_string()),
            Some(self.text.to_string()),


            self.can_modify.as_ref().map(|can_modify| {
                [
                    "canModify".to_string(),
                    can_modify.to_string(),
                ].join(",")
            }),


            self.parent_id.as_ref().map(|parent_id| {
                [
                    "parentId".to_string(),
                    parent_id.to_string(),
                ].join(",")
            }),

            // Skipping author in query parameter serialization

            // Skipping status in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GoodsFeedbackCommentDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GoodsFeedbackCommentDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<i64>,
            pub text: Vec<String>,
            pub can_modify: Vec<bool>,
            pub parent_id: Vec<i64>,
            pub author: Vec<models::GoodsFeedbackCommentAuthorDto>,
            pub status: Vec<models::GoodsFeedbackCommentStatusType>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing GoodsFeedbackCommentDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "text" => intermediate_rep.text.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "canModify" => intermediate_rep.can_modify.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "parentId" => intermediate_rep.parent_id.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "author" => intermediate_rep.author.push(<models::GoodsFeedbackCommentAuthorDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(<models::GoodsFeedbackCommentStatusType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing GoodsFeedbackCommentDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GoodsFeedbackCommentDto {
            id: intermediate_rep.id.into_iter().next().ok_or_else(|| "id missing in GoodsFeedbackCommentDto".to_string())?,
            text: intermediate_rep.text.into_iter().next().ok_or_else(|| "text missing in GoodsFeedbackCommentDto".to_string())?,
            can_modify: intermediate_rep.can_modify.into_iter().next(),
            parent_id: intermediate_rep.parent_id.into_iter().next(),
            author: intermediate_rep.author.into_iter().next().ok_or_else(|| "author missing in GoodsFeedbackCommentDto".to_string())?,
            status: intermediate_rep.status.into_iter().next().ok_or_else(|| "status missing in GoodsFeedbackCommentDto".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GoodsFeedbackCommentDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<GoodsFeedbackCommentDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<GoodsFeedbackCommentDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for GoodsFeedbackCommentDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<GoodsFeedbackCommentDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GoodsFeedbackCommentDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GoodsFeedbackCommentDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Идентификатор комментария к отзыву. 
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GoodsFeedbackCommentId(i64);

impl std::convert::From<i64> for GoodsFeedbackCommentId {
    fn from(x: i64) -> Self {
        GoodsFeedbackCommentId(x)
    }
}

impl std::convert::From<GoodsFeedbackCommentId> for i64 {
    fn from(x: GoodsFeedbackCommentId) -> Self {
        x.0
    }
}

impl std::ops::Deref for GoodsFeedbackCommentId {
    type Target = i64;
    fn deref(&self) -> &i64 {
        &self.0
    }
}

impl std::ops::DerefMut for GoodsFeedbackCommentId {
    fn deref_mut(&mut self) -> &mut i64 {
        &mut self.0
    }
}


/// Комментарии к отзыву.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GoodsFeedbackCommentListDto {
    /// Список комментариев.
    #[serde(rename = "comments")]
    pub comments: Vec<models::GoodsFeedbackCommentDto>,

    #[serde(rename = "paging")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub paging: Option<models::ForwardScrollingPagerDto>,

}


impl GoodsFeedbackCommentListDto {
    #[allow(clippy::new_without_default)]
    pub fn new(comments: Vec<models::GoodsFeedbackCommentDto>, ) -> GoodsFeedbackCommentListDto {
        GoodsFeedbackCommentListDto {
            comments,
            paging: None,
        }
    }
}

/// Converts the GoodsFeedbackCommentListDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for GoodsFeedbackCommentListDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping comments in query parameter serialization

            // Skipping paging in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GoodsFeedbackCommentListDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GoodsFeedbackCommentListDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub comments: Vec<Vec<models::GoodsFeedbackCommentDto>>,
            pub paging: Vec<models::ForwardScrollingPagerDto>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing GoodsFeedbackCommentListDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "comments" => return std::result::Result::Err("Parsing a container in this style is not supported in GoodsFeedbackCommentListDto".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "paging" => intermediate_rep.paging.push(<models::ForwardScrollingPagerDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing GoodsFeedbackCommentListDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GoodsFeedbackCommentListDto {
            comments: intermediate_rep.comments.into_iter().next().ok_or_else(|| "comments missing in GoodsFeedbackCommentListDto".to_string())?,
            paging: intermediate_rep.paging.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GoodsFeedbackCommentListDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<GoodsFeedbackCommentListDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<GoodsFeedbackCommentListDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for GoodsFeedbackCommentListDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<GoodsFeedbackCommentListDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GoodsFeedbackCommentListDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GoodsFeedbackCommentListDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Статус комментария:  * `PUBLISHED` — опубликован. * `UNMODERATED` — не проверен. * `BANNED` — заблокирован. * `DELETED` — удален. 
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum GoodsFeedbackCommentStatusType {
    #[serde(rename = "PUBLISHED")]
    Published,
    #[serde(rename = "UNMODERATED")]
    Unmoderated,
    #[serde(rename = "BANNED")]
    Banned,
    #[serde(rename = "DELETED")]
    Deleted,
}

impl std::fmt::Display for GoodsFeedbackCommentStatusType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            GoodsFeedbackCommentStatusType::Published => write!(f, "PUBLISHED"),
            GoodsFeedbackCommentStatusType::Unmoderated => write!(f, "UNMODERATED"),
            GoodsFeedbackCommentStatusType::Banned => write!(f, "BANNED"),
            GoodsFeedbackCommentStatusType::Deleted => write!(f, "DELETED"),
        }
    }
}

impl std::str::FromStr for GoodsFeedbackCommentStatusType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "PUBLISHED" => std::result::Result::Ok(GoodsFeedbackCommentStatusType::Published),
            "UNMODERATED" => std::result::Result::Ok(GoodsFeedbackCommentStatusType::Unmoderated),
            "BANNED" => std::result::Result::Ok(GoodsFeedbackCommentStatusType::Banned),
            "DELETED" => std::result::Result::Ok(GoodsFeedbackCommentStatusType::Deleted),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Текст комментария.
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GoodsFeedbackCommentText(String);

impl std::convert::From<String> for GoodsFeedbackCommentText {
    fn from(x: String) -> Self {
        GoodsFeedbackCommentText(x)
    }
}

impl std::string::ToString for GoodsFeedbackCommentText {
    fn to_string(&self) -> String {
       self.0.to_string()
    }
}

impl std::str::FromStr for GoodsFeedbackCommentText {
    type Err = std::string::ParseError;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(GoodsFeedbackCommentText(x.to_string()))
    }
}

impl std::convert::From<GoodsFeedbackCommentText> for String {
    fn from(x: GoodsFeedbackCommentText) -> Self {
        x.0
    }
}

impl std::ops::Deref for GoodsFeedbackCommentText {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for GoodsFeedbackCommentText {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}


/// Текстовая часть отзыва.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GoodsFeedbackDescriptionDto {
    /// Описание плюсов товара в отзыве.
    #[serde(rename = "advantages")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub advantages: Option<String>,

    /// Описание минусов товара в отзыве.
    #[serde(rename = "disadvantages")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub disadvantages: Option<String>,

    /// Комментарий в отзыве.
    #[serde(rename = "comment")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub comment: Option<String>,

}


impl GoodsFeedbackDescriptionDto {
    #[allow(clippy::new_without_default)]
    pub fn new() -> GoodsFeedbackDescriptionDto {
        GoodsFeedbackDescriptionDto {
            advantages: None,
            disadvantages: None,
            comment: None,
        }
    }
}

/// Converts the GoodsFeedbackDescriptionDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for GoodsFeedbackDescriptionDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.advantages.as_ref().map(|advantages| {
                [
                    "advantages".to_string(),
                    advantages.to_string(),
                ].join(",")
            }),


            self.disadvantages.as_ref().map(|disadvantages| {
                [
                    "disadvantages".to_string(),
                    disadvantages.to_string(),
                ].join(",")
            }),


            self.comment.as_ref().map(|comment| {
                [
                    "comment".to_string(),
                    comment.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GoodsFeedbackDescriptionDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GoodsFeedbackDescriptionDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub advantages: Vec<String>,
            pub disadvantages: Vec<String>,
            pub comment: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing GoodsFeedbackDescriptionDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "advantages" => intermediate_rep.advantages.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "disadvantages" => intermediate_rep.disadvantages.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "comment" => intermediate_rep.comment.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing GoodsFeedbackDescriptionDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GoodsFeedbackDescriptionDto {
            advantages: intermediate_rep.advantages.into_iter().next(),
            disadvantages: intermediate_rep.disadvantages.into_iter().next(),
            comment: intermediate_rep.comment.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GoodsFeedbackDescriptionDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<GoodsFeedbackDescriptionDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<GoodsFeedbackDescriptionDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for GoodsFeedbackDescriptionDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<GoodsFeedbackDescriptionDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GoodsFeedbackDescriptionDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GoodsFeedbackDescriptionDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Отзыв о товаре.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GoodsFeedbackDto {
    /// Идентификатор отзыва. 
    #[serde(rename = "feedbackId")]
    pub feedback_id: i64,

    /// Дата и время создания отзыва.
    #[serde(rename = "createdAt")]
    pub created_at: chrono::DateTime::<chrono::Utc>,

    /// Нужен ли ответ на отзыв.
    #[serde(rename = "needReaction")]
    pub need_reaction: bool,

    #[serde(rename = "identifiers")]
    pub identifiers: models::GoodsFeedbackIdentifiersDto,

    /// Имя автора отзыва.
    #[serde(rename = "author")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub author: Option<String>,

    #[serde(rename = "description")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<models::GoodsFeedbackDescriptionDto>,

    #[serde(rename = "media")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub media: Option<models::GoodsFeedbackMediaDto>,

    #[serde(rename = "statistics")]
    pub statistics: models::GoodsFeedbackStatisticsDto,

}


impl GoodsFeedbackDto {
    #[allow(clippy::new_without_default)]
    pub fn new(feedback_id: i64, created_at: chrono::DateTime::<chrono::Utc>, need_reaction: bool, identifiers: models::GoodsFeedbackIdentifiersDto, statistics: models::GoodsFeedbackStatisticsDto, ) -> GoodsFeedbackDto {
        GoodsFeedbackDto {
            feedback_id,
            created_at,
            need_reaction,
            identifiers,
            author: None,
            description: None,
            media: None,
            statistics,
        }
    }
}

/// Converts the GoodsFeedbackDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for GoodsFeedbackDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            Some("feedbackId".to_string()),
            Some(self.feedback_id.to_string()),

            // Skipping createdAt in query parameter serialization


            Some("needReaction".to_string()),
            Some(self.need_reaction.to_string()),

            // Skipping identifiers in query parameter serialization


            self.author.as_ref().map(|author| {
                [
                    "author".to_string(),
                    author.to_string(),
                ].join(",")
            }),

            // Skipping description in query parameter serialization

            // Skipping media in query parameter serialization

            // Skipping statistics in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GoodsFeedbackDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GoodsFeedbackDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub feedback_id: Vec<i64>,
            pub created_at: Vec<chrono::DateTime::<chrono::Utc>>,
            pub need_reaction: Vec<bool>,
            pub identifiers: Vec<models::GoodsFeedbackIdentifiersDto>,
            pub author: Vec<String>,
            pub description: Vec<models::GoodsFeedbackDescriptionDto>,
            pub media: Vec<models::GoodsFeedbackMediaDto>,
            pub statistics: Vec<models::GoodsFeedbackStatisticsDto>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing GoodsFeedbackDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "feedbackId" => intermediate_rep.feedback_id.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "createdAt" => intermediate_rep.created_at.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "needReaction" => intermediate_rep.need_reaction.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "identifiers" => intermediate_rep.identifiers.push(<models::GoodsFeedbackIdentifiersDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "author" => intermediate_rep.author.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "description" => intermediate_rep.description.push(<models::GoodsFeedbackDescriptionDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "media" => intermediate_rep.media.push(<models::GoodsFeedbackMediaDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "statistics" => intermediate_rep.statistics.push(<models::GoodsFeedbackStatisticsDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing GoodsFeedbackDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GoodsFeedbackDto {
            feedback_id: intermediate_rep.feedback_id.into_iter().next().ok_or_else(|| "feedbackId missing in GoodsFeedbackDto".to_string())?,
            created_at: intermediate_rep.created_at.into_iter().next().ok_or_else(|| "createdAt missing in GoodsFeedbackDto".to_string())?,
            need_reaction: intermediate_rep.need_reaction.into_iter().next().ok_or_else(|| "needReaction missing in GoodsFeedbackDto".to_string())?,
            identifiers: intermediate_rep.identifiers.into_iter().next().ok_or_else(|| "identifiers missing in GoodsFeedbackDto".to_string())?,
            author: intermediate_rep.author.into_iter().next(),
            description: intermediate_rep.description.into_iter().next(),
            media: intermediate_rep.media.into_iter().next(),
            statistics: intermediate_rep.statistics.into_iter().next().ok_or_else(|| "statistics missing in GoodsFeedbackDto".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GoodsFeedbackDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<GoodsFeedbackDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<GoodsFeedbackDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for GoodsFeedbackDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<GoodsFeedbackDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GoodsFeedbackDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GoodsFeedbackDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Идентификатор отзыва. 
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GoodsFeedbackId(i64);

impl std::convert::From<i64> for GoodsFeedbackId {
    fn from(x: i64) -> Self {
        GoodsFeedbackId(x)
    }
}

impl std::convert::From<GoodsFeedbackId> for i64 {
    fn from(x: GoodsFeedbackId) -> Self {
        x.0
    }
}

impl std::ops::Deref for GoodsFeedbackId {
    type Target = i64;
    fn deref(&self) -> &i64 {
        &self.0
    }
}

impl std::ops::DerefMut for GoodsFeedbackId {
    fn deref_mut(&mut self) -> &mut i64 {
        &mut self.0
    }
}


/// Идентификаторы, которые связаны с отзывом.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GoodsFeedbackIdentifiersDto {
    /// Идентификатор заказа на Маркете.
    #[serde(rename = "orderId")]
    pub order_id: i64,

    /// Идентификатор модели товара.
    #[serde(rename = "modelId")]
    pub model_id: i64,

}


impl GoodsFeedbackIdentifiersDto {
    #[allow(clippy::new_without_default)]
    pub fn new(order_id: i64, model_id: i64, ) -> GoodsFeedbackIdentifiersDto {
        GoodsFeedbackIdentifiersDto {
            order_id,
            model_id,
        }
    }
}

/// Converts the GoodsFeedbackIdentifiersDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for GoodsFeedbackIdentifiersDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            Some("orderId".to_string()),
            Some(self.order_id.to_string()),


            Some("modelId".to_string()),
            Some(self.model_id.to_string()),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GoodsFeedbackIdentifiersDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GoodsFeedbackIdentifiersDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub order_id: Vec<i64>,
            pub model_id: Vec<i64>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing GoodsFeedbackIdentifiersDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "orderId" => intermediate_rep.order_id.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "modelId" => intermediate_rep.model_id.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing GoodsFeedbackIdentifiersDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GoodsFeedbackIdentifiersDto {
            order_id: intermediate_rep.order_id.into_iter().next().ok_or_else(|| "orderId missing in GoodsFeedbackIdentifiersDto".to_string())?,
            model_id: intermediate_rep.model_id.into_iter().next().ok_or_else(|| "modelId missing in GoodsFeedbackIdentifiersDto".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GoodsFeedbackIdentifiersDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<GoodsFeedbackIdentifiersDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<GoodsFeedbackIdentifiersDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for GoodsFeedbackIdentifiersDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<GoodsFeedbackIdentifiersDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GoodsFeedbackIdentifiersDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GoodsFeedbackIdentifiersDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Список отзывов о товарах. 
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GoodsFeedbackListDto {
    /// Список отзывов.
    #[serde(rename = "feedbacks")]
    pub feedbacks: Vec<models::GoodsFeedbackDto>,

    #[serde(rename = "paging")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub paging: Option<models::ForwardScrollingPagerDto>,

}


impl GoodsFeedbackListDto {
    #[allow(clippy::new_without_default)]
    pub fn new(feedbacks: Vec<models::GoodsFeedbackDto>, ) -> GoodsFeedbackListDto {
        GoodsFeedbackListDto {
            feedbacks,
            paging: None,
        }
    }
}

/// Converts the GoodsFeedbackListDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for GoodsFeedbackListDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping feedbacks in query parameter serialization

            // Skipping paging in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GoodsFeedbackListDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GoodsFeedbackListDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub feedbacks: Vec<Vec<models::GoodsFeedbackDto>>,
            pub paging: Vec<models::ForwardScrollingPagerDto>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing GoodsFeedbackListDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "feedbacks" => return std::result::Result::Err("Parsing a container in this style is not supported in GoodsFeedbackListDto".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "paging" => intermediate_rep.paging.push(<models::ForwardScrollingPagerDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing GoodsFeedbackListDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GoodsFeedbackListDto {
            feedbacks: intermediate_rep.feedbacks.into_iter().next().ok_or_else(|| "feedbacks missing in GoodsFeedbackListDto".to_string())?,
            paging: intermediate_rep.paging.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GoodsFeedbackListDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<GoodsFeedbackListDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<GoodsFeedbackListDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for GoodsFeedbackListDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<GoodsFeedbackListDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GoodsFeedbackListDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GoodsFeedbackListDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Фото и видео.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GoodsFeedbackMediaDto {
    /// Ссылки на фото.
    #[serde(rename = "photos")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub photos: Option<swagger::Nullable<Vec<String>>>,

    /// Ссылки на видео.
    #[serde(rename = "videos")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub videos: Option<swagger::Nullable<Vec<String>>>,

}


impl GoodsFeedbackMediaDto {
    #[allow(clippy::new_without_default)]
    pub fn new() -> GoodsFeedbackMediaDto {
        GoodsFeedbackMediaDto {
            photos: None,
            videos: None,
        }
    }
}

/// Converts the GoodsFeedbackMediaDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for GoodsFeedbackMediaDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.photos.as_ref().map(|photos| {
                [
                    "photos".to_string(),
                    photos.as_ref().map_or("null".to_string(), |x| x.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),
                ].join(",")
            }),


            self.videos.as_ref().map(|videos| {
                [
                    "videos".to_string(),
                    videos.as_ref().map_or("null".to_string(), |x| x.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GoodsFeedbackMediaDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GoodsFeedbackMediaDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub photos: Vec<Vec<String>>,
            pub videos: Vec<Vec<String>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing GoodsFeedbackMediaDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "photos" => return std::result::Result::Err("Parsing a container in this style is not supported in GoodsFeedbackMediaDto".to_string()),
                    "videos" => return std::result::Result::Err("Parsing a container in this style is not supported in GoodsFeedbackMediaDto".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing GoodsFeedbackMediaDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GoodsFeedbackMediaDto {
            photos: std::result::Result::Err("Nullable types not supported in GoodsFeedbackMediaDto".to_string())?,
            videos: std::result::Result::Err("Nullable types not supported in GoodsFeedbackMediaDto".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GoodsFeedbackMediaDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<GoodsFeedbackMediaDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<GoodsFeedbackMediaDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for GoodsFeedbackMediaDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<GoodsFeedbackMediaDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GoodsFeedbackMediaDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GoodsFeedbackMediaDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Статистическая информация по отзыву.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GoodsFeedbackStatisticsDto {
    /// Оценка товара.
    #[serde(rename = "rating")]
    #[validate(
            range(min = 1, max = 5),
        )]
    pub rating: u32,

    /// Количество комментариев к отзыву.  Учитываются только ответы на отзывы, а не дочерние комментарии. 
    #[serde(rename = "commentsCount")]
    pub comments_count: i64,

    /// Рекомендуют ли этот товар.
    #[serde(rename = "recommended")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub recommended: Option<bool>,

    /// Количество баллов Плюса, которое автор получил за отзыв.
    #[serde(rename = "paidAmount")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub paid_amount: Option<i64>,

}


impl GoodsFeedbackStatisticsDto {
    #[allow(clippy::new_without_default)]
    pub fn new(rating: u32, comments_count: i64, ) -> GoodsFeedbackStatisticsDto {
        GoodsFeedbackStatisticsDto {
            rating,
            comments_count,
            recommended: None,
            paid_amount: None,
        }
    }
}

/// Converts the GoodsFeedbackStatisticsDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for GoodsFeedbackStatisticsDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            Some("rating".to_string()),
            Some(self.rating.to_string()),


            Some("commentsCount".to_string()),
            Some(self.comments_count.to_string()),


            self.recommended.as_ref().map(|recommended| {
                [
                    "recommended".to_string(),
                    recommended.to_string(),
                ].join(",")
            }),


            self.paid_amount.as_ref().map(|paid_amount| {
                [
                    "paidAmount".to_string(),
                    paid_amount.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GoodsFeedbackStatisticsDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GoodsFeedbackStatisticsDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub rating: Vec<u32>,
            pub comments_count: Vec<i64>,
            pub recommended: Vec<bool>,
            pub paid_amount: Vec<i64>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing GoodsFeedbackStatisticsDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "rating" => intermediate_rep.rating.push(<u32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "commentsCount" => intermediate_rep.comments_count.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "recommended" => intermediate_rep.recommended.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "paidAmount" => intermediate_rep.paid_amount.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing GoodsFeedbackStatisticsDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GoodsFeedbackStatisticsDto {
            rating: intermediate_rep.rating.into_iter().next().ok_or_else(|| "rating missing in GoodsFeedbackStatisticsDto".to_string())?,
            comments_count: intermediate_rep.comments_count.into_iter().next().ok_or_else(|| "commentsCount missing in GoodsFeedbackStatisticsDto".to_string())?,
            recommended: intermediate_rep.recommended.into_iter().next(),
            paid_amount: intermediate_rep.paid_amount.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GoodsFeedbackStatisticsDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<GoodsFeedbackStatisticsDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<GoodsFeedbackStatisticsDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for GoodsFeedbackStatisticsDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<GoodsFeedbackStatisticsDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GoodsFeedbackStatisticsDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GoodsFeedbackStatisticsDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Отчет по товарам.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GoodsStatsDto {
    /// Список товаров.
    #[serde(rename = "shopSkus")]
    pub shop_skus: Vec<models::GoodsStatsGoodsDto>,

}


impl GoodsStatsDto {
    #[allow(clippy::new_without_default)]
    pub fn new(shop_skus: Vec<models::GoodsStatsGoodsDto>, ) -> GoodsStatsDto {
        GoodsStatsDto {
            shop_skus,
        }
    }
}

/// Converts the GoodsStatsDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for GoodsStatsDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping shopSkus in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GoodsStatsDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GoodsStatsDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub shop_skus: Vec<Vec<models::GoodsStatsGoodsDto>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing GoodsStatsDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "shopSkus" => return std::result::Result::Err("Parsing a container in this style is not supported in GoodsStatsDto".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing GoodsStatsDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GoodsStatsDto {
            shop_skus: intermediate_rep.shop_skus.into_iter().next().ok_or_else(|| "shopSkus missing in GoodsStatsDto".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GoodsStatsDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<GoodsStatsDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<GoodsStatsDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for GoodsStatsDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<GoodsStatsDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GoodsStatsDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GoodsStatsDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Информация о товаре.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GoodsStatsGoodsDto {
    /// Ваш SKU — идентификатор товара в вашей системе.  Разрешена любая последовательность длиной до 255 знаков.  Правила использования SKU:  * У каждого товара SKU должен быть свой.  * SKU товара нельзя менять — можно только удалить товар и добавить заново с новым SKU.  * Уже заданный SKU нельзя освободить и использовать заново для другого товара. Каждый товар должен получать новый идентификатор, до того никогда не использовавшийся в вашем каталоге.  [Что такое SKU и как его назначать](https://yandex.ru/support/marketplace/assortment/add/index.html#fields) 
    #[serde(rename = "shopSku")]
    #[validate(
            length(min = 1, max = 255),
           regex = "RE_GOODSSTATSGOODSDTO_SHOP_SKU",
        )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub shop_sku: Option<String>,

    /// SKU на Маркете.
    #[serde(rename = "marketSku")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub market_sku: Option<i64>,

    /// Название товара.
    #[serde(rename = "name")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

    /// Цена на товар в валюте, которая установлена [в кабинете продавца на Маркете](https://partner.market.yandex.ru/).
    #[serde(rename = "price")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub price: Option<f64>,

    /// Идентификатор категории товара на Маркете.
    #[serde(rename = "categoryId")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub category_id: Option<i64>,

    /// Название категории товара на Маркете.
    #[serde(rename = "categoryName")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub category_name: Option<String>,

    #[serde(rename = "weightDimensions")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub weight_dimensions: Option<models::GoodsStatsWeightDimensionsDto>,

    /// Информация о складах, на которых хранится товар.  Параметр не приходит, если товара нет ни на одном складе. 
    #[serde(rename = "warehouses")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub warehouses: Option<swagger::Nullable<Vec<models::GoodsStatsWarehouseDto>>>,

    /// Информация о тарифах, по которым нужно заплатить за услуги Маркета.  По некоторым услугам могут возвращаться несколько разных стоимостей. Например, в модели FBS стоимость услуги `SORTING` (обработка заказа) зависит от способа отгрузки и количества заказов в отгрузке. Подробнее о тарифах на услуги читайте [в Справке Маркета для продавцов](https://yandex.ru/support2/marketplace/ru/introduction/rates/models/). 
    #[serde(rename = "tariffs")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub tariffs: Option<swagger::Nullable<Vec<models::TariffDto>>>,

    /// Ссылки (URL) изображений товара в хорошем качестве.
    #[serde(rename = "pictures")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub pictures: Option<swagger::Nullable<Vec<String>>>,

}

lazy_static::lazy_static! {
    static ref RE_GOODSSTATSGOODSDTO_SHOP_SKU: regex::Regex = regex::Regex::new(r"^[^\\x00-\\x08\\x0A-\\x1f\\x7f]{1,255}$").unwrap();
}

impl GoodsStatsGoodsDto {
    #[allow(clippy::new_without_default)]
    pub fn new() -> GoodsStatsGoodsDto {
        GoodsStatsGoodsDto {
            shop_sku: None,
            market_sku: None,
            name: None,
            price: None,
            category_id: None,
            category_name: None,
            weight_dimensions: None,
            warehouses: None,
            tariffs: None,
            pictures: None,
        }
    }
}

/// Converts the GoodsStatsGoodsDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for GoodsStatsGoodsDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.shop_sku.as_ref().map(|shop_sku| {
                [
                    "shopSku".to_string(),
                    shop_sku.to_string(),
                ].join(",")
            }),


            self.market_sku.as_ref().map(|market_sku| {
                [
                    "marketSku".to_string(),
                    market_sku.to_string(),
                ].join(",")
            }),


            self.name.as_ref().map(|name| {
                [
                    "name".to_string(),
                    name.to_string(),
                ].join(",")
            }),


            self.price.as_ref().map(|price| {
                [
                    "price".to_string(),
                    price.to_string(),
                ].join(",")
            }),


            self.category_id.as_ref().map(|category_id| {
                [
                    "categoryId".to_string(),
                    category_id.to_string(),
                ].join(",")
            }),


            self.category_name.as_ref().map(|category_name| {
                [
                    "categoryName".to_string(),
                    category_name.to_string(),
                ].join(",")
            }),

            // Skipping weightDimensions in query parameter serialization

            // Skipping warehouses in query parameter serialization

            // Skipping tariffs in query parameter serialization


            self.pictures.as_ref().map(|pictures| {
                [
                    "pictures".to_string(),
                    pictures.as_ref().map_or("null".to_string(), |x| x.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GoodsStatsGoodsDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GoodsStatsGoodsDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub shop_sku: Vec<String>,
            pub market_sku: Vec<i64>,
            pub name: Vec<String>,
            pub price: Vec<f64>,
            pub category_id: Vec<i64>,
            pub category_name: Vec<String>,
            pub weight_dimensions: Vec<models::GoodsStatsWeightDimensionsDto>,
            pub warehouses: Vec<Vec<models::GoodsStatsWarehouseDto>>,
            pub tariffs: Vec<Vec<models::TariffDto>>,
            pub pictures: Vec<Vec<String>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing GoodsStatsGoodsDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "shopSku" => intermediate_rep.shop_sku.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "marketSku" => intermediate_rep.market_sku.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "price" => intermediate_rep.price.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "categoryId" => intermediate_rep.category_id.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "categoryName" => intermediate_rep.category_name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "weightDimensions" => intermediate_rep.weight_dimensions.push(<models::GoodsStatsWeightDimensionsDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "warehouses" => return std::result::Result::Err("Parsing a container in this style is not supported in GoodsStatsGoodsDto".to_string()),
                    "tariffs" => return std::result::Result::Err("Parsing a container in this style is not supported in GoodsStatsGoodsDto".to_string()),
                    "pictures" => return std::result::Result::Err("Parsing a container in this style is not supported in GoodsStatsGoodsDto".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing GoodsStatsGoodsDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GoodsStatsGoodsDto {
            shop_sku: intermediate_rep.shop_sku.into_iter().next(),
            market_sku: intermediate_rep.market_sku.into_iter().next(),
            name: intermediate_rep.name.into_iter().next(),
            price: intermediate_rep.price.into_iter().next(),
            category_id: intermediate_rep.category_id.into_iter().next(),
            category_name: intermediate_rep.category_name.into_iter().next(),
            weight_dimensions: intermediate_rep.weight_dimensions.into_iter().next(),
            warehouses: std::result::Result::Err("Nullable types not supported in GoodsStatsGoodsDto".to_string())?,
            tariffs: std::result::Result::Err("Nullable types not supported in GoodsStatsGoodsDto".to_string())?,
            pictures: std::result::Result::Err("Nullable types not supported in GoodsStatsGoodsDto".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GoodsStatsGoodsDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<GoodsStatsGoodsDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<GoodsStatsGoodsDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for GoodsStatsGoodsDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<GoodsStatsGoodsDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GoodsStatsGoodsDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GoodsStatsGoodsDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Информация о складе.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GoodsStatsWarehouseDto {
    /// Идентификатор склада.
    #[serde(rename = "id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,

    /// Название склада.
    #[serde(rename = "name")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

    /// Информация об остатках товаров на складе.
    #[serde(rename = "stocks")]
    pub stocks: Vec<models::WarehouseStockDto>,

}


impl GoodsStatsWarehouseDto {
    #[allow(clippy::new_without_default)]
    pub fn new(stocks: Vec<models::WarehouseStockDto>, ) -> GoodsStatsWarehouseDto {
        GoodsStatsWarehouseDto {
            id: None,
            name: None,
            stocks,
        }
    }
}

/// Converts the GoodsStatsWarehouseDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for GoodsStatsWarehouseDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.id.as_ref().map(|id| {
                [
                    "id".to_string(),
                    id.to_string(),
                ].join(",")
            }),


            self.name.as_ref().map(|name| {
                [
                    "name".to_string(),
                    name.to_string(),
                ].join(",")
            }),

            // Skipping stocks in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GoodsStatsWarehouseDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GoodsStatsWarehouseDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<i64>,
            pub name: Vec<String>,
            pub stocks: Vec<Vec<models::WarehouseStockDto>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing GoodsStatsWarehouseDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "stocks" => return std::result::Result::Err("Parsing a container in this style is not supported in GoodsStatsWarehouseDto".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing GoodsStatsWarehouseDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GoodsStatsWarehouseDto {
            id: intermediate_rep.id.into_iter().next(),
            name: intermediate_rep.name.into_iter().next(),
            stocks: intermediate_rep.stocks.into_iter().next().ok_or_else(|| "stocks missing in GoodsStatsWarehouseDto".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GoodsStatsWarehouseDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<GoodsStatsWarehouseDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<GoodsStatsWarehouseDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for GoodsStatsWarehouseDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<GoodsStatsWarehouseDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GoodsStatsWarehouseDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GoodsStatsWarehouseDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Информация о весе и габаритах товара.  Если товар уже привязан к карточке (`marketSku`), в ответе вернутся габариты из карточки Маркета, а не размеры, которые вы передаете. 
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GoodsStatsWeightDimensionsDto {
    /// Длина товара в сантиметрах.
    #[serde(rename = "length")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub length: Option<f64>,

    /// Ширина товара в сантиметрах.
    #[serde(rename = "width")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub width: Option<f64>,

    /// Высота товара в сантиметрах.
    #[serde(rename = "height")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub height: Option<f64>,

    /// Вес товара в килограммах.
    #[serde(rename = "weight")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub weight: Option<f64>,

}


impl GoodsStatsWeightDimensionsDto {
    #[allow(clippy::new_without_default)]
    pub fn new() -> GoodsStatsWeightDimensionsDto {
        GoodsStatsWeightDimensionsDto {
            length: None,
            width: None,
            height: None,
            weight: None,
        }
    }
}

/// Converts the GoodsStatsWeightDimensionsDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for GoodsStatsWeightDimensionsDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.length.as_ref().map(|length| {
                [
                    "length".to_string(),
                    length.to_string(),
                ].join(",")
            }),


            self.width.as_ref().map(|width| {
                [
                    "width".to_string(),
                    width.to_string(),
                ].join(",")
            }),


            self.height.as_ref().map(|height| {
                [
                    "height".to_string(),
                    height.to_string(),
                ].join(",")
            }),


            self.weight.as_ref().map(|weight| {
                [
                    "weight".to_string(),
                    weight.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GoodsStatsWeightDimensionsDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GoodsStatsWeightDimensionsDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub length: Vec<f64>,
            pub width: Vec<f64>,
            pub height: Vec<f64>,
            pub weight: Vec<f64>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing GoodsStatsWeightDimensionsDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "length" => intermediate_rep.length.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "width" => intermediate_rep.width.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "height" => intermediate_rep.height.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "weight" => intermediate_rep.weight.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing GoodsStatsWeightDimensionsDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GoodsStatsWeightDimensionsDto {
            length: intermediate_rep.length.into_iter().next(),
            width: intermediate_rep.width.into_iter().next(),
            height: intermediate_rep.height.into_iter().next(),
            weight: intermediate_rep.weight.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GoodsStatsWeightDimensionsDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<GoodsStatsWeightDimensionsDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<GoodsStatsWeightDimensionsDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for GoodsStatsWeightDimensionsDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<GoodsStatsWeightDimensionsDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GoodsStatsWeightDimensionsDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GoodsStatsWeightDimensionsDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// GPS-координаты широты и долготы. 
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GpsDto {
    /// Широта.
    #[serde(rename = "latitude")]
    pub latitude: f64,

    /// Долгота.
    #[serde(rename = "longitude")]
    pub longitude: f64,

}


impl GpsDto {
    #[allow(clippy::new_without_default)]
    pub fn new(latitude: f64, longitude: f64, ) -> GpsDto {
        GpsDto {
            latitude,
            longitude,
        }
    }
}

/// Converts the GpsDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for GpsDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            Some("latitude".to_string()),
            Some(self.latitude.to_string()),


            Some("longitude".to_string()),
            Some(self.longitude.to_string()),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GpsDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GpsDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub latitude: Vec<f64>,
            pub longitude: Vec<f64>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing GpsDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "latitude" => intermediate_rep.latitude.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "longitude" => intermediate_rep.longitude.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing GpsDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GpsDto {
            latitude: intermediate_rep.latitude.into_iter().next().ok_or_else(|| "latitude missing in GpsDto".to_string())?,
            longitude: intermediate_rep.longitude.into_iter().next().ok_or_else(|| "longitude missing in GpsDto".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GpsDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<GpsDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<GpsDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for GpsDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<GpsDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GpsDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GpsDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Информация о скрытии.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct HiddenOfferDto {
    /// Ваш SKU — идентификатор товара в вашей системе.  Разрешена любая последовательность длиной до 255 знаков.  Правила использования SKU:  * У каждого товара SKU должен быть свой.  * SKU товара нельзя менять — можно только удалить товар и добавить заново с новым SKU.  * Уже заданный SKU нельзя освободить и использовать заново для другого товара. Каждый товар должен получать новый идентификатор, до того никогда не использовавшийся в вашем каталоге.  [Что такое SKU и как его назначать](https://yandex.ru/support/marketplace/assortment/add/index.html#fields) 
    #[serde(rename = "offerId")]
    #[validate(
            length(min = 1, max = 255),
           regex = "RE_HIDDENOFFERDTO_OFFER_ID",
        )]
    pub offer_id: String,

}

lazy_static::lazy_static! {
    static ref RE_HIDDENOFFERDTO_OFFER_ID: regex::Regex = regex::Regex::new(r"^[^\\x00-\\x08\\x0A-\\x1f\\x7f]{1,255}$").unwrap();
}

impl HiddenOfferDto {
    #[allow(clippy::new_without_default)]
    pub fn new(offer_id: String, ) -> HiddenOfferDto {
        HiddenOfferDto {
            offer_id,
        }
    }
}

/// Converts the HiddenOfferDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for HiddenOfferDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            Some("offerId".to_string()),
            Some(self.offer_id.to_string()),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a HiddenOfferDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for HiddenOfferDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub offer_id: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing HiddenOfferDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "offerId" => intermediate_rep.offer_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing HiddenOfferDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(HiddenOfferDto {
            offer_id: intermediate_rep.offer_id.into_iter().next().ok_or_else(|| "offerId missing in HiddenOfferDto".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<HiddenOfferDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<HiddenOfferDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<HiddenOfferDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for HiddenOfferDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<HiddenOfferDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <HiddenOfferDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into HiddenOfferDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Язык:  * `RU` — русский.  * `EN` — английский. 
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum LanguageType {
    #[serde(rename = "RU")]
    Ru,
    #[serde(rename = "EN")]
    En,
}

impl std::fmt::Display for LanguageType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            LanguageType::Ru => write!(f, "RU"),
            LanguageType::En => write!(f, "EN"),
        }
    }
}

impl std::str::FromStr for LanguageType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "RU" => std::result::Result::Ok(LanguageType::Ru),
            "EN" => std::result::Result::Ok(LanguageType::En),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Статус проверки лицензии:  * `NEW` — лицензия проверяется. * `SUCCESS` — лицензия прошла проверку. * `FAIL` — лицензия не прошла проверку. 
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum LicenseCheckStatusType {
    #[serde(rename = "NEW")]
    New,
    #[serde(rename = "SUCCESS")]
    Success,
    #[serde(rename = "FAIL")]
    Fail,
    #[serde(rename = "REVOKE")]
    Revoke,
    #[serde(rename = "DONT_WANT")]
    DontWant,
    #[serde(rename = "FAIL_MANUAL")]
    FailManual,
}

impl std::fmt::Display for LicenseCheckStatusType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            LicenseCheckStatusType::New => write!(f, "NEW"),
            LicenseCheckStatusType::Success => write!(f, "SUCCESS"),
            LicenseCheckStatusType::Fail => write!(f, "FAIL"),
            LicenseCheckStatusType::Revoke => write!(f, "REVOKE"),
            LicenseCheckStatusType::DontWant => write!(f, "DONT_WANT"),
            LicenseCheckStatusType::FailManual => write!(f, "FAIL_MANUAL"),
        }
    }
}

impl std::str::FromStr for LicenseCheckStatusType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "NEW" => std::result::Result::Ok(LicenseCheckStatusType::New),
            "SUCCESS" => std::result::Result::Ok(LicenseCheckStatusType::Success),
            "FAIL" => std::result::Result::Ok(LicenseCheckStatusType::Fail),
            "REVOKE" => std::result::Result::Ok(LicenseCheckStatusType::Revoke),
            "DONT_WANT" => std::result::Result::Ok(LicenseCheckStatusType::DontWant),
            "FAIL_MANUAL" => std::result::Result::Ok(LicenseCheckStatusType::FailManual),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Тип лицензии:  * `ALCOHOL` — лицензия на розничную продажу алкогольной продукции. 
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum LicenseType {
    #[serde(rename = "ALCOHOL")]
    Alcohol,
    #[serde(rename = "UNKNOWN")]
    Unknown,
}

impl std::fmt::Display for LicenseType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            LicenseType::Alcohol => write!(f, "ALCOHOL"),
            LicenseType::Unknown => write!(f, "UNKNOWN"),
        }
    }
}

impl std::str::FromStr for LicenseType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "ALCOHOL" => std::result::Result::Ok(LicenseType::Alcohol),
            "UNKNOWN" => std::result::Result::Ok(LicenseType::Unknown),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Описание пункта вывоза для возврата.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct LogisticPickupPointDto {
    /// Идентификатор пункта вывоза.
    #[serde(rename = "id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,

    /// Название пункта вывоза.
    #[serde(rename = "name")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

    #[serde(rename = "address")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub address: Option<models::PickupAddressDto>,

    /// Дополнительные инструкции к вывозу.
    #[serde(rename = "instruction")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub instruction: Option<String>,

    #[serde(rename = "type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub r#type: Option<models::LogisticPointType>,

    /// Идентификатор логистического партнера, к которому относится логистическая точка.
    #[serde(rename = "logisticPartnerId")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub logistic_partner_id: Option<i64>,

}


impl LogisticPickupPointDto {
    #[allow(clippy::new_without_default)]
    pub fn new() -> LogisticPickupPointDto {
        LogisticPickupPointDto {
            id: None,
            name: None,
            address: None,
            instruction: None,
            r#type: None,
            logistic_partner_id: None,
        }
    }
}

/// Converts the LogisticPickupPointDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for LogisticPickupPointDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.id.as_ref().map(|id| {
                [
                    "id".to_string(),
                    id.to_string(),
                ].join(",")
            }),


            self.name.as_ref().map(|name| {
                [
                    "name".to_string(),
                    name.to_string(),
                ].join(",")
            }),

            // Skipping address in query parameter serialization


            self.instruction.as_ref().map(|instruction| {
                [
                    "instruction".to_string(),
                    instruction.to_string(),
                ].join(",")
            }),

            // Skipping type in query parameter serialization


            self.logistic_partner_id.as_ref().map(|logistic_partner_id| {
                [
                    "logisticPartnerId".to_string(),
                    logistic_partner_id.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a LogisticPickupPointDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for LogisticPickupPointDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<i64>,
            pub name: Vec<String>,
            pub address: Vec<models::PickupAddressDto>,
            pub instruction: Vec<String>,
            pub r#type: Vec<models::LogisticPointType>,
            pub logistic_partner_id: Vec<i64>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing LogisticPickupPointDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "address" => intermediate_rep.address.push(<models::PickupAddressDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "instruction" => intermediate_rep.instruction.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r#type.push(<models::LogisticPointType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "logisticPartnerId" => intermediate_rep.logistic_partner_id.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing LogisticPickupPointDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(LogisticPickupPointDto {
            id: intermediate_rep.id.into_iter().next(),
            name: intermediate_rep.name.into_iter().next(),
            address: intermediate_rep.address.into_iter().next(),
            instruction: intermediate_rep.instruction.into_iter().next(),
            r#type: intermediate_rep.r#type.into_iter().next(),
            logistic_partner_id: intermediate_rep.logistic_partner_id.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<LogisticPickupPointDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<LogisticPickupPointDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<LogisticPickupPointDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for LogisticPickupPointDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<LogisticPickupPointDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <LogisticPickupPointDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into LogisticPickupPointDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Тип логистической точки:    * `WAREHOUSE` — склад.   * `PICKUP_POINT` — обычная точка выдачи заказов (ПВЗ).   * `PICKUP_TERMINAL` — постамат.   * `PICKUP_POST_OFFICE` — отделение почтовой связи (ОПС).   * `PICKUP_MIXED` — торговый зал и пункт выдачи заказов.   * `PICKUP_RETAIL` — торговый зал. 
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum LogisticPointType {
    #[serde(rename = "WAREHOUSE")]
    Warehouse,
    #[serde(rename = "PICKUP_POINT")]
    PickupPoint,
    #[serde(rename = "PICKUP_TERMINAL")]
    PickupTerminal,
    #[serde(rename = "PICKUP_POST_OFFICE")]
    PickupPostOffice,
    #[serde(rename = "PICKUP_MIXED")]
    PickupMixed,
    #[serde(rename = "PICKUP_RETAIL")]
    PickupRetail,
    #[serde(rename = "UNKNOWN")]
    Unknown,
}

impl std::fmt::Display for LogisticPointType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            LogisticPointType::Warehouse => write!(f, "WAREHOUSE"),
            LogisticPointType::PickupPoint => write!(f, "PICKUP_POINT"),
            LogisticPointType::PickupTerminal => write!(f, "PICKUP_TERMINAL"),
            LogisticPointType::PickupPostOffice => write!(f, "PICKUP_POST_OFFICE"),
            LogisticPointType::PickupMixed => write!(f, "PICKUP_MIXED"),
            LogisticPointType::PickupRetail => write!(f, "PICKUP_RETAIL"),
            LogisticPointType::Unknown => write!(f, "UNKNOWN"),
        }
    }
}

impl std::str::FromStr for LogisticPointType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "WAREHOUSE" => std::result::Result::Ok(LogisticPointType::Warehouse),
            "PICKUP_POINT" => std::result::Result::Ok(LogisticPointType::PickupPoint),
            "PICKUP_TERMINAL" => std::result::Result::Ok(LogisticPointType::PickupTerminal),
            "PICKUP_POST_OFFICE" => std::result::Result::Ok(LogisticPointType::PickupPostOffice),
            "PICKUP_MIXED" => std::result::Result::Ok(LogisticPointType::PickupMixed),
            "PICKUP_RETAIL" => std::result::Result::Ok(LogisticPointType::PickupRetail),
            "UNKNOWN" => std::result::Result::Ok(LogisticPointType::Unknown),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Информация о товарах в каталоге.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct MappingsOfferDto {
    /// Составляйте название по схеме: тип + бренд или производитель + модель + особенности, если есть (например, цвет, размер или вес) и количество в упаковке.  Не включайте в название условия продажи (например, «скидка», «бесплатная доставка» и т. д.), эмоциональные характеристики («хит», «супер» и т. д.). Не пишите слова большими буквами — кроме устоявшихся названий брендов и моделей.  Оптимальная длина — 50–60 символов, максимальная — 256.  [Рекомендации и правила](https://yandex.ru/support/marketplace/assortment/fields/title.html) 
    #[serde(rename = "name")]
    #[validate(
            length(max = 256),
        )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

    /// Ваш SKU — идентификатор товара в вашей системе.  Разрешена любая последовательность длиной до 255 знаков.  Правила использования SKU:  * У каждого товара SKU должен быть свой.  * SKU товара нельзя менять — можно только удалить товар и добавить заново с новым SKU.  * Уже заданный SKU нельзя освободить и использовать заново для другого товара. Каждый товар должен получать новый идентификатор, до того никогда не использовавшийся в вашем каталоге.  [Что такое SKU и как его назначать](https://yandex.ru/support/marketplace/assortment/add/index.html#fields) 
    #[serde(rename = "shopSku")]
    #[validate(
            length(min = 1, max = 255),
           regex = "RE_MAPPINGSOFFERDTO_SHOP_SKU",
        )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub shop_sku: Option<String>,

    /// Категория товара в вашем магазине. Значение будет использовано для определения категории товара на Маркете в случае, если вы не передали категорию в параметре `marketCategoryId`.  Указывайте конкретные категории — например, набор ножей лучше отнести к категории **Столовые приборы**, а не просто **Посуда**.  Выбирайте категории, которые описывают товар, а не абстрактный признак — например, **Духи**, а не **Подарки**.  Значение будет использовано для определения категории товара на Маркете в случае, если вы не передали категорию в параметре `marketCategoryId`. 
    #[serde(rename = "category")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub category: Option<String>,

    /// Название бренда или производителя. Должно быть записано так, как его пишет сам бренд.
    #[serde(rename = "vendor")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub vendor: Option<String>,

    /// Артикул товара от производителя.
    #[serde(rename = "vendorCode")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub vendor_code: Option<String>,

    /// Подробное описание товара: например, его преимущества и особенности.  Не давайте в описании инструкций по установке и сборке. Не используйте слова «скидка», «распродажа», «дешевый», «подарок» (кроме подарочных категорий), «бесплатно», «акция», «специальная цена», «новинка», «new», «аналог», «заказ», «хит». Не указывайте никакой контактной информации и не давайте ссылок.  Можно использовать теги:  * \\<h>, \\<h1>, \\<h2> и так далее — для заголовков; * \\<br> и \\<p> — для переноса строки; * \\<ol> — для нумерованного списка; * \\<ul> — для маркированного списка; * \\<li> — для создания элементов списка (должен находиться внутри \\<ol> или \\<ul>); * \\<div> — поддерживается, но не влияет на отображение текста.  Оптимальная длина — 400–600 символов, максимальная — 6000.  [Рекомендации и правила](https://yandex.ru/support/marketplace/assortment/fields/description.html) 
    #[serde(rename = "description")]
    #[validate(
            length(max = 6000),
        )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,

    /// Ваш SKU — идентификатор товара в вашей системе.  Разрешена любая последовательность длиной до 255 знаков.  Правила использования SKU:  * У каждого товара SKU должен быть свой.  * SKU товара нельзя менять — можно только удалить товар и добавить заново с новым SKU.  * Уже заданный SKU нельзя освободить и использовать заново для другого товара. Каждый товар должен получать новый идентификатор, до того никогда не использовавшийся в вашем каталоге.  [Что такое SKU и как его назначать](https://yandex.ru/support/marketplace/assortment/add/index.html#fields) 
    #[serde(rename = "id")]
    #[validate(
            length(min = 1, max = 255),
           regex = "RE_MAPPINGSOFFERDTO_ID",
        )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

    /// Идентификатор фида.
    #[serde(rename = "feedId")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub feed_id: Option<i64>,

    /// Указывайте в виде последовательности цифр. Подойдут коды EAN-13, EAN-8, UPC-A, UPC-E или Code 128.  Для книг указывайте ISBN.  Для товаров [определенных категорий и торговых марок](https://yastatic.net/s3/doc-binary/src/support/market/ru/yandex-market-list-for-gtin.xlsx) штрихкод должен быть действительным кодом GTIN. Обратите внимание: внутренние штрихкоды, начинающиеся на 2 или 02, и коды формата Code 128 не являются GTIN.  [Что такое GTIN](*gtin)  
    #[serde(rename = "barcodes")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub barcodes: Option<swagger::Nullable<Vec<String>>>,

    /// URL фотографии товара или страницы с описанием на вашем сайте.  Переданные данные не будут отображаться на витрине, но они помогут специалистам Маркета найти карточку для вашего товара.  Должен содержать один вложенный параметр url. 
    #[serde(rename = "urls")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub urls: Option<swagger::Nullable<Vec<String>>>,

    /// Ссылки (URL) изображений товара в хорошем качестве.  Можно указать до 30 ссылок. При этом изображение по первой ссылке будет основным. Оно используется в качестве изображения товара в поиске Маркета и на карточке товара. Другие изображения товара доступны в режиме просмотра увеличенных изображений.  Обязательный параметр.  Должен содержать хотя бы один вложенный параметр `picture`. 
    #[serde(rename = "pictures")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub pictures: Option<swagger::Nullable<Vec<String>>>,

    /// Изготовитель товара: компания, которая произвела товар, ее адрес и регистрационный номер (если есть).  Необязательный параметр. 
    #[serde(rename = "manufacturer")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub manufacturer: Option<String>,

    /// Список стран, в которых произведен товар.  Обязательный параметр.  Должен содержать хотя бы одну, но не больше 5 стран. 
    #[serde(rename = "manufacturerCountries")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub manufacturer_countries: Option<swagger::Nullable<Vec<String>>>,

    /// Минимальное количество единиц товара, которое вы поставляете на склад.  Например, если вы поставляете детское питание партиями минимум по 10 коробок, а в каждой коробке по 6 баночек, укажите значение 60. 
    #[serde(rename = "minShipment")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub min_shipment: Option<i32>,

    /// Количество единиц товара в одной упаковке, которую вы поставляете на склад.  Например, если вы поставляете детское питание коробками по 6 баночек, укажите значение 6. 
    #[serde(rename = "transportUnitSize")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub transport_unit_size: Option<i32>,

    /// Добавочная партия: по сколько единиц товара можно добавлять к минимальному количеству minShipment.  Например, если вы поставляете детское питание партиями минимум по 10 коробок и хотите добавлять к минимальной партии по 2 коробки, а в каждой коробке по 6 баночек, укажите значение 12. 
    #[serde(rename = "quantumOfSupply")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub quantum_of_supply: Option<i32>,

    /// Срок, за который продавец поставляет товары на склад, в днях.
    #[serde(rename = "deliveryDurationDays")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub delivery_duration_days: Option<i32>,

    /// Сколько мест (если больше одного) занимает товар.  Параметр указывается, только если товар занимает больше одного места (например, кондиционер занимает два места: внешний и внутренний блоки в двух коробках). Если товар занимает одно место, не указывайте этот параметр. 
    #[serde(rename = "boxCount")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub box_count: Option<i32>,

    /// Список кодов товара в единой Товарной номенклатуре внешнеэкономической деятельности (ТН ВЭД).  Обязательный параметр, если товар подлежит особому учету (например, в системе «Меркурий» как продукция животного происхождения или в системе «Честный ЗНАК»).  Может содержать только один вложенный код ТН ВЭД. 
    #[serde(rename = "customsCommodityCodes")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub customs_commodity_codes: Option<swagger::Nullable<Vec<String>>>,

    #[serde(rename = "weightDimensions")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub weight_dimensions: Option<models::OfferWeightDimensionsDto>,

    /// Дни недели, в которые продавец поставляет товары на склад.
    #[serde(rename = "supplyScheduleDays")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub supply_schedule_days: Option<swagger::Nullable<Vec<models::DayOfWeekType>>>,

    /// {% note warning \"\" %}  Этот параметр устарел. Вместо него используйте `shelfLife`. Совместное использование обоих параметров приведет к ошибке.  {% endnote %}  Срок годности: через сколько дней товар станет непригоден для использования. 
    #[serde(rename = "shelfLifeDays")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub shelf_life_days: Option<i32>,

    /// {% note warning \"\" %}  Этот параметр устарел. Вместо него используйте `lifeTime`. Совместное использование обоих параметров приведет к ошибке.  {% endnote %}  Срок службы: сколько дней товар будет исправно выполнять свою функцию, а изготовитель — нести ответственность за его существенные недостатки. 
    #[serde(rename = "lifeTimeDays")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub life_time_days: Option<i32>,

    /// Гарантийный срок товара: сколько дней возможно обслуживание и ремонт товара или возврат денег, а изготовитель или продавец будет нести ответственность за недостатки товара. 
    #[serde(rename = "guaranteePeriodDays")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub guarantee_period_days: Option<i32>,

    #[serde(rename = "processingState")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub processing_state: Option<models::OfferProcessingStateDto>,

    #[serde(rename = "availability")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub availability: Option<models::OfferAvailabilityStatusType>,

    #[serde(rename = "shelfLife")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub shelf_life: Option<models::TimePeriodDto>,

    #[serde(rename = "lifeTime")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub life_time: Option<models::TimePeriodDto>,

    #[serde(rename = "guaranteePeriod")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub guarantee_period: Option<models::TimePeriodDto>,

    /// Номер документа на товар.  Перед указанием номера документ нужно загрузить в кабинете продавца на Маркете. [Инструкция](https://yandex.ru/support/marketplace/assortment/restrictions/certificates.html) 
    #[serde(rename = "certificate")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub certificate: Option<String>,

    /// Цена на товар в рублях.
    #[serde(rename = "price")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub price: Option<f64>,

}

lazy_static::lazy_static! {
    static ref RE_MAPPINGSOFFERDTO_SHOP_SKU: regex::Regex = regex::Regex::new(r"^[^\\x00-\\x08\\x0A-\\x1f\\x7f]{1,255}$").unwrap();
}
lazy_static::lazy_static! {
    static ref RE_MAPPINGSOFFERDTO_ID: regex::Regex = regex::Regex::new(r"^[^\\x00-\\x08\\x0A-\\x1f\\x7f]{1,255}$").unwrap();
}

impl MappingsOfferDto {
    #[allow(clippy::new_without_default)]
    pub fn new() -> MappingsOfferDto {
        MappingsOfferDto {
            name: None,
            shop_sku: None,
            category: None,
            vendor: None,
            vendor_code: None,
            description: None,
            id: None,
            feed_id: None,
            barcodes: None,
            urls: None,
            pictures: None,
            manufacturer: None,
            manufacturer_countries: None,
            min_shipment: None,
            transport_unit_size: None,
            quantum_of_supply: None,
            delivery_duration_days: None,
            box_count: None,
            customs_commodity_codes: None,
            weight_dimensions: None,
            supply_schedule_days: None,
            shelf_life_days: None,
            life_time_days: None,
            guarantee_period_days: None,
            processing_state: None,
            availability: None,
            shelf_life: None,
            life_time: None,
            guarantee_period: None,
            certificate: None,
            price: None,
        }
    }
}

/// Converts the MappingsOfferDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for MappingsOfferDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.name.as_ref().map(|name| {
                [
                    "name".to_string(),
                    name.to_string(),
                ].join(",")
            }),


            self.shop_sku.as_ref().map(|shop_sku| {
                [
                    "shopSku".to_string(),
                    shop_sku.to_string(),
                ].join(",")
            }),


            self.category.as_ref().map(|category| {
                [
                    "category".to_string(),
                    category.to_string(),
                ].join(",")
            }),


            self.vendor.as_ref().map(|vendor| {
                [
                    "vendor".to_string(),
                    vendor.to_string(),
                ].join(",")
            }),


            self.vendor_code.as_ref().map(|vendor_code| {
                [
                    "vendorCode".to_string(),
                    vendor_code.to_string(),
                ].join(",")
            }),


            self.description.as_ref().map(|description| {
                [
                    "description".to_string(),
                    description.to_string(),
                ].join(",")
            }),


            self.id.as_ref().map(|id| {
                [
                    "id".to_string(),
                    id.to_string(),
                ].join(",")
            }),


            self.feed_id.as_ref().map(|feed_id| {
                [
                    "feedId".to_string(),
                    feed_id.to_string(),
                ].join(",")
            }),


            self.barcodes.as_ref().map(|barcodes| {
                [
                    "barcodes".to_string(),
                    barcodes.as_ref().map_or("null".to_string(), |x| x.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),
                ].join(",")
            }),


            self.urls.as_ref().map(|urls| {
                [
                    "urls".to_string(),
                    urls.as_ref().map_or("null".to_string(), |x| x.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),
                ].join(",")
            }),


            self.pictures.as_ref().map(|pictures| {
                [
                    "pictures".to_string(),
                    pictures.as_ref().map_or("null".to_string(), |x| x.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),
                ].join(",")
            }),


            self.manufacturer.as_ref().map(|manufacturer| {
                [
                    "manufacturer".to_string(),
                    manufacturer.to_string(),
                ].join(",")
            }),


            self.manufacturer_countries.as_ref().map(|manufacturer_countries| {
                [
                    "manufacturerCountries".to_string(),
                    manufacturer_countries.as_ref().map_or("null".to_string(), |x| x.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),
                ].join(",")
            }),


            self.min_shipment.as_ref().map(|min_shipment| {
                [
                    "minShipment".to_string(),
                    min_shipment.to_string(),
                ].join(",")
            }),


            self.transport_unit_size.as_ref().map(|transport_unit_size| {
                [
                    "transportUnitSize".to_string(),
                    transport_unit_size.to_string(),
                ].join(",")
            }),


            self.quantum_of_supply.as_ref().map(|quantum_of_supply| {
                [
                    "quantumOfSupply".to_string(),
                    quantum_of_supply.to_string(),
                ].join(",")
            }),


            self.delivery_duration_days.as_ref().map(|delivery_duration_days| {
                [
                    "deliveryDurationDays".to_string(),
                    delivery_duration_days.to_string(),
                ].join(",")
            }),


            self.box_count.as_ref().map(|box_count| {
                [
                    "boxCount".to_string(),
                    box_count.to_string(),
                ].join(",")
            }),


            self.customs_commodity_codes.as_ref().map(|customs_commodity_codes| {
                [
                    "customsCommodityCodes".to_string(),
                    customs_commodity_codes.as_ref().map_or("null".to_string(), |x| x.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),
                ].join(",")
            }),

            // Skipping weightDimensions in query parameter serialization

            // Skipping supplyScheduleDays in query parameter serialization


            self.shelf_life_days.as_ref().map(|shelf_life_days| {
                [
                    "shelfLifeDays".to_string(),
                    shelf_life_days.to_string(),
                ].join(",")
            }),


            self.life_time_days.as_ref().map(|life_time_days| {
                [
                    "lifeTimeDays".to_string(),
                    life_time_days.to_string(),
                ].join(",")
            }),


            self.guarantee_period_days.as_ref().map(|guarantee_period_days| {
                [
                    "guaranteePeriodDays".to_string(),
                    guarantee_period_days.to_string(),
                ].join(",")
            }),

            // Skipping processingState in query parameter serialization

            // Skipping availability in query parameter serialization

            // Skipping shelfLife in query parameter serialization

            // Skipping lifeTime in query parameter serialization

            // Skipping guaranteePeriod in query parameter serialization


            self.certificate.as_ref().map(|certificate| {
                [
                    "certificate".to_string(),
                    certificate.to_string(),
                ].join(",")
            }),


            self.price.as_ref().map(|price| {
                [
                    "price".to_string(),
                    price.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a MappingsOfferDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for MappingsOfferDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub name: Vec<String>,
            pub shop_sku: Vec<String>,
            pub category: Vec<String>,
            pub vendor: Vec<String>,
            pub vendor_code: Vec<String>,
            pub description: Vec<String>,
            pub id: Vec<String>,
            pub feed_id: Vec<i64>,
            pub barcodes: Vec<Vec<String>>,
            pub urls: Vec<Vec<String>>,
            pub pictures: Vec<Vec<String>>,
            pub manufacturer: Vec<String>,
            pub manufacturer_countries: Vec<Vec<String>>,
            pub min_shipment: Vec<i32>,
            pub transport_unit_size: Vec<i32>,
            pub quantum_of_supply: Vec<i32>,
            pub delivery_duration_days: Vec<i32>,
            pub box_count: Vec<i32>,
            pub customs_commodity_codes: Vec<Vec<String>>,
            pub weight_dimensions: Vec<models::OfferWeightDimensionsDto>,
            pub supply_schedule_days: Vec<Vec<models::DayOfWeekType>>,
            pub shelf_life_days: Vec<i32>,
            pub life_time_days: Vec<i32>,
            pub guarantee_period_days: Vec<i32>,
            pub processing_state: Vec<models::OfferProcessingStateDto>,
            pub availability: Vec<models::OfferAvailabilityStatusType>,
            pub shelf_life: Vec<models::TimePeriodDto>,
            pub life_time: Vec<models::TimePeriodDto>,
            pub guarantee_period: Vec<models::TimePeriodDto>,
            pub certificate: Vec<String>,
            pub price: Vec<f64>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing MappingsOfferDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "shopSku" => intermediate_rep.shop_sku.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "category" => intermediate_rep.category.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "vendor" => intermediate_rep.vendor.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "vendorCode" => intermediate_rep.vendor_code.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "description" => intermediate_rep.description.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "feedId" => intermediate_rep.feed_id.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "barcodes" => return std::result::Result::Err("Parsing a container in this style is not supported in MappingsOfferDto".to_string()),
                    "urls" => return std::result::Result::Err("Parsing a container in this style is not supported in MappingsOfferDto".to_string()),
                    "pictures" => return std::result::Result::Err("Parsing a container in this style is not supported in MappingsOfferDto".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "manufacturer" => intermediate_rep.manufacturer.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "manufacturerCountries" => return std::result::Result::Err("Parsing a container in this style is not supported in MappingsOfferDto".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "minShipment" => intermediate_rep.min_shipment.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "transportUnitSize" => intermediate_rep.transport_unit_size.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "quantumOfSupply" => intermediate_rep.quantum_of_supply.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "deliveryDurationDays" => intermediate_rep.delivery_duration_days.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "boxCount" => intermediate_rep.box_count.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "customsCommodityCodes" => return std::result::Result::Err("Parsing a container in this style is not supported in MappingsOfferDto".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "weightDimensions" => intermediate_rep.weight_dimensions.push(<models::OfferWeightDimensionsDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "supplyScheduleDays" => return std::result::Result::Err("Parsing a container in this style is not supported in MappingsOfferDto".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "shelfLifeDays" => intermediate_rep.shelf_life_days.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "lifeTimeDays" => intermediate_rep.life_time_days.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "guaranteePeriodDays" => intermediate_rep.guarantee_period_days.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "processingState" => intermediate_rep.processing_state.push(<models::OfferProcessingStateDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "availability" => intermediate_rep.availability.push(<models::OfferAvailabilityStatusType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "shelfLife" => intermediate_rep.shelf_life.push(<models::TimePeriodDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "lifeTime" => intermediate_rep.life_time.push(<models::TimePeriodDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "guaranteePeriod" => intermediate_rep.guarantee_period.push(<models::TimePeriodDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "certificate" => intermediate_rep.certificate.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "price" => intermediate_rep.price.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing MappingsOfferDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(MappingsOfferDto {
            name: intermediate_rep.name.into_iter().next(),
            shop_sku: intermediate_rep.shop_sku.into_iter().next(),
            category: intermediate_rep.category.into_iter().next(),
            vendor: intermediate_rep.vendor.into_iter().next(),
            vendor_code: intermediate_rep.vendor_code.into_iter().next(),
            description: intermediate_rep.description.into_iter().next(),
            id: intermediate_rep.id.into_iter().next(),
            feed_id: intermediate_rep.feed_id.into_iter().next(),
            barcodes: std::result::Result::Err("Nullable types not supported in MappingsOfferDto".to_string())?,
            urls: std::result::Result::Err("Nullable types not supported in MappingsOfferDto".to_string())?,
            pictures: std::result::Result::Err("Nullable types not supported in MappingsOfferDto".to_string())?,
            manufacturer: intermediate_rep.manufacturer.into_iter().next(),
            manufacturer_countries: std::result::Result::Err("Nullable types not supported in MappingsOfferDto".to_string())?,
            min_shipment: intermediate_rep.min_shipment.into_iter().next(),
            transport_unit_size: intermediate_rep.transport_unit_size.into_iter().next(),
            quantum_of_supply: intermediate_rep.quantum_of_supply.into_iter().next(),
            delivery_duration_days: intermediate_rep.delivery_duration_days.into_iter().next(),
            box_count: intermediate_rep.box_count.into_iter().next(),
            customs_commodity_codes: std::result::Result::Err("Nullable types not supported in MappingsOfferDto".to_string())?,
            weight_dimensions: intermediate_rep.weight_dimensions.into_iter().next(),
            supply_schedule_days: std::result::Result::Err("Nullable types not supported in MappingsOfferDto".to_string())?,
            shelf_life_days: intermediate_rep.shelf_life_days.into_iter().next(),
            life_time_days: intermediate_rep.life_time_days.into_iter().next(),
            guarantee_period_days: intermediate_rep.guarantee_period_days.into_iter().next(),
            processing_state: intermediate_rep.processing_state.into_iter().next(),
            availability: intermediate_rep.availability.into_iter().next(),
            shelf_life: intermediate_rep.shelf_life.into_iter().next(),
            life_time: intermediate_rep.life_time.into_iter().next(),
            guarantee_period: intermediate_rep.guarantee_period.into_iter().next(),
            certificate: intermediate_rep.certificate.into_iter().next(),
            price: intermediate_rep.price.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<MappingsOfferDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<MappingsOfferDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<MappingsOfferDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for MappingsOfferDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<MappingsOfferDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <MappingsOfferDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into MappingsOfferDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Базовая информация о товарах в каталоге.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct MappingsOfferInfoDto {
    /// Составляйте название по схеме: тип + бренд или производитель + модель + особенности, если есть (например, цвет, размер или вес) и количество в упаковке.  Не включайте в название условия продажи (например, «скидка», «бесплатная доставка» и т. д.), эмоциональные характеристики («хит», «супер» и т. д.). Не пишите слова большими буквами — кроме устоявшихся названий брендов и моделей.  Оптимальная длина — 50–60 символов, максимальная — 256.  [Рекомендации и правила](https://yandex.ru/support/marketplace/assortment/fields/title.html) 
    #[serde(rename = "name")]
    #[validate(
            length(max = 256),
        )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

    /// Ваш SKU — идентификатор товара в вашей системе.  Разрешена любая последовательность длиной до 255 знаков.  Правила использования SKU:  * У каждого товара SKU должен быть свой.  * SKU товара нельзя менять — можно только удалить товар и добавить заново с новым SKU.  * Уже заданный SKU нельзя освободить и использовать заново для другого товара. Каждый товар должен получать новый идентификатор, до того никогда не использовавшийся в вашем каталоге.  [Что такое SKU и как его назначать](https://yandex.ru/support/marketplace/assortment/add/index.html#fields) 
    #[serde(rename = "shopSku")]
    #[validate(
            length(min = 1, max = 255),
           regex = "RE_MAPPINGSOFFERINFODTO_SHOP_SKU",
        )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub shop_sku: Option<String>,

    /// Категория товара в вашем магазине. Значение будет использовано для определения категории товара на Маркете в случае, если вы не передали категорию в параметре `marketCategoryId`.  Указывайте конкретные категории — например, набор ножей лучше отнести к категории **Столовые приборы**, а не просто **Посуда**.  Выбирайте категории, которые описывают товар, а не абстрактный признак — например, **Духи**, а не **Подарки**.  Значение будет использовано для определения категории товара на Маркете в случае, если вы не передали категорию в параметре `marketCategoryId`. 
    #[serde(rename = "category")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub category: Option<String>,

    /// Название бренда или производителя. Должно быть записано так, как его пишет сам бренд.
    #[serde(rename = "vendor")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub vendor: Option<String>,

    /// Артикул товара от производителя.
    #[serde(rename = "vendorCode")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub vendor_code: Option<String>,

    /// Подробное описание товара: например, его преимущества и особенности.  Не давайте в описании инструкций по установке и сборке. Не используйте слова «скидка», «распродажа», «дешевый», «подарок» (кроме подарочных категорий), «бесплатно», «акция», «специальная цена», «новинка», «new», «аналог», «заказ», «хит». Не указывайте никакой контактной информации и не давайте ссылок.  Можно использовать теги:  * \\<h>, \\<h1>, \\<h2> и так далее — для заголовков; * \\<br> и \\<p> — для переноса строки; * \\<ol> — для нумерованного списка; * \\<ul> — для маркированного списка; * \\<li> — для создания элементов списка (должен находиться внутри \\<ol> или \\<ul>); * \\<div> — поддерживается, но не влияет на отображение текста.  Оптимальная длина — 400–600 символов, максимальная — 6000.  [Рекомендации и правила](https://yandex.ru/support/marketplace/assortment/fields/description.html) 
    #[serde(rename = "description")]
    #[validate(
            length(max = 6000),
        )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,

    /// Ваш SKU — идентификатор товара в вашей системе.  Разрешена любая последовательность длиной до 255 знаков.  Правила использования SKU:  * У каждого товара SKU должен быть свой.  * SKU товара нельзя менять — можно только удалить товар и добавить заново с новым SKU.  * Уже заданный SKU нельзя освободить и использовать заново для другого товара. Каждый товар должен получать новый идентификатор, до того никогда не использовавшийся в вашем каталоге.  [Что такое SKU и как его назначать](https://yandex.ru/support/marketplace/assortment/add/index.html#fields) 
    #[serde(rename = "id")]
    #[validate(
            length(min = 1, max = 255),
           regex = "RE_MAPPINGSOFFERINFODTO_ID",
        )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

    /// Идентификатор фида.
    #[serde(rename = "feedId")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub feed_id: Option<i64>,

    /// Указывайте в виде последовательности цифр. Подойдут коды EAN-13, EAN-8, UPC-A, UPC-E или Code 128.  Для книг указывайте ISBN.  Для товаров [определенных категорий и торговых марок](https://yastatic.net/s3/doc-binary/src/support/market/ru/yandex-market-list-for-gtin.xlsx) штрихкод должен быть действительным кодом GTIN. Обратите внимание: внутренние штрихкоды, начинающиеся на 2 или 02, и коды формата Code 128 не являются GTIN.  [Что такое GTIN](*gtin)  
    #[serde(rename = "barcodes")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub barcodes: Option<swagger::Nullable<Vec<String>>>,

    /// URL фотографии товара или страницы с описанием на вашем сайте.  Переданные данные не будут отображаться на витрине, но они помогут специалистам Маркета найти карточку для вашего товара.  Должен содержать один вложенный параметр url. 
    #[serde(rename = "urls")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub urls: Option<swagger::Nullable<Vec<String>>>,

    /// Ссылки (URL) изображений товара в хорошем качестве.  Можно указать до 30 ссылок. При этом изображение по первой ссылке будет основным. Оно используется в качестве изображения товара в поиске Маркета и на карточке товара. Другие изображения товара доступны в режиме просмотра увеличенных изображений.  Обязательный параметр.  Должен содержать хотя бы один вложенный параметр `picture`. 
    #[serde(rename = "pictures")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub pictures: Option<swagger::Nullable<Vec<String>>>,

    /// Изготовитель товара: компания, которая произвела товар, ее адрес и регистрационный номер (если есть).  Необязательный параметр. 
    #[serde(rename = "manufacturer")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub manufacturer: Option<String>,

    /// Список стран, в которых произведен товар.  Обязательный параметр.  Должен содержать хотя бы одну, но не больше 5 стран. 
    #[serde(rename = "manufacturerCountries")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub manufacturer_countries: Option<swagger::Nullable<Vec<String>>>,

    /// Минимальное количество единиц товара, которое вы поставляете на склад.  Например, если вы поставляете детское питание партиями минимум по 10 коробок, а в каждой коробке по 6 баночек, укажите значение 60. 
    #[serde(rename = "minShipment")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub min_shipment: Option<i32>,

    /// Количество единиц товара в одной упаковке, которую вы поставляете на склад.  Например, если вы поставляете детское питание коробками по 6 баночек, укажите значение 6. 
    #[serde(rename = "transportUnitSize")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub transport_unit_size: Option<i32>,

    /// Добавочная партия: по сколько единиц товара можно добавлять к минимальному количеству minShipment.  Например, если вы поставляете детское питание партиями минимум по 10 коробок и хотите добавлять к минимальной партии по 2 коробки, а в каждой коробке по 6 баночек, укажите значение 12. 
    #[serde(rename = "quantumOfSupply")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub quantum_of_supply: Option<i32>,

    /// Срок, за который продавец поставляет товары на склад, в днях.
    #[serde(rename = "deliveryDurationDays")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub delivery_duration_days: Option<i32>,

    /// Сколько мест (если больше одного) занимает товар.  Параметр указывается, только если товар занимает больше одного места (например, кондиционер занимает два места: внешний и внутренний блоки в двух коробках). Если товар занимает одно место, не указывайте этот параметр. 
    #[serde(rename = "boxCount")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub box_count: Option<i32>,

    /// Список кодов товара в единой Товарной номенклатуре внешнеэкономической деятельности (ТН ВЭД).  Обязательный параметр, если товар подлежит особому учету (например, в системе «Меркурий» как продукция животного происхождения или в системе «Честный ЗНАК»).  Может содержать только один вложенный код ТН ВЭД. 
    #[serde(rename = "customsCommodityCodes")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub customs_commodity_codes: Option<swagger::Nullable<Vec<String>>>,

    #[serde(rename = "weightDimensions")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub weight_dimensions: Option<models::OfferWeightDimensionsDto>,

    /// Дни недели, в которые продавец поставляет товары на склад.
    #[serde(rename = "supplyScheduleDays")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub supply_schedule_days: Option<swagger::Nullable<Vec<models::DayOfWeekType>>>,

    /// {% note warning \"\" %}  Этот параметр устарел. Вместо него используйте `shelfLife`. Совместное использование обоих параметров приведет к ошибке.  {% endnote %}  Срок годности: через сколько дней товар станет непригоден для использования. 
    #[serde(rename = "shelfLifeDays")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub shelf_life_days: Option<i32>,

    /// {% note warning \"\" %}  Этот параметр устарел. Вместо него используйте `lifeTime`. Совместное использование обоих параметров приведет к ошибке.  {% endnote %}  Срок службы: сколько дней товар будет исправно выполнять свою функцию, а изготовитель — нести ответственность за его существенные недостатки. 
    #[serde(rename = "lifeTimeDays")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub life_time_days: Option<i32>,

    /// Гарантийный срок товара: сколько дней возможно обслуживание и ремонт товара или возврат денег, а изготовитель или продавец будет нести ответственность за недостатки товара. 
    #[serde(rename = "guaranteePeriodDays")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub guarantee_period_days: Option<i32>,

    #[serde(rename = "processingState")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub processing_state: Option<models::OfferProcessingStateDto>,

    #[serde(rename = "availability")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub availability: Option<models::OfferAvailabilityStatusType>,

    #[serde(rename = "shelfLife")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub shelf_life: Option<models::TimePeriodDto>,

    #[serde(rename = "lifeTime")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub life_time: Option<models::TimePeriodDto>,

    #[serde(rename = "guaranteePeriod")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub guarantee_period: Option<models::TimePeriodDto>,

    /// Номер документа на товар.  Перед указанием номера документ нужно загрузить в кабинете продавца на Маркете. [Инструкция](https://yandex.ru/support/marketplace/assortment/restrictions/certificates.html) 
    #[serde(rename = "certificate")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub certificate: Option<String>,

}

lazy_static::lazy_static! {
    static ref RE_MAPPINGSOFFERINFODTO_SHOP_SKU: regex::Regex = regex::Regex::new(r"^[^\\x00-\\x08\\x0A-\\x1f\\x7f]{1,255}$").unwrap();
}
lazy_static::lazy_static! {
    static ref RE_MAPPINGSOFFERINFODTO_ID: regex::Regex = regex::Regex::new(r"^[^\\x00-\\x08\\x0A-\\x1f\\x7f]{1,255}$").unwrap();
}

impl MappingsOfferInfoDto {
    #[allow(clippy::new_without_default)]
    pub fn new() -> MappingsOfferInfoDto {
        MappingsOfferInfoDto {
            name: None,
            shop_sku: None,
            category: None,
            vendor: None,
            vendor_code: None,
            description: None,
            id: None,
            feed_id: None,
            barcodes: None,
            urls: None,
            pictures: None,
            manufacturer: None,
            manufacturer_countries: None,
            min_shipment: None,
            transport_unit_size: None,
            quantum_of_supply: None,
            delivery_duration_days: None,
            box_count: None,
            customs_commodity_codes: None,
            weight_dimensions: None,
            supply_schedule_days: None,
            shelf_life_days: None,
            life_time_days: None,
            guarantee_period_days: None,
            processing_state: None,
            availability: None,
            shelf_life: None,
            life_time: None,
            guarantee_period: None,
            certificate: None,
        }
    }
}

/// Converts the MappingsOfferInfoDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for MappingsOfferInfoDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.name.as_ref().map(|name| {
                [
                    "name".to_string(),
                    name.to_string(),
                ].join(",")
            }),


            self.shop_sku.as_ref().map(|shop_sku| {
                [
                    "shopSku".to_string(),
                    shop_sku.to_string(),
                ].join(",")
            }),


            self.category.as_ref().map(|category| {
                [
                    "category".to_string(),
                    category.to_string(),
                ].join(",")
            }),


            self.vendor.as_ref().map(|vendor| {
                [
                    "vendor".to_string(),
                    vendor.to_string(),
                ].join(",")
            }),


            self.vendor_code.as_ref().map(|vendor_code| {
                [
                    "vendorCode".to_string(),
                    vendor_code.to_string(),
                ].join(",")
            }),


            self.description.as_ref().map(|description| {
                [
                    "description".to_string(),
                    description.to_string(),
                ].join(",")
            }),


            self.id.as_ref().map(|id| {
                [
                    "id".to_string(),
                    id.to_string(),
                ].join(",")
            }),


            self.feed_id.as_ref().map(|feed_id| {
                [
                    "feedId".to_string(),
                    feed_id.to_string(),
                ].join(",")
            }),


            self.barcodes.as_ref().map(|barcodes| {
                [
                    "barcodes".to_string(),
                    barcodes.as_ref().map_or("null".to_string(), |x| x.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),
                ].join(",")
            }),


            self.urls.as_ref().map(|urls| {
                [
                    "urls".to_string(),
                    urls.as_ref().map_or("null".to_string(), |x| x.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),
                ].join(",")
            }),


            self.pictures.as_ref().map(|pictures| {
                [
                    "pictures".to_string(),
                    pictures.as_ref().map_or("null".to_string(), |x| x.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),
                ].join(",")
            }),


            self.manufacturer.as_ref().map(|manufacturer| {
                [
                    "manufacturer".to_string(),
                    manufacturer.to_string(),
                ].join(",")
            }),


            self.manufacturer_countries.as_ref().map(|manufacturer_countries| {
                [
                    "manufacturerCountries".to_string(),
                    manufacturer_countries.as_ref().map_or("null".to_string(), |x| x.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),
                ].join(",")
            }),


            self.min_shipment.as_ref().map(|min_shipment| {
                [
                    "minShipment".to_string(),
                    min_shipment.to_string(),
                ].join(",")
            }),


            self.transport_unit_size.as_ref().map(|transport_unit_size| {
                [
                    "transportUnitSize".to_string(),
                    transport_unit_size.to_string(),
                ].join(",")
            }),


            self.quantum_of_supply.as_ref().map(|quantum_of_supply| {
                [
                    "quantumOfSupply".to_string(),
                    quantum_of_supply.to_string(),
                ].join(",")
            }),


            self.delivery_duration_days.as_ref().map(|delivery_duration_days| {
                [
                    "deliveryDurationDays".to_string(),
                    delivery_duration_days.to_string(),
                ].join(",")
            }),


            self.box_count.as_ref().map(|box_count| {
                [
                    "boxCount".to_string(),
                    box_count.to_string(),
                ].join(",")
            }),


            self.customs_commodity_codes.as_ref().map(|customs_commodity_codes| {
                [
                    "customsCommodityCodes".to_string(),
                    customs_commodity_codes.as_ref().map_or("null".to_string(), |x| x.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),
                ].join(",")
            }),

            // Skipping weightDimensions in query parameter serialization

            // Skipping supplyScheduleDays in query parameter serialization


            self.shelf_life_days.as_ref().map(|shelf_life_days| {
                [
                    "shelfLifeDays".to_string(),
                    shelf_life_days.to_string(),
                ].join(",")
            }),


            self.life_time_days.as_ref().map(|life_time_days| {
                [
                    "lifeTimeDays".to_string(),
                    life_time_days.to_string(),
                ].join(",")
            }),


            self.guarantee_period_days.as_ref().map(|guarantee_period_days| {
                [
                    "guaranteePeriodDays".to_string(),
                    guarantee_period_days.to_string(),
                ].join(",")
            }),

            // Skipping processingState in query parameter serialization

            // Skipping availability in query parameter serialization

            // Skipping shelfLife in query parameter serialization

            // Skipping lifeTime in query parameter serialization

            // Skipping guaranteePeriod in query parameter serialization


            self.certificate.as_ref().map(|certificate| {
                [
                    "certificate".to_string(),
                    certificate.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a MappingsOfferInfoDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for MappingsOfferInfoDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub name: Vec<String>,
            pub shop_sku: Vec<String>,
            pub category: Vec<String>,
            pub vendor: Vec<String>,
            pub vendor_code: Vec<String>,
            pub description: Vec<String>,
            pub id: Vec<String>,
            pub feed_id: Vec<i64>,
            pub barcodes: Vec<Vec<String>>,
            pub urls: Vec<Vec<String>>,
            pub pictures: Vec<Vec<String>>,
            pub manufacturer: Vec<String>,
            pub manufacturer_countries: Vec<Vec<String>>,
            pub min_shipment: Vec<i32>,
            pub transport_unit_size: Vec<i32>,
            pub quantum_of_supply: Vec<i32>,
            pub delivery_duration_days: Vec<i32>,
            pub box_count: Vec<i32>,
            pub customs_commodity_codes: Vec<Vec<String>>,
            pub weight_dimensions: Vec<models::OfferWeightDimensionsDto>,
            pub supply_schedule_days: Vec<Vec<models::DayOfWeekType>>,
            pub shelf_life_days: Vec<i32>,
            pub life_time_days: Vec<i32>,
            pub guarantee_period_days: Vec<i32>,
            pub processing_state: Vec<models::OfferProcessingStateDto>,
            pub availability: Vec<models::OfferAvailabilityStatusType>,
            pub shelf_life: Vec<models::TimePeriodDto>,
            pub life_time: Vec<models::TimePeriodDto>,
            pub guarantee_period: Vec<models::TimePeriodDto>,
            pub certificate: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing MappingsOfferInfoDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "shopSku" => intermediate_rep.shop_sku.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "category" => intermediate_rep.category.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "vendor" => intermediate_rep.vendor.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "vendorCode" => intermediate_rep.vendor_code.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "description" => intermediate_rep.description.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "feedId" => intermediate_rep.feed_id.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "barcodes" => return std::result::Result::Err("Parsing a container in this style is not supported in MappingsOfferInfoDto".to_string()),
                    "urls" => return std::result::Result::Err("Parsing a container in this style is not supported in MappingsOfferInfoDto".to_string()),
                    "pictures" => return std::result::Result::Err("Parsing a container in this style is not supported in MappingsOfferInfoDto".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "manufacturer" => intermediate_rep.manufacturer.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "manufacturerCountries" => return std::result::Result::Err("Parsing a container in this style is not supported in MappingsOfferInfoDto".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "minShipment" => intermediate_rep.min_shipment.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "transportUnitSize" => intermediate_rep.transport_unit_size.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "quantumOfSupply" => intermediate_rep.quantum_of_supply.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "deliveryDurationDays" => intermediate_rep.delivery_duration_days.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "boxCount" => intermediate_rep.box_count.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "customsCommodityCodes" => return std::result::Result::Err("Parsing a container in this style is not supported in MappingsOfferInfoDto".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "weightDimensions" => intermediate_rep.weight_dimensions.push(<models::OfferWeightDimensionsDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "supplyScheduleDays" => return std::result::Result::Err("Parsing a container in this style is not supported in MappingsOfferInfoDto".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "shelfLifeDays" => intermediate_rep.shelf_life_days.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "lifeTimeDays" => intermediate_rep.life_time_days.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "guaranteePeriodDays" => intermediate_rep.guarantee_period_days.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "processingState" => intermediate_rep.processing_state.push(<models::OfferProcessingStateDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "availability" => intermediate_rep.availability.push(<models::OfferAvailabilityStatusType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "shelfLife" => intermediate_rep.shelf_life.push(<models::TimePeriodDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "lifeTime" => intermediate_rep.life_time.push(<models::TimePeriodDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "guaranteePeriod" => intermediate_rep.guarantee_period.push(<models::TimePeriodDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "certificate" => intermediate_rep.certificate.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing MappingsOfferInfoDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(MappingsOfferInfoDto {
            name: intermediate_rep.name.into_iter().next(),
            shop_sku: intermediate_rep.shop_sku.into_iter().next(),
            category: intermediate_rep.category.into_iter().next(),
            vendor: intermediate_rep.vendor.into_iter().next(),
            vendor_code: intermediate_rep.vendor_code.into_iter().next(),
            description: intermediate_rep.description.into_iter().next(),
            id: intermediate_rep.id.into_iter().next(),
            feed_id: intermediate_rep.feed_id.into_iter().next(),
            barcodes: std::result::Result::Err("Nullable types not supported in MappingsOfferInfoDto".to_string())?,
            urls: std::result::Result::Err("Nullable types not supported in MappingsOfferInfoDto".to_string())?,
            pictures: std::result::Result::Err("Nullable types not supported in MappingsOfferInfoDto".to_string())?,
            manufacturer: intermediate_rep.manufacturer.into_iter().next(),
            manufacturer_countries: std::result::Result::Err("Nullable types not supported in MappingsOfferInfoDto".to_string())?,
            min_shipment: intermediate_rep.min_shipment.into_iter().next(),
            transport_unit_size: intermediate_rep.transport_unit_size.into_iter().next(),
            quantum_of_supply: intermediate_rep.quantum_of_supply.into_iter().next(),
            delivery_duration_days: intermediate_rep.delivery_duration_days.into_iter().next(),
            box_count: intermediate_rep.box_count.into_iter().next(),
            customs_commodity_codes: std::result::Result::Err("Nullable types not supported in MappingsOfferInfoDto".to_string())?,
            weight_dimensions: intermediate_rep.weight_dimensions.into_iter().next(),
            supply_schedule_days: std::result::Result::Err("Nullable types not supported in MappingsOfferInfoDto".to_string())?,
            shelf_life_days: intermediate_rep.shelf_life_days.into_iter().next(),
            life_time_days: intermediate_rep.life_time_days.into_iter().next(),
            guarantee_period_days: intermediate_rep.guarantee_period_days.into_iter().next(),
            processing_state: intermediate_rep.processing_state.into_iter().next(),
            availability: intermediate_rep.availability.into_iter().next(),
            shelf_life: intermediate_rep.shelf_life.into_iter().next(),
            life_time: intermediate_rep.life_time.into_iter().next(),
            guarantee_period: intermediate_rep.guarantee_period.into_iter().next(),
            certificate: intermediate_rep.certificate.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<MappingsOfferInfoDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<MappingsOfferInfoDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<MappingsOfferInfoDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for MappingsOfferInfoDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<MappingsOfferInfoDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <MappingsOfferInfoDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into MappingsOfferInfoDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// SKU на Маркете.
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct MarketSku(i64);

impl std::convert::From<i64> for MarketSku {
    fn from(x: i64) -> Self {
        MarketSku(x)
    }
}

impl std::convert::From<MarketSku> for i64 {
    fn from(x: MarketSku) -> Self {
        x.0
    }
}

impl std::ops::Deref for MarketSku {
    type Target = i64;
    fn deref(&self) -> &i64 {
        &self.0
    }
}

impl std::ops::DerefMut for MarketSku {
    fn deref_mut(&mut self) -> &mut i64 {
        &mut self.0
    }
}


/// Лимит на установку кванта и минимального количества товаров по категориям. 
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct MaxSaleQuantumDto {
    /// Идентификатор категории.
    #[serde(rename = "id")]
    pub id: i64,

    /// Название категории.
    #[serde(rename = "name")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

    /// Лимит на установку кванта и минимального количества товаров.
    #[serde(rename = "maxSaleQuantum")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub max_sale_quantum: Option<i32>,

}


impl MaxSaleQuantumDto {
    #[allow(clippy::new_without_default)]
    pub fn new(id: i64, ) -> MaxSaleQuantumDto {
        MaxSaleQuantumDto {
            id,
            name: None,
            max_sale_quantum: None,
        }
    }
}

/// Converts the MaxSaleQuantumDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for MaxSaleQuantumDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            Some("id".to_string()),
            Some(self.id.to_string()),


            self.name.as_ref().map(|name| {
                [
                    "name".to_string(),
                    name.to_string(),
                ].join(",")
            }),


            self.max_sale_quantum.as_ref().map(|max_sale_quantum| {
                [
                    "maxSaleQuantum".to_string(),
                    max_sale_quantum.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a MaxSaleQuantumDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for MaxSaleQuantumDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<i64>,
            pub name: Vec<String>,
            pub max_sale_quantum: Vec<i32>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing MaxSaleQuantumDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "maxSaleQuantum" => intermediate_rep.max_sale_quantum.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing MaxSaleQuantumDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(MaxSaleQuantumDto {
            id: intermediate_rep.id.into_iter().next().ok_or_else(|| "id missing in MaxSaleQuantumDto".to_string())?,
            name: intermediate_rep.name.into_iter().next(),
            max_sale_quantum: intermediate_rep.max_sale_quantum.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<MaxSaleQuantumDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<MaxSaleQuantumDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<MaxSaleQuantumDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for MaxSaleQuantumDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<MaxSaleQuantumDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <MaxSaleQuantumDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into MaxSaleQuantumDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Тип акции:  * `DIRECT_DISCOUNT` — прямая скидка.  * `BLUE_FLASH` — флеш-акция.  * `MARKET_PROMOCODE` — скидка по промокоду. 
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum MechanicsType {
    #[serde(rename = "DIRECT_DISCOUNT")]
    DirectDiscount,
    #[serde(rename = "BLUE_FLASH")]
    BlueFlash,
    #[serde(rename = "MARKET_PROMOCODE")]
    MarketPromocode,
}

impl std::fmt::Display for MechanicsType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            MechanicsType::DirectDiscount => write!(f, "DIRECT_DISCOUNT"),
            MechanicsType::BlueFlash => write!(f, "BLUE_FLASH"),
            MechanicsType::MarketPromocode => write!(f, "MARKET_PROMOCODE"),
        }
    }
}

impl std::str::FromStr for MechanicsType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "DIRECT_DISCOUNT" => std::result::Result::Ok(MechanicsType::DirectDiscount),
            "BLUE_FLASH" => std::result::Result::Ok(MechanicsType::BlueFlash),
            "MARKET_PROMOCODE" => std::result::Result::Ok(MechanicsType::MarketPromocode),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Модель товара.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ModelDto {
    /// Идентификатор модели товара.
    #[serde(rename = "id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,

    /// Название модели товара.
    #[serde(rename = "name")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

    #[serde(rename = "prices")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub prices: Option<models::ModelPriceDto>,

}


impl ModelDto {
    #[allow(clippy::new_without_default)]
    pub fn new() -> ModelDto {
        ModelDto {
            id: None,
            name: None,
            prices: None,
        }
    }
}

/// Converts the ModelDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ModelDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.id.as_ref().map(|id| {
                [
                    "id".to_string(),
                    id.to_string(),
                ].join(",")
            }),


            self.name.as_ref().map(|name| {
                [
                    "name".to_string(),
                    name.to_string(),
                ].join(",")
            }),

            // Skipping prices in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ModelDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ModelDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<i64>,
            pub name: Vec<String>,
            pub prices: Vec<models::ModelPriceDto>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ModelDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "prices" => intermediate_rep.prices.push(<models::ModelPriceDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ModelDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ModelDto {
            id: intermediate_rep.id.into_iter().next(),
            name: intermediate_rep.name.into_iter().next(),
            prices: intermediate_rep.prices.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ModelDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<ModelDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ModelDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ModelDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<ModelDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ModelDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ModelDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Информация о предложении.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ModelOfferDto {
    /// Скидка на предложение в процентах.
    #[serde(rename = "discount")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub discount: Option<i32>,

    /// Наименование предложения.
    #[serde(rename = "name")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

    /// Позиция предложения в выдаче Маркета на карточке модели.
    #[serde(rename = "pos")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub pos: Option<i32>,

    /// Цена предложения без скидки магазина.
    #[serde(rename = "preDiscountPrice")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub pre_discount_price: Option<f64>,

    /// Цена предложения без скидки, которую получает покупатель при оплате через Yandex Pay.
    #[serde(rename = "price")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub price: Option<f64>,

    /// Идентификатор региона предложения (регион, откуда доставляется товар).  Сначала показываются предложения, доставляемые из региона, указанного в запросе в параметре `regionId`. Предложения, доставляемые из других регионов, показываются после них. 
    #[serde(rename = "regionId")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub region_id: Option<i64>,

    /// Стоимость доставки товара в регион:  * `0` — доставка осуществляется бесплатно. * `-1` — магазин не осуществляет доставку этого товара (самовывоз).  Если стоимость доставки неизвестна, параметр не выводится. 
    #[serde(rename = "shippingCost")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub shipping_cost: Option<f64>,

    /// Название магазина (в том виде, в котором отображается на Маркете).
    #[serde(rename = "shopName")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub shop_name: Option<String>,

    /// Рейтинг магазина.  Возможные значения: * `-1` — у магазинов, недавно появившихся на Маркете, рейтинг появляется не сразу. До момента появления рейтинга для таких магазинов возвращается значение `-1`. * `1`. * `2`. * `3`. * `4`. * `5`. 
    #[serde(rename = "shopRating")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub shop_rating: Option<i32>,

    /// {% note warning \"\" %}  Этот параметр устарел. Не используйте его.  {% endnote %} 
    #[serde(rename = "inStock")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub in_stock: Option<i32>,

}


impl ModelOfferDto {
    #[allow(clippy::new_without_default)]
    pub fn new() -> ModelOfferDto {
        ModelOfferDto {
            discount: None,
            name: None,
            pos: None,
            pre_discount_price: None,
            price: None,
            region_id: None,
            shipping_cost: None,
            shop_name: None,
            shop_rating: None,
            in_stock: None,
        }
    }
}

/// Converts the ModelOfferDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ModelOfferDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.discount.as_ref().map(|discount| {
                [
                    "discount".to_string(),
                    discount.to_string(),
                ].join(",")
            }),


            self.name.as_ref().map(|name| {
                [
                    "name".to_string(),
                    name.to_string(),
                ].join(",")
            }),


            self.pos.as_ref().map(|pos| {
                [
                    "pos".to_string(),
                    pos.to_string(),
                ].join(",")
            }),


            self.pre_discount_price.as_ref().map(|pre_discount_price| {
                [
                    "preDiscountPrice".to_string(),
                    pre_discount_price.to_string(),
                ].join(",")
            }),


            self.price.as_ref().map(|price| {
                [
                    "price".to_string(),
                    price.to_string(),
                ].join(",")
            }),


            self.region_id.as_ref().map(|region_id| {
                [
                    "regionId".to_string(),
                    region_id.to_string(),
                ].join(",")
            }),


            self.shipping_cost.as_ref().map(|shipping_cost| {
                [
                    "shippingCost".to_string(),
                    shipping_cost.to_string(),
                ].join(",")
            }),


            self.shop_name.as_ref().map(|shop_name| {
                [
                    "shopName".to_string(),
                    shop_name.to_string(),
                ].join(",")
            }),


            self.shop_rating.as_ref().map(|shop_rating| {
                [
                    "shopRating".to_string(),
                    shop_rating.to_string(),
                ].join(",")
            }),


            self.in_stock.as_ref().map(|in_stock| {
                [
                    "inStock".to_string(),
                    in_stock.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ModelOfferDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ModelOfferDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub discount: Vec<i32>,
            pub name: Vec<String>,
            pub pos: Vec<i32>,
            pub pre_discount_price: Vec<f64>,
            pub price: Vec<f64>,
            pub region_id: Vec<i64>,
            pub shipping_cost: Vec<f64>,
            pub shop_name: Vec<String>,
            pub shop_rating: Vec<i32>,
            pub in_stock: Vec<i32>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ModelOfferDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "discount" => intermediate_rep.discount.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "pos" => intermediate_rep.pos.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "preDiscountPrice" => intermediate_rep.pre_discount_price.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "price" => intermediate_rep.price.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "regionId" => intermediate_rep.region_id.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "shippingCost" => intermediate_rep.shipping_cost.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "shopName" => intermediate_rep.shop_name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "shopRating" => intermediate_rep.shop_rating.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "inStock" => intermediate_rep.in_stock.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ModelOfferDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ModelOfferDto {
            discount: intermediate_rep.discount.into_iter().next(),
            name: intermediate_rep.name.into_iter().next(),
            pos: intermediate_rep.pos.into_iter().next(),
            pre_discount_price: intermediate_rep.pre_discount_price.into_iter().next(),
            price: intermediate_rep.price.into_iter().next(),
            region_id: intermediate_rep.region_id.into_iter().next(),
            shipping_cost: intermediate_rep.shipping_cost.into_iter().next(),
            shop_name: intermediate_rep.shop_name.into_iter().next(),
            shop_rating: intermediate_rep.shop_rating.into_iter().next(),
            in_stock: intermediate_rep.in_stock.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ModelOfferDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<ModelOfferDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ModelOfferDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ModelOfferDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<ModelOfferDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ModelOfferDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ModelOfferDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Информация о ценах на модель товара.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ModelPriceDto {
    /// Средняя цена предложения для модели в регионе.
    #[serde(rename = "avg")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub avg: Option<f64>,

    /// Максимальная цена предложения для модели в регионе.
    #[serde(rename = "max")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub max: Option<f64>,

    /// Минимальная цена предложения для модели в регионе.
    #[serde(rename = "min")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub min: Option<f64>,

}


impl ModelPriceDto {
    #[allow(clippy::new_without_default)]
    pub fn new() -> ModelPriceDto {
        ModelPriceDto {
            avg: None,
            max: None,
            min: None,
        }
    }
}

/// Converts the ModelPriceDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ModelPriceDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.avg.as_ref().map(|avg| {
                [
                    "avg".to_string(),
                    avg.to_string(),
                ].join(",")
            }),


            self.max.as_ref().map(|max| {
                [
                    "max".to_string(),
                    max.to_string(),
                ].join(",")
            }),


            self.min.as_ref().map(|min| {
                [
                    "min".to_string(),
                    min.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ModelPriceDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ModelPriceDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub avg: Vec<f64>,
            pub max: Vec<f64>,
            pub min: Vec<f64>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ModelPriceDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "avg" => intermediate_rep.avg.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "max" => intermediate_rep.max.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "min" => intermediate_rep.min.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ModelPriceDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ModelPriceDto {
            avg: intermediate_rep.avg.into_iter().next(),
            max: intermediate_rep.max.into_iter().next(),
            min: intermediate_rep.min.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ModelPriceDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<ModelPriceDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ModelPriceDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ModelPriceDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<ModelPriceDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ModelPriceDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ModelPriceDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Список моделей товаров.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ModelsDto {
    /// Список моделей товаров.
    #[serde(rename = "models")]
    pub models: Vec<models::ModelDto>,

}


impl ModelsDto {
    #[allow(clippy::new_without_default)]
    pub fn new(models: Vec<models::ModelDto>, ) -> ModelsDto {
        ModelsDto {
            models,
        }
    }
}

/// Converts the ModelsDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ModelsDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping models in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ModelsDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ModelsDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub models: Vec<Vec<models::ModelDto>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ModelsDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "models" => return std::result::Result::Err("Parsing a container in this style is not supported in ModelsDto".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing ModelsDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ModelsDto {
            models: intermediate_rep.models.into_iter().next().ok_or_else(|| "models missing in ModelsDto".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ModelsDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<ModelsDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ModelsDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ModelsDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<ModelsDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ModelsDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ModelsDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Планы по поставкам:  * `ACTIVE` — поставки будут. * `INACTIVE` — поставок не будет: товар есть на складе, но вы больше не планируете его поставлять. Через 60 дней после того, как товар закончится на складе, этот статус изменится на `DELISTED`. * `DELISTED` — архив: товар закончился на складе, и его поставок больше не будет. Если товар вернется на склад (например, покупатель вернет заказ), этот статус изменится на `INACTIVE`. 
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum OfferAvailabilityStatusType {
    #[serde(rename = "ACTIVE")]
    Active,
    #[serde(rename = "INACTIVE")]
    Inactive,
    #[serde(rename = "DELISTED")]
    Delisted,
}

impl std::fmt::Display for OfferAvailabilityStatusType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            OfferAvailabilityStatusType::Active => write!(f, "ACTIVE"),
            OfferAvailabilityStatusType::Inactive => write!(f, "INACTIVE"),
            OfferAvailabilityStatusType::Delisted => write!(f, "DELISTED"),
        }
    }
}

impl std::str::FromStr for OfferAvailabilityStatusType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "ACTIVE" => std::result::Result::Ok(OfferAvailabilityStatusType::Active),
            "INACTIVE" => std::result::Result::Ok(OfferAvailabilityStatusType::Inactive),
            "DELISTED" => std::result::Result::Ok(OfferAvailabilityStatusType::Delisted),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Статус товара в магазине.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct OfferCampaignStatusDto {
    /// Идентификатор кампании. 
    #[serde(rename = "campaignId")]
    pub campaign_id: i64,

    #[serde(rename = "status")]
    pub status: models::OfferCampaignStatusType,

}


impl OfferCampaignStatusDto {
    #[allow(clippy::new_without_default)]
    pub fn new(campaign_id: i64, status: models::OfferCampaignStatusType, ) -> OfferCampaignStatusDto {
        OfferCampaignStatusDto {
            campaign_id,
            status,
        }
    }
}

/// Converts the OfferCampaignStatusDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for OfferCampaignStatusDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            Some("campaignId".to_string()),
            Some(self.campaign_id.to_string()),

            // Skipping status in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a OfferCampaignStatusDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for OfferCampaignStatusDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub campaign_id: Vec<i64>,
            pub status: Vec<models::OfferCampaignStatusType>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing OfferCampaignStatusDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "campaignId" => intermediate_rep.campaign_id.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(<models::OfferCampaignStatusType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing OfferCampaignStatusDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(OfferCampaignStatusDto {
            campaign_id: intermediate_rep.campaign_id.into_iter().next().ok_or_else(|| "campaignId missing in OfferCampaignStatusDto".to_string())?,
            status: intermediate_rep.status.into_iter().next().ok_or_else(|| "status missing in OfferCampaignStatusDto".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<OfferCampaignStatusDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<OfferCampaignStatusDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<OfferCampaignStatusDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for OfferCampaignStatusDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<OfferCampaignStatusDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <OfferCampaignStatusDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into OfferCampaignStatusDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Статус товара:  * `PUBLISHED` — Готов к продаже. * `CHECKING` — На проверке. * `DISABLED_BY_PARTNER` — Скрыт вами. * `REJECTED_BY_MARKET` — Отклонен. * `DISABLED_AUTOMATICALLY` — Исправьте ошибки. * `CREATING_CARD` — Создается карточка. * `NO_CARD` — Нужна карточка. * `NO_STOCKS` — Нет на складе. * `ARCHIVED` — В архиве.  [Что обозначает каждый из статусов](https://yandex.ru/support/marketplace/assortment/add/statuses.html) 
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum OfferCampaignStatusType {
    #[serde(rename = "PUBLISHED")]
    Published,
    #[serde(rename = "CHECKING")]
    Checking,
    #[serde(rename = "DISABLED_BY_PARTNER")]
    DisabledByPartner,
    #[serde(rename = "DISABLED_AUTOMATICALLY")]
    DisabledAutomatically,
    #[serde(rename = "REJECTED_BY_MARKET")]
    RejectedByMarket,
    #[serde(rename = "CREATING_CARD")]
    CreatingCard,
    #[serde(rename = "NO_CARD")]
    NoCard,
    #[serde(rename = "NO_STOCKS")]
    NoStocks,
    #[serde(rename = "ARCHIVED")]
    Archived,
}

impl std::fmt::Display for OfferCampaignStatusType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            OfferCampaignStatusType::Published => write!(f, "PUBLISHED"),
            OfferCampaignStatusType::Checking => write!(f, "CHECKING"),
            OfferCampaignStatusType::DisabledByPartner => write!(f, "DISABLED_BY_PARTNER"),
            OfferCampaignStatusType::DisabledAutomatically => write!(f, "DISABLED_AUTOMATICALLY"),
            OfferCampaignStatusType::RejectedByMarket => write!(f, "REJECTED_BY_MARKET"),
            OfferCampaignStatusType::CreatingCard => write!(f, "CREATING_CARD"),
            OfferCampaignStatusType::NoCard => write!(f, "NO_CARD"),
            OfferCampaignStatusType::NoStocks => write!(f, "NO_STOCKS"),
            OfferCampaignStatusType::Archived => write!(f, "ARCHIVED"),
        }
    }
}

impl std::str::FromStr for OfferCampaignStatusType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "PUBLISHED" => std::result::Result::Ok(OfferCampaignStatusType::Published),
            "CHECKING" => std::result::Result::Ok(OfferCampaignStatusType::Checking),
            "DISABLED_BY_PARTNER" => std::result::Result::Ok(OfferCampaignStatusType::DisabledByPartner),
            "DISABLED_AUTOMATICALLY" => std::result::Result::Ok(OfferCampaignStatusType::DisabledAutomatically),
            "REJECTED_BY_MARKET" => std::result::Result::Ok(OfferCampaignStatusType::RejectedByMarket),
            "CREATING_CARD" => std::result::Result::Ok(OfferCampaignStatusType::CreatingCard),
            "NO_CARD" => std::result::Result::Ok(OfferCampaignStatusType::NoCard),
            "NO_STOCKS" => std::result::Result::Ok(OfferCampaignStatusType::NoStocks),
            "ARCHIVED" => std::result::Result::Ok(OfferCampaignStatusType::Archived),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Информация о состоянии карточки товара.  Если поле `mapping` отсутствует в ответе, Маркет еще не успел обработать информацию о товаре. Чтобы определить категорию такого товара, повторите запрос через несколько минут. 
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct OfferCardDto {
    /// Ваш SKU — идентификатор товара в вашей системе.  Разрешена любая последовательность длиной до 255 знаков.  Правила использования SKU:  * У каждого товара SKU должен быть свой.  * SKU товара нельзя менять — можно только удалить товар и добавить заново с новым SKU.  * Уже заданный SKU нельзя освободить и использовать заново для другого товара. Каждый товар должен получать новый идентификатор, до того никогда не использовавшийся в вашем каталоге.  [Что такое SKU и как его назначать](https://yandex.ru/support/marketplace/assortment/add/index.html#fields) 
    #[serde(rename = "offerId")]
    #[validate(
            length(min = 1, max = 255),
           regex = "RE_OFFERCARDDTO_OFFER_ID",
        )]
    pub offer_id: String,

    #[serde(rename = "mapping")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub mapping: Option<models::GetMappingDto>,

    /// Список характеристик с их значениями. 
    #[serde(rename = "parameterValues")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub parameter_values: Option<swagger::Nullable<Vec<models::ParameterValueDto>>>,

    #[serde(rename = "cardStatus")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub card_status: Option<models::OfferCardStatusType>,

    /// Процент заполненности карточки.
    #[serde(rename = "contentRating")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub content_rating: Option<i32>,

    /// Список рекомендаций к заполнению карточки.  Рекомендации Маркета помогают заполнять карточку так, чтобы покупателям было проще найти ваш товар и решиться на покупку. 
    #[serde(rename = "recommendations")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub recommendations: Option<swagger::Nullable<Vec<models::OfferCardRecommendationDto>>>,

    /// Ошибки в контенте, препятствующие размещению товара на витрине.
    #[serde(rename = "errors")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub errors: Option<swagger::Nullable<Vec<models::OfferErrorDto>>>,

    /// Связанные с контентом предупреждения, не препятствующие размещению товара на витрине.
    #[serde(rename = "warnings")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub warnings: Option<swagger::Nullable<Vec<models::OfferErrorDto>>>,

}

lazy_static::lazy_static! {
    static ref RE_OFFERCARDDTO_OFFER_ID: regex::Regex = regex::Regex::new(r"^[^\\x00-\\x08\\x0A-\\x1f\\x7f]{1,255}$").unwrap();
}

impl OfferCardDto {
    #[allow(clippy::new_without_default)]
    pub fn new(offer_id: String, ) -> OfferCardDto {
        OfferCardDto {
            offer_id,
            mapping: None,
            parameter_values: None,
            card_status: None,
            content_rating: None,
            recommendations: None,
            errors: None,
            warnings: None,
        }
    }
}

/// Converts the OfferCardDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for OfferCardDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            Some("offerId".to_string()),
            Some(self.offer_id.to_string()),

            // Skipping mapping in query parameter serialization

            // Skipping parameterValues in query parameter serialization

            // Skipping cardStatus in query parameter serialization


            self.content_rating.as_ref().map(|content_rating| {
                [
                    "contentRating".to_string(),
                    content_rating.to_string(),
                ].join(",")
            }),

            // Skipping recommendations in query parameter serialization

            // Skipping errors in query parameter serialization

            // Skipping warnings in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a OfferCardDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for OfferCardDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub offer_id: Vec<String>,
            pub mapping: Vec<models::GetMappingDto>,
            pub parameter_values: Vec<Vec<models::ParameterValueDto>>,
            pub card_status: Vec<models::OfferCardStatusType>,
            pub content_rating: Vec<i32>,
            pub recommendations: Vec<Vec<models::OfferCardRecommendationDto>>,
            pub errors: Vec<Vec<models::OfferErrorDto>>,
            pub warnings: Vec<Vec<models::OfferErrorDto>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing OfferCardDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "offerId" => intermediate_rep.offer_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "mapping" => intermediate_rep.mapping.push(<models::GetMappingDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "parameterValues" => return std::result::Result::Err("Parsing a container in this style is not supported in OfferCardDto".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "cardStatus" => intermediate_rep.card_status.push(<models::OfferCardStatusType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "contentRating" => intermediate_rep.content_rating.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "recommendations" => return std::result::Result::Err("Parsing a container in this style is not supported in OfferCardDto".to_string()),
                    "errors" => return std::result::Result::Err("Parsing a container in this style is not supported in OfferCardDto".to_string()),
                    "warnings" => return std::result::Result::Err("Parsing a container in this style is not supported in OfferCardDto".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing OfferCardDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(OfferCardDto {
            offer_id: intermediate_rep.offer_id.into_iter().next().ok_or_else(|| "offerId missing in OfferCardDto".to_string())?,
            mapping: intermediate_rep.mapping.into_iter().next(),
            parameter_values: std::result::Result::Err("Nullable types not supported in OfferCardDto".to_string())?,
            card_status: intermediate_rep.card_status.into_iter().next(),
            content_rating: intermediate_rep.content_rating.into_iter().next(),
            recommendations: std::result::Result::Err("Nullable types not supported in OfferCardDto".to_string())?,
            errors: std::result::Result::Err("Nullable types not supported in OfferCardDto".to_string())?,
            warnings: std::result::Result::Err("Nullable types not supported in OfferCardDto".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<OfferCardDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<OfferCardDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<OfferCardDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for OfferCardDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<OfferCardDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <OfferCardDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into OfferCardDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Рекомендация по заполнению карточки товара.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct OfferCardRecommendationDto {
    #[serde(rename = "type")]
    pub r#type: models::OfferCardRecommendationType,

    /// Процент выполнения рекомендации. Указывается для рекомендаций некоторых типов.
    #[serde(rename = "percent")]
    #[validate(
            range(min = 0, max = 100),
        )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub percent: Option<u32>,

}


impl OfferCardRecommendationDto {
    #[allow(clippy::new_without_default)]
    pub fn new(r#type: models::OfferCardRecommendationType, ) -> OfferCardRecommendationDto {
        OfferCardRecommendationDto {
            r#type,
            percent: None,
        }
    }
}

/// Converts the OfferCardRecommendationDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for OfferCardRecommendationDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping type in query parameter serialization


            self.percent.as_ref().map(|percent| {
                [
                    "percent".to_string(),
                    percent.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a OfferCardRecommendationDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for OfferCardRecommendationDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub r#type: Vec<models::OfferCardRecommendationType>,
            pub percent: Vec<u32>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing OfferCardRecommendationDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r#type.push(<models::OfferCardRecommendationType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "percent" => intermediate_rep.percent.push(<u32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing OfferCardRecommendationDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(OfferCardRecommendationDto {
            r#type: intermediate_rep.r#type.into_iter().next().ok_or_else(|| "type missing in OfferCardRecommendationDto".to_string())?,
            percent: intermediate_rep.percent.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<OfferCardRecommendationDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<OfferCardRecommendationDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<OfferCardRecommendationDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for OfferCardRecommendationDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<OfferCardRecommendationDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <OfferCardRecommendationDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into OfferCardRecommendationDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Рекомендация по дополнению или замене контента. Не возвращается для карточек, которые заполнены Маркетом или содержат бывшие в употреблении товары.  Часть рекомендаций относятся к **основным параметрам**, которые есть у товаров любых категорий. Другие — к тем **характеристикам**, которые есть у товара потому, что он относится к определенной категории.  **1. Рекомендации, относящиеся к основным параметрам**  Каждая такая рекомендация относится к **единственному параметру**. Чтобы заполнить этот параметр, пользуйтесь запросом [POST businesses/{businessId}/offer-mappings/update](../../reference/business-assortment/updateOfferMappings.md).  Рекомендации по заполнению параметров в `updateOfferMappings`:  * `RECOGNIZED_VENDOR` — напишите название производителя так, как его пишет сам производитель (параметр `vendor`). * `PICTURE_COUNT` — добавьте изображения (параметр `pictures`). * `FIRST_PICTURE_SIZE` — замените первое изображение более крупным (параметр `pictures`). * `TITLE_LENGTH` — измените название (параметр `name`). Составьте название по схеме: тип + бренд или производитель + модель + особенности, если есть (размер, вес, цвет). * `DESCRIPTION_LENGTH` — добавьте описание рекомендуемого размера (параметр `description`). * `AVERAGE_PICTURE_SIZE` — замените все изображения на изображения высокого качества (параметр `pictures`). * `FIRST_VIDEO_LENGTH` — добавьте первое видео рекомендуемой длины (параметр `videos`). * `AVERAGE_VIDEO_SIZE` — замените все видео на видео высокого качества (параметр `videos`). * `VIDEO_COUNT` — добавьте больше видео (параметр `videos`).  Рекомендуемые значения параметров описаны в [Справке Яндекс Маркета для продавцов](https://yandex.ru/support2/marketplace/ru/assortment/add/).  **2. Рекомендации, относящиеся к характеристикам по категориям**  Каждая такая рекомендация предполагает заполнение **одной или нескольких характеристик**. Чтобы узнать, какие именно характеристики нужно заполнить, воспользуйтесь запросом [POST category/{categoryId}/parameters](../../reference/content/getCategoryContentParameters.md). Например, если вы получили рекомендацию `MAIN`, нужно заполнить характеристики, имеющие `MAIN` в массиве `recommendationTypes`.  Рекомендации:  * `MAIN` — заполните ключевые характеристики товара, которые используются в поиске и фильтрах. * `ADDITIONAL` — заполните дополнительные характеристики товара. * `DISTINCTIVE` — заполните характеристики, которыми отличаются друг от друга варианты товара.  **3. Устаревшие рекомендации**  * `HAS_VIDEO`. * `FILTERABLE`. * `HAS_DESCRIPTION`. * `HAS_BARCODE`. 
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum OfferCardRecommendationType {
    #[serde(rename = "HAS_VIDEO")]
    HasVideo,
    #[serde(rename = "RECOGNIZED_VENDOR")]
    RecognizedVendor,
    #[serde(rename = "MAIN")]
    Main,
    #[serde(rename = "ADDITIONAL")]
    Additional,
    #[serde(rename = "DISTINCTIVE")]
    Distinctive,
    #[serde(rename = "FILTERABLE")]
    Filterable,
    #[serde(rename = "PICTURE_COUNT")]
    PictureCount,
    #[serde(rename = "HAS_DESCRIPTION")]
    HasDescription,
    #[serde(rename = "HAS_BARCODE")]
    HasBarcode,
    #[serde(rename = "FIRST_PICTURE_SIZE")]
    FirstPictureSize,
    #[serde(rename = "TITLE_LENGTH")]
    TitleLength,
    #[serde(rename = "DESCRIPTION_LENGTH")]
    DescriptionLength,
    #[serde(rename = "AVERAGE_PICTURE_SIZE")]
    AveragePictureSize,
    #[serde(rename = "FIRST_VIDEO_SIZE")]
    FirstVideoSize,
    #[serde(rename = "FIRST_VIDEO_LENGTH")]
    FirstVideoLength,
    #[serde(rename = "AVERAGE_VIDEO_SIZE")]
    AverageVideoSize,
    #[serde(rename = "VIDEO_COUNT")]
    VideoCount,
}

impl std::fmt::Display for OfferCardRecommendationType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            OfferCardRecommendationType::HasVideo => write!(f, "HAS_VIDEO"),
            OfferCardRecommendationType::RecognizedVendor => write!(f, "RECOGNIZED_VENDOR"),
            OfferCardRecommendationType::Main => write!(f, "MAIN"),
            OfferCardRecommendationType::Additional => write!(f, "ADDITIONAL"),
            OfferCardRecommendationType::Distinctive => write!(f, "DISTINCTIVE"),
            OfferCardRecommendationType::Filterable => write!(f, "FILTERABLE"),
            OfferCardRecommendationType::PictureCount => write!(f, "PICTURE_COUNT"),
            OfferCardRecommendationType::HasDescription => write!(f, "HAS_DESCRIPTION"),
            OfferCardRecommendationType::HasBarcode => write!(f, "HAS_BARCODE"),
            OfferCardRecommendationType::FirstPictureSize => write!(f, "FIRST_PICTURE_SIZE"),
            OfferCardRecommendationType::TitleLength => write!(f, "TITLE_LENGTH"),
            OfferCardRecommendationType::DescriptionLength => write!(f, "DESCRIPTION_LENGTH"),
            OfferCardRecommendationType::AveragePictureSize => write!(f, "AVERAGE_PICTURE_SIZE"),
            OfferCardRecommendationType::FirstVideoSize => write!(f, "FIRST_VIDEO_SIZE"),
            OfferCardRecommendationType::FirstVideoLength => write!(f, "FIRST_VIDEO_LENGTH"),
            OfferCardRecommendationType::AverageVideoSize => write!(f, "AVERAGE_VIDEO_SIZE"),
            OfferCardRecommendationType::VideoCount => write!(f, "VIDEO_COUNT"),
        }
    }
}

impl std::str::FromStr for OfferCardRecommendationType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "HAS_VIDEO" => std::result::Result::Ok(OfferCardRecommendationType::HasVideo),
            "RECOGNIZED_VENDOR" => std::result::Result::Ok(OfferCardRecommendationType::RecognizedVendor),
            "MAIN" => std::result::Result::Ok(OfferCardRecommendationType::Main),
            "ADDITIONAL" => std::result::Result::Ok(OfferCardRecommendationType::Additional),
            "DISTINCTIVE" => std::result::Result::Ok(OfferCardRecommendationType::Distinctive),
            "FILTERABLE" => std::result::Result::Ok(OfferCardRecommendationType::Filterable),
            "PICTURE_COUNT" => std::result::Result::Ok(OfferCardRecommendationType::PictureCount),
            "HAS_DESCRIPTION" => std::result::Result::Ok(OfferCardRecommendationType::HasDescription),
            "HAS_BARCODE" => std::result::Result::Ok(OfferCardRecommendationType::HasBarcode),
            "FIRST_PICTURE_SIZE" => std::result::Result::Ok(OfferCardRecommendationType::FirstPictureSize),
            "TITLE_LENGTH" => std::result::Result::Ok(OfferCardRecommendationType::TitleLength),
            "DESCRIPTION_LENGTH" => std::result::Result::Ok(OfferCardRecommendationType::DescriptionLength),
            "AVERAGE_PICTURE_SIZE" => std::result::Result::Ok(OfferCardRecommendationType::AveragePictureSize),
            "FIRST_VIDEO_SIZE" => std::result::Result::Ok(OfferCardRecommendationType::FirstVideoSize),
            "FIRST_VIDEO_LENGTH" => std::result::Result::Ok(OfferCardRecommendationType::FirstVideoLength),
            "AVERAGE_VIDEO_SIZE" => std::result::Result::Ok(OfferCardRecommendationType::AverageVideoSize),
            "VIDEO_COUNT" => std::result::Result::Ok(OfferCardRecommendationType::VideoCount),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Статус карточки товара:  * `HAS_CARD_CAN_NOT_UPDATE` — Карточка Маркета. * `HAS_CARD_CAN_UPDATE` — Можно дополнить. * `HAS_CARD_CAN_UPDATE_ERRORS` — Изменения не приняты. * `HAS_CARD_CAN_UPDATE_PROCESSING` — Изменения на проверке. * `NO_CARD_NEED_CONTENT` — Создайте карточку. * `NO_CARD_MARKET_WILL_CREATE` — Создаст Маркет. * `NO_CARD_ERRORS` — Не создана из-за ошибки. * `NO_CARD_PROCESSING` — Проверяем данные. * `NO_CARD_ADD_TO_CAMPAIGN` — Разместите товар в магазине.  [Что обозначает каждый из статусов](https://yandex.ru/support/marketplace/assortment/content/statuses.html) 
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum OfferCardStatusType {
    #[serde(rename = "HAS_CARD_CAN_NOT_UPDATE")]
    HasCardCanNotUpdate,
    #[serde(rename = "HAS_CARD_CAN_UPDATE")]
    HasCardCanUpdate,
    #[serde(rename = "HAS_CARD_CAN_UPDATE_ERRORS")]
    HasCardCanUpdateErrors,
    #[serde(rename = "HAS_CARD_CAN_UPDATE_PROCESSING")]
    HasCardCanUpdateProcessing,
    #[serde(rename = "NO_CARD_NEED_CONTENT")]
    NoCardNeedContent,
    #[serde(rename = "NO_CARD_MARKET_WILL_CREATE")]
    NoCardMarketWillCreate,
    #[serde(rename = "NO_CARD_ERRORS")]
    NoCardErrors,
    #[serde(rename = "NO_CARD_PROCESSING")]
    NoCardProcessing,
    #[serde(rename = "NO_CARD_ADD_TO_CAMPAIGN")]
    NoCardAddToCampaign,
}

impl std::fmt::Display for OfferCardStatusType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            OfferCardStatusType::HasCardCanNotUpdate => write!(f, "HAS_CARD_CAN_NOT_UPDATE"),
            OfferCardStatusType::HasCardCanUpdate => write!(f, "HAS_CARD_CAN_UPDATE"),
            OfferCardStatusType::HasCardCanUpdateErrors => write!(f, "HAS_CARD_CAN_UPDATE_ERRORS"),
            OfferCardStatusType::HasCardCanUpdateProcessing => write!(f, "HAS_CARD_CAN_UPDATE_PROCESSING"),
            OfferCardStatusType::NoCardNeedContent => write!(f, "NO_CARD_NEED_CONTENT"),
            OfferCardStatusType::NoCardMarketWillCreate => write!(f, "NO_CARD_MARKET_WILL_CREATE"),
            OfferCardStatusType::NoCardErrors => write!(f, "NO_CARD_ERRORS"),
            OfferCardStatusType::NoCardProcessing => write!(f, "NO_CARD_PROCESSING"),
            OfferCardStatusType::NoCardAddToCampaign => write!(f, "NO_CARD_ADD_TO_CAMPAIGN"),
        }
    }
}

impl std::str::FromStr for OfferCardStatusType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "HAS_CARD_CAN_NOT_UPDATE" => std::result::Result::Ok(OfferCardStatusType::HasCardCanNotUpdate),
            "HAS_CARD_CAN_UPDATE" => std::result::Result::Ok(OfferCardStatusType::HasCardCanUpdate),
            "HAS_CARD_CAN_UPDATE_ERRORS" => std::result::Result::Ok(OfferCardStatusType::HasCardCanUpdateErrors),
            "HAS_CARD_CAN_UPDATE_PROCESSING" => std::result::Result::Ok(OfferCardStatusType::HasCardCanUpdateProcessing),
            "NO_CARD_NEED_CONTENT" => std::result::Result::Ok(OfferCardStatusType::NoCardNeedContent),
            "NO_CARD_MARKET_WILL_CREATE" => std::result::Result::Ok(OfferCardStatusType::NoCardMarketWillCreate),
            "NO_CARD_ERRORS" => std::result::Result::Ok(OfferCardStatusType::NoCardErrors),
            "NO_CARD_PROCESSING" => std::result::Result::Ok(OfferCardStatusType::NoCardProcessing),
            "NO_CARD_ADD_TO_CAMPAIGN" => std::result::Result::Ok(OfferCardStatusType::NoCardAddToCampaign),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Список товаров с информацией о состоянии карточек.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct OfferCardsContentStatusDto {
    /// Страница списка товаров с информацией о состоянии карточек.
    #[serde(rename = "offerCards")]
    pub offer_cards: Vec<models::OfferCardDto>,

    #[serde(rename = "paging")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub paging: Option<models::ForwardScrollingPagerDto>,

}


impl OfferCardsContentStatusDto {
    #[allow(clippy::new_without_default)]
    pub fn new(offer_cards: Vec<models::OfferCardDto>, ) -> OfferCardsContentStatusDto {
        OfferCardsContentStatusDto {
            offer_cards,
            paging: None,
        }
    }
}

/// Converts the OfferCardsContentStatusDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for OfferCardsContentStatusDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping offerCards in query parameter serialization

            // Skipping paging in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a OfferCardsContentStatusDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for OfferCardsContentStatusDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub offer_cards: Vec<Vec<models::OfferCardDto>>,
            pub paging: Vec<models::ForwardScrollingPagerDto>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing OfferCardsContentStatusDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "offerCards" => return std::result::Result::Err("Parsing a container in this style is not supported in OfferCardsContentStatusDto".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "paging" => intermediate_rep.paging.push(<models::ForwardScrollingPagerDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing OfferCardsContentStatusDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(OfferCardsContentStatusDto {
            offer_cards: intermediate_rep.offer_cards.into_iter().next().ok_or_else(|| "offerCards missing in OfferCardsContentStatusDto".to_string())?,
            paging: intermediate_rep.paging.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<OfferCardsContentStatusDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<OfferCardsContentStatusDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<OfferCardsContentStatusDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for OfferCardsContentStatusDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<OfferCardsContentStatusDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <OfferCardsContentStatusDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into OfferCardsContentStatusDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Категория товара в вашем магазине. Значение будет использовано для определения категории товара на Маркете в случае, если вы не передали категорию в параметре `marketCategoryId`.  Указывайте конкретные категории — например, набор ножей лучше отнести к категории **Столовые приборы**, а не просто **Посуда**.  Выбирайте категории, которые описывают товар, а не абстрактный признак — например, **Духи**, а не **Подарки**.  Значение будет использовано для определения категории товара на Маркете в случае, если вы не передали категорию в параметре `marketCategoryId`. 
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct OfferCategory(String);

impl std::convert::From<String> for OfferCategory {
    fn from(x: String) -> Self {
        OfferCategory(x)
    }
}

impl std::string::ToString for OfferCategory {
    fn to_string(&self) -> String {
       self.0.to_string()
    }
}

impl std::str::FromStr for OfferCategory {
    type Err = std::string::ParseError;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(OfferCategory(x.to_string()))
    }
}

impl std::convert::From<OfferCategory> for String {
    fn from(x: OfferCategory) -> Self {
        x.0
    }
}

impl std::ops::Deref for OfferCategory {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for OfferCategory {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}


/// Состояние уцененного товара. 
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct OfferConditionDto {
    #[serde(rename = "type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub r#type: Option<models::OfferConditionType>,

    #[serde(rename = "quality")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub quality: Option<models::OfferConditionQualityType>,

    /// Описание товара. Подробно опишите дефекты, насколько они заметны и где их искать. 
    #[serde(rename = "reason")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub reason: Option<String>,

}


impl OfferConditionDto {
    #[allow(clippy::new_without_default)]
    pub fn new() -> OfferConditionDto {
        OfferConditionDto {
            r#type: None,
            quality: None,
            reason: None,
        }
    }
}

/// Converts the OfferConditionDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for OfferConditionDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping type in query parameter serialization

            // Skipping quality in query parameter serialization


            self.reason.as_ref().map(|reason| {
                [
                    "reason".to_string(),
                    reason.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a OfferConditionDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for OfferConditionDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub r#type: Vec<models::OfferConditionType>,
            pub quality: Vec<models::OfferConditionQualityType>,
            pub reason: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing OfferConditionDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r#type.push(<models::OfferConditionType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "quality" => intermediate_rep.quality.push(<models::OfferConditionQualityType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "reason" => intermediate_rep.reason.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing OfferConditionDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(OfferConditionDto {
            r#type: intermediate_rep.r#type.into_iter().next(),
            quality: intermediate_rep.quality.into_iter().next(),
            reason: intermediate_rep.reason.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<OfferConditionDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<OfferConditionDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<OfferConditionDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for OfferConditionDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<OfferConditionDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <OfferConditionDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into OfferConditionDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Внешний вид товара:  * `PERFECT` — идеальный. * `EXCELLENT` — отличный. * `GOOD` — хороший. * `NOT_SPECIFIED` — не выбран. 
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum OfferConditionQualityType {
    #[serde(rename = "PERFECT")]
    Perfect,
    #[serde(rename = "EXCELLENT")]
    Excellent,
    #[serde(rename = "GOOD")]
    Good,
    #[serde(rename = "NOT_SPECIFIED")]
    NotSpecified,
}

impl std::fmt::Display for OfferConditionQualityType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            OfferConditionQualityType::Perfect => write!(f, "PERFECT"),
            OfferConditionQualityType::Excellent => write!(f, "EXCELLENT"),
            OfferConditionQualityType::Good => write!(f, "GOOD"),
            OfferConditionQualityType::NotSpecified => write!(f, "NOT_SPECIFIED"),
        }
    }
}

impl std::str::FromStr for OfferConditionQualityType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "PERFECT" => std::result::Result::Ok(OfferConditionQualityType::Perfect),
            "EXCELLENT" => std::result::Result::Ok(OfferConditionQualityType::Excellent),
            "GOOD" => std::result::Result::Ok(OfferConditionQualityType::Good),
            "NOT_SPECIFIED" => std::result::Result::Ok(OfferConditionQualityType::NotSpecified),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Тип уценки:  * `PREOWNED` —  бывший в употреблении товар, раньше принадлежал другому человеку. * `SHOWCASESAMPLE` — витринный образец. * `REFURBISHED` — повторная продажа товара. * `REDUCTION` — товар с дефектами. * `RENOVATED` — восстановленный товар. * `NOT_SPECIFIED` — не выбран.  `REFURBISHED` — специальное значение для одежды, обуви и аксессуаров. Используется только для уцененных товаров из этой категории. Другие значения для одежды, обуви и аксессуаров не используются. 
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum OfferConditionType {
    #[serde(rename = "PREOWNED")]
    Preowned,
    #[serde(rename = "SHOWCASESAMPLE")]
    Showcasesample,
    #[serde(rename = "REFURBISHED")]
    Refurbished,
    #[serde(rename = "REDUCTION")]
    Reduction,
    #[serde(rename = "RENOVATED")]
    Renovated,
    #[serde(rename = "NOT_SPECIFIED")]
    NotSpecified,
}

impl std::fmt::Display for OfferConditionType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            OfferConditionType::Preowned => write!(f, "PREOWNED"),
            OfferConditionType::Showcasesample => write!(f, "SHOWCASESAMPLE"),
            OfferConditionType::Refurbished => write!(f, "REFURBISHED"),
            OfferConditionType::Reduction => write!(f, "REDUCTION"),
            OfferConditionType::Renovated => write!(f, "RENOVATED"),
            OfferConditionType::NotSpecified => write!(f, "NOT_SPECIFIED"),
        }
    }
}

impl std::str::FromStr for OfferConditionType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "PREOWNED" => std::result::Result::Ok(OfferConditionType::Preowned),
            "SHOWCASESAMPLE" => std::result::Result::Ok(OfferConditionType::Showcasesample),
            "REFURBISHED" => std::result::Result::Ok(OfferConditionType::Refurbished),
            "REDUCTION" => std::result::Result::Ok(OfferConditionType::Reduction),
            "RENOVATED" => std::result::Result::Ok(OfferConditionType::Renovated),
            "NOT_SPECIFIED" => std::result::Result::Ok(OfferConditionType::NotSpecified),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Товар с указанными характеристиками.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct OfferContentDto {
    /// Ваш SKU — идентификатор товара в вашей системе.  Разрешена любая последовательность длиной до 255 знаков.  Правила использования SKU:  * У каждого товара SKU должен быть свой.  * SKU товара нельзя менять — можно только удалить товар и добавить заново с новым SKU.  * Уже заданный SKU нельзя освободить и использовать заново для другого товара. Каждый товар должен получать новый идентификатор, до того никогда не использовавшийся в вашем каталоге.  [Что такое SKU и как его назначать](https://yandex.ru/support/marketplace/assortment/add/index.html#fields) 
    #[serde(rename = "offerId")]
    #[validate(
            length(min = 1, max = 255),
           regex = "RE_OFFERCONTENTDTO_OFFER_ID",
        )]
    pub offer_id: String,

    /// Идентификатор категории на Маркете. Чтобы узнать идентификатор категории, к которой относится товар, воспользуйтесь запросом [POST categories/tree](../../reference/categories/getCategoriesTree.md).
    #[serde(rename = "categoryId")]
    pub category_id: i32,

    /// Список характеристик с их значениями.  С `parameterValues` обязательно передавайте `marketCategoryId` — идентификатор категории на Маркете, к которой относятся указанные характеристики товара.  При **изменении** характеристик передавайте только те, значение которых нужно обновить.  Чтобы **удалить** значение заданной характеристики, передайте ее `parameterId` с пустым `value`.  Максимальное количество характеристик — 300. 
    #[serde(rename = "parameterValues")]
    #[validate(
            length(min = 1, max = 300),
        )]
    pub parameter_values: Vec<models::ParameterValueDto>,

}

lazy_static::lazy_static! {
    static ref RE_OFFERCONTENTDTO_OFFER_ID: regex::Regex = regex::Regex::new(r"^[^\\x00-\\x08\\x0A-\\x1f\\x7f]{1,255}$").unwrap();
}

impl OfferContentDto {
    #[allow(clippy::new_without_default)]
    pub fn new(offer_id: String, category_id: i32, parameter_values: Vec<models::ParameterValueDto>, ) -> OfferContentDto {
        OfferContentDto {
            offer_id,
            category_id,
            parameter_values,
        }
    }
}

/// Converts the OfferContentDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for OfferContentDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            Some("offerId".to_string()),
            Some(self.offer_id.to_string()),


            Some("categoryId".to_string()),
            Some(self.category_id.to_string()),

            // Skipping parameterValues in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a OfferContentDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for OfferContentDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub offer_id: Vec<String>,
            pub category_id: Vec<i32>,
            pub parameter_values: Vec<Vec<models::ParameterValueDto>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing OfferContentDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "offerId" => intermediate_rep.offer_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "categoryId" => intermediate_rep.category_id.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "parameterValues" => return std::result::Result::Err("Parsing a container in this style is not supported in OfferContentDto".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing OfferContentDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(OfferContentDto {
            offer_id: intermediate_rep.offer_id.into_iter().next().ok_or_else(|| "offerId missing in OfferContentDto".to_string())?,
            category_id: intermediate_rep.category_id.into_iter().next().ok_or_else(|| "categoryId missing in OfferContentDto".to_string())?,
            parameter_values: intermediate_rep.parameter_values.into_iter().next().ok_or_else(|| "parameterValues missing in OfferContentDto".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<OfferContentDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<OfferContentDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<OfferContentDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for OfferContentDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<OfferContentDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <OfferContentDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into OfferContentDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Текст ошибки.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct OfferContentErrorDto {
    #[serde(rename = "type")]
    pub r#type: models::OfferContentErrorType,

    /// Идентификатор характеристики, с которой связана ошибка.
    #[serde(rename = "parameterId")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub parameter_id: Option<i64>,

    /// Текст ошибки.
    #[serde(rename = "message")]
    pub message: String,

}


impl OfferContentErrorDto {
    #[allow(clippy::new_without_default)]
    pub fn new(r#type: models::OfferContentErrorType, message: String, ) -> OfferContentErrorDto {
        OfferContentErrorDto {
            r#type,
            parameter_id: None,
            message,
        }
    }
}

/// Converts the OfferContentErrorDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for OfferContentErrorDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping type in query parameter serialization


            self.parameter_id.as_ref().map(|parameter_id| {
                [
                    "parameterId".to_string(),
                    parameter_id.to_string(),
                ].join(",")
            }),


            Some("message".to_string()),
            Some(self.message.to_string()),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a OfferContentErrorDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for OfferContentErrorDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub r#type: Vec<models::OfferContentErrorType>,
            pub parameter_id: Vec<i64>,
            pub message: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing OfferContentErrorDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r#type.push(<models::OfferContentErrorType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "parameterId" => intermediate_rep.parameter_id.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "message" => intermediate_rep.message.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing OfferContentErrorDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(OfferContentErrorDto {
            r#type: intermediate_rep.r#type.into_iter().next().ok_or_else(|| "type missing in OfferContentErrorDto".to_string())?,
            parameter_id: intermediate_rep.parameter_id.into_iter().next(),
            message: intermediate_rep.message.into_iter().next().ok_or_else(|| "message missing in OfferContentErrorDto".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<OfferContentErrorDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<OfferContentErrorDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<OfferContentErrorDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for OfferContentErrorDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<OfferContentErrorDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <OfferContentErrorDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into OfferContentErrorDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Типы ошибок:  * `OFFER_NOT_FOUND` — такого товара нет в каталоге. * `UNKNOWN_CATEGORY` — указана неизвестная категория. * `CATEGORY_MISMATCH` — указана категория, которая не совпадает с категорией товара. * `UNKNOWN_PARAMETER` — передана характеристика, которой нет среди характеристик категории. * `UNEXPECTED_BOOLEAN_VALUE` — вместо boolean-значения передано что-то другое. * `NUMBER_FORMAT` — передана строка, не обозначающая число, вместо числа. * `VALUE_BLANK` — передано пустое значение. * `INVALID_UNIT_ID` — передана единица измерения, недопустимая для характеристики. * `INVALID_GROUP_ID_LENGTH` — в названии превышено допустимое значение символов — 255. * `INVALID_GROUP_ID_CHARACTERS` — переданы [недопустимые символы](*ascii-code). 
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum OfferContentErrorType {
    #[serde(rename = "OFFER_NOT_FOUND")]
    OfferNotFound,
    #[serde(rename = "UNKNOWN_CATEGORY")]
    UnknownCategory,
    #[serde(rename = "CATEGORY_MISMATCH")]
    CategoryMismatch,
    #[serde(rename = "UNKNOWN_PARAMETER")]
    UnknownParameter,
    #[serde(rename = "UNEXPECTED_BOOLEAN_VALUE")]
    UnexpectedBooleanValue,
    #[serde(rename = "NUMBER_FORMAT")]
    NumberFormat,
    #[serde(rename = "VALUE_BLANK")]
    ValueBlank,
    #[serde(rename = "INVALID_UNIT_ID")]
    InvalidUnitId,
    #[serde(rename = "INVALID_GROUP_ID_LENGTH")]
    InvalidGroupIdLength,
    #[serde(rename = "INVALID_GROUP_ID_CHARACTERS")]
    InvalidGroupIdCharacters,
}

impl std::fmt::Display for OfferContentErrorType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            OfferContentErrorType::OfferNotFound => write!(f, "OFFER_NOT_FOUND"),
            OfferContentErrorType::UnknownCategory => write!(f, "UNKNOWN_CATEGORY"),
            OfferContentErrorType::CategoryMismatch => write!(f, "CATEGORY_MISMATCH"),
            OfferContentErrorType::UnknownParameter => write!(f, "UNKNOWN_PARAMETER"),
            OfferContentErrorType::UnexpectedBooleanValue => write!(f, "UNEXPECTED_BOOLEAN_VALUE"),
            OfferContentErrorType::NumberFormat => write!(f, "NUMBER_FORMAT"),
            OfferContentErrorType::ValueBlank => write!(f, "VALUE_BLANK"),
            OfferContentErrorType::InvalidUnitId => write!(f, "INVALID_UNIT_ID"),
            OfferContentErrorType::InvalidGroupIdLength => write!(f, "INVALID_GROUP_ID_LENGTH"),
            OfferContentErrorType::InvalidGroupIdCharacters => write!(f, "INVALID_GROUP_ID_CHARACTERS"),
        }
    }
}

impl std::str::FromStr for OfferContentErrorType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "OFFER_NOT_FOUND" => std::result::Result::Ok(OfferContentErrorType::OfferNotFound),
            "UNKNOWN_CATEGORY" => std::result::Result::Ok(OfferContentErrorType::UnknownCategory),
            "CATEGORY_MISMATCH" => std::result::Result::Ok(OfferContentErrorType::CategoryMismatch),
            "UNKNOWN_PARAMETER" => std::result::Result::Ok(OfferContentErrorType::UnknownParameter),
            "UNEXPECTED_BOOLEAN_VALUE" => std::result::Result::Ok(OfferContentErrorType::UnexpectedBooleanValue),
            "NUMBER_FORMAT" => std::result::Result::Ok(OfferContentErrorType::NumberFormat),
            "VALUE_BLANK" => std::result::Result::Ok(OfferContentErrorType::ValueBlank),
            "INVALID_UNIT_ID" => std::result::Result::Ok(OfferContentErrorType::InvalidUnitId),
            "INVALID_GROUP_ID_LENGTH" => std::result::Result::Ok(OfferContentErrorType::InvalidGroupIdLength),
            "INVALID_GROUP_ID_CHARACTERS" => std::result::Result::Ok(OfferContentErrorType::InvalidGroupIdCharacters),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Подробное описание товара: например, его преимущества и особенности.  Не давайте в описании инструкций по установке и сборке. Не используйте слова «скидка», «распродажа», «дешевый», «подарок» (кроме подарочных категорий), «бесплатно», «акция», «специальная цена», «новинка», «new», «аналог», «заказ», «хит». Не указывайте никакой контактной информации и не давайте ссылок.  Можно использовать теги:  * \\<h>, \\<h1>, \\<h2> и так далее — для заголовков; * \\<br> и \\<p> — для переноса строки; * \\<ol> — для нумерованного списка; * \\<ul> — для маркированного списка; * \\<li> — для создания элементов списка (должен находиться внутри \\<ol> или \\<ul>); * \\<div> — поддерживается, но не влияет на отображение текста.  Оптимальная длина — 400–600 символов, максимальная — 6000.  [Рекомендации и правила](https://yandex.ru/support/marketplace/assortment/fields/description.html) 
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct OfferDescription(String);

impl std::convert::From<String> for OfferDescription {
    fn from(x: String) -> Self {
        OfferDescription(x)
    }
}

impl std::string::ToString for OfferDescription {
    fn to_string(&self) -> String {
       self.0.to_string()
    }
}

impl std::str::FromStr for OfferDescription {
    type Err = std::string::ParseError;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(OfferDescription(x.to_string()))
    }
}

impl std::convert::From<OfferDescription> for String {
    fn from(x: OfferDescription) -> Self {
        x.0
    }
}

impl std::ops::Deref for OfferDescription {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for OfferDescription {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}


/// Предложение.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct OfferDto {
    /// Цена предложения.  До версии 2.0 партнерского API у параметра был тип String. 
    #[serde(rename = "price")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub price: Option<f64>,

    /// Идентификатор прайс-листа, содержащего предложение.  Параметр доступен начиная с версии 2.0 партнерского API. 
    #[serde(rename = "feedId")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub feed_id: Option<i64>,

    /// Идентификатор предложения из прайс-листа.  Параметр выводится, если в прайс-листе задан уникальный идентификатор. Если в прайс-листе содержится несколько предложений с одинаковыми идентификаторами, параметр `id` указывается только для первого из них, для остальных параметры `id` и `feedId` не выводятся.  Параметр доступен начиная с версии 2.0 партнерского API. 
    #[serde(rename = "id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

    /// Идентификатор категории предложения, указанный магазином в прайс-листе.  Параметр выводится только для предложений, у которых указана категория в прайс-листе.  Параметр доступен начиная с версии 2.0 партнерского API. 
    #[serde(rename = "shopCategoryId")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub shop_category_id: Option<String>,

    /// Идентификатор категории предложения в дереве категорий Маркета. Параметр доступен начиная с версии 2.0 партнерского API. 
    #[serde(rename = "marketCategoryId")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub market_category_id: Option<i32>,

    /// Цена предложения без скидки.
    #[serde(rename = "preDiscountPrice")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub pre_discount_price: Option<f64>,

    /// Скидка на предложение в процентах.
    #[serde(rename = "discount")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub discount: Option<i32>,

    /// Является ли предложение уцененным:  * `true` — да. * `false` — нет.  Параметр доступен начиная с версии 2.58 партнерского API. 
    #[serde(rename = "cutPrice")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub cut_price: Option<bool>,

    /// URL-адрес предложения на сайте магазина.
    #[serde(rename = "url")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,

    /// Идентификатор модели Маркета, с которой соотнесено предложение.  Если предложение не соотнесено ни с какой карточкой модели, то параметр `modelid` содержит значение `0`.  {% note info %}  Идентификатор модели присутствует в URL карточки модели в виде значения параметра `product`. Например: `https://market.yandex.ru/product/13584121`.  {% endnote %} 
    #[serde(rename = "modelId")]
    pub model_id: i64,

    /// Наименование предложения.
    #[serde(rename = "name")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

    #[serde(rename = "currency")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub currency: Option<models::CurrencyType>,

    /// {% note warning \"\" %}  Этот параметр устарел. Не используйте его.  {% endnote %}  Ставка на клик. 
    #[serde(rename = "bid")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub bid: Option<f64>,

    /// {% note warning \"\" %}  Этот параметр устарел. Не используйте его.  {% endnote %}  Ставка на клик. 
    #[serde(rename = "cbid")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub cbid: Option<f64>,

    /// {% note warning \"\" %}  Этот параметр устарел. Не используйте его.  {% endnote %}  Процент комиссии на товар при продаже по CPA. 
    #[serde(rename = "fee")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub fee: Option<f64>,

    /// Признак блокировки предложения. Возможные значения: * `false` — предложение активно, параметр не выводится. * `true` — предложение заблокировано. Параметр выводится, если предложение заблокировано и не попадает в выдачу Маркета. Это может произойти из-за отключения магазина. 
    #[serde(rename = "blocked")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub blocked: Option<bool>,

}


impl OfferDto {
    #[allow(clippy::new_without_default)]
    pub fn new(model_id: i64, ) -> OfferDto {
        OfferDto {
            price: None,
            feed_id: None,
            id: None,
            shop_category_id: None,
            market_category_id: None,
            pre_discount_price: None,
            discount: None,
            cut_price: None,
            url: None,
            model_id,
            name: None,
            currency: None,
            bid: None,
            cbid: None,
            fee: None,
            blocked: None,
        }
    }
}

/// Converts the OfferDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for OfferDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.price.as_ref().map(|price| {
                [
                    "price".to_string(),
                    price.to_string(),
                ].join(",")
            }),


            self.feed_id.as_ref().map(|feed_id| {
                [
                    "feedId".to_string(),
                    feed_id.to_string(),
                ].join(",")
            }),


            self.id.as_ref().map(|id| {
                [
                    "id".to_string(),
                    id.to_string(),
                ].join(",")
            }),


            self.shop_category_id.as_ref().map(|shop_category_id| {
                [
                    "shopCategoryId".to_string(),
                    shop_category_id.to_string(),
                ].join(",")
            }),


            self.market_category_id.as_ref().map(|market_category_id| {
                [
                    "marketCategoryId".to_string(),
                    market_category_id.to_string(),
                ].join(",")
            }),


            self.pre_discount_price.as_ref().map(|pre_discount_price| {
                [
                    "preDiscountPrice".to_string(),
                    pre_discount_price.to_string(),
                ].join(",")
            }),


            self.discount.as_ref().map(|discount| {
                [
                    "discount".to_string(),
                    discount.to_string(),
                ].join(",")
            }),


            self.cut_price.as_ref().map(|cut_price| {
                [
                    "cutPrice".to_string(),
                    cut_price.to_string(),
                ].join(",")
            }),


            self.url.as_ref().map(|url| {
                [
                    "url".to_string(),
                    url.to_string(),
                ].join(",")
            }),


            Some("modelId".to_string()),
            Some(self.model_id.to_string()),


            self.name.as_ref().map(|name| {
                [
                    "name".to_string(),
                    name.to_string(),
                ].join(",")
            }),

            // Skipping currency in query parameter serialization


            self.bid.as_ref().map(|bid| {
                [
                    "bid".to_string(),
                    bid.to_string(),
                ].join(",")
            }),


            self.cbid.as_ref().map(|cbid| {
                [
                    "cbid".to_string(),
                    cbid.to_string(),
                ].join(",")
            }),


            self.fee.as_ref().map(|fee| {
                [
                    "fee".to_string(),
                    fee.to_string(),
                ].join(",")
            }),


            self.blocked.as_ref().map(|blocked| {
                [
                    "blocked".to_string(),
                    blocked.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a OfferDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for OfferDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub price: Vec<f64>,
            pub feed_id: Vec<i64>,
            pub id: Vec<String>,
            pub shop_category_id: Vec<String>,
            pub market_category_id: Vec<i32>,
            pub pre_discount_price: Vec<f64>,
            pub discount: Vec<i32>,
            pub cut_price: Vec<bool>,
            pub url: Vec<String>,
            pub model_id: Vec<i64>,
            pub name: Vec<String>,
            pub currency: Vec<models::CurrencyType>,
            pub bid: Vec<f64>,
            pub cbid: Vec<f64>,
            pub fee: Vec<f64>,
            pub blocked: Vec<bool>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing OfferDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "price" => intermediate_rep.price.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "feedId" => intermediate_rep.feed_id.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "shopCategoryId" => intermediate_rep.shop_category_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "marketCategoryId" => intermediate_rep.market_category_id.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "preDiscountPrice" => intermediate_rep.pre_discount_price.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "discount" => intermediate_rep.discount.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "cutPrice" => intermediate_rep.cut_price.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "url" => intermediate_rep.url.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "modelId" => intermediate_rep.model_id.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "currency" => intermediate_rep.currency.push(<models::CurrencyType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "bid" => intermediate_rep.bid.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "cbid" => intermediate_rep.cbid.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "fee" => intermediate_rep.fee.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "blocked" => intermediate_rep.blocked.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing OfferDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(OfferDto {
            price: intermediate_rep.price.into_iter().next(),
            feed_id: intermediate_rep.feed_id.into_iter().next(),
            id: intermediate_rep.id.into_iter().next(),
            shop_category_id: intermediate_rep.shop_category_id.into_iter().next(),
            market_category_id: intermediate_rep.market_category_id.into_iter().next(),
            pre_discount_price: intermediate_rep.pre_discount_price.into_iter().next(),
            discount: intermediate_rep.discount.into_iter().next(),
            cut_price: intermediate_rep.cut_price.into_iter().next(),
            url: intermediate_rep.url.into_iter().next(),
            model_id: intermediate_rep.model_id.into_iter().next().ok_or_else(|| "modelId missing in OfferDto".to_string())?,
            name: intermediate_rep.name.into_iter().next(),
            currency: intermediate_rep.currency.into_iter().next(),
            bid: intermediate_rep.bid.into_iter().next(),
            cbid: intermediate_rep.cbid.into_iter().next(),
            fee: intermediate_rep.fee.into_iter().next(),
            blocked: intermediate_rep.blocked.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<OfferDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<OfferDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<OfferDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for OfferDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<OfferDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <OfferDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into OfferDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Сообщение об ошибке, связанной с размещением товара.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct OfferErrorDto {
    /// Тип ошибки.
    #[serde(rename = "message")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub message: Option<String>,

    /// Пояснение.
    #[serde(rename = "comment")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub comment: Option<String>,

}


impl OfferErrorDto {
    #[allow(clippy::new_without_default)]
    pub fn new() -> OfferErrorDto {
        OfferErrorDto {
            message: None,
            comment: None,
        }
    }
}

/// Converts the OfferErrorDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for OfferErrorDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.message.as_ref().map(|message| {
                [
                    "message".to_string(),
                    message.to_string(),
                ].join(",")
            }),


            self.comment.as_ref().map(|comment| {
                [
                    "comment".to_string(),
                    comment.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a OfferErrorDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for OfferErrorDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub message: Vec<String>,
            pub comment: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing OfferErrorDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "message" => intermediate_rep.message.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "comment" => intermediate_rep.comment.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing OfferErrorDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(OfferErrorDto {
            message: intermediate_rep.message.into_iter().next(),
            comment: intermediate_rep.comment.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<OfferErrorDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<OfferErrorDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<OfferErrorDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for OfferErrorDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<OfferErrorDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <OfferErrorDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into OfferErrorDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Информация о состоянии цены на товар.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct OfferForRecommendationDto {
    /// Ваш SKU — идентификатор товара в вашей системе.  Разрешена любая последовательность длиной до 255 знаков.  Правила использования SKU:  * У каждого товара SKU должен быть свой.  * SKU товара нельзя менять — можно только удалить товар и добавить заново с новым SKU.  * Уже заданный SKU нельзя освободить и использовать заново для другого товара. Каждый товар должен получать новый идентификатор, до того никогда не использовавшийся в вашем каталоге.  [Что такое SKU и как его назначать](https://yandex.ru/support/marketplace/assortment/add/index.html#fields) 
    #[serde(rename = "offerId")]
    #[validate(
            length(min = 1, max = 255),
           regex = "RE_OFFERFORRECOMMENDATIONDTO_OFFER_ID",
        )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub offer_id: Option<String>,

    #[serde(rename = "price")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub price: Option<models::BasePriceDto>,

    #[serde(rename = "cofinancePrice")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub cofinance_price: Option<models::GetPriceDto>,

    #[serde(rename = "competitiveness")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub competitiveness: Option<models::PriceCompetitivenessType>,

    /// Количество показов карточки товара за последние 7 дней.
    #[serde(rename = "shows")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub shows: Option<i64>,

}

lazy_static::lazy_static! {
    static ref RE_OFFERFORRECOMMENDATIONDTO_OFFER_ID: regex::Regex = regex::Regex::new(r"^[^\\x00-\\x08\\x0A-\\x1f\\x7f]{1,255}$").unwrap();
}

impl OfferForRecommendationDto {
    #[allow(clippy::new_without_default)]
    pub fn new() -> OfferForRecommendationDto {
        OfferForRecommendationDto {
            offer_id: None,
            price: None,
            cofinance_price: None,
            competitiveness: None,
            shows: None,
        }
    }
}

/// Converts the OfferForRecommendationDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for OfferForRecommendationDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.offer_id.as_ref().map(|offer_id| {
                [
                    "offerId".to_string(),
                    offer_id.to_string(),
                ].join(",")
            }),

            // Skipping price in query parameter serialization

            // Skipping cofinancePrice in query parameter serialization

            // Skipping competitiveness in query parameter serialization


            self.shows.as_ref().map(|shows| {
                [
                    "shows".to_string(),
                    shows.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a OfferForRecommendationDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for OfferForRecommendationDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub offer_id: Vec<String>,
            pub price: Vec<models::BasePriceDto>,
            pub cofinance_price: Vec<models::GetPriceDto>,
            pub competitiveness: Vec<models::PriceCompetitivenessType>,
            pub shows: Vec<i64>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing OfferForRecommendationDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "offerId" => intermediate_rep.offer_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "price" => intermediate_rep.price.push(<models::BasePriceDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "cofinancePrice" => intermediate_rep.cofinance_price.push(<models::GetPriceDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "competitiveness" => intermediate_rep.competitiveness.push(<models::PriceCompetitivenessType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "shows" => intermediate_rep.shows.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing OfferForRecommendationDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(OfferForRecommendationDto {
            offer_id: intermediate_rep.offer_id.into_iter().next(),
            price: intermediate_rep.price.into_iter().next(),
            cofinance_price: intermediate_rep.cofinance_price.into_iter().next(),
            competitiveness: intermediate_rep.competitiveness.into_iter().next(),
            shows: intermediate_rep.shows.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<OfferForRecommendationDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<OfferForRecommendationDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<OfferForRecommendationDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for OfferForRecommendationDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<OfferForRecommendationDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <OfferForRecommendationDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into OfferForRecommendationDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Инструкция по использованию товара. 
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct OfferManualDto {
    /// Ссылка на инструкцию.
    #[serde(rename = "url")]
    pub url: String,

    /// Название инструкции, которое будет отображаться на карточке товара. 
    #[serde(rename = "title")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub title: Option<String>,

}


impl OfferManualDto {
    #[allow(clippy::new_without_default)]
    pub fn new(url: String, ) -> OfferManualDto {
        OfferManualDto {
            url,
            title: None,
        }
    }
}

/// Converts the OfferManualDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for OfferManualDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            Some("url".to_string()),
            Some(self.url.to_string()),


            self.title.as_ref().map(|title| {
                [
                    "title".to_string(),
                    title.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a OfferManualDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for OfferManualDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub url: Vec<String>,
            pub title: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing OfferManualDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "url" => intermediate_rep.url.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "title" => intermediate_rep.title.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing OfferManualDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(OfferManualDto {
            url: intermediate_rep.url.into_iter().next().ok_or_else(|| "url missing in OfferManualDto".to_string())?,
            title: intermediate_rep.title.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<OfferManualDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<OfferManualDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<OfferManualDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for OfferManualDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<OfferManualDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <OfferManualDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into OfferManualDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Информация о текущей карточке товара на Маркете.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct OfferMappingDto {
    /// SKU на Маркете.
    #[serde(rename = "marketSku")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub market_sku: Option<i64>,

    /// Идентификатор модели для текущей карточки товара на Маркете.  Например, две лопатки разных цветов имеют разные SKU на Маркете (параметр `marketSku`), но одинаковый идентификатор модели товара. 
    #[serde(rename = "modelId")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub model_id: Option<i64>,

    /// Идентификатор категории для текущей карточки товара на Маркете.
    #[serde(rename = "categoryId")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub category_id: Option<i64>,

}


impl OfferMappingDto {
    #[allow(clippy::new_without_default)]
    pub fn new() -> OfferMappingDto {
        OfferMappingDto {
            market_sku: None,
            model_id: None,
            category_id: None,
        }
    }
}

/// Converts the OfferMappingDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for OfferMappingDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.market_sku.as_ref().map(|market_sku| {
                [
                    "marketSku".to_string(),
                    market_sku.to_string(),
                ].join(",")
            }),


            self.model_id.as_ref().map(|model_id| {
                [
                    "modelId".to_string(),
                    model_id.to_string(),
                ].join(",")
            }),


            self.category_id.as_ref().map(|category_id| {
                [
                    "categoryId".to_string(),
                    category_id.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a OfferMappingDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for OfferMappingDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub market_sku: Vec<i64>,
            pub model_id: Vec<i64>,
            pub category_id: Vec<i64>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing OfferMappingDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "marketSku" => intermediate_rep.market_sku.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "modelId" => intermediate_rep.model_id.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "categoryId" => intermediate_rep.category_id.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing OfferMappingDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(OfferMappingDto {
            market_sku: intermediate_rep.market_sku.into_iter().next(),
            model_id: intermediate_rep.model_id.into_iter().next(),
            category_id: intermediate_rep.category_id.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<OfferMappingDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<OfferMappingDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<OfferMappingDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for OfferMappingDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<OfferMappingDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <OfferMappingDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into OfferMappingDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Информация о товарах в каталоге.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct OfferMappingEntriesDto {
    #[serde(rename = "paging")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub paging: Option<models::ScrollingPagerDto>,

    /// Информация о товарах в каталоге.
    #[serde(rename = "offerMappingEntries")]
    pub offer_mapping_entries: Vec<models::OfferMappingEntryDto>,

}


impl OfferMappingEntriesDto {
    #[allow(clippy::new_without_default)]
    pub fn new(offer_mapping_entries: Vec<models::OfferMappingEntryDto>, ) -> OfferMappingEntriesDto {
        OfferMappingEntriesDto {
            paging: None,
            offer_mapping_entries,
        }
    }
}

/// Converts the OfferMappingEntriesDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for OfferMappingEntriesDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping paging in query parameter serialization

            // Skipping offerMappingEntries in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a OfferMappingEntriesDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for OfferMappingEntriesDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub paging: Vec<models::ScrollingPagerDto>,
            pub offer_mapping_entries: Vec<Vec<models::OfferMappingEntryDto>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing OfferMappingEntriesDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "paging" => intermediate_rep.paging.push(<models::ScrollingPagerDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "offerMappingEntries" => return std::result::Result::Err("Parsing a container in this style is not supported in OfferMappingEntriesDto".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing OfferMappingEntriesDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(OfferMappingEntriesDto {
            paging: intermediate_rep.paging.into_iter().next(),
            offer_mapping_entries: intermediate_rep.offer_mapping_entries.into_iter().next().ok_or_else(|| "offerMappingEntries missing in OfferMappingEntriesDto".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<OfferMappingEntriesDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<OfferMappingEntriesDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<OfferMappingEntriesDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for OfferMappingEntriesDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<OfferMappingEntriesDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <OfferMappingEntriesDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into OfferMappingEntriesDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Список товаров. 
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct OfferMappingEntryDto {
    #[serde(rename = "mapping")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub mapping: Option<models::OfferMappingDto>,

    #[serde(rename = "awaitingModerationMapping")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub awaiting_moderation_mapping: Option<models::OfferMappingDto>,

    #[serde(rename = "rejectedMapping")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub rejected_mapping: Option<models::OfferMappingDto>,

    #[serde(rename = "offer")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub offer: Option<models::MappingsOfferDto>,

}


impl OfferMappingEntryDto {
    #[allow(clippy::new_without_default)]
    pub fn new() -> OfferMappingEntryDto {
        OfferMappingEntryDto {
            mapping: None,
            awaiting_moderation_mapping: None,
            rejected_mapping: None,
            offer: None,
        }
    }
}

/// Converts the OfferMappingEntryDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for OfferMappingEntryDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping mapping in query parameter serialization

            // Skipping awaitingModerationMapping in query parameter serialization

            // Skipping rejectedMapping in query parameter serialization

            // Skipping offer in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a OfferMappingEntryDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for OfferMappingEntryDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub mapping: Vec<models::OfferMappingDto>,
            pub awaiting_moderation_mapping: Vec<models::OfferMappingDto>,
            pub rejected_mapping: Vec<models::OfferMappingDto>,
            pub offer: Vec<models::MappingsOfferDto>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing OfferMappingEntryDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "mapping" => intermediate_rep.mapping.push(<models::OfferMappingDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "awaitingModerationMapping" => intermediate_rep.awaiting_moderation_mapping.push(<models::OfferMappingDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "rejectedMapping" => intermediate_rep.rejected_mapping.push(<models::OfferMappingDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "offer" => intermediate_rep.offer.push(<models::MappingsOfferDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing OfferMappingEntryDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(OfferMappingEntryDto {
            mapping: intermediate_rep.mapping.into_iter().next(),
            awaiting_moderation_mapping: intermediate_rep.awaiting_moderation_mapping.into_iter().next(),
            rejected_mapping: intermediate_rep.rejected_mapping.into_iter().next(),
            offer: intermediate_rep.offer.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<OfferMappingEntryDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<OfferMappingEntryDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<OfferMappingEntryDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for OfferMappingEntryDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<OfferMappingEntryDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <OfferMappingEntryDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into OfferMappingEntryDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Текст ошибки.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct OfferMappingErrorDto {
    #[serde(rename = "type")]
    pub r#type: models::OfferMappingErrorType,

    /// Идентификатор характеристики, с которой связана ошибка.
    #[serde(rename = "parameterId")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub parameter_id: Option<i64>,

    /// Текст ошибки.
    #[serde(rename = "message")]
    pub message: String,

}


impl OfferMappingErrorDto {
    #[allow(clippy::new_without_default)]
    pub fn new(r#type: models::OfferMappingErrorType, message: String, ) -> OfferMappingErrorDto {
        OfferMappingErrorDto {
            r#type,
            parameter_id: None,
            message,
        }
    }
}

/// Converts the OfferMappingErrorDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for OfferMappingErrorDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping type in query parameter serialization


            self.parameter_id.as_ref().map(|parameter_id| {
                [
                    "parameterId".to_string(),
                    parameter_id.to_string(),
                ].join(",")
            }),


            Some("message".to_string()),
            Some(self.message.to_string()),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a OfferMappingErrorDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for OfferMappingErrorDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub r#type: Vec<models::OfferMappingErrorType>,
            pub parameter_id: Vec<i64>,
            pub message: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing OfferMappingErrorDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r#type.push(<models::OfferMappingErrorType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "parameterId" => intermediate_rep.parameter_id.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "message" => intermediate_rep.message.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing OfferMappingErrorDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(OfferMappingErrorDto {
            r#type: intermediate_rep.r#type.into_iter().next().ok_or_else(|| "type missing in OfferMappingErrorDto".to_string())?,
            parameter_id: intermediate_rep.parameter_id.into_iter().next(),
            message: intermediate_rep.message.into_iter().next().ok_or_else(|| "message missing in OfferMappingErrorDto".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<OfferMappingErrorDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<OfferMappingErrorDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<OfferMappingErrorDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for OfferMappingErrorDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<OfferMappingErrorDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <OfferMappingErrorDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into OfferMappingErrorDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Типы ошибок:  * `UNKNOWN_CATEGORY` — указана неизвестная категория. * `CATEGORY_MISMATCH` — указана категория, которая не совпадает с категорией товара. * `EMPTY_MARKET_CATEGORY` — не указана категория Маркета при передаче характеристик категории. * `UNKNOWN_PARAMETER` — передана характеристика, которой нет среди характеристик категории. * `UNEXPECTED_BOOLEAN_VALUE` — вместо boolean-значения передано что-то другое. * `NUMBER_FORMAT` — передана строка, не обозначающая число, вместо числа. * `VALUE_BLANK` — передано пустое значение. * `INVALID_UNIT_ID` — передана единица измерения, недопустимая для характеристики. * `INVALID_GROUP_ID_LENGTH` — в названии превышено допустимое значение символов — 255. * `INVALID_GROUP_ID_CHARACTERS` — переданы [недопустимые символы](*ascii-code). * `INVALID_PICKER_URL` — передана ссылка на изображение для миниатюры, которой нет в переданных ссылках на изображение товара. 
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum OfferMappingErrorType {
    #[serde(rename = "UNKNOWN_CATEGORY")]
    UnknownCategory,
    #[serde(rename = "CATEGORY_MISMATCH")]
    CategoryMismatch,
    #[serde(rename = "EMPTY_MARKET_CATEGORY")]
    EmptyMarketCategory,
    #[serde(rename = "UNKNOWN_PARAMETER")]
    UnknownParameter,
    #[serde(rename = "UNEXPECTED_BOOLEAN_VALUE")]
    UnexpectedBooleanValue,
    #[serde(rename = "NUMBER_FORMAT")]
    NumberFormat,
    #[serde(rename = "VALUE_BLANK")]
    ValueBlank,
    #[serde(rename = "INVALID_UNIT_ID")]
    InvalidUnitId,
    #[serde(rename = "INVALID_GROUP_ID_LENGTH")]
    InvalidGroupIdLength,
    #[serde(rename = "INVALID_GROUP_ID_CHARACTERS")]
    InvalidGroupIdCharacters,
    #[serde(rename = "INVALID_PICKER_URL")]
    InvalidPickerUrl,
}

impl std::fmt::Display for OfferMappingErrorType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            OfferMappingErrorType::UnknownCategory => write!(f, "UNKNOWN_CATEGORY"),
            OfferMappingErrorType::CategoryMismatch => write!(f, "CATEGORY_MISMATCH"),
            OfferMappingErrorType::EmptyMarketCategory => write!(f, "EMPTY_MARKET_CATEGORY"),
            OfferMappingErrorType::UnknownParameter => write!(f, "UNKNOWN_PARAMETER"),
            OfferMappingErrorType::UnexpectedBooleanValue => write!(f, "UNEXPECTED_BOOLEAN_VALUE"),
            OfferMappingErrorType::NumberFormat => write!(f, "NUMBER_FORMAT"),
            OfferMappingErrorType::ValueBlank => write!(f, "VALUE_BLANK"),
            OfferMappingErrorType::InvalidUnitId => write!(f, "INVALID_UNIT_ID"),
            OfferMappingErrorType::InvalidGroupIdLength => write!(f, "INVALID_GROUP_ID_LENGTH"),
            OfferMappingErrorType::InvalidGroupIdCharacters => write!(f, "INVALID_GROUP_ID_CHARACTERS"),
            OfferMappingErrorType::InvalidPickerUrl => write!(f, "INVALID_PICKER_URL"),
        }
    }
}

impl std::str::FromStr for OfferMappingErrorType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "UNKNOWN_CATEGORY" => std::result::Result::Ok(OfferMappingErrorType::UnknownCategory),
            "CATEGORY_MISMATCH" => std::result::Result::Ok(OfferMappingErrorType::CategoryMismatch),
            "EMPTY_MARKET_CATEGORY" => std::result::Result::Ok(OfferMappingErrorType::EmptyMarketCategory),
            "UNKNOWN_PARAMETER" => std::result::Result::Ok(OfferMappingErrorType::UnknownParameter),
            "UNEXPECTED_BOOLEAN_VALUE" => std::result::Result::Ok(OfferMappingErrorType::UnexpectedBooleanValue),
            "NUMBER_FORMAT" => std::result::Result::Ok(OfferMappingErrorType::NumberFormat),
            "VALUE_BLANK" => std::result::Result::Ok(OfferMappingErrorType::ValueBlank),
            "INVALID_UNIT_ID" => std::result::Result::Ok(OfferMappingErrorType::InvalidUnitId),
            "INVALID_GROUP_ID_LENGTH" => std::result::Result::Ok(OfferMappingErrorType::InvalidGroupIdLength),
            "INVALID_GROUP_ID_CHARACTERS" => std::result::Result::Ok(OfferMappingErrorType::InvalidGroupIdCharacters),
            "INVALID_PICKER_URL" => std::result::Result::Ok(OfferMappingErrorType::InvalidPickerUrl),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Информация о карточке товара.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct OfferMappingInfoDto {
    #[serde(rename = "mapping")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub mapping: Option<models::OfferMappingDto>,

    #[serde(rename = "awaitingModerationMapping")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub awaiting_moderation_mapping: Option<models::OfferMappingDto>,

    #[serde(rename = "rejectedMapping")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub rejected_mapping: Option<models::OfferMappingDto>,

}


impl OfferMappingInfoDto {
    #[allow(clippy::new_without_default)]
    pub fn new() -> OfferMappingInfoDto {
        OfferMappingInfoDto {
            mapping: None,
            awaiting_moderation_mapping: None,
            rejected_mapping: None,
        }
    }
}

/// Converts the OfferMappingInfoDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for OfferMappingInfoDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping mapping in query parameter serialization

            // Skipping awaitingModerationMapping in query parameter serialization

            // Skipping rejectedMapping in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a OfferMappingInfoDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for OfferMappingInfoDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub mapping: Vec<models::OfferMappingDto>,
            pub awaiting_moderation_mapping: Vec<models::OfferMappingDto>,
            pub rejected_mapping: Vec<models::OfferMappingDto>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing OfferMappingInfoDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "mapping" => intermediate_rep.mapping.push(<models::OfferMappingDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "awaitingModerationMapping" => intermediate_rep.awaiting_moderation_mapping.push(<models::OfferMappingDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "rejectedMapping" => intermediate_rep.rejected_mapping.push(<models::OfferMappingDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing OfferMappingInfoDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(OfferMappingInfoDto {
            mapping: intermediate_rep.mapping.into_iter().next(),
            awaiting_moderation_mapping: intermediate_rep.awaiting_moderation_mapping.into_iter().next(),
            rejected_mapping: intermediate_rep.rejected_mapping.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<OfferMappingInfoDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<OfferMappingInfoDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<OfferMappingInfoDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for OfferMappingInfoDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<OfferMappingInfoDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <OfferMappingInfoDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into OfferMappingInfoDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Вид маппинга.
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum OfferMappingKindType {
    #[serde(rename = "ACTIVE")]
    Active,
    #[serde(rename = "ALL")]
    All,
}

impl std::fmt::Display for OfferMappingKindType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            OfferMappingKindType::Active => write!(f, "ACTIVE"),
            OfferMappingKindType::All => write!(f, "ALL"),
        }
    }
}

impl std::str::FromStr for OfferMappingKindType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "ACTIVE" => std::result::Result::Ok(OfferMappingKindType::Active),
            "ALL" => std::result::Result::Ok(OfferMappingKindType::All),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Список рекомендованных карточек товара.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct OfferMappingSuggestionsListDto {
    /// Список товаров.
    #[serde(rename = "offers")]
    pub offers: Vec<models::EnrichedMappingsOfferDto>,

}


impl OfferMappingSuggestionsListDto {
    #[allow(clippy::new_without_default)]
    pub fn new(offers: Vec<models::EnrichedMappingsOfferDto>, ) -> OfferMappingSuggestionsListDto {
        OfferMappingSuggestionsListDto {
            offers,
        }
    }
}

/// Converts the OfferMappingSuggestionsListDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for OfferMappingSuggestionsListDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping offers in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a OfferMappingSuggestionsListDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for OfferMappingSuggestionsListDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub offers: Vec<Vec<models::EnrichedMappingsOfferDto>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing OfferMappingSuggestionsListDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "offers" => return std::result::Result::Err("Parsing a container in this style is not supported in OfferMappingSuggestionsListDto".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing OfferMappingSuggestionsListDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(OfferMappingSuggestionsListDto {
            offers: intermediate_rep.offers.into_iter().next().ok_or_else(|| "offers missing in OfferMappingSuggestionsListDto".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<OfferMappingSuggestionsListDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<OfferMappingSuggestionsListDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<OfferMappingSuggestionsListDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for OfferMappingSuggestionsListDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<OfferMappingSuggestionsListDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <OfferMappingSuggestionsListDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into OfferMappingSuggestionsListDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Составляйте название по схеме: тип + бренд или производитель + модель + особенности, если есть (например, цвет, размер или вес) и количество в упаковке.  Не включайте в название условия продажи (например, «скидка», «бесплатная доставка» и т. д.), эмоциональные характеристики («хит», «супер» и т. д.). Не пишите слова большими буквами — кроме устоявшихся названий брендов и моделей.  Оптимальная длина — 50–60 символов, максимальная — 256.  [Рекомендации и правила](https://yandex.ru/support/marketplace/assortment/fields/title.html) 
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct OfferName(String);

impl std::convert::From<String> for OfferName {
    fn from(x: String) -> Self {
        OfferName(x)
    }
}

impl std::string::ToString for OfferName {
    fn to_string(&self) -> String {
       self.0.to_string()
    }
}

impl std::str::FromStr for OfferName {
    type Err = std::string::ParseError;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(OfferName(x.to_string()))
    }
}

impl std::convert::From<OfferName> for String {
    fn from(x: OfferName) -> Self {
        x.0
    }
}

impl std::ops::Deref for OfferName {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for OfferName {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}


/// Параметры товара.  Если у товара несколько значений одного параметра, передайте их с одним и тем же `name`, но разными `value`.  {% cut \"Пример\" %}  ```json \"params\": [   {     \"name\": \"Цвет\",     \"value\": \"Зеленый\"   },   {     \"name\": \"Цвет\",     \"value\": \"Желтый\"   } ] ```  {% endcut %} 
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct OfferParamDto {
    /// Название.  Должно совпадать с названием характеристики на Маркете. Узнать его можно из Excel-шаблона категории или через запрос [POST category/{categoryId}/parameters](../../reference/content/getCategoryContentParameters.md). 
    #[serde(rename = "name")]
    pub name: String,

    /// Значение. 
    #[serde(rename = "value")]
    pub value: String,

}


impl OfferParamDto {
    #[allow(clippy::new_without_default)]
    pub fn new(name: String, value: String, ) -> OfferParamDto {
        OfferParamDto {
            name,
            value,
        }
    }
}

/// Converts the OfferParamDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for OfferParamDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            Some("name".to_string()),
            Some(self.name.to_string()),


            Some("value".to_string()),
            Some(self.value.to_string()),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a OfferParamDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for OfferParamDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub name: Vec<String>,
            pub value: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing OfferParamDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "value" => intermediate_rep.value.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing OfferParamDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(OfferParamDto {
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "name missing in OfferParamDto".to_string())?,
            value: intermediate_rep.value.into_iter().next().ok_or_else(|| "value missing in OfferParamDto".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<OfferParamDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<OfferParamDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<OfferParamDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for OfferParamDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<OfferParamDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <OfferParamDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into OfferParamDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Список цен.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct OfferPriceByOfferIdsListResponseDto {
    /// Страница списка цен.
    #[serde(rename = "offers")]
    pub offers: Vec<models::OfferPriceByOfferIdsResponseDto>,

    #[serde(rename = "paging")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub paging: Option<models::ScrollingPagerDto>,

}


impl OfferPriceByOfferIdsListResponseDto {
    #[allow(clippy::new_without_default)]
    pub fn new(offers: Vec<models::OfferPriceByOfferIdsResponseDto>, ) -> OfferPriceByOfferIdsListResponseDto {
        OfferPriceByOfferIdsListResponseDto {
            offers,
            paging: None,
        }
    }
}

/// Converts the OfferPriceByOfferIdsListResponseDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for OfferPriceByOfferIdsListResponseDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping offers in query parameter serialization

            // Skipping paging in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a OfferPriceByOfferIdsListResponseDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for OfferPriceByOfferIdsListResponseDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub offers: Vec<Vec<models::OfferPriceByOfferIdsResponseDto>>,
            pub paging: Vec<models::ScrollingPagerDto>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing OfferPriceByOfferIdsListResponseDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "offers" => return std::result::Result::Err("Parsing a container in this style is not supported in OfferPriceByOfferIdsListResponseDto".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "paging" => intermediate_rep.paging.push(<models::ScrollingPagerDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing OfferPriceByOfferIdsListResponseDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(OfferPriceByOfferIdsListResponseDto {
            offers: intermediate_rep.offers.into_iter().next().ok_or_else(|| "offers missing in OfferPriceByOfferIdsListResponseDto".to_string())?,
            paging: intermediate_rep.paging.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<OfferPriceByOfferIdsListResponseDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<OfferPriceByOfferIdsListResponseDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<OfferPriceByOfferIdsListResponseDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for OfferPriceByOfferIdsListResponseDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<OfferPriceByOfferIdsListResponseDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <OfferPriceByOfferIdsListResponseDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into OfferPriceByOfferIdsListResponseDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Информация об установленной цене.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct OfferPriceByOfferIdsResponseDto {
    /// Ваш SKU — идентификатор товара в вашей системе.  Разрешена любая последовательность длиной до 255 знаков.  Правила использования SKU:  * У каждого товара SKU должен быть свой.  * SKU товара нельзя менять — можно только удалить товар и добавить заново с новым SKU.  * Уже заданный SKU нельзя освободить и использовать заново для другого товара. Каждый товар должен получать новый идентификатор, до того никогда не использовавшийся в вашем каталоге.  [Что такое SKU и как его назначать](https://yandex.ru/support/marketplace/assortment/add/index.html#fields) 
    #[serde(rename = "offerId")]
    #[validate(
            length(min = 1, max = 255),
           regex = "RE_OFFERPRICEBYOFFERIDSRESPONSEDTO_OFFER_ID",
        )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub offer_id: Option<String>,

    #[serde(rename = "price")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub price: Option<models::PriceDto>,

    /// Дата и время последнего обновления цены.
    #[serde(rename = "updatedAt")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime::<chrono::Utc>>,

}

lazy_static::lazy_static! {
    static ref RE_OFFERPRICEBYOFFERIDSRESPONSEDTO_OFFER_ID: regex::Regex = regex::Regex::new(r"^[^\\x00-\\x08\\x0A-\\x1f\\x7f]{1,255}$").unwrap();
}

impl OfferPriceByOfferIdsResponseDto {
    #[allow(clippy::new_without_default)]
    pub fn new() -> OfferPriceByOfferIdsResponseDto {
        OfferPriceByOfferIdsResponseDto {
            offer_id: None,
            price: None,
            updated_at: None,
        }
    }
}

/// Converts the OfferPriceByOfferIdsResponseDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for OfferPriceByOfferIdsResponseDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.offer_id.as_ref().map(|offer_id| {
                [
                    "offerId".to_string(),
                    offer_id.to_string(),
                ].join(",")
            }),

            // Skipping price in query parameter serialization

            // Skipping updatedAt in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a OfferPriceByOfferIdsResponseDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for OfferPriceByOfferIdsResponseDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub offer_id: Vec<String>,
            pub price: Vec<models::PriceDto>,
            pub updated_at: Vec<chrono::DateTime::<chrono::Utc>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing OfferPriceByOfferIdsResponseDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "offerId" => intermediate_rep.offer_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "price" => intermediate_rep.price.push(<models::PriceDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "updatedAt" => intermediate_rep.updated_at.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing OfferPriceByOfferIdsResponseDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(OfferPriceByOfferIdsResponseDto {
            offer_id: intermediate_rep.offer_id.into_iter().next(),
            price: intermediate_rep.price.into_iter().next(),
            updated_at: intermediate_rep.updated_at.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<OfferPriceByOfferIdsResponseDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<OfferPriceByOfferIdsResponseDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<OfferPriceByOfferIdsResponseDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for OfferPriceByOfferIdsResponseDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<OfferPriceByOfferIdsResponseDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <OfferPriceByOfferIdsResponseDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into OfferPriceByOfferIdsResponseDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Товар с информацией о новой цене на него.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct OfferPriceDto {
    /// Ваш SKU — идентификатор товара в вашей системе.  Разрешена любая последовательность длиной до 255 знаков.  Правила использования SKU:  * У каждого товара SKU должен быть свой.  * SKU товара нельзя менять — можно только удалить товар и добавить заново с новым SKU.  * Уже заданный SKU нельзя освободить и использовать заново для другого товара. Каждый товар должен получать новый идентификатор, до того никогда не использовавшийся в вашем каталоге.  [Что такое SKU и как его назначать](https://yandex.ru/support/marketplace/assortment/add/index.html#fields) 
    #[serde(rename = "offerId")]
    #[validate(
            length(min = 1, max = 255),
           regex = "RE_OFFERPRICEDTO_OFFER_ID",
        )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub offer_id: Option<String>,

    #[serde(rename = "price")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub price: Option<models::PriceDto>,

}

lazy_static::lazy_static! {
    static ref RE_OFFERPRICEDTO_OFFER_ID: regex::Regex = regex::Regex::new(r"^[^\\x00-\\x08\\x0A-\\x1f\\x7f]{1,255}$").unwrap();
}

impl OfferPriceDto {
    #[allow(clippy::new_without_default)]
    pub fn new() -> OfferPriceDto {
        OfferPriceDto {
            offer_id: None,
            price: None,
        }
    }
}

/// Converts the OfferPriceDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for OfferPriceDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.offer_id.as_ref().map(|offer_id| {
                [
                    "offerId".to_string(),
                    offer_id.to_string(),
                ].join(",")
            }),

            // Skipping price in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a OfferPriceDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for OfferPriceDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub offer_id: Vec<String>,
            pub price: Vec<models::PriceDto>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing OfferPriceDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "offerId" => intermediate_rep.offer_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "price" => intermediate_rep.price.push(<models::PriceDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing OfferPriceDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(OfferPriceDto {
            offer_id: intermediate_rep.offer_id.into_iter().next(),
            price: intermediate_rep.price.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<OfferPriceDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<OfferPriceDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<OfferPriceDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for OfferPriceDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<OfferPriceDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <OfferPriceDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into OfferPriceDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Список цен на товары.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct OfferPriceListResponseDto {
    /// Страница списка.
    #[serde(rename = "offers")]
    pub offers: Vec<models::OfferPriceResponseDto>,

    #[serde(rename = "paging")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub paging: Option<models::ScrollingPagerDto>,

    /// Количество всех цен магазина, измененных через API.
    #[serde(rename = "total")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub total: Option<i32>,

}


impl OfferPriceListResponseDto {
    #[allow(clippy::new_without_default)]
    pub fn new(offers: Vec<models::OfferPriceResponseDto>, ) -> OfferPriceListResponseDto {
        OfferPriceListResponseDto {
            offers,
            paging: None,
            total: None,
        }
    }
}

/// Converts the OfferPriceListResponseDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for OfferPriceListResponseDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping offers in query parameter serialization

            // Skipping paging in query parameter serialization


            self.total.as_ref().map(|total| {
                [
                    "total".to_string(),
                    total.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a OfferPriceListResponseDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for OfferPriceListResponseDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub offers: Vec<Vec<models::OfferPriceResponseDto>>,
            pub paging: Vec<models::ScrollingPagerDto>,
            pub total: Vec<i32>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing OfferPriceListResponseDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "offers" => return std::result::Result::Err("Parsing a container in this style is not supported in OfferPriceListResponseDto".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "paging" => intermediate_rep.paging.push(<models::ScrollingPagerDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "total" => intermediate_rep.total.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing OfferPriceListResponseDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(OfferPriceListResponseDto {
            offers: intermediate_rep.offers.into_iter().next().ok_or_else(|| "offers missing in OfferPriceListResponseDto".to_string())?,
            paging: intermediate_rep.paging.into_iter().next(),
            total: intermediate_rep.total.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<OfferPriceListResponseDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<OfferPriceListResponseDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<OfferPriceListResponseDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for OfferPriceListResponseDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<OfferPriceListResponseDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <OfferPriceListResponseDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into OfferPriceListResponseDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Информация об установленной цене на товар.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct OfferPriceResponseDto {
    /// Идентификатор предложения из прайс-листа.
    #[serde(rename = "id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

    #[serde(rename = "price")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub price: Option<models::PriceDto>,

    /// SKU на Маркете.
    #[serde(rename = "marketSku")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub market_sku: Option<i64>,

    /// Дата и время последнего обновления цены на товар.
    #[serde(rename = "updatedAt")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime::<chrono::Utc>>,

}


impl OfferPriceResponseDto {
    #[allow(clippy::new_without_default)]
    pub fn new() -> OfferPriceResponseDto {
        OfferPriceResponseDto {
            id: None,
            price: None,
            market_sku: None,
            updated_at: None,
        }
    }
}

/// Converts the OfferPriceResponseDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for OfferPriceResponseDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.id.as_ref().map(|id| {
                [
                    "id".to_string(),
                    id.to_string(),
                ].join(",")
            }),

            // Skipping price in query parameter serialization


            self.market_sku.as_ref().map(|market_sku| {
                [
                    "marketSku".to_string(),
                    market_sku.to_string(),
                ].join(",")
            }),

            // Skipping updatedAt in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a OfferPriceResponseDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for OfferPriceResponseDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub price: Vec<models::PriceDto>,
            pub market_sku: Vec<i64>,
            pub updated_at: Vec<chrono::DateTime::<chrono::Utc>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing OfferPriceResponseDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "price" => intermediate_rep.price.push(<models::PriceDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "marketSku" => intermediate_rep.market_sku.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "updatedAt" => intermediate_rep.updated_at.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing OfferPriceResponseDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(OfferPriceResponseDto {
            id: intermediate_rep.id.into_iter().next(),
            price: intermediate_rep.price.into_iter().next(),
            market_sku: intermediate_rep.market_sku.into_iter().next(),
            updated_at: intermediate_rep.updated_at.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<OfferPriceResponseDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<OfferPriceResponseDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<OfferPriceResponseDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for OfferPriceResponseDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<OfferPriceResponseDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <OfferPriceResponseDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into OfferPriceResponseDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Причины, по которым товар не прошел модерацию.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct OfferProcessingNoteDto {
    #[serde(rename = "type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub r#type: Option<models::OfferProcessingNoteType>,

    /// Дополнительная информация о причине отклонения товара. 
    #[serde(rename = "payload")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub payload: Option<String>,

}


impl OfferProcessingNoteDto {
    #[allow(clippy::new_without_default)]
    pub fn new() -> OfferProcessingNoteDto {
        OfferProcessingNoteDto {
            r#type: None,
            payload: None,
        }
    }
}

/// Converts the OfferProcessingNoteDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for OfferProcessingNoteDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping type in query parameter serialization


            self.payload.as_ref().map(|payload| {
                [
                    "payload".to_string(),
                    payload.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a OfferProcessingNoteDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for OfferProcessingNoteDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub r#type: Vec<models::OfferProcessingNoteType>,
            pub payload: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing OfferProcessingNoteDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r#type.push(<models::OfferProcessingNoteType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "payload" => intermediate_rep.payload.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing OfferProcessingNoteDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(OfferProcessingNoteDto {
            r#type: intermediate_rep.r#type.into_iter().next(),
            payload: intermediate_rep.payload.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<OfferProcessingNoteDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<OfferProcessingNoteDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<OfferProcessingNoteDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for OfferProcessingNoteDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<OfferProcessingNoteDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <OfferProcessingNoteDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into OfferProcessingNoteDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Тип причины, по которой товар не прошел модерацию:  * `ASSORTMENT` — товар производится в разных вариантах. Каждый из них нужно описать как отдельный товар (входной параметр `offer-mapping-entry` запроса [POST campaigns/{campaignId}/offer-mapping-entries/updates](../../reference/offer-mappings/updateOfferMappingEntries.md) или строка в каталоге, если вы загружаете товары через кабинет продавца на Маркете). * `CANCELLED` — товар отозван с модерации по вашей инициативе. * `CONFLICTING_INFORMATION` _(ранее ошибочно `CONFLICTING`)_ — вы предоставили противоречивую информацию о товаре. Параметры, которые нужно исправить, указаны в параметре `payload`. * `DEPARTMENT_FROZEN` — правила размещения товаров в данной категории перерабатываются, поэтому товар пока не может пройти модерацию. * `INCORRECT_INFORMATION` — информация о товаре, которую вы предоставили, противоречит описанию от производителя. Параметры, которые нужно исправить, указаны в параметре `payload`. * `LEGAL_CONFLICT` — товар не прошел модерацию по юридическим причинам. Например, он официально не продается в России или у вас нет разрешения на его продажу. * `NEED_CLASSIFICATION_INFORMATION` — информации о товаре, которую вы предоставили, не хватает, чтобы отнести его к категории. Проверьте, что правильно указали название, категорию, производителя и страны производства товара, а также URL изображений или страниц с описанием, по которым можно идентифицировать товар. * `NEED_INFORMATION` — товар раньше не продавался в России и пока не размещается на Маркете. Для него можно создать карточку. Подробнее см. в разделе [Работа с карточкой товара](https://yandex.ru/support/marketplace/assortment/content/index.html) Справки Маркета для продавцов. * `NEED_PICTURES` — для идентификации товара нужны его изображения. Отправьте URL изображений товара в запросе [POST campaigns/{campaignId}/offer-mapping-entries/updates](../../reference/offer-mappings/updateOfferMappingEntries.md) или загрузите обновленный каталог через кабинет продавца на Маркете. * `NEED_VENDOR` — неверно указан производитель товара. * `NO_CATEGORY`, `NO_KNOWLEDGE` — товары из указанной категории пока не размещаются на Маркете. Если категория появится, товар будет снова отправлен на модерацию. * `NO_PARAMETERS_IN_SHOP_TITLE` — товар производится в разных вариантах, и из указанного названия непонятно, о каком идет речь. Параметры, которые нужно добавить в название товара, указаны в параметре `payload`. * `NO_SIZE_MEASURE` — для этого товара нужна размерная сетка. Отправьте ее в службу поддержки или вашему менеджеру. Требования к размерной сетке указаны в параметре `payload`. * `UNKNOWN` — товар не прошел модерацию по другой причине. Обратитесь в службу поддержки или к вашему менеджеру. 
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum OfferProcessingNoteType {
    #[serde(rename = "ASSORTMENT")]
    Assortment,
    #[serde(rename = "CANCELLED")]
    Cancelled,
    #[serde(rename = "CONFLICTING_INFORMATION")]
    ConflictingInformation,
    #[serde(rename = "OTHER")]
    Other,
    #[serde(rename = "DEPARTMENT_FROZEN")]
    DepartmentFrozen,
    #[serde(rename = "INCORRECT_INFORMATION")]
    IncorrectInformation,
    #[serde(rename = "LEGAL_CONFLICT")]
    LegalConflict,
    #[serde(rename = "NEED_CLASSIFICATION_INFORMATION")]
    NeedClassificationInformation,
    #[serde(rename = "NEED_INFORMATION")]
    NeedInformation,
    #[serde(rename = "NEED_PICTURES")]
    NeedPictures,
    #[serde(rename = "NEED_VENDOR")]
    NeedVendor,
    #[serde(rename = "NO_CATEGORY")]
    NoCategory,
    #[serde(rename = "NO_KNOWLEDGE")]
    NoKnowledge,
    #[serde(rename = "NO_PARAMETERS_IN_SHOP_TITLE")]
    NoParametersInShopTitle,
    #[serde(rename = "NO_SIZE_MEASURE")]
    NoSizeMeasure,
    #[serde(rename = "SAMPLE_LINE")]
    SampleLine,
}

impl std::fmt::Display for OfferProcessingNoteType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            OfferProcessingNoteType::Assortment => write!(f, "ASSORTMENT"),
            OfferProcessingNoteType::Cancelled => write!(f, "CANCELLED"),
            OfferProcessingNoteType::ConflictingInformation => write!(f, "CONFLICTING_INFORMATION"),
            OfferProcessingNoteType::Other => write!(f, "OTHER"),
            OfferProcessingNoteType::DepartmentFrozen => write!(f, "DEPARTMENT_FROZEN"),
            OfferProcessingNoteType::IncorrectInformation => write!(f, "INCORRECT_INFORMATION"),
            OfferProcessingNoteType::LegalConflict => write!(f, "LEGAL_CONFLICT"),
            OfferProcessingNoteType::NeedClassificationInformation => write!(f, "NEED_CLASSIFICATION_INFORMATION"),
            OfferProcessingNoteType::NeedInformation => write!(f, "NEED_INFORMATION"),
            OfferProcessingNoteType::NeedPictures => write!(f, "NEED_PICTURES"),
            OfferProcessingNoteType::NeedVendor => write!(f, "NEED_VENDOR"),
            OfferProcessingNoteType::NoCategory => write!(f, "NO_CATEGORY"),
            OfferProcessingNoteType::NoKnowledge => write!(f, "NO_KNOWLEDGE"),
            OfferProcessingNoteType::NoParametersInShopTitle => write!(f, "NO_PARAMETERS_IN_SHOP_TITLE"),
            OfferProcessingNoteType::NoSizeMeasure => write!(f, "NO_SIZE_MEASURE"),
            OfferProcessingNoteType::SampleLine => write!(f, "SAMPLE_LINE"),
        }
    }
}

impl std::str::FromStr for OfferProcessingNoteType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "ASSORTMENT" => std::result::Result::Ok(OfferProcessingNoteType::Assortment),
            "CANCELLED" => std::result::Result::Ok(OfferProcessingNoteType::Cancelled),
            "CONFLICTING_INFORMATION" => std::result::Result::Ok(OfferProcessingNoteType::ConflictingInformation),
            "OTHER" => std::result::Result::Ok(OfferProcessingNoteType::Other),
            "DEPARTMENT_FROZEN" => std::result::Result::Ok(OfferProcessingNoteType::DepartmentFrozen),
            "INCORRECT_INFORMATION" => std::result::Result::Ok(OfferProcessingNoteType::IncorrectInformation),
            "LEGAL_CONFLICT" => std::result::Result::Ok(OfferProcessingNoteType::LegalConflict),
            "NEED_CLASSIFICATION_INFORMATION" => std::result::Result::Ok(OfferProcessingNoteType::NeedClassificationInformation),
            "NEED_INFORMATION" => std::result::Result::Ok(OfferProcessingNoteType::NeedInformation),
            "NEED_PICTURES" => std::result::Result::Ok(OfferProcessingNoteType::NeedPictures),
            "NEED_VENDOR" => std::result::Result::Ok(OfferProcessingNoteType::NeedVendor),
            "NO_CATEGORY" => std::result::Result::Ok(OfferProcessingNoteType::NoCategory),
            "NO_KNOWLEDGE" => std::result::Result::Ok(OfferProcessingNoteType::NoKnowledge),
            "NO_PARAMETERS_IN_SHOP_TITLE" => std::result::Result::Ok(OfferProcessingNoteType::NoParametersInShopTitle),
            "NO_SIZE_MEASURE" => std::result::Result::Ok(OfferProcessingNoteType::NoSizeMeasure),
            "SAMPLE_LINE" => std::result::Result::Ok(OfferProcessingNoteType::SampleLine),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Информация о статусе публикации товара на Маркете.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct OfferProcessingStateDto {
    #[serde(rename = "status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<models::OfferProcessingStatusType>,

    /// Причины, по которым товар не прошел модерацию.
    #[serde(rename = "notes")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub notes: Option<swagger::Nullable<Vec<models::OfferProcessingNoteDto>>>,

}


impl OfferProcessingStateDto {
    #[allow(clippy::new_without_default)]
    pub fn new() -> OfferProcessingStateDto {
        OfferProcessingStateDto {
            status: None,
            notes: None,
        }
    }
}

/// Converts the OfferProcessingStateDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for OfferProcessingStateDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping status in query parameter serialization

            // Skipping notes in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a OfferProcessingStateDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for OfferProcessingStateDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub status: Vec<models::OfferProcessingStatusType>,
            pub notes: Vec<Vec<models::OfferProcessingNoteDto>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing OfferProcessingStateDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(<models::OfferProcessingStatusType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "notes" => return std::result::Result::Err("Parsing a container in this style is not supported in OfferProcessingStateDto".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing OfferProcessingStateDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(OfferProcessingStateDto {
            status: intermediate_rep.status.into_iter().next(),
            notes: std::result::Result::Err("Nullable types not supported in OfferProcessingStateDto".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<OfferProcessingStateDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<OfferProcessingStateDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<OfferProcessingStateDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for OfferProcessingStateDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<OfferProcessingStateDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <OfferProcessingStateDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into OfferProcessingStateDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Статус публикации товара:  * `READY` — товар прошел модерацию. Чтобы разместить его на Маркете, установите для него цену. * `IN_WORK` — товар проходит модерацию. Это занимает несколько дней. * `NEED_CONTENT` — для товара без SKU на Маркете `marketSku` нужно найти карточку самостоятельно (через API или кабинет продавца на Маркете) или создать ее, если товар еще не продается на Маркете. * `NEED_INFO` — товар не прошел модерацию из-за ошибок или недостающих сведений в описании товара. Информация о причинах отклонения возвращается в параметре `notes`. * `REJECTED` — товар не прошел модерацию, так как Маркет не планирует размещать подобные товары. * `SUSPENDED` — товар не прошел модерацию, так как Маркет пока не размещает подобные товары. 
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum OfferProcessingStatusType {
    #[serde(rename = "UNKNOWN")]
    Unknown,
    #[serde(rename = "READY")]
    Ready,
    #[serde(rename = "IN_WORK")]
    InWork,
    #[serde(rename = "NEED_INFO")]
    NeedInfo,
    #[serde(rename = "NEED_MAPPING")]
    NeedMapping,
    #[serde(rename = "NEED_CONTENT")]
    NeedContent,
    #[serde(rename = "CONTENT_PROCESSING")]
    ContentProcessing,
    #[serde(rename = "SUSPENDED")]
    Suspended,
    #[serde(rename = "REJECTED")]
    Rejected,
    #[serde(rename = "REVIEW")]
    Review,
    #[serde(rename = "CREATE_ERROR")]
    CreateError,
    #[serde(rename = "UPDATE_ERROR")]
    UpdateError,
}

impl std::fmt::Display for OfferProcessingStatusType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            OfferProcessingStatusType::Unknown => write!(f, "UNKNOWN"),
            OfferProcessingStatusType::Ready => write!(f, "READY"),
            OfferProcessingStatusType::InWork => write!(f, "IN_WORK"),
            OfferProcessingStatusType::NeedInfo => write!(f, "NEED_INFO"),
            OfferProcessingStatusType::NeedMapping => write!(f, "NEED_MAPPING"),
            OfferProcessingStatusType::NeedContent => write!(f, "NEED_CONTENT"),
            OfferProcessingStatusType::ContentProcessing => write!(f, "CONTENT_PROCESSING"),
            OfferProcessingStatusType::Suspended => write!(f, "SUSPENDED"),
            OfferProcessingStatusType::Rejected => write!(f, "REJECTED"),
            OfferProcessingStatusType::Review => write!(f, "REVIEW"),
            OfferProcessingStatusType::CreateError => write!(f, "CREATE_ERROR"),
            OfferProcessingStatusType::UpdateError => write!(f, "UPDATE_ERROR"),
        }
    }
}

impl std::str::FromStr for OfferProcessingStatusType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "UNKNOWN" => std::result::Result::Ok(OfferProcessingStatusType::Unknown),
            "READY" => std::result::Result::Ok(OfferProcessingStatusType::Ready),
            "IN_WORK" => std::result::Result::Ok(OfferProcessingStatusType::InWork),
            "NEED_INFO" => std::result::Result::Ok(OfferProcessingStatusType::NeedInfo),
            "NEED_MAPPING" => std::result::Result::Ok(OfferProcessingStatusType::NeedMapping),
            "NEED_CONTENT" => std::result::Result::Ok(OfferProcessingStatusType::NeedContent),
            "CONTENT_PROCESSING" => std::result::Result::Ok(OfferProcessingStatusType::ContentProcessing),
            "SUSPENDED" => std::result::Result::Ok(OfferProcessingStatusType::Suspended),
            "REJECTED" => std::result::Result::Ok(OfferProcessingStatusType::Rejected),
            "REVIEW" => std::result::Result::Ok(OfferProcessingStatusType::Review),
            "CREATE_ERROR" => std::result::Result::Ok(OfferProcessingStatusType::CreateError),
            "UPDATE_ERROR" => std::result::Result::Ok(OfferProcessingStatusType::UpdateError),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Информация о состоянии цен и рекомендации. 
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct OfferRecommendationDto {
    #[serde(rename = "offer")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub offer: Option<models::OfferForRecommendationDto>,

    #[serde(rename = "recommendation")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub recommendation: Option<models::OfferRecommendationInfoDto>,

}


impl OfferRecommendationDto {
    #[allow(clippy::new_without_default)]
    pub fn new() -> OfferRecommendationDto {
        OfferRecommendationDto {
            offer: None,
            recommendation: None,
        }
    }
}

/// Converts the OfferRecommendationDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for OfferRecommendationDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping offer in query parameter serialization

            // Skipping recommendation in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a OfferRecommendationDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for OfferRecommendationDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub offer: Vec<models::OfferForRecommendationDto>,
            pub recommendation: Vec<models::OfferRecommendationInfoDto>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing OfferRecommendationDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "offer" => intermediate_rep.offer.push(<models::OfferForRecommendationDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "recommendation" => intermediate_rep.recommendation.push(<models::OfferRecommendationInfoDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing OfferRecommendationDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(OfferRecommendationDto {
            offer: intermediate_rep.offer.into_iter().next(),
            recommendation: intermediate_rep.recommendation.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<OfferRecommendationDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<OfferRecommendationDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<OfferRecommendationDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for OfferRecommendationDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<OfferRecommendationDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <OfferRecommendationDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into OfferRecommendationDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Рекомендации, касающиеся цены на товар.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct OfferRecommendationInfoDto {
    /// Ваш SKU — идентификатор товара в вашей системе.  Разрешена любая последовательность длиной до 255 знаков.  Правила использования SKU:  * У каждого товара SKU должен быть свой.  * SKU товара нельзя менять — можно только удалить товар и добавить заново с новым SKU.  * Уже заданный SKU нельзя освободить и использовать заново для другого товара. Каждый товар должен получать новый идентификатор, до того никогда не использовавшийся в вашем каталоге.  [Что такое SKU и как его назначать](https://yandex.ru/support/marketplace/assortment/add/index.html#fields) 
    #[serde(rename = "offerId")]
    #[validate(
            length(min = 1, max = 255),
           regex = "RE_OFFERRECOMMENDATIONINFODTO_OFFER_ID",
        )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub offer_id: Option<String>,

    #[serde(rename = "recommendedCofinancePrice")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub recommended_cofinance_price: Option<models::BasePriceDto>,

    #[serde(rename = "competitivenessThresholds")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub competitiveness_thresholds: Option<models::PriceCompetitivenessThresholdsDto>,

}

lazy_static::lazy_static! {
    static ref RE_OFFERRECOMMENDATIONINFODTO_OFFER_ID: regex::Regex = regex::Regex::new(r"^[^\\x00-\\x08\\x0A-\\x1f\\x7f]{1,255}$").unwrap();
}

impl OfferRecommendationInfoDto {
    #[allow(clippy::new_without_default)]
    pub fn new() -> OfferRecommendationInfoDto {
        OfferRecommendationInfoDto {
            offer_id: None,
            recommended_cofinance_price: None,
            competitiveness_thresholds: None,
        }
    }
}

/// Converts the OfferRecommendationInfoDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for OfferRecommendationInfoDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.offer_id.as_ref().map(|offer_id| {
                [
                    "offerId".to_string(),
                    offer_id.to_string(),
                ].join(",")
            }),

            // Skipping recommendedCofinancePrice in query parameter serialization

            // Skipping competitivenessThresholds in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a OfferRecommendationInfoDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for OfferRecommendationInfoDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub offer_id: Vec<String>,
            pub recommended_cofinance_price: Vec<models::BasePriceDto>,
            pub competitiveness_thresholds: Vec<models::PriceCompetitivenessThresholdsDto>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing OfferRecommendationInfoDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "offerId" => intermediate_rep.offer_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "recommendedCofinancePrice" => intermediate_rep.recommended_cofinance_price.push(<models::BasePriceDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "competitivenessThresholds" => intermediate_rep.competitiveness_thresholds.push(<models::PriceCompetitivenessThresholdsDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing OfferRecommendationInfoDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(OfferRecommendationInfoDto {
            offer_id: intermediate_rep.offer_id.into_iter().next(),
            recommended_cofinance_price: intermediate_rep.recommended_cofinance_price.into_iter().next(),
            competitiveness_thresholds: intermediate_rep.competitiveness_thresholds.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<OfferRecommendationInfoDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<OfferRecommendationInfoDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<OfferRecommendationInfoDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for OfferRecommendationInfoDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<OfferRecommendationInfoDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <OfferRecommendationInfoDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into OfferRecommendationInfoDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Список товаров с рекомендациями.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct OfferRecommendationsResultDto {
    #[serde(rename = "paging")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub paging: Option<models::ScrollingPagerDto>,

    /// Страница списка товаров.
    #[serde(rename = "offerRecommendations")]
    pub offer_recommendations: Vec<models::OfferRecommendationDto>,

}


impl OfferRecommendationsResultDto {
    #[allow(clippy::new_without_default)]
    pub fn new(offer_recommendations: Vec<models::OfferRecommendationDto>, ) -> OfferRecommendationsResultDto {
        OfferRecommendationsResultDto {
            paging: None,
            offer_recommendations,
        }
    }
}

/// Converts the OfferRecommendationsResultDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for OfferRecommendationsResultDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping paging in query parameter serialization

            // Skipping offerRecommendations in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a OfferRecommendationsResultDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for OfferRecommendationsResultDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub paging: Vec<models::ScrollingPagerDto>,
            pub offer_recommendations: Vec<Vec<models::OfferRecommendationDto>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing OfferRecommendationsResultDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "paging" => intermediate_rep.paging.push(<models::ScrollingPagerDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "offerRecommendations" => return std::result::Result::Err("Parsing a container in this style is not supported in OfferRecommendationsResultDto".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing OfferRecommendationsResultDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(OfferRecommendationsResultDto {
            paging: intermediate_rep.paging.into_iter().next(),
            offer_recommendations: intermediate_rep.offer_recommendations.into_iter().next().ok_or_else(|| "offerRecommendations missing in OfferRecommendationsResultDto".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<OfferRecommendationsResultDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<OfferRecommendationsResultDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<OfferRecommendationsResultDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for OfferRecommendationsResultDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<OfferRecommendationsResultDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <OfferRecommendationsResultDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into OfferRecommendationsResultDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Информация о том, по каким моделям можно продавать товар, а по каким нельзя.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct OfferSellingProgramDto {
    #[serde(rename = "sellingProgram")]
    pub selling_program: models::SellingProgramType,

    #[serde(rename = "status")]
    pub status: models::OfferSellingProgramStatusType,

}


impl OfferSellingProgramDto {
    #[allow(clippy::new_without_default)]
    pub fn new(selling_program: models::SellingProgramType, status: models::OfferSellingProgramStatusType, ) -> OfferSellingProgramDto {
        OfferSellingProgramDto {
            selling_program,
            status,
        }
    }
}

/// Converts the OfferSellingProgramDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for OfferSellingProgramDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping sellingProgram in query parameter serialization

            // Skipping status in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a OfferSellingProgramDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for OfferSellingProgramDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub selling_program: Vec<models::SellingProgramType>,
            pub status: Vec<models::OfferSellingProgramStatusType>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing OfferSellingProgramDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "sellingProgram" => intermediate_rep.selling_program.push(<models::SellingProgramType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(<models::OfferSellingProgramStatusType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing OfferSellingProgramDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(OfferSellingProgramDto {
            selling_program: intermediate_rep.selling_program.into_iter().next().ok_or_else(|| "sellingProgram missing in OfferSellingProgramDto".to_string())?,
            status: intermediate_rep.status.into_iter().next().ok_or_else(|| "status missing in OfferSellingProgramDto".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<OfferSellingProgramDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<OfferSellingProgramDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<OfferSellingProgramDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for OfferSellingProgramDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<OfferSellingProgramDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <OfferSellingProgramDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into OfferSellingProgramDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Информация о доступности или недоступности.  * `FINE` — доступно. * `REJECT` — недоступно. 
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum OfferSellingProgramStatusType {
    #[serde(rename = "FINE")]
    Fine,
    #[serde(rename = "REJECT")]
    Reject,
}

impl std::fmt::Display for OfferSellingProgramStatusType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            OfferSellingProgramStatusType::Fine => write!(f, "FINE"),
            OfferSellingProgramStatusType::Reject => write!(f, "REJECT"),
        }
    }
}

impl std::str::FromStr for OfferSellingProgramStatusType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "FINE" => std::result::Result::Ok(OfferSellingProgramStatusType::Fine),
            "REJECT" => std::result::Result::Ok(OfferSellingProgramStatusType::Reject),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Особый тип товара:  * `MEDICINE` — лекарства. * `BOOK` — бумажные и электронные книги. * `AUDIOBOOK` — аудиокниги. * `ARTIST_TITLE` — музыкальная и видеопродукция. * `ON_DEMAND` — товары на заказ.  {% note info \"Если ваш товар — книга\" %}  Укажите год издания в характеристиках товара. [Подробнее о параметре](../../reference/business-assortment/updateOfferMappings.md#offerparamdto)  {% endnote %} 
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum OfferType {
    #[serde(rename = "DEFAULT")]
    Default,
    #[serde(rename = "MEDICINE")]
    Medicine,
    #[serde(rename = "BOOK")]
    Book,
    #[serde(rename = "AUDIOBOOK")]
    Audiobook,
    #[serde(rename = "ARTIST_TITLE")]
    ArtistTitle,
    #[serde(rename = "ON_DEMAND")]
    OnDemand,
}

impl std::fmt::Display for OfferType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            OfferType::Default => write!(f, "DEFAULT"),
            OfferType::Medicine => write!(f, "MEDICINE"),
            OfferType::Book => write!(f, "BOOK"),
            OfferType::Audiobook => write!(f, "AUDIOBOOK"),
            OfferType::ArtistTitle => write!(f, "ARTIST_TITLE"),
            OfferType::OnDemand => write!(f, "ON_DEMAND"),
        }
    }
}

impl std::str::FromStr for OfferType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "DEFAULT" => std::result::Result::Ok(OfferType::Default),
            "MEDICINE" => std::result::Result::Ok(OfferType::Medicine),
            "BOOK" => std::result::Result::Ok(OfferType::Book),
            "AUDIOBOOK" => std::result::Result::Ok(OfferType::Audiobook),
            "ARTIST_TITLE" => std::result::Result::Ok(OfferType::ArtistTitle),
            "ON_DEMAND" => std::result::Result::Ok(OfferType::OnDemand),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Название бренда или производителя. Должно быть записано так, как его пишет сам бренд.
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct OfferVendor(String);

impl std::convert::From<String> for OfferVendor {
    fn from(x: String) -> Self {
        OfferVendor(x)
    }
}

impl std::string::ToString for OfferVendor {
    fn to_string(&self) -> String {
       self.0.to_string()
    }
}

impl std::str::FromStr for OfferVendor {
    type Err = std::string::ParseError;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(OfferVendor(x.to_string()))
    }
}

impl std::convert::From<OfferVendor> for String {
    fn from(x: OfferVendor) -> Self {
        x.0
    }
}

impl std::ops::Deref for OfferVendor {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for OfferVendor {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}


/// Артикул товара от производителя.
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct OfferVendorCode(String);

impl std::convert::From<String> for OfferVendorCode {
    fn from(x: String) -> Self {
        OfferVendorCode(x)
    }
}

impl std::string::ToString for OfferVendorCode {
    fn to_string(&self) -> String {
       self.0.to_string()
    }
}

impl std::str::FromStr for OfferVendorCode {
    type Err = std::string::ParseError;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(OfferVendorCode(x.to_string()))
    }
}

impl std::convert::From<OfferVendorCode> for String {
    fn from(x: OfferVendorCode) -> Self {
        x.0
    }
}

impl std::ops::Deref for OfferVendorCode {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for OfferVendorCode {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}


/// Габариты упаковки и вес товара.  Если товар занимает несколько коробок, перед измерением размеров сложите их компактно.  ![Схема измерения многоместных грузов](../../_images/reference/boxes-measure.png) 
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct OfferWeightDimensionsDto {
    /// Длина упаковки в см. 
    #[serde(rename = "length")]
    pub length: f64,

    /// Ширина упаковки в см. 
    #[serde(rename = "width")]
    pub width: f64,

    /// Высота упаковки в см. 
    #[serde(rename = "height")]
    pub height: f64,

    /// Вес товара в кг с учетом упаковки (брутто). 
    #[serde(rename = "weight")]
    pub weight: f64,

}


impl OfferWeightDimensionsDto {
    #[allow(clippy::new_without_default)]
    pub fn new(length: f64, width: f64, height: f64, weight: f64, ) -> OfferWeightDimensionsDto {
        OfferWeightDimensionsDto {
            length,
            width,
            height,
            weight,
        }
    }
}

/// Converts the OfferWeightDimensionsDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for OfferWeightDimensionsDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            Some("length".to_string()),
            Some(self.length.to_string()),


            Some("width".to_string()),
            Some(self.width.to_string()),


            Some("height".to_string()),
            Some(self.height.to_string()),


            Some("weight".to_string()),
            Some(self.weight.to_string()),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a OfferWeightDimensionsDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for OfferWeightDimensionsDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub length: Vec<f64>,
            pub width: Vec<f64>,
            pub height: Vec<f64>,
            pub weight: Vec<f64>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing OfferWeightDimensionsDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "length" => intermediate_rep.length.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "width" => intermediate_rep.width.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "height" => intermediate_rep.height.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "weight" => intermediate_rep.weight.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing OfferWeightDimensionsDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(OfferWeightDimensionsDto {
            length: intermediate_rep.length.into_iter().next().ok_or_else(|| "length missing in OfferWeightDimensionsDto".to_string())?,
            width: intermediate_rep.width.into_iter().next().ok_or_else(|| "width missing in OfferWeightDimensionsDto".to_string())?,
            height: intermediate_rep.height.into_iter().next().ok_or_else(|| "height missing in OfferWeightDimensionsDto".to_string())?,
            weight: intermediate_rep.weight.into_iter().next().ok_or_else(|| "weight missing in OfferWeightDimensionsDto".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<OfferWeightDimensionsDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<OfferWeightDimensionsDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<OfferWeightDimensionsDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for OfferWeightDimensionsDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<OfferWeightDimensionsDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <OfferWeightDimensionsDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into OfferWeightDimensionsDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Найденные предложения магазина.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct OffersDto {
    /// Список предложений магазина.
    #[serde(rename = "offers")]
    pub offers: Vec<models::OfferDto>,

}


impl OffersDto {
    #[allow(clippy::new_without_default)]
    pub fn new(offers: Vec<models::OfferDto>, ) -> OffersDto {
        OffersDto {
            offers,
        }
    }
}

/// Converts the OffersDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for OffersDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping offers in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a OffersDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for OffersDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub offers: Vec<Vec<models::OfferDto>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing OffersDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "offers" => return std::result::Result::Err("Parsing a container in this style is not supported in OffersDto".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing OffersDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(OffersDto {
            offers: intermediate_rep.offers.into_iter().next().ok_or_else(|| "offers missing in OffersDto".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<OffersDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<OffersDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<OffersDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for OffersDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<OffersDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <OffersDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into OffersDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Значение ограничивающей характеристики и список допустимых значений ограничиваемой характеристики.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct OptionValuesLimitedDto {
    /// Идентификатор значения ограничивающей характеристики.
    #[serde(rename = "limitingOptionValueId")]
    pub limiting_option_value_id: i64,

    /// Идентификаторы допустимых значений ограничиваемой характеристики. 
    #[serde(rename = "optionValueIds")]
    pub option_value_ids: Vec<i64>,

}


impl OptionValuesLimitedDto {
    #[allow(clippy::new_without_default)]
    pub fn new(limiting_option_value_id: i64, option_value_ids: Vec<i64>, ) -> OptionValuesLimitedDto {
        OptionValuesLimitedDto {
            limiting_option_value_id,
            option_value_ids,
        }
    }
}

/// Converts the OptionValuesLimitedDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for OptionValuesLimitedDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            Some("limitingOptionValueId".to_string()),
            Some(self.limiting_option_value_id.to_string()),


            Some("optionValueIds".to_string()),
            Some(self.option_value_ids.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a OptionValuesLimitedDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for OptionValuesLimitedDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub limiting_option_value_id: Vec<i64>,
            pub option_value_ids: Vec<Vec<i64>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing OptionValuesLimitedDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "limitingOptionValueId" => intermediate_rep.limiting_option_value_id.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "optionValueIds" => return std::result::Result::Err("Parsing a container in this style is not supported in OptionValuesLimitedDto".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing OptionValuesLimitedDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(OptionValuesLimitedDto {
            limiting_option_value_id: intermediate_rep.limiting_option_value_id.into_iter().next().ok_or_else(|| "limitingOptionValueId missing in OptionValuesLimitedDto".to_string())?,
            option_value_ids: intermediate_rep.option_value_ids.into_iter().next().ok_or_else(|| "optionValueIds missing in OptionValuesLimitedDto".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<OptionValuesLimitedDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<OptionValuesLimitedDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<OptionValuesLimitedDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for OptionValuesLimitedDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<OptionValuesLimitedDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <OptionValuesLimitedDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into OptionValuesLimitedDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Информация о коробке.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct OrderBoxLayoutDto {
    /// Список товаров в коробке.  Если в коробке едет часть большого товара, в списке может быть только один пункт. 
    #[serde(rename = "items")]
    #[validate(
            length(min = 1),
        )]
    pub items: Vec<models::OrderBoxLayoutItemDto>,

}


impl OrderBoxLayoutDto {
    #[allow(clippy::new_without_default)]
    pub fn new(items: Vec<models::OrderBoxLayoutItemDto>, ) -> OrderBoxLayoutDto {
        OrderBoxLayoutDto {
            items,
        }
    }
}

/// Converts the OrderBoxLayoutDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for OrderBoxLayoutDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping items in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a OrderBoxLayoutDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for OrderBoxLayoutDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub items: Vec<Vec<models::OrderBoxLayoutItemDto>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing OrderBoxLayoutDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "items" => return std::result::Result::Err("Parsing a container in this style is not supported in OrderBoxLayoutDto".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing OrderBoxLayoutDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(OrderBoxLayoutDto {
            items: intermediate_rep.items.into_iter().next().ok_or_else(|| "items missing in OrderBoxLayoutDto".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<OrderBoxLayoutDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<OrderBoxLayoutDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<OrderBoxLayoutDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for OrderBoxLayoutDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<OrderBoxLayoutDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <OrderBoxLayoutDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into OrderBoxLayoutDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Информация о товаре в коробке.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct OrderBoxLayoutItemDto {
    /// Идентификатор товара в заказе.  {% cut \"Где его взять\" %}  Идентификатор приходит в ответе на запрос [GET campaigns/{campaignId}/orders/{orderId}](../../reference/orders/getOrder.md) и в запросе Маркета [POST order/accept](../../pushapi/reference/orderAccept.md) — параметр `id` в `items`.  {% endcut %}   
    #[serde(rename = "id")]
    pub id: i64,

    /// Количество единиц товара в коробке.  Используйте это поле, если в коробке поедут целые товары, не разделенные на части. Не используйте это поле одновременно с `partialCount`. 
    #[serde(rename = "fullCount")]
    #[validate(
            range(min = 1),
        )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub full_count: Option<u32>,

    #[serde(rename = "partialCount")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub partial_count: Option<models::OrderBoxLayoutPartialCountDto>,

    /// Переданные вами коды маркировки.
    #[serde(rename = "instances")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub instances: Option<swagger::Nullable<Vec<models::BriefOrderItemInstanceDto>>>,

}


impl OrderBoxLayoutItemDto {
    #[allow(clippy::new_without_default)]
    pub fn new(id: i64, ) -> OrderBoxLayoutItemDto {
        OrderBoxLayoutItemDto {
            id,
            full_count: None,
            partial_count: None,
            instances: None,
        }
    }
}

/// Converts the OrderBoxLayoutItemDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for OrderBoxLayoutItemDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            Some("id".to_string()),
            Some(self.id.to_string()),


            self.full_count.as_ref().map(|full_count| {
                [
                    "fullCount".to_string(),
                    full_count.to_string(),
                ].join(",")
            }),

            // Skipping partialCount in query parameter serialization

            // Skipping instances in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a OrderBoxLayoutItemDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for OrderBoxLayoutItemDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<i64>,
            pub full_count: Vec<u32>,
            pub partial_count: Vec<models::OrderBoxLayoutPartialCountDto>,
            pub instances: Vec<Vec<models::BriefOrderItemInstanceDto>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing OrderBoxLayoutItemDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "fullCount" => intermediate_rep.full_count.push(<u32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "partialCount" => intermediate_rep.partial_count.push(<models::OrderBoxLayoutPartialCountDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "instances" => return std::result::Result::Err("Parsing a container in this style is not supported in OrderBoxLayoutItemDto".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing OrderBoxLayoutItemDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(OrderBoxLayoutItemDto {
            id: intermediate_rep.id.into_iter().next().ok_or_else(|| "id missing in OrderBoxLayoutItemDto".to_string())?,
            full_count: intermediate_rep.full_count.into_iter().next(),
            partial_count: intermediate_rep.partial_count.into_iter().next(),
            instances: std::result::Result::Err("Nullable types not supported in OrderBoxLayoutItemDto".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<OrderBoxLayoutItemDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<OrderBoxLayoutItemDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<OrderBoxLayoutItemDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for OrderBoxLayoutItemDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<OrderBoxLayoutItemDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <OrderBoxLayoutItemDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into OrderBoxLayoutItemDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Информация о части товара в коробке.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct OrderBoxLayoutPartialCountDto {
    /// Номер части, начиная с 1.
    #[serde(rename = "current")]
    #[validate(
            range(min = 1),
        )]
    pub current: u32,

    /// На сколько всего частей разделен товар.
    #[serde(rename = "total")]
    #[validate(
            range(min = 2),
        )]
    pub total: u32,

}


impl OrderBoxLayoutPartialCountDto {
    #[allow(clippy::new_without_default)]
    pub fn new(current: u32, total: u32, ) -> OrderBoxLayoutPartialCountDto {
        OrderBoxLayoutPartialCountDto {
            current,
            total,
        }
    }
}

/// Converts the OrderBoxLayoutPartialCountDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for OrderBoxLayoutPartialCountDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            Some("current".to_string()),
            Some(self.current.to_string()),


            Some("total".to_string()),
            Some(self.total.to_string()),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a OrderBoxLayoutPartialCountDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for OrderBoxLayoutPartialCountDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub current: Vec<u32>,
            pub total: Vec<u32>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing OrderBoxLayoutPartialCountDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "current" => intermediate_rep.current.push(<u32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "total" => intermediate_rep.total.push(<u32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing OrderBoxLayoutPartialCountDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(OrderBoxLayoutPartialCountDto {
            current: intermediate_rep.current.into_iter().next().ok_or_else(|| "current missing in OrderBoxLayoutPartialCountDto".to_string())?,
            total: intermediate_rep.total.into_iter().next().ok_or_else(|| "total missing in OrderBoxLayoutPartialCountDto".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<OrderBoxLayoutPartialCountDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<OrderBoxLayoutPartialCountDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<OrderBoxLayoutPartialCountDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for OrderBoxLayoutPartialCountDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<OrderBoxLayoutPartialCountDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <OrderBoxLayoutPartialCountDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into OrderBoxLayoutPartialCountDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Распределение товаров по коробкам.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct OrderBoxesLayoutDto {
    /// Список коробок.
    #[serde(rename = "boxes")]
    pub boxes: Vec<models::EnrichedOrderBoxLayoutDto>,

}


impl OrderBoxesLayoutDto {
    #[allow(clippy::new_without_default)]
    pub fn new(boxes: Vec<models::EnrichedOrderBoxLayoutDto>, ) -> OrderBoxesLayoutDto {
        OrderBoxesLayoutDto {
            boxes,
        }
    }
}

/// Converts the OrderBoxesLayoutDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for OrderBoxesLayoutDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping boxes in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a OrderBoxesLayoutDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for OrderBoxesLayoutDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub boxes: Vec<Vec<models::EnrichedOrderBoxLayoutDto>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing OrderBoxesLayoutDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "boxes" => return std::result::Result::Err("Parsing a container in this style is not supported in OrderBoxesLayoutDto".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing OrderBoxesLayoutDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(OrderBoxesLayoutDto {
            boxes: intermediate_rep.boxes.into_iter().next().ok_or_else(|| "boxes missing in OrderBoxesLayoutDto".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<OrderBoxesLayoutDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<OrderBoxesLayoutDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<OrderBoxesLayoutDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for OrderBoxesLayoutDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<OrderBoxesLayoutDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <OrderBoxesLayoutDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into OrderBoxesLayoutDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Информация о покупателе. 
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct OrderBusinessBuyerDto {
    /// ИНН.
    #[serde(rename = "inn")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub inn: Option<String>,

    /// КПП.
    #[serde(rename = "kpp")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub kpp: Option<String>,

    /// Наименование юридического лица.
    #[serde(rename = "organizationName")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization_name: Option<String>,

    /// Юридический адрес.
    #[serde(rename = "organizationJurAddress")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization_jur_address: Option<String>,

}


impl OrderBusinessBuyerDto {
    #[allow(clippy::new_without_default)]
    pub fn new() -> OrderBusinessBuyerDto {
        OrderBusinessBuyerDto {
            inn: None,
            kpp: None,
            organization_name: None,
            organization_jur_address: None,
        }
    }
}

/// Converts the OrderBusinessBuyerDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for OrderBusinessBuyerDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.inn.as_ref().map(|inn| {
                [
                    "inn".to_string(),
                    inn.to_string(),
                ].join(",")
            }),


            self.kpp.as_ref().map(|kpp| {
                [
                    "kpp".to_string(),
                    kpp.to_string(),
                ].join(",")
            }),


            self.organization_name.as_ref().map(|organization_name| {
                [
                    "organizationName".to_string(),
                    organization_name.to_string(),
                ].join(",")
            }),


            self.organization_jur_address.as_ref().map(|organization_jur_address| {
                [
                    "organizationJurAddress".to_string(),
                    organization_jur_address.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a OrderBusinessBuyerDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for OrderBusinessBuyerDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub inn: Vec<String>,
            pub kpp: Vec<String>,
            pub organization_name: Vec<String>,
            pub organization_jur_address: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing OrderBusinessBuyerDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "inn" => intermediate_rep.inn.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "kpp" => intermediate_rep.kpp.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "organizationName" => intermediate_rep.organization_name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "organizationJurAddress" => intermediate_rep.organization_jur_address.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing OrderBusinessBuyerDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(OrderBusinessBuyerDto {
            inn: intermediate_rep.inn.into_iter().next(),
            kpp: intermediate_rep.kpp.into_iter().next(),
            organization_name: intermediate_rep.organization_name.into_iter().next(),
            organization_jur_address: intermediate_rep.organization_jur_address.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<OrderBusinessBuyerDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<OrderBusinessBuyerDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<OrderBusinessBuyerDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for OrderBusinessBuyerDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<OrderBusinessBuyerDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <OrderBusinessBuyerDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into OrderBusinessBuyerDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Информация о документах. 
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct OrderBusinessDocumentsDto {
    #[serde(rename = "upd")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub upd: Option<models::DocumentDto>,

    #[serde(rename = "ukd")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub ukd: Option<models::DocumentDto>,

    #[serde(rename = "torgTwelve")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub torg_twelve: Option<models::DocumentDto>,

    #[serde(rename = "sf")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub sf: Option<models::DocumentDto>,

    #[serde(rename = "ksf")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub ksf: Option<models::DocumentDto>,

}


impl OrderBusinessDocumentsDto {
    #[allow(clippy::new_without_default)]
    pub fn new() -> OrderBusinessDocumentsDto {
        OrderBusinessDocumentsDto {
            upd: None,
            ukd: None,
            torg_twelve: None,
            sf: None,
            ksf: None,
        }
    }
}

/// Converts the OrderBusinessDocumentsDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for OrderBusinessDocumentsDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping upd in query parameter serialization

            // Skipping ukd in query parameter serialization

            // Skipping torgTwelve in query parameter serialization

            // Skipping sf in query parameter serialization

            // Skipping ksf in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a OrderBusinessDocumentsDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for OrderBusinessDocumentsDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub upd: Vec<models::DocumentDto>,
            pub ukd: Vec<models::DocumentDto>,
            pub torg_twelve: Vec<models::DocumentDto>,
            pub sf: Vec<models::DocumentDto>,
            pub ksf: Vec<models::DocumentDto>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing OrderBusinessDocumentsDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "upd" => intermediate_rep.upd.push(<models::DocumentDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "ukd" => intermediate_rep.ukd.push(<models::DocumentDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "torgTwelve" => intermediate_rep.torg_twelve.push(<models::DocumentDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "sf" => intermediate_rep.sf.push(<models::DocumentDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "ksf" => intermediate_rep.ksf.push(<models::DocumentDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing OrderBusinessDocumentsDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(OrderBusinessDocumentsDto {
            upd: intermediate_rep.upd.into_iter().next(),
            ukd: intermediate_rep.ukd.into_iter().next(),
            torg_twelve: intermediate_rep.torg_twelve.into_iter().next(),
            sf: intermediate_rep.sf.into_iter().next(),
            ksf: intermediate_rep.ksf.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<OrderBusinessDocumentsDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<OrderBusinessDocumentsDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<OrderBusinessDocumentsDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for OrderBusinessDocumentsDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<OrderBusinessDocumentsDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <OrderBusinessDocumentsDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into OrderBusinessDocumentsDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Информация о покупателе с базовыми полями.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct OrderBuyerBasicInfoDto {
    /// Идентификатор покупателя.
    #[serde(rename = "id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

    /// Фамилия покупателя.
    #[serde(rename = "lastName")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub last_name: Option<String>,

    /// Имя покупателя.
    #[serde(rename = "firstName")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub first_name: Option<String>,

    /// Отчество покупателя.
    #[serde(rename = "middleName")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub middle_name: Option<String>,

    #[serde(rename = "type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub r#type: Option<models::OrderBuyerType>,

}


impl OrderBuyerBasicInfoDto {
    #[allow(clippy::new_without_default)]
    pub fn new() -> OrderBuyerBasicInfoDto {
        OrderBuyerBasicInfoDto {
            id: None,
            last_name: None,
            first_name: None,
            middle_name: None,
            r#type: None,
        }
    }
}

/// Converts the OrderBuyerBasicInfoDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for OrderBuyerBasicInfoDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.id.as_ref().map(|id| {
                [
                    "id".to_string(),
                    id.to_string(),
                ].join(",")
            }),


            self.last_name.as_ref().map(|last_name| {
                [
                    "lastName".to_string(),
                    last_name.to_string(),
                ].join(",")
            }),


            self.first_name.as_ref().map(|first_name| {
                [
                    "firstName".to_string(),
                    first_name.to_string(),
                ].join(",")
            }),


            self.middle_name.as_ref().map(|middle_name| {
                [
                    "middleName".to_string(),
                    middle_name.to_string(),
                ].join(",")
            }),

            // Skipping type in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a OrderBuyerBasicInfoDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for OrderBuyerBasicInfoDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub last_name: Vec<String>,
            pub first_name: Vec<String>,
            pub middle_name: Vec<String>,
            pub r#type: Vec<models::OrderBuyerType>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing OrderBuyerBasicInfoDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "lastName" => intermediate_rep.last_name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "firstName" => intermediate_rep.first_name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "middleName" => intermediate_rep.middle_name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r#type.push(<models::OrderBuyerType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing OrderBuyerBasicInfoDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(OrderBuyerBasicInfoDto {
            id: intermediate_rep.id.into_iter().next(),
            last_name: intermediate_rep.last_name.into_iter().next(),
            first_name: intermediate_rep.first_name.into_iter().next(),
            middle_name: intermediate_rep.middle_name.into_iter().next(),
            r#type: intermediate_rep.r#type.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<OrderBuyerBasicInfoDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<OrderBuyerBasicInfoDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<OrderBuyerBasicInfoDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for OrderBuyerBasicInfoDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<OrderBuyerBasicInfoDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <OrderBuyerBasicInfoDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into OrderBuyerBasicInfoDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Информация о покупателе.  Параметры `id`, `lastName`, `firstName` и `middleName` возвращаются, только если вы работаете по модели DBS. 
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct OrderBuyerDto {
    /// Идентификатор покупателя.
    #[serde(rename = "id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

    /// Фамилия покупателя.
    #[serde(rename = "lastName")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub last_name: Option<String>,

    /// Имя покупателя.
    #[serde(rename = "firstName")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub first_name: Option<String>,

    /// Отчество покупателя.
    #[serde(rename = "middleName")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub middle_name: Option<String>,

    #[serde(rename = "type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub r#type: Option<models::OrderBuyerType>,

}


impl OrderBuyerDto {
    #[allow(clippy::new_without_default)]
    pub fn new() -> OrderBuyerDto {
        OrderBuyerDto {
            id: None,
            last_name: None,
            first_name: None,
            middle_name: None,
            r#type: None,
        }
    }
}

/// Converts the OrderBuyerDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for OrderBuyerDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.id.as_ref().map(|id| {
                [
                    "id".to_string(),
                    id.to_string(),
                ].join(",")
            }),


            self.last_name.as_ref().map(|last_name| {
                [
                    "lastName".to_string(),
                    last_name.to_string(),
                ].join(",")
            }),


            self.first_name.as_ref().map(|first_name| {
                [
                    "firstName".to_string(),
                    first_name.to_string(),
                ].join(",")
            }),


            self.middle_name.as_ref().map(|middle_name| {
                [
                    "middleName".to_string(),
                    middle_name.to_string(),
                ].join(",")
            }),

            // Skipping type in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a OrderBuyerDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for OrderBuyerDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub last_name: Vec<String>,
            pub first_name: Vec<String>,
            pub middle_name: Vec<String>,
            pub r#type: Vec<models::OrderBuyerType>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing OrderBuyerDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "lastName" => intermediate_rep.last_name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "firstName" => intermediate_rep.first_name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "middleName" => intermediate_rep.middle_name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r#type.push(<models::OrderBuyerType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing OrderBuyerDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(OrderBuyerDto {
            id: intermediate_rep.id.into_iter().next(),
            last_name: intermediate_rep.last_name.into_iter().next(),
            first_name: intermediate_rep.first_name.into_iter().next(),
            middle_name: intermediate_rep.middle_name.into_iter().next(),
            r#type: intermediate_rep.r#type.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<OrderBuyerDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<OrderBuyerDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<OrderBuyerDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for OrderBuyerDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<OrderBuyerDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <OrderBuyerDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into OrderBuyerDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Информация о покупателе и его номере телефона.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct OrderBuyerInfoDto {
    /// Идентификатор покупателя.
    #[serde(rename = "id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

    /// Фамилия покупателя.
    #[serde(rename = "lastName")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub last_name: Option<String>,

    /// Имя покупателя.
    #[serde(rename = "firstName")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub first_name: Option<String>,

    /// Отчество покупателя.
    #[serde(rename = "middleName")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub middle_name: Option<String>,

    #[serde(rename = "type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub r#type: Option<models::OrderBuyerType>,

    /// Подменный номер телефона покупателя. Подробнее о таких номерах читайте [в Справке Маркета для продавцов](https://yandex.ru/support2/marketplace/ru/orders/dbs/call#fake-number).  Формат номера: `+<код_страны><код_региона><номер_телефона>`. 
    #[serde(rename = "phone")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub phone: Option<String>,

}


impl OrderBuyerInfoDto {
    #[allow(clippy::new_without_default)]
    pub fn new() -> OrderBuyerInfoDto {
        OrderBuyerInfoDto {
            id: None,
            last_name: None,
            first_name: None,
            middle_name: None,
            r#type: None,
            phone: None,
        }
    }
}

/// Converts the OrderBuyerInfoDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for OrderBuyerInfoDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.id.as_ref().map(|id| {
                [
                    "id".to_string(),
                    id.to_string(),
                ].join(",")
            }),


            self.last_name.as_ref().map(|last_name| {
                [
                    "lastName".to_string(),
                    last_name.to_string(),
                ].join(",")
            }),


            self.first_name.as_ref().map(|first_name| {
                [
                    "firstName".to_string(),
                    first_name.to_string(),
                ].join(",")
            }),


            self.middle_name.as_ref().map(|middle_name| {
                [
                    "middleName".to_string(),
                    middle_name.to_string(),
                ].join(",")
            }),

            // Skipping type in query parameter serialization


            self.phone.as_ref().map(|phone| {
                [
                    "phone".to_string(),
                    phone.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a OrderBuyerInfoDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for OrderBuyerInfoDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub last_name: Vec<String>,
            pub first_name: Vec<String>,
            pub middle_name: Vec<String>,
            pub r#type: Vec<models::OrderBuyerType>,
            pub phone: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing OrderBuyerInfoDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "lastName" => intermediate_rep.last_name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "firstName" => intermediate_rep.first_name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "middleName" => intermediate_rep.middle_name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r#type.push(<models::OrderBuyerType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "phone" => intermediate_rep.phone.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing OrderBuyerInfoDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(OrderBuyerInfoDto {
            id: intermediate_rep.id.into_iter().next(),
            last_name: intermediate_rep.last_name.into_iter().next(),
            first_name: intermediate_rep.first_name.into_iter().next(),
            middle_name: intermediate_rep.middle_name.into_iter().next(),
            r#type: intermediate_rep.r#type.into_iter().next(),
            phone: intermediate_rep.phone.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<OrderBuyerInfoDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<OrderBuyerInfoDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<OrderBuyerInfoDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for OrderBuyerInfoDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<OrderBuyerInfoDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <OrderBuyerInfoDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into OrderBuyerInfoDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Тип покупателя:  * `PERSON` — физическое лицо.  * `BUSINESS` — организация. 
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum OrderBuyerType {
    #[serde(rename = "PERSON")]
    Person,
    #[serde(rename = "BUSINESS")]
    Business,
}

impl std::fmt::Display for OrderBuyerType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            OrderBuyerType::Person => write!(f, "PERSON"),
            OrderBuyerType::Business => write!(f, "BUSINESS"),
        }
    }
}

impl std::str::FromStr for OrderBuyerType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "PERSON" => std::result::Result::Ok(OrderBuyerType::Person),
            "BUSINESS" => std::result::Result::Ok(OrderBuyerType::Business),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Варианты причин, по которым заказ не может быть отменен.  * `ORDER_DELIVERED` — заказ уже доставлен. * `ORDER_IN_DELIVERY` — заказ уже у курьера. 
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum OrderCancellationReasonType {
    #[serde(rename = "ORDER_DELIVERED")]
    Delivered,
    #[serde(rename = "ORDER_IN_DELIVERY")]
    InDelivery,
}

impl std::fmt::Display for OrderCancellationReasonType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            OrderCancellationReasonType::Delivered => write!(f, "ORDER_DELIVERED"),
            OrderCancellationReasonType::InDelivery => write!(f, "ORDER_IN_DELIVERY"),
        }
    }
}

impl std::str::FromStr for OrderCancellationReasonType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "ORDER_DELIVERED" => std::result::Result::Ok(OrderCancellationReasonType::Delivered),
            "ORDER_IN_DELIVERY" => std::result::Result::Ok(OrderCancellationReasonType::InDelivery),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Информация о курьере.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct OrderCourierDto {
    /// Полное имя курьера.
    #[serde(rename = "fullName")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub full_name: Option<String>,

    /// Номер телефона курьера.
    #[serde(rename = "phone")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub phone: Option<String>,

    /// Добавочный номер телефона.
    #[serde(rename = "phoneExtension")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub phone_extension: Option<String>,

    /// Номер транспортного средства.
    #[serde(rename = "vehicleNumber")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub vehicle_number: Option<String>,

    /// Описание машины. Например, модель и цвет.
    #[serde(rename = "vehicleDescription")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub vehicle_description: Option<String>,

}


impl OrderCourierDto {
    #[allow(clippy::new_without_default)]
    pub fn new() -> OrderCourierDto {
        OrderCourierDto {
            full_name: None,
            phone: None,
            phone_extension: None,
            vehicle_number: None,
            vehicle_description: None,
        }
    }
}

/// Converts the OrderCourierDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for OrderCourierDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.full_name.as_ref().map(|full_name| {
                [
                    "fullName".to_string(),
                    full_name.to_string(),
                ].join(",")
            }),


            self.phone.as_ref().map(|phone| {
                [
                    "phone".to_string(),
                    phone.to_string(),
                ].join(",")
            }),


            self.phone_extension.as_ref().map(|phone_extension| {
                [
                    "phoneExtension".to_string(),
                    phone_extension.to_string(),
                ].join(",")
            }),


            self.vehicle_number.as_ref().map(|vehicle_number| {
                [
                    "vehicleNumber".to_string(),
                    vehicle_number.to_string(),
                ].join(",")
            }),


            self.vehicle_description.as_ref().map(|vehicle_description| {
                [
                    "vehicleDescription".to_string(),
                    vehicle_description.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a OrderCourierDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for OrderCourierDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub full_name: Vec<String>,
            pub phone: Vec<String>,
            pub phone_extension: Vec<String>,
            pub vehicle_number: Vec<String>,
            pub vehicle_description: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing OrderCourierDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "fullName" => intermediate_rep.full_name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "phone" => intermediate_rep.phone.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "phoneExtension" => intermediate_rep.phone_extension.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "vehicleNumber" => intermediate_rep.vehicle_number.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "vehicleDescription" => intermediate_rep.vehicle_description.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing OrderCourierDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(OrderCourierDto {
            full_name: intermediate_rep.full_name.into_iter().next(),
            phone: intermediate_rep.phone.into_iter().next(),
            phone_extension: intermediate_rep.phone_extension.into_iter().next(),
            vehicle_number: intermediate_rep.vehicle_number.into_iter().next(),
            vehicle_description: intermediate_rep.vehicle_description.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<OrderCourierDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<OrderCourierDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<OrderCourierDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for OrderCourierDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<OrderCourierDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <OrderCourierDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into OrderCourierDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Адрес доставки.  Указывается, если `type=DELIVERY`, `type=POST` или `type=PICKUP` (адрес пункта выдачи). 
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct OrderDeliveryAddressDto {
    /// Страна.  Обязательный параметр. 
    #[serde(rename = "country")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub country: Option<String>,

    /// Почтовый индекс.  Указывается, если выбрана доставка почтой (`delivery type=POST`). 
    #[serde(rename = "postcode")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub postcode: Option<String>,

    /// Город или населенный пункт.  Обязательный параметр. 
    #[serde(rename = "city")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub city: Option<String>,

    /// Район.
    #[serde(rename = "district")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub district: Option<String>,

    /// Станция метро.
    #[serde(rename = "subway")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub subway: Option<String>,

    /// Улица.  Обязательный параметр. 
    #[serde(rename = "street")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub street: Option<String>,

    /// Дом или владение.  Обязательный параметр. 
    #[serde(rename = "house")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub house: Option<String>,

    /// Корпус или строение.
    #[serde(rename = "block")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub block: Option<String>,

    /// Подъезд.
    #[serde(rename = "entrance")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub entrance: Option<String>,

    /// Код домофона.
    #[serde(rename = "entryphone")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub entryphone: Option<String>,

    /// Этаж.
    #[serde(rename = "floor")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub floor: Option<String>,

    /// Квартира или офис.
    #[serde(rename = "apartment")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub apartment: Option<String>,

    /// Телефон получателя заказа.  Обязательный параметр. 
    #[serde(rename = "phone")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub phone: Option<String>,

    /// Фамилия, имя и отчество получателя заказа.  Обязательный параметр. 
    #[serde(rename = "recipient")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub recipient: Option<String>,

    #[serde(rename = "gps")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub gps: Option<models::GpsDto>,

}


impl OrderDeliveryAddressDto {
    #[allow(clippy::new_without_default)]
    pub fn new() -> OrderDeliveryAddressDto {
        OrderDeliveryAddressDto {
            country: None,
            postcode: None,
            city: None,
            district: None,
            subway: None,
            street: None,
            house: None,
            block: None,
            entrance: None,
            entryphone: None,
            floor: None,
            apartment: None,
            phone: None,
            recipient: None,
            gps: None,
        }
    }
}

/// Converts the OrderDeliveryAddressDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for OrderDeliveryAddressDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.country.as_ref().map(|country| {
                [
                    "country".to_string(),
                    country.to_string(),
                ].join(",")
            }),


            self.postcode.as_ref().map(|postcode| {
                [
                    "postcode".to_string(),
                    postcode.to_string(),
                ].join(",")
            }),


            self.city.as_ref().map(|city| {
                [
                    "city".to_string(),
                    city.to_string(),
                ].join(",")
            }),


            self.district.as_ref().map(|district| {
                [
                    "district".to_string(),
                    district.to_string(),
                ].join(",")
            }),


            self.subway.as_ref().map(|subway| {
                [
                    "subway".to_string(),
                    subway.to_string(),
                ].join(",")
            }),


            self.street.as_ref().map(|street| {
                [
                    "street".to_string(),
                    street.to_string(),
                ].join(",")
            }),


            self.house.as_ref().map(|house| {
                [
                    "house".to_string(),
                    house.to_string(),
                ].join(",")
            }),


            self.block.as_ref().map(|block| {
                [
                    "block".to_string(),
                    block.to_string(),
                ].join(",")
            }),


            self.entrance.as_ref().map(|entrance| {
                [
                    "entrance".to_string(),
                    entrance.to_string(),
                ].join(",")
            }),


            self.entryphone.as_ref().map(|entryphone| {
                [
                    "entryphone".to_string(),
                    entryphone.to_string(),
                ].join(",")
            }),


            self.floor.as_ref().map(|floor| {
                [
                    "floor".to_string(),
                    floor.to_string(),
                ].join(",")
            }),


            self.apartment.as_ref().map(|apartment| {
                [
                    "apartment".to_string(),
                    apartment.to_string(),
                ].join(",")
            }),


            self.phone.as_ref().map(|phone| {
                [
                    "phone".to_string(),
                    phone.to_string(),
                ].join(",")
            }),


            self.recipient.as_ref().map(|recipient| {
                [
                    "recipient".to_string(),
                    recipient.to_string(),
                ].join(",")
            }),

            // Skipping gps in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a OrderDeliveryAddressDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for OrderDeliveryAddressDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub country: Vec<String>,
            pub postcode: Vec<String>,
            pub city: Vec<String>,
            pub district: Vec<String>,
            pub subway: Vec<String>,
            pub street: Vec<String>,
            pub house: Vec<String>,
            pub block: Vec<String>,
            pub entrance: Vec<String>,
            pub entryphone: Vec<String>,
            pub floor: Vec<String>,
            pub apartment: Vec<String>,
            pub phone: Vec<String>,
            pub recipient: Vec<String>,
            pub gps: Vec<models::GpsDto>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing OrderDeliveryAddressDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "country" => intermediate_rep.country.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "postcode" => intermediate_rep.postcode.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "city" => intermediate_rep.city.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "district" => intermediate_rep.district.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "subway" => intermediate_rep.subway.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "street" => intermediate_rep.street.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "house" => intermediate_rep.house.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "block" => intermediate_rep.block.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "entrance" => intermediate_rep.entrance.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "entryphone" => intermediate_rep.entryphone.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "floor" => intermediate_rep.floor.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "apartment" => intermediate_rep.apartment.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "phone" => intermediate_rep.phone.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "recipient" => intermediate_rep.recipient.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "gps" => intermediate_rep.gps.push(<models::GpsDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing OrderDeliveryAddressDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(OrderDeliveryAddressDto {
            country: intermediate_rep.country.into_iter().next(),
            postcode: intermediate_rep.postcode.into_iter().next(),
            city: intermediate_rep.city.into_iter().next(),
            district: intermediate_rep.district.into_iter().next(),
            subway: intermediate_rep.subway.into_iter().next(),
            street: intermediate_rep.street.into_iter().next(),
            house: intermediate_rep.house.into_iter().next(),
            block: intermediate_rep.block.into_iter().next(),
            entrance: intermediate_rep.entrance.into_iter().next(),
            entryphone: intermediate_rep.entryphone.into_iter().next(),
            floor: intermediate_rep.floor.into_iter().next(),
            apartment: intermediate_rep.apartment.into_iter().next(),
            phone: intermediate_rep.phone.into_iter().next(),
            recipient: intermediate_rep.recipient.into_iter().next(),
            gps: intermediate_rep.gps.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<OrderDeliveryAddressDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<OrderDeliveryAddressDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<OrderDeliveryAddressDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for OrderDeliveryAddressDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<OrderDeliveryAddressDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <OrderDeliveryAddressDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into OrderDeliveryAddressDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Информация о новой дате доставки заказа.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct OrderDeliveryDateDto {
    /// Новая дата доставки заказа.  Формат даты: `ГГГГ-ММ-ДД`. 
    #[serde(rename = "toDate")]
    pub to_date: chrono::naive::NaiveDate,

}


impl OrderDeliveryDateDto {
    #[allow(clippy::new_without_default)]
    pub fn new(to_date: chrono::naive::NaiveDate, ) -> OrderDeliveryDateDto {
        OrderDeliveryDateDto {
            to_date,
        }
    }
}

/// Converts the OrderDeliveryDateDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for OrderDeliveryDateDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping toDate in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a OrderDeliveryDateDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for OrderDeliveryDateDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub to_date: Vec<chrono::naive::NaiveDate>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing OrderDeliveryDateDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "toDate" => intermediate_rep.to_date.push(<chrono::naive::NaiveDate as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing OrderDeliveryDateDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(OrderDeliveryDateDto {
            to_date: intermediate_rep.to_date.into_iter().next().ok_or_else(|| "toDate missing in OrderDeliveryDateDto".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<OrderDeliveryDateDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<OrderDeliveryDateDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<OrderDeliveryDateDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for OrderDeliveryDateDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<OrderDeliveryDateDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <OrderDeliveryDateDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into OrderDeliveryDateDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Причина переноса доставки заказа. Возможные причины изменения даты:   - ```USER_MOVED_DELIVERY_DATES``` — покупатель попросил изменить дату или вы договорились привезти ему заказ раньше изначальной даты. Кроме этого указывается для подтверждения даты доставки товаров на заказ с долгой (31-60 дней) доставкой.   - ```PARTNER_MOVED_DELIVERY_DATES``` — магазин не может доставить заказ в срок. 
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum OrderDeliveryDateReasonType {
    #[serde(rename = "USER_MOVED_DELIVERY_DATES")]
    UserMovedDeliveryDates,
    #[serde(rename = "PARTNER_MOVED_DELIVERY_DATES")]
    PartnerMovedDeliveryDates,
}

impl std::fmt::Display for OrderDeliveryDateReasonType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            OrderDeliveryDateReasonType::UserMovedDeliveryDates => write!(f, "USER_MOVED_DELIVERY_DATES"),
            OrderDeliveryDateReasonType::PartnerMovedDeliveryDates => write!(f, "PARTNER_MOVED_DELIVERY_DATES"),
        }
    }
}

impl std::str::FromStr for OrderDeliveryDateReasonType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "USER_MOVED_DELIVERY_DATES" => std::result::Result::Ok(OrderDeliveryDateReasonType::UserMovedDeliveryDates),
            "PARTNER_MOVED_DELIVERY_DATES" => std::result::Result::Ok(OrderDeliveryDateReasonType::PartnerMovedDeliveryDates),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Диапазон дат доставки.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct OrderDeliveryDatesDto {
    /// Формат даты: `ДД-ММ-ГГГГ`. 
    #[serde(rename = "fromDate")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub from_date: Option<String>,

    /// Формат даты: `ДД-ММ-ГГГГ`. 
    #[serde(rename = "toDate")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub to_date: Option<String>,

    /// Начало интервала времени доставки.  Передается только совместно с параметром `type=DELIVERY`.  Формат времени: 24-часовой, `ЧЧ:ММ`. В качестве минут всегда должно быть указано `00` (исключение — `23:59`).  Минимальное значение: `00:00`. 
    #[serde(rename = "fromTime")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub from_time: Option<String>,

    /// Конец интервала времени доставки.  Передается только совместно с параметром `type=DELIVERY`.  Формат времени: 24-часовой, `ЧЧ:ММ`. В качестве минут всегда должно быть указано `00` (исключение — `23:59`).  Максимальное значение: `23:59`. 
    #[serde(rename = "toTime")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub to_time: Option<String>,

    /// Формат даты: `ДД-ММ-ГГГГ`. 
    #[serde(rename = "realDeliveryDate")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub real_delivery_date: Option<String>,

}


impl OrderDeliveryDatesDto {
    #[allow(clippy::new_without_default)]
    pub fn new() -> OrderDeliveryDatesDto {
        OrderDeliveryDatesDto {
            from_date: None,
            to_date: None,
            from_time: None,
            to_time: None,
            real_delivery_date: None,
        }
    }
}

/// Converts the OrderDeliveryDatesDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for OrderDeliveryDatesDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.from_date.as_ref().map(|from_date| {
                [
                    "fromDate".to_string(),
                    from_date.to_string(),
                ].join(",")
            }),


            self.to_date.as_ref().map(|to_date| {
                [
                    "toDate".to_string(),
                    to_date.to_string(),
                ].join(",")
            }),


            self.from_time.as_ref().map(|from_time| {
                [
                    "fromTime".to_string(),
                    from_time.to_string(),
                ].join(",")
            }),


            self.to_time.as_ref().map(|to_time| {
                [
                    "toTime".to_string(),
                    to_time.to_string(),
                ].join(",")
            }),


            self.real_delivery_date.as_ref().map(|real_delivery_date| {
                [
                    "realDeliveryDate".to_string(),
                    real_delivery_date.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a OrderDeliveryDatesDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for OrderDeliveryDatesDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub from_date: Vec<String>,
            pub to_date: Vec<String>,
            pub from_time: Vec<String>,
            pub to_time: Vec<String>,
            pub real_delivery_date: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing OrderDeliveryDatesDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "fromDate" => intermediate_rep.from_date.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "toDate" => intermediate_rep.to_date.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "fromTime" => intermediate_rep.from_time.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "toTime" => intermediate_rep.to_time.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "realDeliveryDate" => intermediate_rep.real_delivery_date.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing OrderDeliveryDatesDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(OrderDeliveryDatesDto {
            from_date: intermediate_rep.from_date.into_iter().next(),
            to_date: intermediate_rep.to_date.into_iter().next(),
            from_time: intermediate_rep.from_time.into_iter().next(),
            to_time: intermediate_rep.to_time.into_iter().next(),
            real_delivery_date: intermediate_rep.real_delivery_date.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<OrderDeliveryDatesDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<OrderDeliveryDatesDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<OrderDeliveryDatesDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for OrderDeliveryDatesDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<OrderDeliveryDatesDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <OrderDeliveryDatesDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into OrderDeliveryDatesDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Способ отгрузки:  * `BUYER` — доставка покупателю.  * `MARKET_PARTNER_OUTLET` — доставка в пункт выдачи партнера.  * `MARKET_BRANDED_OUTLET` — доставка в пункт выдачи заказов Маркета.  * `SHOP_OUTLET` — доставка в пункт выдачи заказов магазина.  * `DROPOFF` — доставка в пункт выдачи, который принимает заказы от продавцов и передает их курьерам.  * `UNKNOWN` — неизвестный тип. 
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum OrderDeliveryDispatchType {
    #[serde(rename = "UNKNOWN")]
    Unknown,
    #[serde(rename = "BUYER")]
    Buyer,
    #[serde(rename = "MARKET_PARTNER_OUTLET")]
    MarketPartnerOutlet,
    #[serde(rename = "MARKET_BRANDED_OUTLET")]
    MarketBrandedOutlet,
    #[serde(rename = "SHOP_OUTLET")]
    ShopOutlet,
    #[serde(rename = "DROPOFF")]
    Dropoff,
}

impl std::fmt::Display for OrderDeliveryDispatchType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            OrderDeliveryDispatchType::Unknown => write!(f, "UNKNOWN"),
            OrderDeliveryDispatchType::Buyer => write!(f, "BUYER"),
            OrderDeliveryDispatchType::MarketPartnerOutlet => write!(f, "MARKET_PARTNER_OUTLET"),
            OrderDeliveryDispatchType::MarketBrandedOutlet => write!(f, "MARKET_BRANDED_OUTLET"),
            OrderDeliveryDispatchType::ShopOutlet => write!(f, "SHOP_OUTLET"),
            OrderDeliveryDispatchType::Dropoff => write!(f, "DROPOFF"),
        }
    }
}

impl std::str::FromStr for OrderDeliveryDispatchType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "UNKNOWN" => std::result::Result::Ok(OrderDeliveryDispatchType::Unknown),
            "BUYER" => std::result::Result::Ok(OrderDeliveryDispatchType::Buyer),
            "MARKET_PARTNER_OUTLET" => std::result::Result::Ok(OrderDeliveryDispatchType::MarketPartnerOutlet),
            "MARKET_BRANDED_OUTLET" => std::result::Result::Ok(OrderDeliveryDispatchType::MarketBrandedOutlet),
            "SHOP_OUTLET" => std::result::Result::Ok(OrderDeliveryDispatchType::ShopOutlet),
            "DROPOFF" => std::result::Result::Ok(OrderDeliveryDispatchType::Dropoff),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Информация о доставке.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct OrderDeliveryDto {
    /// Идентификатор доставки, присвоенный магазином.  Указывается, только если магазин передал данный идентификатор в ответе на запрос методом [POST cart](../../pushapi/reference/cart.md). 
    #[serde(rename = "id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

    #[serde(rename = "type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub r#type: Option<models::OrderDeliveryType>,

    /// Наименование службы доставки.
    #[serde(rename = "serviceName")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub service_name: Option<String>,

    /// {% note warning \"\" %}  Этот параметр устарел. Стоимость доставки смотрите в параметре `deliveryTotal`.  {% endnote %}  Стоимость доставки в валюте заказа. 
    #[serde(rename = "price")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub price: Option<f64>,

    #[serde(rename = "deliveryPartnerType")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub delivery_partner_type: Option<models::OrderDeliveryPartnerType>,

    #[serde(rename = "courier")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub courier: Option<models::OrderCourierDto>,

    #[serde(rename = "dates")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub dates: Option<models::OrderDeliveryDatesDto>,

    #[serde(rename = "region")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub region: Option<models::RegionDto>,

    #[serde(rename = "address")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub address: Option<models::OrderDeliveryAddressDto>,

    #[serde(rename = "vat")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub vat: Option<models::OrderVatType>,

    /// Идентификатор службы доставки.
    #[serde(rename = "deliveryServiceId")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub delivery_service_id: Option<i64>,

    #[serde(rename = "liftType")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub lift_type: Option<models::OrderLiftType>,

    /// Стоимость подъема на этаж.
    #[serde(rename = "liftPrice")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub lift_price: Option<f64>,

    /// Идентификатор пункта самовывоза, присвоенный магазином.
    #[serde(rename = "outletCode")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub outlet_code: Option<String>,

    /// Формат даты: `ДД-ММ-ГГГГ`. 
    #[serde(rename = "outletStorageLimitDate")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub outlet_storage_limit_date: Option<String>,

    #[serde(rename = "dispatchType")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub dispatch_type: Option<models::OrderDeliveryDispatchType>,

    /// Информация для отслеживания перемещений посылки.
    #[serde(rename = "tracks")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub tracks: Option<swagger::Nullable<Vec<models::OrderTrackDto>>>,

    /// Информация о посылках.
    #[serde(rename = "shipments")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub shipments: Option<swagger::Nullable<Vec<models::OrderShipmentDto>>>,

    /// Приблизительная ли дата доставки.
    #[serde(rename = "estimated")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub estimated: Option<bool>,

    #[serde(rename = "eacType")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub eac_type: Option<models::OrderDeliveryEacType>,

    /// Код подтверждения ЭАПП (для типа `MERCHANT_TO_COURIER`). 
    #[serde(rename = "eacCode")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub eac_code: Option<String>,

}


impl OrderDeliveryDto {
    #[allow(clippy::new_without_default)]
    pub fn new() -> OrderDeliveryDto {
        OrderDeliveryDto {
            id: None,
            r#type: None,
            service_name: None,
            price: None,
            delivery_partner_type: None,
            courier: None,
            dates: None,
            region: None,
            address: None,
            vat: None,
            delivery_service_id: None,
            lift_type: None,
            lift_price: None,
            outlet_code: None,
            outlet_storage_limit_date: None,
            dispatch_type: None,
            tracks: None,
            shipments: None,
            estimated: None,
            eac_type: None,
            eac_code: None,
        }
    }
}

/// Converts the OrderDeliveryDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for OrderDeliveryDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.id.as_ref().map(|id| {
                [
                    "id".to_string(),
                    id.to_string(),
                ].join(",")
            }),

            // Skipping type in query parameter serialization


            self.service_name.as_ref().map(|service_name| {
                [
                    "serviceName".to_string(),
                    service_name.to_string(),
                ].join(",")
            }),


            self.price.as_ref().map(|price| {
                [
                    "price".to_string(),
                    price.to_string(),
                ].join(",")
            }),

            // Skipping deliveryPartnerType in query parameter serialization

            // Skipping courier in query parameter serialization

            // Skipping dates in query parameter serialization

            // Skipping region in query parameter serialization

            // Skipping address in query parameter serialization

            // Skipping vat in query parameter serialization


            self.delivery_service_id.as_ref().map(|delivery_service_id| {
                [
                    "deliveryServiceId".to_string(),
                    delivery_service_id.to_string(),
                ].join(",")
            }),

            // Skipping liftType in query parameter serialization


            self.lift_price.as_ref().map(|lift_price| {
                [
                    "liftPrice".to_string(),
                    lift_price.to_string(),
                ].join(",")
            }),


            self.outlet_code.as_ref().map(|outlet_code| {
                [
                    "outletCode".to_string(),
                    outlet_code.to_string(),
                ].join(",")
            }),


            self.outlet_storage_limit_date.as_ref().map(|outlet_storage_limit_date| {
                [
                    "outletStorageLimitDate".to_string(),
                    outlet_storage_limit_date.to_string(),
                ].join(",")
            }),

            // Skipping dispatchType in query parameter serialization

            // Skipping tracks in query parameter serialization

            // Skipping shipments in query parameter serialization


            self.estimated.as_ref().map(|estimated| {
                [
                    "estimated".to_string(),
                    estimated.to_string(),
                ].join(",")
            }),

            // Skipping eacType in query parameter serialization


            self.eac_code.as_ref().map(|eac_code| {
                [
                    "eacCode".to_string(),
                    eac_code.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a OrderDeliveryDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for OrderDeliveryDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub r#type: Vec<models::OrderDeliveryType>,
            pub service_name: Vec<String>,
            pub price: Vec<f64>,
            pub delivery_partner_type: Vec<models::OrderDeliveryPartnerType>,
            pub courier: Vec<models::OrderCourierDto>,
            pub dates: Vec<models::OrderDeliveryDatesDto>,
            pub region: Vec<models::RegionDto>,
            pub address: Vec<models::OrderDeliveryAddressDto>,
            pub vat: Vec<models::OrderVatType>,
            pub delivery_service_id: Vec<i64>,
            pub lift_type: Vec<models::OrderLiftType>,
            pub lift_price: Vec<f64>,
            pub outlet_code: Vec<String>,
            pub outlet_storage_limit_date: Vec<String>,
            pub dispatch_type: Vec<models::OrderDeliveryDispatchType>,
            pub tracks: Vec<Vec<models::OrderTrackDto>>,
            pub shipments: Vec<Vec<models::OrderShipmentDto>>,
            pub estimated: Vec<bool>,
            pub eac_type: Vec<models::OrderDeliveryEacType>,
            pub eac_code: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing OrderDeliveryDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r#type.push(<models::OrderDeliveryType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "serviceName" => intermediate_rep.service_name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "price" => intermediate_rep.price.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "deliveryPartnerType" => intermediate_rep.delivery_partner_type.push(<models::OrderDeliveryPartnerType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "courier" => intermediate_rep.courier.push(<models::OrderCourierDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "dates" => intermediate_rep.dates.push(<models::OrderDeliveryDatesDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "region" => intermediate_rep.region.push(<models::RegionDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "address" => intermediate_rep.address.push(<models::OrderDeliveryAddressDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "vat" => intermediate_rep.vat.push(<models::OrderVatType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "deliveryServiceId" => intermediate_rep.delivery_service_id.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "liftType" => intermediate_rep.lift_type.push(<models::OrderLiftType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "liftPrice" => intermediate_rep.lift_price.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "outletCode" => intermediate_rep.outlet_code.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "outletStorageLimitDate" => intermediate_rep.outlet_storage_limit_date.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "dispatchType" => intermediate_rep.dispatch_type.push(<models::OrderDeliveryDispatchType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "tracks" => return std::result::Result::Err("Parsing a container in this style is not supported in OrderDeliveryDto".to_string()),
                    "shipments" => return std::result::Result::Err("Parsing a container in this style is not supported in OrderDeliveryDto".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "estimated" => intermediate_rep.estimated.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "eacType" => intermediate_rep.eac_type.push(<models::OrderDeliveryEacType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "eacCode" => intermediate_rep.eac_code.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing OrderDeliveryDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(OrderDeliveryDto {
            id: intermediate_rep.id.into_iter().next(),
            r#type: intermediate_rep.r#type.into_iter().next(),
            service_name: intermediate_rep.service_name.into_iter().next(),
            price: intermediate_rep.price.into_iter().next(),
            delivery_partner_type: intermediate_rep.delivery_partner_type.into_iter().next(),
            courier: intermediate_rep.courier.into_iter().next(),
            dates: intermediate_rep.dates.into_iter().next(),
            region: intermediate_rep.region.into_iter().next(),
            address: intermediate_rep.address.into_iter().next(),
            vat: intermediate_rep.vat.into_iter().next(),
            delivery_service_id: intermediate_rep.delivery_service_id.into_iter().next(),
            lift_type: intermediate_rep.lift_type.into_iter().next(),
            lift_price: intermediate_rep.lift_price.into_iter().next(),
            outlet_code: intermediate_rep.outlet_code.into_iter().next(),
            outlet_storage_limit_date: intermediate_rep.outlet_storage_limit_date.into_iter().next(),
            dispatch_type: intermediate_rep.dispatch_type.into_iter().next(),
            tracks: std::result::Result::Err("Nullable types not supported in OrderDeliveryDto".to_string())?,
            shipments: std::result::Result::Err("Nullable types not supported in OrderDeliveryDto".to_string())?,
            estimated: intermediate_rep.estimated.into_iter().next(),
            eac_type: intermediate_rep.eac_type.into_iter().next(),
            eac_code: intermediate_rep.eac_code.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<OrderDeliveryDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<OrderDeliveryDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<OrderDeliveryDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for OrderDeliveryDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<OrderDeliveryDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <OrderDeliveryDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into OrderDeliveryDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Тип кода подтверждения ЭАПП:  * `MERCHANT_TO_COURIER` — продавец передает код курьеру.  * `COURIER_TO_MERCHANT` — курьер передает код продавцу.  * `CHECKING_BY_MERCHANT` — продавец проверяет код на своей стороне. 
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum OrderDeliveryEacType {
    #[serde(rename = "MERCHANT_TO_COURIER")]
    MerchantToCourier,
    #[serde(rename = "COURIER_TO_MERCHANT")]
    CourierToMerchant,
    #[serde(rename = "CHECKING_BY_MERCHANT")]
    CheckingByMerchant,
}

impl std::fmt::Display for OrderDeliveryEacType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            OrderDeliveryEacType::MerchantToCourier => write!(f, "MERCHANT_TO_COURIER"),
            OrderDeliveryEacType::CourierToMerchant => write!(f, "COURIER_TO_MERCHANT"),
            OrderDeliveryEacType::CheckingByMerchant => write!(f, "CHECKING_BY_MERCHANT"),
        }
    }
}

impl std::str::FromStr for OrderDeliveryEacType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "MERCHANT_TO_COURIER" => std::result::Result::Ok(OrderDeliveryEacType::MerchantToCourier),
            "COURIER_TO_MERCHANT" => std::result::Result::Ok(OrderDeliveryEacType::CourierToMerchant),
            "CHECKING_BY_MERCHANT" => std::result::Result::Ok(OrderDeliveryEacType::CheckingByMerchant),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Тип сотрудничества со службой доставки в рамках конкретного заказа:  * `SHOP` — магазин работает со службой доставки напрямую или доставляет заказы самостоятельно.  * `YANDEX_MARKET` — магазин работает со службой доставки через Маркет.  * `UNKNOWN` — неизвестный тип. 
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum OrderDeliveryPartnerType {
    #[serde(rename = "SHOP")]
    Shop,
    #[serde(rename = "YANDEX_MARKET")]
    YandexMarket,
    #[serde(rename = "UNKNOWN")]
    Unknown,
}

impl std::fmt::Display for OrderDeliveryPartnerType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            OrderDeliveryPartnerType::Shop => write!(f, "SHOP"),
            OrderDeliveryPartnerType::YandexMarket => write!(f, "YANDEX_MARKET"),
            OrderDeliveryPartnerType::Unknown => write!(f, "UNKNOWN"),
        }
    }
}

impl std::str::FromStr for OrderDeliveryPartnerType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "SHOP" => std::result::Result::Ok(OrderDeliveryPartnerType::Shop),
            "YANDEX_MARKET" => std::result::Result::Ok(OrderDeliveryPartnerType::YandexMarket),
            "UNKNOWN" => std::result::Result::Ok(OrderDeliveryPartnerType::Unknown),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Способ доставки заказа:  * `DELIVERY` — курьерская доставка.  * `PICKUP` — самовывоз.  * `POST` — почта.  * `DIGITAL` — для цифровых товаров.  * `UNKNOWN` — неизвестный тип. 
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum OrderDeliveryType {
    #[serde(rename = "DELIVERY")]
    Delivery,
    #[serde(rename = "PICKUP")]
    Pickup,
    #[serde(rename = "POST")]
    Post,
    #[serde(rename = "DIGITAL")]
    Digital,
    #[serde(rename = "UNKNOWN")]
    Unknown,
}

impl std::fmt::Display for OrderDeliveryType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            OrderDeliveryType::Delivery => write!(f, "DELIVERY"),
            OrderDeliveryType::Pickup => write!(f, "PICKUP"),
            OrderDeliveryType::Post => write!(f, "POST"),
            OrderDeliveryType::Digital => write!(f, "DIGITAL"),
            OrderDeliveryType::Unknown => write!(f, "UNKNOWN"),
        }
    }
}

impl std::str::FromStr for OrderDeliveryType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "DELIVERY" => std::result::Result::Ok(OrderDeliveryType::Delivery),
            "PICKUP" => std::result::Result::Ok(OrderDeliveryType::Pickup),
            "POST" => std::result::Result::Ok(OrderDeliveryType::Post),
            "DIGITAL" => std::result::Result::Ok(OrderDeliveryType::Digital),
            "UNKNOWN" => std::result::Result::Ok(OrderDeliveryType::Unknown),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Ключ цифрового товара.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct OrderDigitalItemDto {
    /// Идентификатор товара в заказе.  Он приходит в ответе на запрос [GET campaigns/{campaignId}/orders/{orderId}](../../reference/orders/getOrder.md) и в запросе Маркета [POST order/accept](../../pushapi/reference/orderAccept.md) — параметр `id` в `items`. 
    #[serde(rename = "id")]
    pub id: i64,

    /// Сам ключ.
    #[serde(rename = "code")]
    pub code: String,

    /// Инструкция по активации.
    #[serde(rename = "slip")]
    pub slip: String,

    /// Дата, до которой нужно активировать ключ. Если ключ действует бессрочно, укажите любую дату в отдаленном будущем.  Формат даты: `ГГГГ-ММ-ДД`. 
    #[serde(rename = "activate_till")]
    pub activate_till: chrono::naive::NaiveDate,

}


impl OrderDigitalItemDto {
    #[allow(clippy::new_without_default)]
    pub fn new(id: i64, code: String, slip: String, activate_till: chrono::naive::NaiveDate, ) -> OrderDigitalItemDto {
        OrderDigitalItemDto {
            id,
            code,
            slip,
            activate_till,
        }
    }
}

/// Converts the OrderDigitalItemDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for OrderDigitalItemDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            Some("id".to_string()),
            Some(self.id.to_string()),


            Some("code".to_string()),
            Some(self.code.to_string()),


            Some("slip".to_string()),
            Some(self.slip.to_string()),

            // Skipping activate_till in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a OrderDigitalItemDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for OrderDigitalItemDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<i64>,
            pub code: Vec<String>,
            pub slip: Vec<String>,
            pub activate_till: Vec<chrono::naive::NaiveDate>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing OrderDigitalItemDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "code" => intermediate_rep.code.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "slip" => intermediate_rep.slip.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "activate_till" => intermediate_rep.activate_till.push(<chrono::naive::NaiveDate as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing OrderDigitalItemDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(OrderDigitalItemDto {
            id: intermediate_rep.id.into_iter().next().ok_or_else(|| "id missing in OrderDigitalItemDto".to_string())?,
            code: intermediate_rep.code.into_iter().next().ok_or_else(|| "code missing in OrderDigitalItemDto".to_string())?,
            slip: intermediate_rep.slip.into_iter().next().ok_or_else(|| "slip missing in OrderDigitalItemDto".to_string())?,
            activate_till: intermediate_rep.activate_till.into_iter().next().ok_or_else(|| "activate_till missing in OrderDigitalItemDto".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<OrderDigitalItemDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<OrderDigitalItemDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<OrderDigitalItemDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for OrderDigitalItemDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<OrderDigitalItemDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <OrderDigitalItemDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into OrderDigitalItemDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Статус документа:  * `READY` — готов. * `NOT_READY` — не готов. 
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum OrderDocumentStatusType {
    #[serde(rename = "READY")]
    Ready,
    #[serde(rename = "NOT_READY")]
    NotReady,
}

impl std::fmt::Display for OrderDocumentStatusType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            OrderDocumentStatusType::Ready => write!(f, "READY"),
            OrderDocumentStatusType::NotReady => write!(f, "NOT_READY"),
        }
    }
}

impl std::str::FromStr for OrderDocumentStatusType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "READY" => std::result::Result::Ok(OrderDocumentStatusType::Ready),
            "NOT_READY" => std::result::Result::Ok(OrderDocumentStatusType::NotReady),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Заказ.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct OrderDto {
    /// Идентификатор заказа.
    #[serde(rename = "id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,

    #[serde(rename = "status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<models::OrderStatusType>,

    #[serde(rename = "substatus")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub substatus: Option<models::OrderSubstatusType>,

    #[serde(rename = "creationDate")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub creation_date: Option<String>,

    #[serde(rename = "updatedAt")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<String>,

    #[serde(rename = "currency")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub currency: Option<models::CurrencyType>,

    /// Платеж покупателя. 
    #[serde(rename = "itemsTotal")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub items_total: Option<f64>,

    /// Стоимость доставки. 
    #[serde(rename = "deliveryTotal")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub delivery_total: Option<f64>,

    /// {% note warning \"\" %}  Этот параметр устарел.  {% endnote %}  Стоимость всех товаров в заказе в валюте покупателя после применения скидок и без учета стоимости доставки. 
    #[serde(rename = "buyerItemsTotal")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub buyer_items_total: Option<f64>,

    /// {% note warning \"\" %}  Этот параметр устарел.  {% endnote %}  Стоимость всех товаров в заказе в валюте покупателя после применения скидок и с учетом стоимости доставки. 
    #[serde(rename = "buyerTotal")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub buyer_total: Option<f64>,

    /// Стоимость всех товаров в заказе в валюте покупателя без учета стоимости доставки и до применения скидок по:  * акциям; * купонам; * промокодам. 
    #[serde(rename = "buyerItemsTotalBeforeDiscount")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub buyer_items_total_before_discount: Option<f64>,

    /// {% note warning \"\" %}  Этот параметр устарел.  {% endnote %}  Стоимость всех товаров в заказе в валюте покупателя до применения скидок и с учетом стоимости доставки (`buyerItemsTotalBeforeDiscount` + стоимость доставки). 
    #[serde(rename = "buyerTotalBeforeDiscount")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub buyer_total_before_discount: Option<f64>,

    #[serde(rename = "paymentType")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub payment_type: Option<models::OrderPaymentType>,

    #[serde(rename = "paymentMethod")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub payment_method: Option<models::OrderPaymentMethodType>,

    /// Тип заказа:  * `false` — настоящий заказ покупателя.  * `true` — [тестовый](../../pushapi/concepts/sandbox.md) заказ Маркета. 
    #[serde(rename = "fake")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub fake: Option<bool>,

    /// Список товаров в заказе.
    #[serde(rename = "items")]
    pub items: Vec<models::OrderItemDto>,

    /// Список субсидий по типам.
    #[serde(rename = "subsidies")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub subsidies: Option<swagger::Nullable<Vec<models::OrderSubsidyDto>>>,

    #[serde(rename = "delivery")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub delivery: Option<models::OrderDeliveryDto>,

    #[serde(rename = "buyer")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub buyer: Option<models::OrderBuyerDto>,

    /// Комментарий к заказу.
    #[serde(rename = "notes")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub notes: Option<String>,

    #[serde(rename = "taxSystem")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub tax_system: Option<models::OrderTaxSystemType>,

    /// **Только для модели DBS**  Запрошена ли отмена. 
    #[serde(rename = "cancelRequested")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub cancel_requested: Option<bool>,

    #[serde(rename = "expiryDate")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub expiry_date: Option<String>,

}


impl OrderDto {
    #[allow(clippy::new_without_default)]
    pub fn new(items: Vec<models::OrderItemDto>, ) -> OrderDto {
        OrderDto {
            id: None,
            status: None,
            substatus: None,
            creation_date: None,
            updated_at: None,
            currency: None,
            items_total: None,
            delivery_total: None,
            buyer_items_total: None,
            buyer_total: None,
            buyer_items_total_before_discount: None,
            buyer_total_before_discount: None,
            payment_type: None,
            payment_method: None,
            fake: None,
            items,
            subsidies: None,
            delivery: None,
            buyer: None,
            notes: None,
            tax_system: None,
            cancel_requested: None,
            expiry_date: None,
        }
    }
}

/// Converts the OrderDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for OrderDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.id.as_ref().map(|id| {
                [
                    "id".to_string(),
                    id.to_string(),
                ].join(",")
            }),

            // Skipping status in query parameter serialization

            // Skipping substatus in query parameter serialization


            self.creation_date.as_ref().map(|creation_date| {
                [
                    "creationDate".to_string(),
                    creation_date.to_string(),
                ].join(",")
            }),


            self.updated_at.as_ref().map(|updated_at| {
                [
                    "updatedAt".to_string(),
                    updated_at.to_string(),
                ].join(",")
            }),

            // Skipping currency in query parameter serialization


            self.items_total.as_ref().map(|items_total| {
                [
                    "itemsTotal".to_string(),
                    items_total.to_string(),
                ].join(",")
            }),


            self.delivery_total.as_ref().map(|delivery_total| {
                [
                    "deliveryTotal".to_string(),
                    delivery_total.to_string(),
                ].join(",")
            }),


            self.buyer_items_total.as_ref().map(|buyer_items_total| {
                [
                    "buyerItemsTotal".to_string(),
                    buyer_items_total.to_string(),
                ].join(",")
            }),


            self.buyer_total.as_ref().map(|buyer_total| {
                [
                    "buyerTotal".to_string(),
                    buyer_total.to_string(),
                ].join(",")
            }),


            self.buyer_items_total_before_discount.as_ref().map(|buyer_items_total_before_discount| {
                [
                    "buyerItemsTotalBeforeDiscount".to_string(),
                    buyer_items_total_before_discount.to_string(),
                ].join(",")
            }),


            self.buyer_total_before_discount.as_ref().map(|buyer_total_before_discount| {
                [
                    "buyerTotalBeforeDiscount".to_string(),
                    buyer_total_before_discount.to_string(),
                ].join(",")
            }),

            // Skipping paymentType in query parameter serialization

            // Skipping paymentMethod in query parameter serialization


            self.fake.as_ref().map(|fake| {
                [
                    "fake".to_string(),
                    fake.to_string(),
                ].join(",")
            }),

            // Skipping items in query parameter serialization

            // Skipping subsidies in query parameter serialization

            // Skipping delivery in query parameter serialization

            // Skipping buyer in query parameter serialization


            self.notes.as_ref().map(|notes| {
                [
                    "notes".to_string(),
                    notes.to_string(),
                ].join(",")
            }),

            // Skipping taxSystem in query parameter serialization


            self.cancel_requested.as_ref().map(|cancel_requested| {
                [
                    "cancelRequested".to_string(),
                    cancel_requested.to_string(),
                ].join(",")
            }),


            self.expiry_date.as_ref().map(|expiry_date| {
                [
                    "expiryDate".to_string(),
                    expiry_date.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a OrderDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for OrderDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<i64>,
            pub status: Vec<models::OrderStatusType>,
            pub substatus: Vec<models::OrderSubstatusType>,
            pub creation_date: Vec<String>,
            pub updated_at: Vec<String>,
            pub currency: Vec<models::CurrencyType>,
            pub items_total: Vec<f64>,
            pub delivery_total: Vec<f64>,
            pub buyer_items_total: Vec<f64>,
            pub buyer_total: Vec<f64>,
            pub buyer_items_total_before_discount: Vec<f64>,
            pub buyer_total_before_discount: Vec<f64>,
            pub payment_type: Vec<models::OrderPaymentType>,
            pub payment_method: Vec<models::OrderPaymentMethodType>,
            pub fake: Vec<bool>,
            pub items: Vec<Vec<models::OrderItemDto>>,
            pub subsidies: Vec<Vec<models::OrderSubsidyDto>>,
            pub delivery: Vec<models::OrderDeliveryDto>,
            pub buyer: Vec<models::OrderBuyerDto>,
            pub notes: Vec<String>,
            pub tax_system: Vec<models::OrderTaxSystemType>,
            pub cancel_requested: Vec<bool>,
            pub expiry_date: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing OrderDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(<models::OrderStatusType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "substatus" => intermediate_rep.substatus.push(<models::OrderSubstatusType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "creationDate" => intermediate_rep.creation_date.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "updatedAt" => intermediate_rep.updated_at.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "currency" => intermediate_rep.currency.push(<models::CurrencyType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "itemsTotal" => intermediate_rep.items_total.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "deliveryTotal" => intermediate_rep.delivery_total.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "buyerItemsTotal" => intermediate_rep.buyer_items_total.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "buyerTotal" => intermediate_rep.buyer_total.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "buyerItemsTotalBeforeDiscount" => intermediate_rep.buyer_items_total_before_discount.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "buyerTotalBeforeDiscount" => intermediate_rep.buyer_total_before_discount.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "paymentType" => intermediate_rep.payment_type.push(<models::OrderPaymentType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "paymentMethod" => intermediate_rep.payment_method.push(<models::OrderPaymentMethodType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "fake" => intermediate_rep.fake.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "items" => return std::result::Result::Err("Parsing a container in this style is not supported in OrderDto".to_string()),
                    "subsidies" => return std::result::Result::Err("Parsing a container in this style is not supported in OrderDto".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "delivery" => intermediate_rep.delivery.push(<models::OrderDeliveryDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "buyer" => intermediate_rep.buyer.push(<models::OrderBuyerDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "notes" => intermediate_rep.notes.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "taxSystem" => intermediate_rep.tax_system.push(<models::OrderTaxSystemType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "cancelRequested" => intermediate_rep.cancel_requested.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "expiryDate" => intermediate_rep.expiry_date.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing OrderDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(OrderDto {
            id: intermediate_rep.id.into_iter().next(),
            status: intermediate_rep.status.into_iter().next(),
            substatus: intermediate_rep.substatus.into_iter().next(),
            creation_date: intermediate_rep.creation_date.into_iter().next(),
            updated_at: intermediate_rep.updated_at.into_iter().next(),
            currency: intermediate_rep.currency.into_iter().next(),
            items_total: intermediate_rep.items_total.into_iter().next(),
            delivery_total: intermediate_rep.delivery_total.into_iter().next(),
            buyer_items_total: intermediate_rep.buyer_items_total.into_iter().next(),
            buyer_total: intermediate_rep.buyer_total.into_iter().next(),
            buyer_items_total_before_discount: intermediate_rep.buyer_items_total_before_discount.into_iter().next(),
            buyer_total_before_discount: intermediate_rep.buyer_total_before_discount.into_iter().next(),
            payment_type: intermediate_rep.payment_type.into_iter().next(),
            payment_method: intermediate_rep.payment_method.into_iter().next(),
            fake: intermediate_rep.fake.into_iter().next(),
            items: intermediate_rep.items.into_iter().next().ok_or_else(|| "items missing in OrderDto".to_string())?,
            subsidies: std::result::Result::Err("Nullable types not supported in OrderDto".to_string())?,
            delivery: intermediate_rep.delivery.into_iter().next(),
            buyer: intermediate_rep.buyer.into_iter().next(),
            notes: intermediate_rep.notes.into_iter().next(),
            tax_system: intermediate_rep.tax_system.into_iter().next(),
            cancel_requested: intermediate_rep.cancel_requested.into_iter().next(),
            expiry_date: intermediate_rep.expiry_date.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<OrderDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<OrderDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<OrderDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for OrderDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<OrderDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <OrderDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into OrderDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Детали по товару в заказе.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct OrderItemDetailDto {
    /// Количество единиц товара.
    #[serde(rename = "itemCount")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub item_count: Option<i64>,

    #[serde(rename = "itemStatus")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub item_status: Option<models::OrderItemStatusType>,

    /// Формат даты: `ДД-ММ-ГГГГ`. 
    #[serde(rename = "updateDate")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub update_date: Option<String>,

}


impl OrderItemDetailDto {
    #[allow(clippy::new_without_default)]
    pub fn new() -> OrderItemDetailDto {
        OrderItemDetailDto {
            item_count: None,
            item_status: None,
            update_date: None,
        }
    }
}

/// Converts the OrderItemDetailDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for OrderItemDetailDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.item_count.as_ref().map(|item_count| {
                [
                    "itemCount".to_string(),
                    item_count.to_string(),
                ].join(",")
            }),

            // Skipping itemStatus in query parameter serialization


            self.update_date.as_ref().map(|update_date| {
                [
                    "updateDate".to_string(),
                    update_date.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a OrderItemDetailDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for OrderItemDetailDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub item_count: Vec<i64>,
            pub item_status: Vec<models::OrderItemStatusType>,
            pub update_date: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing OrderItemDetailDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "itemCount" => intermediate_rep.item_count.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "itemStatus" => intermediate_rep.item_status.push(<models::OrderItemStatusType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "updateDate" => intermediate_rep.update_date.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing OrderItemDetailDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(OrderItemDetailDto {
            item_count: intermediate_rep.item_count.into_iter().next(),
            item_status: intermediate_rep.item_status.into_iter().next(),
            update_date: intermediate_rep.update_date.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<OrderItemDetailDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<OrderItemDetailDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<OrderItemDetailDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for OrderItemDetailDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<OrderItemDetailDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <OrderItemDetailDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into OrderItemDetailDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Список товаров в заказе.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct OrderItemDto {
    /// Идентификатор товара в заказе.  Позволяет идентифицировать товар в рамках данного заказа. 
    #[serde(rename = "id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,

    /// Ваш SKU — идентификатор товара в вашей системе.  Разрешена любая последовательность длиной до 255 знаков.  Правила использования SKU:  * У каждого товара SKU должен быть свой.  * SKU товара нельзя менять — можно только удалить товар и добавить заново с новым SKU.  * Уже заданный SKU нельзя освободить и использовать заново для другого товара. Каждый товар должен получать новый идентификатор, до того никогда не использовавшийся в вашем каталоге.  [Что такое SKU и как его назначать](https://yandex.ru/support/marketplace/assortment/add/index.html#fields) 
    #[serde(rename = "offerId")]
    #[validate(
            length(min = 1, max = 255),
           regex = "RE_ORDERITEMDTO_OFFER_ID",
        )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub offer_id: Option<String>,

    /// Название товара.
    #[serde(rename = "offerName")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub offer_name: Option<String>,

    /// Цена на товар в валюте заказа без учета вознаграждения партнеру за скидки по промокодам, купонам и акциям (параметр `subsidies`). 
    #[serde(rename = "price")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub price: Option<f64>,

    /// Цена на товар в валюте покупателя. В цене уже учтены скидки по:  * акциям; * купонам; * промокодам. 
    #[serde(rename = "buyerPrice")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub buyer_price: Option<f64>,

    /// Стоимость товара в валюте покупателя до применения скидок по:  * акциям; * купонам; * промокодам. 
    #[serde(rename = "buyerPriceBeforeDiscount")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub buyer_price_before_discount: Option<f64>,

    /// {% note warning \"\" %}  Этот параметр устарел.  {% endnote %}  Стоимость товара в валюте магазина до применения скидок. 
    #[serde(rename = "priceBeforeDiscount")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub price_before_discount: Option<f64>,

    /// Количество единиц товара.
    #[serde(rename = "count")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub count: Option<i32>,

    #[serde(rename = "vat")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub vat: Option<models::OrderVatType>,

    /// Ваш SKU — идентификатор товара в вашей системе.  Разрешена любая последовательность длиной до 255 знаков.  Правила использования SKU:  * У каждого товара SKU должен быть свой.  * SKU товара нельзя менять — можно только удалить товар и добавить заново с новым SKU.  * Уже заданный SKU нельзя освободить и использовать заново для другого товара. Каждый товар должен получать новый идентификатор, до того никогда не использовавшийся в вашем каталоге.  [Что такое SKU и как его назначать](https://yandex.ru/support/marketplace/assortment/add/index.html#fields) 
    #[serde(rename = "shopSku")]
    #[validate(
            length(min = 1, max = 255),
           regex = "RE_ORDERITEMDTO_SHOP_SKU",
        )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub shop_sku: Option<String>,

    /// {% note warning \"\" %}  Этот параметр устарел. Вместо него используйте `subsidies`.  {% endnote %}  Общее вознаграждение партнеру за DBS-доставку и все скидки на товар:  * по промокодам; * по купонам; * по баллам Плюса; * по акциям.  Передается в валюте заказа. 
    #[serde(rename = "subsidy")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub subsidy: Option<f64>,

    /// {% note warning \"\" %}  Этот параметр устарел. Не используйте его.  {% endnote %}  Идентификатор склада в системе партнера, на который сформирован заказ. 
    #[serde(rename = "partnerWarehouseId")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub partner_warehouse_id: Option<String>,

    /// Информация о вознаграждениях партнеру за скидки на товар по промокодам, купонам и акциям.
    #[serde(rename = "promos")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub promos: Option<swagger::Nullable<Vec<models::OrderItemPromoDto>>>,

    /// Информация о маркировке единиц товара.  Возвращаются данные для маркировки, переданные в запросе [PUT campaigns/{campaignId}/orders/{orderId}/cis](../../reference/orders/provideOrderItemCis.md).  Если магазин еще не передавал коды для этого заказа, `instances` отсутствует. 
    #[serde(rename = "instances")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub instances: Option<swagger::Nullable<Vec<models::OrderItemInstanceDto>>>,

    /// Информация об удалении товара из заказа. 
    #[serde(rename = "details")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub details: Option<swagger::Nullable<Vec<models::OrderItemDetailDto>>>,

    /// Список субсидий по типам.
    #[serde(rename = "subsidies")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub subsidies: Option<swagger::Nullable<Vec<models::OrderItemSubsidyDto>>>,

    /// Список необходимых маркировок товара.
    #[serde(rename = "requiredInstanceTypes")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub required_instance_types: Option<swagger::Nullable<Vec<models::OrderItemInstanceType>>>,

}

lazy_static::lazy_static! {
    static ref RE_ORDERITEMDTO_OFFER_ID: regex::Regex = regex::Regex::new(r"^[^\\x00-\\x08\\x0A-\\x1f\\x7f]{1,255}$").unwrap();
}
lazy_static::lazy_static! {
    static ref RE_ORDERITEMDTO_SHOP_SKU: regex::Regex = regex::Regex::new(r"^[^\\x00-\\x08\\x0A-\\x1f\\x7f]{1,255}$").unwrap();
}

impl OrderItemDto {
    #[allow(clippy::new_without_default)]
    pub fn new() -> OrderItemDto {
        OrderItemDto {
            id: None,
            offer_id: None,
            offer_name: None,
            price: None,
            buyer_price: None,
            buyer_price_before_discount: None,
            price_before_discount: None,
            count: None,
            vat: None,
            shop_sku: None,
            subsidy: None,
            partner_warehouse_id: None,
            promos: None,
            instances: None,
            details: None,
            subsidies: None,
            required_instance_types: None,
        }
    }
}

/// Converts the OrderItemDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for OrderItemDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.id.as_ref().map(|id| {
                [
                    "id".to_string(),
                    id.to_string(),
                ].join(",")
            }),


            self.offer_id.as_ref().map(|offer_id| {
                [
                    "offerId".to_string(),
                    offer_id.to_string(),
                ].join(",")
            }),


            self.offer_name.as_ref().map(|offer_name| {
                [
                    "offerName".to_string(),
                    offer_name.to_string(),
                ].join(",")
            }),


            self.price.as_ref().map(|price| {
                [
                    "price".to_string(),
                    price.to_string(),
                ].join(",")
            }),


            self.buyer_price.as_ref().map(|buyer_price| {
                [
                    "buyerPrice".to_string(),
                    buyer_price.to_string(),
                ].join(",")
            }),


            self.buyer_price_before_discount.as_ref().map(|buyer_price_before_discount| {
                [
                    "buyerPriceBeforeDiscount".to_string(),
                    buyer_price_before_discount.to_string(),
                ].join(",")
            }),


            self.price_before_discount.as_ref().map(|price_before_discount| {
                [
                    "priceBeforeDiscount".to_string(),
                    price_before_discount.to_string(),
                ].join(",")
            }),


            self.count.as_ref().map(|count| {
                [
                    "count".to_string(),
                    count.to_string(),
                ].join(",")
            }),

            // Skipping vat in query parameter serialization


            self.shop_sku.as_ref().map(|shop_sku| {
                [
                    "shopSku".to_string(),
                    shop_sku.to_string(),
                ].join(",")
            }),


            self.subsidy.as_ref().map(|subsidy| {
                [
                    "subsidy".to_string(),
                    subsidy.to_string(),
                ].join(",")
            }),


            self.partner_warehouse_id.as_ref().map(|partner_warehouse_id| {
                [
                    "partnerWarehouseId".to_string(),
                    partner_warehouse_id.to_string(),
                ].join(",")
            }),

            // Skipping promos in query parameter serialization

            // Skipping instances in query parameter serialization

            // Skipping details in query parameter serialization

            // Skipping subsidies in query parameter serialization

            // Skipping requiredInstanceTypes in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a OrderItemDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for OrderItemDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<i64>,
            pub offer_id: Vec<String>,
            pub offer_name: Vec<String>,
            pub price: Vec<f64>,
            pub buyer_price: Vec<f64>,
            pub buyer_price_before_discount: Vec<f64>,
            pub price_before_discount: Vec<f64>,
            pub count: Vec<i32>,
            pub vat: Vec<models::OrderVatType>,
            pub shop_sku: Vec<String>,
            pub subsidy: Vec<f64>,
            pub partner_warehouse_id: Vec<String>,
            pub promos: Vec<Vec<models::OrderItemPromoDto>>,
            pub instances: Vec<Vec<models::OrderItemInstanceDto>>,
            pub details: Vec<Vec<models::OrderItemDetailDto>>,
            pub subsidies: Vec<Vec<models::OrderItemSubsidyDto>>,
            pub required_instance_types: Vec<Vec<models::OrderItemInstanceType>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing OrderItemDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "offerId" => intermediate_rep.offer_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "offerName" => intermediate_rep.offer_name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "price" => intermediate_rep.price.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "buyerPrice" => intermediate_rep.buyer_price.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "buyerPriceBeforeDiscount" => intermediate_rep.buyer_price_before_discount.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "priceBeforeDiscount" => intermediate_rep.price_before_discount.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "count" => intermediate_rep.count.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "vat" => intermediate_rep.vat.push(<models::OrderVatType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "shopSku" => intermediate_rep.shop_sku.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "subsidy" => intermediate_rep.subsidy.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "partnerWarehouseId" => intermediate_rep.partner_warehouse_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "promos" => return std::result::Result::Err("Parsing a container in this style is not supported in OrderItemDto".to_string()),
                    "instances" => return std::result::Result::Err("Parsing a container in this style is not supported in OrderItemDto".to_string()),
                    "details" => return std::result::Result::Err("Parsing a container in this style is not supported in OrderItemDto".to_string()),
                    "subsidies" => return std::result::Result::Err("Parsing a container in this style is not supported in OrderItemDto".to_string()),
                    "requiredInstanceTypes" => return std::result::Result::Err("Parsing a container in this style is not supported in OrderItemDto".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing OrderItemDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(OrderItemDto {
            id: intermediate_rep.id.into_iter().next(),
            offer_id: intermediate_rep.offer_id.into_iter().next(),
            offer_name: intermediate_rep.offer_name.into_iter().next(),
            price: intermediate_rep.price.into_iter().next(),
            buyer_price: intermediate_rep.buyer_price.into_iter().next(),
            buyer_price_before_discount: intermediate_rep.buyer_price_before_discount.into_iter().next(),
            price_before_discount: intermediate_rep.price_before_discount.into_iter().next(),
            count: intermediate_rep.count.into_iter().next(),
            vat: intermediate_rep.vat.into_iter().next(),
            shop_sku: intermediate_rep.shop_sku.into_iter().next(),
            subsidy: intermediate_rep.subsidy.into_iter().next(),
            partner_warehouse_id: intermediate_rep.partner_warehouse_id.into_iter().next(),
            promos: std::result::Result::Err("Nullable types not supported in OrderItemDto".to_string())?,
            instances: std::result::Result::Err("Nullable types not supported in OrderItemDto".to_string())?,
            details: std::result::Result::Err("Nullable types not supported in OrderItemDto".to_string())?,
            subsidies: std::result::Result::Err("Nullable types not supported in OrderItemDto".to_string())?,
            required_instance_types: std::result::Result::Err("Nullable types not supported in OrderItemDto".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<OrderItemDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<OrderItemDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<OrderItemDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for OrderItemDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<OrderItemDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <OrderItemDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into OrderItemDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Переданные вами для данной позиции коды маркировки или УИНы. Коды «Честного знака» возвращаются в двух вариантах — с криптохвостом и без. 
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct OrderItemInstanceDto {
    /// Код идентификации единицы товара [в системе «Честный ЗНАК»](https://честныйзнак.рф/) без криптохвоста.
    #[serde(rename = "cis")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub cis: Option<String>,

    /// Код идентификации единицы товара [в системе «Честный ЗНАК»](https://честныйзнак.рф/) с криптохвостом.
    #[serde(rename = "cisFull")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub cis_full: Option<String>,

    /// УИН ювелирного изделия (16-значный код) Производитель получает УИН, когда регистрирует изделие в системе контроля за оборотом драгоценных металлов и камней — ГИИС ДМДК. 
    #[serde(rename = "uin")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub uin: Option<String>,

    /// Регистрационный номер партии товара.  Представляет собой строку из четырех чисел, разделенных косой чертой: ХХХХХХХХ/ХХХХХХ/ХХХХХХХ/ХХХ.  Первая часть — код таможни, которая зарегистрировала декларацию на партию товара. Далее — дата, номер декларации и номер маркированного товара в декларации. 
    #[serde(rename = "rnpt")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub rnpt: Option<String>,

    /// Грузовая таможенная декларация.  Представляет собой строку из трех чисел, разделенных косой чертой: ХХХХХХХХ/ХХХХХХ/ХХХХХХХ.  Первая часть — код таможни, которая зарегистрировала декларацию на ввезенные товары. Далее — дата и номер декларации. 
    #[serde(rename = "gtd")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub gtd: Option<String>,

}


impl OrderItemInstanceDto {
    #[allow(clippy::new_without_default)]
    pub fn new() -> OrderItemInstanceDto {
        OrderItemInstanceDto {
            cis: None,
            cis_full: None,
            uin: None,
            rnpt: None,
            gtd: None,
        }
    }
}

/// Converts the OrderItemInstanceDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for OrderItemInstanceDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.cis.as_ref().map(|cis| {
                [
                    "cis".to_string(),
                    cis.to_string(),
                ].join(",")
            }),


            self.cis_full.as_ref().map(|cis_full| {
                [
                    "cisFull".to_string(),
                    cis_full.to_string(),
                ].join(",")
            }),


            self.uin.as_ref().map(|uin| {
                [
                    "uin".to_string(),
                    uin.to_string(),
                ].join(",")
            }),


            self.rnpt.as_ref().map(|rnpt| {
                [
                    "rnpt".to_string(),
                    rnpt.to_string(),
                ].join(",")
            }),


            self.gtd.as_ref().map(|gtd| {
                [
                    "gtd".to_string(),
                    gtd.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a OrderItemInstanceDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for OrderItemInstanceDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub cis: Vec<String>,
            pub cis_full: Vec<String>,
            pub uin: Vec<String>,
            pub rnpt: Vec<String>,
            pub gtd: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing OrderItemInstanceDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "cis" => intermediate_rep.cis.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "cisFull" => intermediate_rep.cis_full.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "uin" => intermediate_rep.uin.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "rnpt" => intermediate_rep.rnpt.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "gtd" => intermediate_rep.gtd.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing OrderItemInstanceDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(OrderItemInstanceDto {
            cis: intermediate_rep.cis.into_iter().next(),
            cis_full: intermediate_rep.cis_full.into_iter().next(),
            uin: intermediate_rep.uin.into_iter().next(),
            rnpt: intermediate_rep.rnpt.into_iter().next(),
            gtd: intermediate_rep.gtd.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<OrderItemInstanceDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<OrderItemInstanceDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<OrderItemInstanceDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for OrderItemInstanceDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<OrderItemInstanceDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <OrderItemInstanceDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into OrderItemInstanceDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Позиция в корзине, требующая маркировки.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct OrderItemInstanceModificationDto {
    /// Идентификатор товара в заказе.  Он приходит в ответе на запрос [GET campaigns/{campaignId}/orders/{orderId}](../../reference/orders/getOrder.md) и в запросе Маркета [POST order/accept](../../pushapi/reference/orderAccept.md) — параметр `id` в `items`. 
    #[serde(rename = "id")]
    pub id: i64,

    /// Список кодов маркировки единиц товара. 
    #[serde(rename = "instances")]
    pub instances: Vec<models::BriefOrderItemInstanceDto>,

}


impl OrderItemInstanceModificationDto {
    #[allow(clippy::new_without_default)]
    pub fn new(id: i64, instances: Vec<models::BriefOrderItemInstanceDto>, ) -> OrderItemInstanceModificationDto {
        OrderItemInstanceModificationDto {
            id,
            instances,
        }
    }
}

/// Converts the OrderItemInstanceModificationDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for OrderItemInstanceModificationDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            Some("id".to_string()),
            Some(self.id.to_string()),

            // Skipping instances in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a OrderItemInstanceModificationDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for OrderItemInstanceModificationDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<i64>,
            pub instances: Vec<Vec<models::BriefOrderItemInstanceDto>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing OrderItemInstanceModificationDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "instances" => return std::result::Result::Err("Parsing a container in this style is not supported in OrderItemInstanceModificationDto".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing OrderItemInstanceModificationDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(OrderItemInstanceModificationDto {
            id: intermediate_rep.id.into_iter().next().ok_or_else(|| "id missing in OrderItemInstanceModificationDto".to_string())?,
            instances: intermediate_rep.instances.into_iter().next().ok_or_else(|| "instances missing in OrderItemInstanceModificationDto".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<OrderItemInstanceModificationDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<OrderItemInstanceModificationDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<OrderItemInstanceModificationDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for OrderItemInstanceModificationDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<OrderItemInstanceModificationDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <OrderItemInstanceModificationDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into OrderItemInstanceModificationDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Вид маркировки товара:  * `CIS` — КИЗ, идентификатор единицы товара [в системе «Честный ЗНАК»](https://честныйзнак.рф/).  * `UIN` — УИН, уникальный идентификационный номер.  * `RNPT` — РНПТ, регистрационный номер партии товара.  * `GTD` — номер ГТД, грузовой таможенной декларации. 
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum OrderItemInstanceType {
    #[serde(rename = "CIS")]
    Cis,
    #[serde(rename = "UIN")]
    Uin,
    #[serde(rename = "RNPT")]
    Rnpt,
    #[serde(rename = "GTD")]
    Gtd,
}

impl std::fmt::Display for OrderItemInstanceType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            OrderItemInstanceType::Cis => write!(f, "CIS"),
            OrderItemInstanceType::Uin => write!(f, "UIN"),
            OrderItemInstanceType::Rnpt => write!(f, "RNPT"),
            OrderItemInstanceType::Gtd => write!(f, "GTD"),
        }
    }
}

impl std::str::FromStr for OrderItemInstanceType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "CIS" => std::result::Result::Ok(OrderItemInstanceType::Cis),
            "UIN" => std::result::Result::Ok(OrderItemInstanceType::Uin),
            "RNPT" => std::result::Result::Ok(OrderItemInstanceType::Rnpt),
            "GTD" => std::result::Result::Ok(OrderItemInstanceType::Gtd),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Список товаров в заказе.  Если магазин не передал информацию о товаре во входных данных, он будет удален из заказа.  Обязательный параметр. 
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct OrderItemModificationDto {
    /// Идентификатор товара в рамках заказа.  Получить идентификатор можно с помощью ресурсов [GET campaigns/{campaignId}/orders](../../reference/orders/getOrders.md) или [GET campaigns/{campaignId}/orders/{orderId}](../../reference/orders/getOrder.md).  Обязательный параметр. 
    #[serde(rename = "id")]
    pub id: i64,

    /// Новое количество товара.
    #[serde(rename = "count")]
    #[validate(
            range(min = 0),
        )]
    pub count: u32,

    /// Информация о маркировке единиц товара.  Передавайте в запросе все единицы товара, который подлежит маркировке.  Обязательный параметр, если в заказе есть товары, подлежащие маркировке [в системе «Честный ЗНАК»](https://честныйзнак.рф/). 
    #[serde(rename = "instances")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub instances: Option<swagger::Nullable<Vec<models::BriefOrderItemInstanceDto>>>,

}


impl OrderItemModificationDto {
    #[allow(clippy::new_without_default)]
    pub fn new(id: i64, count: u32, ) -> OrderItemModificationDto {
        OrderItemModificationDto {
            id,
            count,
            instances: None,
        }
    }
}

/// Converts the OrderItemModificationDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for OrderItemModificationDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            Some("id".to_string()),
            Some(self.id.to_string()),


            Some("count".to_string()),
            Some(self.count.to_string()),

            // Skipping instances in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a OrderItemModificationDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for OrderItemModificationDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<i64>,
            pub count: Vec<u32>,
            pub instances: Vec<Vec<models::BriefOrderItemInstanceDto>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing OrderItemModificationDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "count" => intermediate_rep.count.push(<u32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "instances" => return std::result::Result::Err("Parsing a container in this style is not supported in OrderItemModificationDto".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing OrderItemModificationDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(OrderItemModificationDto {
            id: intermediate_rep.id.into_iter().next().ok_or_else(|| "id missing in OrderItemModificationDto".to_string())?,
            count: intermediate_rep.count.into_iter().next().ok_or_else(|| "count missing in OrderItemModificationDto".to_string())?,
            instances: std::result::Result::Err("Nullable types not supported in OrderItemModificationDto".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<OrderItemModificationDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<OrderItemModificationDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<OrderItemModificationDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for OrderItemModificationDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<OrderItemModificationDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <OrderItemModificationDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into OrderItemModificationDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Информация о вознаграждениях партнеру за скидки на товар по промокодам, купонам и акциям.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct OrderItemPromoDto {
    #[serde(rename = "type")]
    pub r#type: models::OrderPromoType,

    /// Размер пользовательской скидки в валюте покупателя. 
    #[serde(rename = "discount")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub discount: Option<f64>,

    /// Вознаграждение партнеру от Маркета за товар, проданный в рамках акции.  Передается в валюте заказа. 
    #[serde(rename = "subsidy")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub subsidy: Option<f64>,

    /// Идентификатор акции поставщика. 
    #[serde(rename = "shopPromoId")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub shop_promo_id: Option<String>,

    /// Идентификатор акции в рамках соглашения на оказание услуг по продвижению сервиса между Маркетом и партнером.  Параметр передается, только если параметр `type=MARKET_DEAL`. 
    #[serde(rename = "marketPromoId")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub market_promo_id: Option<String>,

}


impl OrderItemPromoDto {
    #[allow(clippy::new_without_default)]
    pub fn new(r#type: models::OrderPromoType, ) -> OrderItemPromoDto {
        OrderItemPromoDto {
            r#type,
            discount: None,
            subsidy: None,
            shop_promo_id: None,
            market_promo_id: None,
        }
    }
}

/// Converts the OrderItemPromoDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for OrderItemPromoDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping type in query parameter serialization


            self.discount.as_ref().map(|discount| {
                [
                    "discount".to_string(),
                    discount.to_string(),
                ].join(",")
            }),


            self.subsidy.as_ref().map(|subsidy| {
                [
                    "subsidy".to_string(),
                    subsidy.to_string(),
                ].join(",")
            }),


            self.shop_promo_id.as_ref().map(|shop_promo_id| {
                [
                    "shopPromoId".to_string(),
                    shop_promo_id.to_string(),
                ].join(",")
            }),


            self.market_promo_id.as_ref().map(|market_promo_id| {
                [
                    "marketPromoId".to_string(),
                    market_promo_id.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a OrderItemPromoDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for OrderItemPromoDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub r#type: Vec<models::OrderPromoType>,
            pub discount: Vec<f64>,
            pub subsidy: Vec<f64>,
            pub shop_promo_id: Vec<String>,
            pub market_promo_id: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing OrderItemPromoDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r#type.push(<models::OrderPromoType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "discount" => intermediate_rep.discount.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "subsidy" => intermediate_rep.subsidy.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "shopPromoId" => intermediate_rep.shop_promo_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "marketPromoId" => intermediate_rep.market_promo_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing OrderItemPromoDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(OrderItemPromoDto {
            r#type: intermediate_rep.r#type.into_iter().next().ok_or_else(|| "type missing in OrderItemPromoDto".to_string())?,
            discount: intermediate_rep.discount.into_iter().next(),
            subsidy: intermediate_rep.subsidy.into_iter().next(),
            shop_promo_id: intermediate_rep.shop_promo_id.into_iter().next(),
            market_promo_id: intermediate_rep.market_promo_id.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<OrderItemPromoDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<OrderItemPromoDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<OrderItemPromoDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for OrderItemPromoDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<OrderItemPromoDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <OrderItemPromoDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into OrderItemPromoDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Возвращенный или невыкупленный товар:  * `REJECTED` — невыкупленный.  * `RETURNED` — возвращенный. 
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum OrderItemStatusType {
    #[serde(rename = "REJECTED")]
    Rejected,
    #[serde(rename = "RETURNED")]
    Returned,
}

impl std::fmt::Display for OrderItemStatusType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            OrderItemStatusType::Rejected => write!(f, "REJECTED"),
            OrderItemStatusType::Returned => write!(f, "RETURNED"),
        }
    }
}

impl std::str::FromStr for OrderItemStatusType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "REJECTED" => std::result::Result::Ok(OrderItemStatusType::Rejected),
            "RETURNED" => std::result::Result::Ok(OrderItemStatusType::Returned),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Общее вознаграждение партнеру за все скидки на товар:  * по промокодам, купонам и акциям; * по баллам Плюса.  Передается в валюте заказа. 
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct OrderItemSubsidyDto {
    #[serde(rename = "type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub r#type: Option<models::OrderItemSubsidyType>,

    /// Сумма субсидии.
    #[serde(rename = "amount")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub amount: Option<f64>,

}


impl OrderItemSubsidyDto {
    #[allow(clippy::new_without_default)]
    pub fn new() -> OrderItemSubsidyDto {
        OrderItemSubsidyDto {
            r#type: None,
            amount: None,
        }
    }
}

/// Converts the OrderItemSubsidyDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for OrderItemSubsidyDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping type in query parameter serialization


            self.amount.as_ref().map(|amount| {
                [
                    "amount".to_string(),
                    amount.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a OrderItemSubsidyDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for OrderItemSubsidyDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub r#type: Vec<models::OrderItemSubsidyType>,
            pub amount: Vec<f64>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing OrderItemSubsidyDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r#type.push(<models::OrderItemSubsidyType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "amount" => intermediate_rep.amount.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing OrderItemSubsidyDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(OrderItemSubsidyDto {
            r#type: intermediate_rep.r#type.into_iter().next(),
            amount: intermediate_rep.amount.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<OrderItemSubsidyDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<OrderItemSubsidyDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<OrderItemSubsidyDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for OrderItemSubsidyDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<OrderItemSubsidyDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <OrderItemSubsidyDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into OrderItemSubsidyDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Тип субсидии:  * `YANDEX_CASHBACK` — скидка по подписке Яндекс Плюс.  * `SUBSIDY` — скидка Маркета (по акциям, промокодам, купонам и т. д.). 
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum OrderItemSubsidyType {
    #[serde(rename = "YANDEX_CASHBACK")]
    YandexCashback,
    #[serde(rename = "SUBSIDY")]
    Subsidy,
}

impl std::fmt::Display for OrderItemSubsidyType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            OrderItemSubsidyType::YandexCashback => write!(f, "YANDEX_CASHBACK"),
            OrderItemSubsidyType::Subsidy => write!(f, "SUBSIDY"),
        }
    }
}

impl std::str::FromStr for OrderItemSubsidyType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "YANDEX_CASHBACK" => std::result::Result::Ok(OrderItemSubsidyType::YandexCashback),
            "SUBSIDY" => std::result::Result::Ok(OrderItemSubsidyType::Subsidy),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Причина обновления состава заказа.
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum OrderItemsModificationRequestReasonType {
    #[serde(rename = "PARTNER_REQUESTED_REMOVE")]
    PartnerRequestedRemove,
    #[serde(rename = "USER_REQUESTED_REMOVE")]
    UserRequestedRemove,
}

impl std::fmt::Display for OrderItemsModificationRequestReasonType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            OrderItemsModificationRequestReasonType::PartnerRequestedRemove => write!(f, "PARTNER_REQUESTED_REMOVE"),
            OrderItemsModificationRequestReasonType::UserRequestedRemove => write!(f, "USER_REQUESTED_REMOVE"),
        }
    }
}

impl std::str::FromStr for OrderItemsModificationRequestReasonType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "PARTNER_REQUESTED_REMOVE" => std::result::Result::Ok(OrderItemsModificationRequestReasonType::PartnerRequestedRemove),
            "USER_REQUESTED_REMOVE" => std::result::Result::Ok(OrderItemsModificationRequestReasonType::UserRequestedRemove),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Краткие сведения о промаркированных товарах. Параметр возвращается, если ответ `OK`. 
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct OrderItemsModificationResultDto {
    /// Список позиций в заказе, подлежащих маркировке.
    #[serde(rename = "items")]
    pub items: Vec<models::BriefOrderItemDto>,

}


impl OrderItemsModificationResultDto {
    #[allow(clippy::new_without_default)]
    pub fn new(items: Vec<models::BriefOrderItemDto>, ) -> OrderItemsModificationResultDto {
        OrderItemsModificationResultDto {
            items,
        }
    }
}

/// Converts the OrderItemsModificationResultDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for OrderItemsModificationResultDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping items in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a OrderItemsModificationResultDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for OrderItemsModificationResultDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub items: Vec<Vec<models::BriefOrderItemDto>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing OrderItemsModificationResultDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "items" => return std::result::Result::Err("Parsing a container in this style is not supported in OrderItemsModificationResultDto".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing OrderItemsModificationResultDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(OrderItemsModificationResultDto {
            items: intermediate_rep.items.into_iter().next().ok_or_else(|| "items missing in OrderItemsModificationResultDto".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<OrderItemsModificationResultDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<OrderItemsModificationResultDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<OrderItemsModificationResultDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for OrderItemsModificationResultDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<OrderItemsModificationResultDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <OrderItemsModificationResultDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into OrderItemsModificationResultDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Данные для печати ярлыка.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct OrderLabelDto {
    /// Идентификатор заказа.
    #[serde(rename = "orderId")]
    pub order_id: i64,

    /// Количество коробок в заказе.
    #[serde(rename = "placesNumber")]
    pub places_number: i32,

    /// URL файла с ярлыками‑наклейками на все коробки в заказе.  Соответствует URL, по которому выполняется запрос [GET campaigns/{campaignId}/orders/{orderId}/delivery/labels](../../reference/orders/generateOrderLabels.md). 
    #[serde(rename = "url")]
    pub url: String,

    /// Информация на ярлыке.
    #[serde(rename = "parcelBoxLabels")]
    pub parcel_box_labels: Vec<models::ParcelBoxLabelDto>,

}


impl OrderLabelDto {
    #[allow(clippy::new_without_default)]
    pub fn new(order_id: i64, places_number: i32, url: String, parcel_box_labels: Vec<models::ParcelBoxLabelDto>, ) -> OrderLabelDto {
        OrderLabelDto {
            order_id,
            places_number,
            url,
            parcel_box_labels,
        }
    }
}

/// Converts the OrderLabelDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for OrderLabelDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            Some("orderId".to_string()),
            Some(self.order_id.to_string()),


            Some("placesNumber".to_string()),
            Some(self.places_number.to_string()),


            Some("url".to_string()),
            Some(self.url.to_string()),

            // Skipping parcelBoxLabels in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a OrderLabelDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for OrderLabelDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub order_id: Vec<i64>,
            pub places_number: Vec<i32>,
            pub url: Vec<String>,
            pub parcel_box_labels: Vec<Vec<models::ParcelBoxLabelDto>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing OrderLabelDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "orderId" => intermediate_rep.order_id.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "placesNumber" => intermediate_rep.places_number.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "url" => intermediate_rep.url.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "parcelBoxLabels" => return std::result::Result::Err("Parsing a container in this style is not supported in OrderLabelDto".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing OrderLabelDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(OrderLabelDto {
            order_id: intermediate_rep.order_id.into_iter().next().ok_or_else(|| "orderId missing in OrderLabelDto".to_string())?,
            places_number: intermediate_rep.places_number.into_iter().next().ok_or_else(|| "placesNumber missing in OrderLabelDto".to_string())?,
            url: intermediate_rep.url.into_iter().next().ok_or_else(|| "url missing in OrderLabelDto".to_string())?,
            parcel_box_labels: intermediate_rep.parcel_box_labels.into_iter().next().ok_or_else(|| "parcelBoxLabels missing in OrderLabelDto".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<OrderLabelDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<OrderLabelDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<OrderLabelDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for OrderLabelDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<OrderLabelDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <OrderLabelDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into OrderLabelDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Тип подъема заказа на этаж:  * `NOT_NEEDED` — не требуется.  * `MANUAL` — ручной.  * `ELEVATOR` — лифт.  * `CARGO_ELEVATOR` — грузовой лифт.  * `FREE` — любой из перечисленных выше, если включена опция бесплатного подъема.  * `UNKNOWN` — неизвестный тип. 
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum OrderLiftType {
    #[serde(rename = "NOT_NEEDED")]
    NotNeeded,
    #[serde(rename = "MANUAL")]
    Manual,
    #[serde(rename = "ELEVATOR")]
    Elevator,
    #[serde(rename = "CARGO_ELEVATOR")]
    CargoElevator,
    #[serde(rename = "FREE")]
    Free,
    #[serde(rename = "UNKNOWN")]
    Unknown,
}

impl std::fmt::Display for OrderLiftType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            OrderLiftType::NotNeeded => write!(f, "NOT_NEEDED"),
            OrderLiftType::Manual => write!(f, "MANUAL"),
            OrderLiftType::Elevator => write!(f, "ELEVATOR"),
            OrderLiftType::CargoElevator => write!(f, "CARGO_ELEVATOR"),
            OrderLiftType::Free => write!(f, "FREE"),
            OrderLiftType::Unknown => write!(f, "UNKNOWN"),
        }
    }
}

impl std::str::FromStr for OrderLiftType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "NOT_NEEDED" => std::result::Result::Ok(OrderLiftType::NotNeeded),
            "MANUAL" => std::result::Result::Ok(OrderLiftType::Manual),
            "ELEVATOR" => std::result::Result::Ok(OrderLiftType::Elevator),
            "CARGO_ELEVATOR" => std::result::Result::Ok(OrderLiftType::CargoElevator),
            "FREE" => std::result::Result::Ok(OrderLiftType::Free),
            "UNKNOWN" => std::result::Result::Ok(OrderLiftType::Unknown),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Информация о грузоместе.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct OrderParcelBoxDto {
    /// Идентификатор грузоместа.
    #[serde(rename = "id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,

    /// Идентификатор грузового места в информационной системе магазина.
    #[serde(rename = "fulfilmentId")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub fulfilment_id: Option<String>,

}


impl OrderParcelBoxDto {
    #[allow(clippy::new_without_default)]
    pub fn new() -> OrderParcelBoxDto {
        OrderParcelBoxDto {
            id: None,
            fulfilment_id: None,
        }
    }
}

/// Converts the OrderParcelBoxDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for OrderParcelBoxDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.id.as_ref().map(|id| {
                [
                    "id".to_string(),
                    id.to_string(),
                ].join(",")
            }),


            self.fulfilment_id.as_ref().map(|fulfilment_id| {
                [
                    "fulfilmentId".to_string(),
                    fulfilment_id.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a OrderParcelBoxDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for OrderParcelBoxDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<i64>,
            pub fulfilment_id: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing OrderParcelBoxDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "fulfilmentId" => intermediate_rep.fulfilment_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing OrderParcelBoxDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(OrderParcelBoxDto {
            id: intermediate_rep.id.into_iter().next(),
            fulfilment_id: intermediate_rep.fulfilment_id.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<OrderParcelBoxDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<OrderParcelBoxDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<OrderParcelBoxDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for OrderParcelBoxDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<OrderParcelBoxDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <OrderParcelBoxDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into OrderParcelBoxDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Способ оплаты заказа:  * Значения, если выбрана оплата при оформлении заказа (`\"paymentType\": \"PREPAID\"`):    * `YANDEX` — банковской картой.    * `APPLE_PAY` — Apple Pay.    * `GOOGLE_PAY` — Google Pay.    * `CREDIT` — в кредит.    * `TINKOFF_CREDIT` — в кредит в Тинькофф Банке.    * `TINKOFF_INSTALLMENTS` — рассрочка в Тинькофф Банке.    * `EXTERNAL_CERTIFICATE` — подарочным сертификатом (например, из приложения «Сбербанк Онлайн»).    * `SBP` — через систему быстрых платежей.    * `B2B_ACCOUNT_PREPAYMENT` — заказ оплачивает организация.   * Значения, если выбрана оплата при получении заказа (`\"paymentType\": \"POSTPAID\"`):    * `CARD_ON_DELIVERY` — банковской картой.    * `BOUND_CARD_ON_DELIVERY` — привязанной картой при получении.    * `CASH_ON_DELIVERY` — наличными.    * `B2B_ACCOUNT_POSTPAYMENT` — заказ оплачивает организация после доставки.  * `UNKNOWN` — неизвестный тип.  Значение по умолчанию: `CASH_ON_DELIVERY`. 
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum OrderPaymentMethodType {
    #[serde(rename = "CASH_ON_DELIVERY")]
    CashOnDelivery,
    #[serde(rename = "CARD_ON_DELIVERY")]
    CardOnDelivery,
    #[serde(rename = "BOUND_CARD_ON_DELIVERY")]
    BoundCardOnDelivery,
    #[serde(rename = "YANDEX")]
    Yandex,
    #[serde(rename = "APPLE_PAY")]
    ApplePay,
    #[serde(rename = "EXTERNAL_CERTIFICATE")]
    ExternalCertificate,
    #[serde(rename = "CREDIT")]
    Credit,
    #[serde(rename = "GOOGLE_PAY")]
    GooglePay,
    #[serde(rename = "TINKOFF_CREDIT")]
    TinkoffCredit,
    #[serde(rename = "SBP")]
    Sbp,
    #[serde(rename = "TINKOFF_INSTALLMENTS")]
    TinkoffInstallments,
    #[serde(rename = "B2B_ACCOUNT_PREPAYMENT")]
    B2BAccountPrepayment,
    #[serde(rename = "B2B_ACCOUNT_POSTPAYMENT")]
    B2BAccountPostpayment,
    #[serde(rename = "UNKNOWN")]
    Unknown,
}

impl std::fmt::Display for OrderPaymentMethodType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            OrderPaymentMethodType::CashOnDelivery => write!(f, "CASH_ON_DELIVERY"),
            OrderPaymentMethodType::CardOnDelivery => write!(f, "CARD_ON_DELIVERY"),
            OrderPaymentMethodType::BoundCardOnDelivery => write!(f, "BOUND_CARD_ON_DELIVERY"),
            OrderPaymentMethodType::Yandex => write!(f, "YANDEX"),
            OrderPaymentMethodType::ApplePay => write!(f, "APPLE_PAY"),
            OrderPaymentMethodType::ExternalCertificate => write!(f, "EXTERNAL_CERTIFICATE"),
            OrderPaymentMethodType::Credit => write!(f, "CREDIT"),
            OrderPaymentMethodType::GooglePay => write!(f, "GOOGLE_PAY"),
            OrderPaymentMethodType::TinkoffCredit => write!(f, "TINKOFF_CREDIT"),
            OrderPaymentMethodType::Sbp => write!(f, "SBP"),
            OrderPaymentMethodType::TinkoffInstallments => write!(f, "TINKOFF_INSTALLMENTS"),
            OrderPaymentMethodType::B2BAccountPrepayment => write!(f, "B2B_ACCOUNT_PREPAYMENT"),
            OrderPaymentMethodType::B2BAccountPostpayment => write!(f, "B2B_ACCOUNT_POSTPAYMENT"),
            OrderPaymentMethodType::Unknown => write!(f, "UNKNOWN"),
        }
    }
}

impl std::str::FromStr for OrderPaymentMethodType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "CASH_ON_DELIVERY" => std::result::Result::Ok(OrderPaymentMethodType::CashOnDelivery),
            "CARD_ON_DELIVERY" => std::result::Result::Ok(OrderPaymentMethodType::CardOnDelivery),
            "BOUND_CARD_ON_DELIVERY" => std::result::Result::Ok(OrderPaymentMethodType::BoundCardOnDelivery),
            "YANDEX" => std::result::Result::Ok(OrderPaymentMethodType::Yandex),
            "APPLE_PAY" => std::result::Result::Ok(OrderPaymentMethodType::ApplePay),
            "EXTERNAL_CERTIFICATE" => std::result::Result::Ok(OrderPaymentMethodType::ExternalCertificate),
            "CREDIT" => std::result::Result::Ok(OrderPaymentMethodType::Credit),
            "GOOGLE_PAY" => std::result::Result::Ok(OrderPaymentMethodType::GooglePay),
            "TINKOFF_CREDIT" => std::result::Result::Ok(OrderPaymentMethodType::TinkoffCredit),
            "SBP" => std::result::Result::Ok(OrderPaymentMethodType::Sbp),
            "TINKOFF_INSTALLMENTS" => std::result::Result::Ok(OrderPaymentMethodType::TinkoffInstallments),
            "B2B_ACCOUNT_PREPAYMENT" => std::result::Result::Ok(OrderPaymentMethodType::B2BAccountPrepayment),
            "B2B_ACCOUNT_POSTPAYMENT" => std::result::Result::Ok(OrderPaymentMethodType::B2BAccountPostpayment),
            "UNKNOWN" => std::result::Result::Ok(OrderPaymentMethodType::Unknown),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Тип оплаты заказа:  * `PREPAID` — оплата при оформлении заказа.  * `POSTPAID` — оплата при получении заказа.  * `UNKNOWN` — неизвестный тип.  Если параметр отсутствует, заказ будет оплачен при получении. 
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum OrderPaymentType {
    #[serde(rename = "PREPAID")]
    Prepaid,
    #[serde(rename = "POSTPAID")]
    Postpaid,
    #[serde(rename = "UNKNOWN")]
    Unknown,
}

impl std::fmt::Display for OrderPaymentType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            OrderPaymentType::Prepaid => write!(f, "PREPAID"),
            OrderPaymentType::Postpaid => write!(f, "POSTPAID"),
            OrderPaymentType::Unknown => write!(f, "UNKNOWN"),
        }
    }
}

impl std::str::FromStr for OrderPaymentType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "PREPAID" => std::result::Result::Ok(OrderPaymentType::Prepaid),
            "POSTPAID" => std::result::Result::Ok(OrderPaymentType::Postpaid),
            "UNKNOWN" => std::result::Result::Ok(OrderPaymentType::Unknown),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Тип скидки:  * `DIRECT_DISCOUNT` — прямая скидка, которую устанавливает продавец или Маркет.  * `BLUE_SET` — комплекты.  * `BLUE_FLASH` — флеш-акция.  * `MARKET_COUPON` — скидка по промокоду Маркета.  * `MARKET_PROMOCODE` — скидка по промокоду магазина.  * `MARKET_BLUE` — скидка на Маркете.  * `YANDEX_PLUS` — бесплатная доставка с подпиской Яндекс Плюс.  * `YANDEX_EMPLOYEE` — бесплатная доставка по определенным адресам.  * `LIMITED_FREE_DELIVERY_PROMO` — бесплатная доставка по ограниченному предложению.  * `FREE_DELIVERY_THRESHOLD` — бесплатная доставка при достижении определенной суммы заказа.  * `MULTICART_DISCOUNT` — скидка за то, что оформлена мультикорзина.  * `FREE_DELIVERY_FOR_LDI` — бесплатная доставка за то, что один из товаров крупногабаритный.  * `FREE_DELIVERY_FOR_LSC` — бесплатная доставка за то, что одна из корзин в мультикорзине крупногабаритная.  * `FREE_PICKUP` — бесплатная доставка в пункт выдачи заказов.  * `CHEAPEST_AS_GIFT` — самый дешевый товар в подарок.  * `CASHBACK` — кешбэк.  * `SUPPLIER_MULTICART_DISCOUNT` — скидка за доставку.  * `SPREAD_DISCOUNT_COUNT` — скидка за количество одинаковых товаров.  * `SPREAD_DISCOUNT_RECEIPT` — скидка от суммы чека.  * `ANNOUNCEMENT_PROMO` — информационная акция, скидка не применяется к товарам.  * `DISCOUNT_BY_PAYMENT_TYPE` — прямая скидка при оплате картой Плюса.  * `PERCENT_DISCOUNT` — прямая скидка в процентах.  * `DCO_EXTRA_DISCOUNT` — дополнительная скидка, необходимая для расчета субсидии от Маркета.  * `EMPTY_PROMO` — скрытые промокоды.  * `BLOCKING_PROMO` — блокирующее промо.  * `UNKNOWN` — неизвестный тип.  Устаревшие типы:  * `GENERIC_BUNDLE`.  * `MARKET_DEAL`.  * `MARKET_PRIME`.  * `MARKET_COIN`.  * `BERU_PLUS`.  * `PRICE_DROP_AS_YOU_SHOP`.  * `SECRET_SALE`. 
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum OrderPromoType {
    #[serde(rename = "DIRECT_DISCOUNT")]
    DirectDiscount,
    #[serde(rename = "BLUE_SET")]
    BlueSet,
    #[serde(rename = "BLUE_FLASH")]
    BlueFlash,
    #[serde(rename = "GENERIC_BUNDLE")]
    GenericBundle,
    #[serde(rename = "MARKET_COUPON")]
    MarketCoupon,
    #[serde(rename = "MARKET_PROMOCODE")]
    MarketPromocode,
    #[serde(rename = "MARKET_DEAL")]
    MarketDeal,
    #[serde(rename = "MARKET_BLUE")]
    MarketBlue,
    #[serde(rename = "MARKET_PRIME")]
    MarketPrime,
    #[serde(rename = "YANDEX_PLUS")]
    YandexPlus,
    #[serde(rename = "BERU_PLUS")]
    BeruPlus,
    #[serde(rename = "MARKET_COIN")]
    MarketCoin,
    #[serde(rename = "YANDEX_EMPLOYEE")]
    YandexEmployee,
    #[serde(rename = "LIMITED_FREE_DELIVERY_PROMO")]
    LimitedFreeDeliveryPromo,
    #[serde(rename = "FREE_DELIVERY_THRESHOLD")]
    FreeDeliveryThreshold,
    #[serde(rename = "MULTICART_DISCOUNT")]
    MulticartDiscount,
    #[serde(rename = "PRICE_DROP_AS_YOU_SHOP")]
    PriceDropAsYouShop,
    #[serde(rename = "FREE_DELIVERY_FOR_LDI")]
    FreeDeliveryForLdi,
    #[serde(rename = "FREE_DELIVERY_FOR_LSC")]
    FreeDeliveryForLsc,
    #[serde(rename = "SECRET_SALE")]
    SecretSale,
    #[serde(rename = "FREE_PICKUP")]
    FreePickup,
    #[serde(rename = "CHEAPEST_AS_GIFT")]
    CheapestAsGift,
    #[serde(rename = "CASHBACK")]
    Cashback,
    #[serde(rename = "SUPPLIER_MULTICART_DISCOUNT")]
    SupplierMulticartDiscount,
    #[serde(rename = "SPREAD_DISCOUNT_COUNT")]
    SpreadDiscountCount,
    #[serde(rename = "SPREAD_DISCOUNT_RECEIPT")]
    SpreadDiscountReceipt,
    #[serde(rename = "ANNOUNCEMENT_PROMO")]
    AnnouncementPromo,
    #[serde(rename = "DISCOUNT_BY_PAYMENT_TYPE")]
    DiscountByPaymentType,
    #[serde(rename = "PERCENT_DISCOUNT")]
    PercentDiscount,
    #[serde(rename = "DCO_EXTRA_DISCOUNT")]
    DcoExtraDiscount,
    #[serde(rename = "EMPTY_PROMO")]
    EmptyPromo,
    #[serde(rename = "BLOCKING_PROMO")]
    BlockingPromo,
    #[serde(rename = "UNKNOWN")]
    Unknown,
}

impl std::fmt::Display for OrderPromoType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            OrderPromoType::DirectDiscount => write!(f, "DIRECT_DISCOUNT"),
            OrderPromoType::BlueSet => write!(f, "BLUE_SET"),
            OrderPromoType::BlueFlash => write!(f, "BLUE_FLASH"),
            OrderPromoType::GenericBundle => write!(f, "GENERIC_BUNDLE"),
            OrderPromoType::MarketCoupon => write!(f, "MARKET_COUPON"),
            OrderPromoType::MarketPromocode => write!(f, "MARKET_PROMOCODE"),
            OrderPromoType::MarketDeal => write!(f, "MARKET_DEAL"),
            OrderPromoType::MarketBlue => write!(f, "MARKET_BLUE"),
            OrderPromoType::MarketPrime => write!(f, "MARKET_PRIME"),
            OrderPromoType::YandexPlus => write!(f, "YANDEX_PLUS"),
            OrderPromoType::BeruPlus => write!(f, "BERU_PLUS"),
            OrderPromoType::MarketCoin => write!(f, "MARKET_COIN"),
            OrderPromoType::YandexEmployee => write!(f, "YANDEX_EMPLOYEE"),
            OrderPromoType::LimitedFreeDeliveryPromo => write!(f, "LIMITED_FREE_DELIVERY_PROMO"),
            OrderPromoType::FreeDeliveryThreshold => write!(f, "FREE_DELIVERY_THRESHOLD"),
            OrderPromoType::MulticartDiscount => write!(f, "MULTICART_DISCOUNT"),
            OrderPromoType::PriceDropAsYouShop => write!(f, "PRICE_DROP_AS_YOU_SHOP"),
            OrderPromoType::FreeDeliveryForLdi => write!(f, "FREE_DELIVERY_FOR_LDI"),
            OrderPromoType::FreeDeliveryForLsc => write!(f, "FREE_DELIVERY_FOR_LSC"),
            OrderPromoType::SecretSale => write!(f, "SECRET_SALE"),
            OrderPromoType::FreePickup => write!(f, "FREE_PICKUP"),
            OrderPromoType::CheapestAsGift => write!(f, "CHEAPEST_AS_GIFT"),
            OrderPromoType::Cashback => write!(f, "CASHBACK"),
            OrderPromoType::SupplierMulticartDiscount => write!(f, "SUPPLIER_MULTICART_DISCOUNT"),
            OrderPromoType::SpreadDiscountCount => write!(f, "SPREAD_DISCOUNT_COUNT"),
            OrderPromoType::SpreadDiscountReceipt => write!(f, "SPREAD_DISCOUNT_RECEIPT"),
            OrderPromoType::AnnouncementPromo => write!(f, "ANNOUNCEMENT_PROMO"),
            OrderPromoType::DiscountByPaymentType => write!(f, "DISCOUNT_BY_PAYMENT_TYPE"),
            OrderPromoType::PercentDiscount => write!(f, "PERCENT_DISCOUNT"),
            OrderPromoType::DcoExtraDiscount => write!(f, "DCO_EXTRA_DISCOUNT"),
            OrderPromoType::EmptyPromo => write!(f, "EMPTY_PROMO"),
            OrderPromoType::BlockingPromo => write!(f, "BLOCKING_PROMO"),
            OrderPromoType::Unknown => write!(f, "UNKNOWN"),
        }
    }
}

impl std::str::FromStr for OrderPromoType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "DIRECT_DISCOUNT" => std::result::Result::Ok(OrderPromoType::DirectDiscount),
            "BLUE_SET" => std::result::Result::Ok(OrderPromoType::BlueSet),
            "BLUE_FLASH" => std::result::Result::Ok(OrderPromoType::BlueFlash),
            "GENERIC_BUNDLE" => std::result::Result::Ok(OrderPromoType::GenericBundle),
            "MARKET_COUPON" => std::result::Result::Ok(OrderPromoType::MarketCoupon),
            "MARKET_PROMOCODE" => std::result::Result::Ok(OrderPromoType::MarketPromocode),
            "MARKET_DEAL" => std::result::Result::Ok(OrderPromoType::MarketDeal),
            "MARKET_BLUE" => std::result::Result::Ok(OrderPromoType::MarketBlue),
            "MARKET_PRIME" => std::result::Result::Ok(OrderPromoType::MarketPrime),
            "YANDEX_PLUS" => std::result::Result::Ok(OrderPromoType::YandexPlus),
            "BERU_PLUS" => std::result::Result::Ok(OrderPromoType::BeruPlus),
            "MARKET_COIN" => std::result::Result::Ok(OrderPromoType::MarketCoin),
            "YANDEX_EMPLOYEE" => std::result::Result::Ok(OrderPromoType::YandexEmployee),
            "LIMITED_FREE_DELIVERY_PROMO" => std::result::Result::Ok(OrderPromoType::LimitedFreeDeliveryPromo),
            "FREE_DELIVERY_THRESHOLD" => std::result::Result::Ok(OrderPromoType::FreeDeliveryThreshold),
            "MULTICART_DISCOUNT" => std::result::Result::Ok(OrderPromoType::MulticartDiscount),
            "PRICE_DROP_AS_YOU_SHOP" => std::result::Result::Ok(OrderPromoType::PriceDropAsYouShop),
            "FREE_DELIVERY_FOR_LDI" => std::result::Result::Ok(OrderPromoType::FreeDeliveryForLdi),
            "FREE_DELIVERY_FOR_LSC" => std::result::Result::Ok(OrderPromoType::FreeDeliveryForLsc),
            "SECRET_SALE" => std::result::Result::Ok(OrderPromoType::SecretSale),
            "FREE_PICKUP" => std::result::Result::Ok(OrderPromoType::FreePickup),
            "CHEAPEST_AS_GIFT" => std::result::Result::Ok(OrderPromoType::CheapestAsGift),
            "CASHBACK" => std::result::Result::Ok(OrderPromoType::Cashback),
            "SUPPLIER_MULTICART_DISCOUNT" => std::result::Result::Ok(OrderPromoType::SupplierMulticartDiscount),
            "SPREAD_DISCOUNT_COUNT" => std::result::Result::Ok(OrderPromoType::SpreadDiscountCount),
            "SPREAD_DISCOUNT_RECEIPT" => std::result::Result::Ok(OrderPromoType::SpreadDiscountReceipt),
            "ANNOUNCEMENT_PROMO" => std::result::Result::Ok(OrderPromoType::AnnouncementPromo),
            "DISCOUNT_BY_PAYMENT_TYPE" => std::result::Result::Ok(OrderPromoType::DiscountByPaymentType),
            "PERCENT_DISCOUNT" => std::result::Result::Ok(OrderPromoType::PercentDiscount),
            "DCO_EXTRA_DISCOUNT" => std::result::Result::Ok(OrderPromoType::DcoExtraDiscount),
            "EMPTY_PROMO" => std::result::Result::Ok(OrderPromoType::EmptyPromo),
            "BLOCKING_PROMO" => std::result::Result::Ok(OrderPromoType::BlockingPromo),
            "UNKNOWN" => std::result::Result::Ok(OrderPromoType::Unknown),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Список посылок.  В параметре может указываться несколько посылок. 
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct OrderShipmentDto {
    /// Идентификатор посылки, присвоенный Маркетом.
    #[serde(rename = "id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,

    /// Формат даты: `ДД-ММ-ГГГГ`. 
    #[serde(rename = "shipmentDate")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub shipment_date: Option<String>,

    /// **Только для модели Экспресс**  Время, к которому магазин должен упаковать заказ и перевести его в статус `READY_TO_SHIP`. После смены статуса за заказом приедет курьер.  Поле может появиться не сразу. Запрашивайте информацию о заказе в течении 5–10 минут, пока оно не вернется.  Формат времени: 24-часовой, `ЧЧ:ММ`.  Если заказ сделан организацией, параметр не возвращается до согласования даты доставки. 
    #[serde(rename = "shipmentTime")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub shipment_time: Option<String>,

    /// **Только для модели DBS**  Информация для отслеживания перемещений посылки. 
    #[serde(rename = "tracks")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub tracks: Option<swagger::Nullable<Vec<models::OrderTrackDto>>>,

    /// Список грузовых мест.
    #[serde(rename = "boxes")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub boxes: Option<swagger::Nullable<Vec<models::OrderParcelBoxDto>>>,

}


impl OrderShipmentDto {
    #[allow(clippy::new_without_default)]
    pub fn new() -> OrderShipmentDto {
        OrderShipmentDto {
            id: None,
            shipment_date: None,
            shipment_time: None,
            tracks: None,
            boxes: None,
        }
    }
}

/// Converts the OrderShipmentDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for OrderShipmentDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.id.as_ref().map(|id| {
                [
                    "id".to_string(),
                    id.to_string(),
                ].join(",")
            }),


            self.shipment_date.as_ref().map(|shipment_date| {
                [
                    "shipmentDate".to_string(),
                    shipment_date.to_string(),
                ].join(",")
            }),


            self.shipment_time.as_ref().map(|shipment_time| {
                [
                    "shipmentTime".to_string(),
                    shipment_time.to_string(),
                ].join(",")
            }),

            // Skipping tracks in query parameter serialization

            // Skipping boxes in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a OrderShipmentDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for OrderShipmentDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<i64>,
            pub shipment_date: Vec<String>,
            pub shipment_time: Vec<String>,
            pub tracks: Vec<Vec<models::OrderTrackDto>>,
            pub boxes: Vec<Vec<models::OrderParcelBoxDto>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing OrderShipmentDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "shipmentDate" => intermediate_rep.shipment_date.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "shipmentTime" => intermediate_rep.shipment_time.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "tracks" => return std::result::Result::Err("Parsing a container in this style is not supported in OrderShipmentDto".to_string()),
                    "boxes" => return std::result::Result::Err("Parsing a container in this style is not supported in OrderShipmentDto".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing OrderShipmentDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(OrderShipmentDto {
            id: intermediate_rep.id.into_iter().next(),
            shipment_date: intermediate_rep.shipment_date.into_iter().next(),
            shipment_time: intermediate_rep.shipment_time.into_iter().next(),
            tracks: std::result::Result::Err("Nullable types not supported in OrderShipmentDto".to_string())?,
            boxes: std::result::Result::Err("Nullable types not supported in OrderShipmentDto".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<OrderShipmentDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<OrderShipmentDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<OrderShipmentDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for OrderShipmentDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<OrderShipmentDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <OrderShipmentDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into OrderShipmentDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Информация по заказу.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct OrderStateDto {
    /// Идентификатор заказа.
    #[serde(rename = "id")]
    pub id: i64,

    #[serde(rename = "status")]
    pub status: models::OrderStatusType,

    #[serde(rename = "substatus")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub substatus: Option<models::OrderSubstatusType>,

}


impl OrderStateDto {
    #[allow(clippy::new_without_default)]
    pub fn new(id: i64, status: models::OrderStatusType, ) -> OrderStateDto {
        OrderStateDto {
            id,
            status,
            substatus: None,
        }
    }
}

/// Converts the OrderStateDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for OrderStateDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            Some("id".to_string()),
            Some(self.id.to_string()),

            // Skipping status in query parameter serialization

            // Skipping substatus in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a OrderStateDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for OrderStateDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<i64>,
            pub status: Vec<models::OrderStatusType>,
            pub substatus: Vec<models::OrderSubstatusType>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing OrderStateDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(<models::OrderStatusType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "substatus" => intermediate_rep.substatus.push(<models::OrderSubstatusType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing OrderStateDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(OrderStateDto {
            id: intermediate_rep.id.into_iter().next().ok_or_else(|| "id missing in OrderStateDto".to_string())?,
            status: intermediate_rep.status.into_iter().next().ok_or_else(|| "status missing in OrderStateDto".to_string())?,
            substatus: intermediate_rep.substatus.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<OrderStateDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<OrderStateDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<OrderStateDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for OrderStateDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<OrderStateDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <OrderStateDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into OrderStateDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Текущий статус заказа:  * `CANCELLED_BEFORE_PROCESSING` — заказ отменен до начала его обработки.  * `CANCELLED_IN_DELIVERY` — заказ отменен во время его доставки.  * `CANCELLED_IN_PROCESSING` — заказ отменен во время его обработки.  * `DELIVERY` — заказ передан службе доставки.  * `DELIVERED` — заказ доставлен.  * `PARTIALLY_DELIVERED` — заказ частично доставлен.  * `PARTIALLY_RETURNED` — заказ частично возвращен покупателем.  * `PENDING` — заказ ожидает подтверждения.  * `PICKUP` — заказ доставлен в пункт выдачи.  * `PROCESSING` — заказ в обработке.  * `RESERVED` — товар зарезервирован на складе.  * `RETURNED` — заказ полностью возвращен покупателем.  * `UNKNOWN` — неизвестный статус заказа.  * `UNPAID` — заказ от юридического лица ожидает оплаты.  * `LOST` — заказ утерян. 
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum OrderStatsStatusType {
    #[serde(rename = "CANCELLED_BEFORE_PROCESSING")]
    CancelledBeforeProcessing,
    #[serde(rename = "CANCELLED_IN_DELIVERY")]
    CancelledInDelivery,
    #[serde(rename = "CANCELLED_IN_PROCESSING")]
    CancelledInProcessing,
    #[serde(rename = "DELIVERY")]
    Delivery,
    #[serde(rename = "DELIVERED")]
    Delivered,
    #[serde(rename = "PARTIALLY_DELIVERED")]
    PartiallyDelivered,
    #[serde(rename = "PARTIALLY_RETURNED")]
    PartiallyReturned,
    #[serde(rename = "PENDING")]
    Pending,
    #[serde(rename = "PICKUP")]
    Pickup,
    #[serde(rename = "PROCESSING")]
    Processing,
    #[serde(rename = "RESERVED")]
    Reserved,
    #[serde(rename = "RETURNED")]
    Returned,
    #[serde(rename = "UNKNOWN")]
    Unknown,
    #[serde(rename = "UNPAID")]
    Unpaid,
    #[serde(rename = "LOST")]
    Lost,
}

impl std::fmt::Display for OrderStatsStatusType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            OrderStatsStatusType::CancelledBeforeProcessing => write!(f, "CANCELLED_BEFORE_PROCESSING"),
            OrderStatsStatusType::CancelledInDelivery => write!(f, "CANCELLED_IN_DELIVERY"),
            OrderStatsStatusType::CancelledInProcessing => write!(f, "CANCELLED_IN_PROCESSING"),
            OrderStatsStatusType::Delivery => write!(f, "DELIVERY"),
            OrderStatsStatusType::Delivered => write!(f, "DELIVERED"),
            OrderStatsStatusType::PartiallyDelivered => write!(f, "PARTIALLY_DELIVERED"),
            OrderStatsStatusType::PartiallyReturned => write!(f, "PARTIALLY_RETURNED"),
            OrderStatsStatusType::Pending => write!(f, "PENDING"),
            OrderStatsStatusType::Pickup => write!(f, "PICKUP"),
            OrderStatsStatusType::Processing => write!(f, "PROCESSING"),
            OrderStatsStatusType::Reserved => write!(f, "RESERVED"),
            OrderStatsStatusType::Returned => write!(f, "RETURNED"),
            OrderStatsStatusType::Unknown => write!(f, "UNKNOWN"),
            OrderStatsStatusType::Unpaid => write!(f, "UNPAID"),
            OrderStatsStatusType::Lost => write!(f, "LOST"),
        }
    }
}

impl std::str::FromStr for OrderStatsStatusType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "CANCELLED_BEFORE_PROCESSING" => std::result::Result::Ok(OrderStatsStatusType::CancelledBeforeProcessing),
            "CANCELLED_IN_DELIVERY" => std::result::Result::Ok(OrderStatsStatusType::CancelledInDelivery),
            "CANCELLED_IN_PROCESSING" => std::result::Result::Ok(OrderStatsStatusType::CancelledInProcessing),
            "DELIVERY" => std::result::Result::Ok(OrderStatsStatusType::Delivery),
            "DELIVERED" => std::result::Result::Ok(OrderStatsStatusType::Delivered),
            "PARTIALLY_DELIVERED" => std::result::Result::Ok(OrderStatsStatusType::PartiallyDelivered),
            "PARTIALLY_RETURNED" => std::result::Result::Ok(OrderStatsStatusType::PartiallyReturned),
            "PENDING" => std::result::Result::Ok(OrderStatsStatusType::Pending),
            "PICKUP" => std::result::Result::Ok(OrderStatsStatusType::Pickup),
            "PROCESSING" => std::result::Result::Ok(OrderStatsStatusType::Processing),
            "RESERVED" => std::result::Result::Ok(OrderStatsStatusType::Reserved),
            "RETURNED" => std::result::Result::Ok(OrderStatsStatusType::Returned),
            "UNKNOWN" => std::result::Result::Ok(OrderStatsStatusType::Unknown),
            "UNPAID" => std::result::Result::Ok(OrderStatsStatusType::Unpaid),
            "LOST" => std::result::Result::Ok(OrderStatsStatusType::Lost),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Диапазон дат доставки.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct OrderStatusChangeDeliveryDatesDto {
    /// **Только для модели DBS**  Фактическая дата доставки. <br><br> Когда передавать параметр `realDeliveryDate`:  * Не передавайте параметр, если:   * переводите заказ в любой статус, кроме `PICKUP` или `DELIVERED`;   * меняете статус заказа на `PICKUP` или `DELIVERED` в день доставки — будет указана дата выполнения запроса. * Передавайте дату доставки, если переводите заказ в статус `PICKUP` или `DELIVERED` не в день доставки. Нельзя указывать дату доставки в будущем.    {% note warning \"Индекс качества\" %}    Передача статуса после установленного срока снижает индекс качества. О сроках читайте [в Справке Маркета для продавцов](https://yandex.ru/support2/marketplace/ru/quality/tech#dbs).    {% endnote %}      
    #[serde(rename = "realDeliveryDate")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub real_delivery_date: Option<chrono::naive::NaiveDate>,

}


impl OrderStatusChangeDeliveryDatesDto {
    #[allow(clippy::new_without_default)]
    pub fn new() -> OrderStatusChangeDeliveryDatesDto {
        OrderStatusChangeDeliveryDatesDto {
            real_delivery_date: None,
        }
    }
}

/// Converts the OrderStatusChangeDeliveryDatesDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for OrderStatusChangeDeliveryDatesDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping realDeliveryDate in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a OrderStatusChangeDeliveryDatesDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for OrderStatusChangeDeliveryDatesDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub real_delivery_date: Vec<chrono::naive::NaiveDate>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing OrderStatusChangeDeliveryDatesDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "realDeliveryDate" => intermediate_rep.real_delivery_date.push(<chrono::naive::NaiveDate as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing OrderStatusChangeDeliveryDatesDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(OrderStatusChangeDeliveryDatesDto {
            real_delivery_date: intermediate_rep.real_delivery_date.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<OrderStatusChangeDeliveryDatesDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<OrderStatusChangeDeliveryDatesDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<OrderStatusChangeDeliveryDatesDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for OrderStatusChangeDeliveryDatesDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<OrderStatusChangeDeliveryDatesDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <OrderStatusChangeDeliveryDatesDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into OrderStatusChangeDeliveryDatesDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Информация о доставке.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct OrderStatusChangeDeliveryDto {
    #[serde(rename = "dates")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub dates: Option<models::OrderStatusChangeDeliveryDatesDto>,

}


impl OrderStatusChangeDeliveryDto {
    #[allow(clippy::new_without_default)]
    pub fn new() -> OrderStatusChangeDeliveryDto {
        OrderStatusChangeDeliveryDto {
            dates: None,
        }
    }
}

/// Converts the OrderStatusChangeDeliveryDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for OrderStatusChangeDeliveryDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping dates in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a OrderStatusChangeDeliveryDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for OrderStatusChangeDeliveryDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub dates: Vec<models::OrderStatusChangeDeliveryDatesDto>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing OrderStatusChangeDeliveryDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "dates" => intermediate_rep.dates.push(<models::OrderStatusChangeDeliveryDatesDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing OrderStatusChangeDeliveryDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(OrderStatusChangeDeliveryDto {
            dates: intermediate_rep.dates.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<OrderStatusChangeDeliveryDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<OrderStatusChangeDeliveryDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<OrderStatusChangeDeliveryDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for OrderStatusChangeDeliveryDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<OrderStatusChangeDeliveryDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <OrderStatusChangeDeliveryDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into OrderStatusChangeDeliveryDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Заказ.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct OrderStatusChangeDto {
    #[serde(rename = "status")]
    pub status: models::OrderStatusType,

    #[serde(rename = "substatus")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub substatus: Option<models::OrderSubstatusType>,

    #[serde(rename = "delivery")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub delivery: Option<models::OrderStatusChangeDeliveryDto>,

}


impl OrderStatusChangeDto {
    #[allow(clippy::new_without_default)]
    pub fn new(status: models::OrderStatusType, ) -> OrderStatusChangeDto {
        OrderStatusChangeDto {
            status,
            substatus: None,
            delivery: None,
        }
    }
}

/// Converts the OrderStatusChangeDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for OrderStatusChangeDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping status in query parameter serialization

            // Skipping substatus in query parameter serialization

            // Skipping delivery in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a OrderStatusChangeDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for OrderStatusChangeDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub status: Vec<models::OrderStatusType>,
            pub substatus: Vec<models::OrderSubstatusType>,
            pub delivery: Vec<models::OrderStatusChangeDeliveryDto>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing OrderStatusChangeDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(<models::OrderStatusType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "substatus" => intermediate_rep.substatus.push(<models::OrderSubstatusType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "delivery" => intermediate_rep.delivery.push(<models::OrderStatusChangeDeliveryDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing OrderStatusChangeDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(OrderStatusChangeDto {
            status: intermediate_rep.status.into_iter().next().ok_or_else(|| "status missing in OrderStatusChangeDto".to_string())?,
            substatus: intermediate_rep.substatus.into_iter().next(),
            delivery: intermediate_rep.delivery.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<OrderStatusChangeDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<OrderStatusChangeDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<OrderStatusChangeDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for OrderStatusChangeDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<OrderStatusChangeDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <OrderStatusChangeDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into OrderStatusChangeDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Статус заказа:  * `CANCELLED` — отменен.  * `DELIVERED` — получен покупателем.  * `DELIVERY` — передан в службу доставки.  * `PICKUP` — доставлен в пункт самовывоза.  * `PROCESSING` — находится в обработке.  * `PENDING` — ожидает обработки со стороны продавца.  * `UNPAID` — оформлен, но еще не оплачен (если выбрана оплата при оформлении).  * `PLACING` — оформляется, подготовка к резервированию.  * `RESERVED` — зарезервирован, но недооформлен.  * `PARTIALLY_RETURNED` — возвращен частично.  * `RETURNED` — возвращен полностью.  * `UNKNOWN` — неизвестный статус.  Также могут возвращаться другие значения. Обрабатывать их не требуется. 
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum OrderStatusType {
    #[serde(rename = "PLACING")]
    Placing,
    #[serde(rename = "RESERVED")]
    Reserved,
    #[serde(rename = "UNPAID")]
    Unpaid,
    #[serde(rename = "PROCESSING")]
    Processing,
    #[serde(rename = "DELIVERY")]
    Delivery,
    #[serde(rename = "PICKUP")]
    Pickup,
    #[serde(rename = "DELIVERED")]
    Delivered,
    #[serde(rename = "CANCELLED")]
    Cancelled,
    #[serde(rename = "PENDING")]
    Pending,
    #[serde(rename = "PARTIALLY_RETURNED")]
    PartiallyReturned,
    #[serde(rename = "RETURNED")]
    Returned,
    #[serde(rename = "UNKNOWN")]
    Unknown,
}

impl std::fmt::Display for OrderStatusType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            OrderStatusType::Placing => write!(f, "PLACING"),
            OrderStatusType::Reserved => write!(f, "RESERVED"),
            OrderStatusType::Unpaid => write!(f, "UNPAID"),
            OrderStatusType::Processing => write!(f, "PROCESSING"),
            OrderStatusType::Delivery => write!(f, "DELIVERY"),
            OrderStatusType::Pickup => write!(f, "PICKUP"),
            OrderStatusType::Delivered => write!(f, "DELIVERED"),
            OrderStatusType::Cancelled => write!(f, "CANCELLED"),
            OrderStatusType::Pending => write!(f, "PENDING"),
            OrderStatusType::PartiallyReturned => write!(f, "PARTIALLY_RETURNED"),
            OrderStatusType::Returned => write!(f, "RETURNED"),
            OrderStatusType::Unknown => write!(f, "UNKNOWN"),
        }
    }
}

impl std::str::FromStr for OrderStatusType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "PLACING" => std::result::Result::Ok(OrderStatusType::Placing),
            "RESERVED" => std::result::Result::Ok(OrderStatusType::Reserved),
            "UNPAID" => std::result::Result::Ok(OrderStatusType::Unpaid),
            "PROCESSING" => std::result::Result::Ok(OrderStatusType::Processing),
            "DELIVERY" => std::result::Result::Ok(OrderStatusType::Delivery),
            "PICKUP" => std::result::Result::Ok(OrderStatusType::Pickup),
            "DELIVERED" => std::result::Result::Ok(OrderStatusType::Delivered),
            "CANCELLED" => std::result::Result::Ok(OrderStatusType::Cancelled),
            "PENDING" => std::result::Result::Ok(OrderStatusType::Pending),
            "PARTIALLY_RETURNED" => std::result::Result::Ok(OrderStatusType::PartiallyReturned),
            "RETURNED" => std::result::Result::Ok(OrderStatusType::Returned),
            "UNKNOWN" => std::result::Result::Ok(OrderStatusType::Unknown),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Общее вознаграждение партнеру за DBS-доставку и все скидки на товар:  * по промокодам, купонам и акциям; * по баллам Плюса; * по доставке (DBS).  Передается в валюте заказа. 
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct OrderSubsidyDto {
    #[serde(rename = "type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub r#type: Option<models::OrderSubsidyType>,

    /// Сумма субсидии.
    #[serde(rename = "amount")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub amount: Option<f64>,

}


impl OrderSubsidyDto {
    #[allow(clippy::new_without_default)]
    pub fn new() -> OrderSubsidyDto {
        OrderSubsidyDto {
            r#type: None,
            amount: None,
        }
    }
}

/// Converts the OrderSubsidyDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for OrderSubsidyDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping type in query parameter serialization


            self.amount.as_ref().map(|amount| {
                [
                    "amount".to_string(),
                    amount.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a OrderSubsidyDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for OrderSubsidyDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub r#type: Vec<models::OrderSubsidyType>,
            pub amount: Vec<f64>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing OrderSubsidyDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r#type.push(<models::OrderSubsidyType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "amount" => intermediate_rep.amount.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing OrderSubsidyDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(OrderSubsidyDto {
            r#type: intermediate_rep.r#type.into_iter().next(),
            amount: intermediate_rep.amount.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<OrderSubsidyDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<OrderSubsidyDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<OrderSubsidyDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for OrderSubsidyDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<OrderSubsidyDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <OrderSubsidyDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into OrderSubsidyDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Тип субсидии:  * `YANDEX_CASHBACK` — скидка по подписке Яндекс Плюс.  * `SUBSIDY` — скидка Маркета (по акциям, промокодам, купонам и т. д.)  * `DELIVERY` — скидка за доставку (DBS). 
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum OrderSubsidyType {
    #[serde(rename = "YANDEX_CASHBACK")]
    YandexCashback,
    #[serde(rename = "SUBSIDY")]
    Subsidy,
    #[serde(rename = "DELIVERY")]
    Delivery,
}

impl std::fmt::Display for OrderSubsidyType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            OrderSubsidyType::YandexCashback => write!(f, "YANDEX_CASHBACK"),
            OrderSubsidyType::Subsidy => write!(f, "SUBSIDY"),
            OrderSubsidyType::Delivery => write!(f, "DELIVERY"),
        }
    }
}

impl std::str::FromStr for OrderSubsidyType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "YANDEX_CASHBACK" => std::result::Result::Ok(OrderSubsidyType::YandexCashback),
            "SUBSIDY" => std::result::Result::Ok(OrderSubsidyType::Subsidy),
            "DELIVERY" => std::result::Result::Ok(OrderSubsidyType::Delivery),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Этап обработки заказа (если он имеет статус `PROCESSING`) или причина отмены заказа (если он имеет статус `CANCELLED`).  * Значения для заказа в статусе `PROCESSING`:      * `STARTED` — заказ подтвержден, его можно начать обрабатывать.      * `READY_TO_SHIP` — заказ собран и готов к отправке.  * Значения для заказа в статусе `CANCELLED`:      * `PROCESSING_EXPIRED` — значение более не используется.      * `REPLACING_ORDER` — покупатель решил заменить товар другим по собственной инициативе.      * `RESERVATION_EXPIRED` — покупатель не завершил оформление зарезервированного заказа в течение 10 минут.      * `SHOP_FAILED` — магазин не может выполнить заказ.      * `USER_CHANGED_MIND` — покупатель отменил заказ по личным причинам.      * `USER_NOT_PAID` — покупатель не оплатил заказ (для типа оплаты `PREPAID`) в течение 30 минут.      * `USER_REFUSED_DELIVERY` — покупателя не устроили условия доставки.      * `USER_REFUSED_PRODUCT` — покупателю не подошел товар.      * `USER_REFUSED_QUALITY` — покупателя не устроило качество товара.      * `USER_UNREACHABLE` — не удалось связаться с покупателем. Для отмены с этой причиной необходимо выполнить условия:        * не менее 3 звонков с 8 до 21 в часовом поясе покупателя;       * перерыв между первым и третьим звонком не менее 90 минут;       * соединение не короче 5 секунд.        Если хотя бы одно из этих условий не выполнено (кроме случая, когда номер недоступен), отменить заказ не получится. Вернется ответ с кодом ошибки 400.  * `TECHNICAL_ERROR` — техническая ошибка на стороне Маркета. Обратитесь в поддержку.  Также могут возвращаться другие значения. Обрабатывать их не требуется. 
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum OrderSubstatusType {
    #[serde(rename = "RESERVATION_EXPIRED")]
    ReservationExpired,
    #[serde(rename = "USER_NOT_PAID")]
    UserNotPaid,
    #[serde(rename = "USER_UNREACHABLE")]
    UserUnreachable,
    #[serde(rename = "USER_CHANGED_MIND")]
    UserChangedMind,
    #[serde(rename = "USER_REFUSED_DELIVERY")]
    UserRefusedDelivery,
    #[serde(rename = "USER_REFUSED_PRODUCT")]
    UserRefusedProduct,
    #[serde(rename = "SHOP_FAILED")]
    ShopFailed,
    #[serde(rename = "USER_REFUSED_QUALITY")]
    UserRefusedQuality,
    #[serde(rename = "REPLACING_ORDER")]
    ReplacingOrder,
    #[serde(rename = "PROCESSING_EXPIRED")]
    ProcessingExpired,
    #[serde(rename = "PENDING_EXPIRED")]
    PendingExpired,
    #[serde(rename = "SHOP_PENDING_CANCELLED")]
    ShopPendingCancelled,
    #[serde(rename = "PENDING_CANCELLED")]
    PendingCancelled,
    #[serde(rename = "USER_FRAUD")]
    UserFraud,
    #[serde(rename = "RESERVATION_FAILED")]
    ReservationFailed,
    #[serde(rename = "USER_PLACED_OTHER_ORDER")]
    UserPlacedOtherOrder,
    #[serde(rename = "USER_BOUGHT_CHEAPER")]
    UserBoughtCheaper,
    #[serde(rename = "MISSING_ITEM")]
    MissingItem,
    #[serde(rename = "BROKEN_ITEM")]
    BrokenItem,
    #[serde(rename = "WRONG_ITEM")]
    WrongItem,
    #[serde(rename = "PICKUP_EXPIRED")]
    PickupExpired,
    #[serde(rename = "DELIVERY_PROBLEMS")]
    DeliveryProblems,
    #[serde(rename = "LATE_CONTACT")]
    LateContact,
    #[serde(rename = "CUSTOM")]
    Custom,
    #[serde(rename = "DELIVERY_SERVICE_FAILED")]
    DeliveryServiceFailed,
    #[serde(rename = "WAREHOUSE_FAILED_TO_SHIP")]
    WarehouseFailedToShip,
    #[serde(rename = "DELIVERY_SERIVCE_UNDELIVERED")]
    DeliverySerivceUndelivered,
    #[serde(rename = "DELIVERY_SERVICE_UNDELIVERED")]
    DeliveryServiceUndelivered,
    #[serde(rename = "PREORDER")]
    Preorder,
    #[serde(rename = "AWAIT_CONFIRMATION")]
    AwaitConfirmation,
    #[serde(rename = "STARTED")]
    Started,
    #[serde(rename = "PACKAGING")]
    Packaging,
    #[serde(rename = "READY_TO_SHIP")]
    ReadyToShip,
    #[serde(rename = "SHIPPED")]
    Shipped,
    #[serde(rename = "ASYNC_PROCESSING")]
    AsyncProcessing,
    #[serde(rename = "USER_REFUSED_TO_PROVIDE_PERSONAL_DATA")]
    UserRefusedToProvidePersonalData,
    #[serde(rename = "WAITING_USER_INPUT")]
    WaitingUserInput,
    #[serde(rename = "WAITING_BANK_DECISION")]
    WaitingBankDecision,
    #[serde(rename = "BANK_REJECT_CREDIT_OFFER")]
    BankRejectCreditOffer,
    #[serde(rename = "CUSTOMER_REJECT_CREDIT_OFFER")]
    CustomerRejectCreditOffer,
    #[serde(rename = "CREDIT_OFFER_FAILED")]
    CreditOfferFailed,
    #[serde(rename = "AWAIT_DELIVERY_DATES_CONFIRMATION")]
    AwaitDeliveryDatesConfirmation,
    #[serde(rename = "SERVICE_FAULT")]
    ServiceFault,
    #[serde(rename = "DELIVERY_SERVICE_RECEIVED")]
    DeliveryServiceReceived,
    #[serde(rename = "USER_RECEIVED")]
    UserReceived,
    #[serde(rename = "WAITING_FOR_STOCKS")]
    WaitingForStocks,
    #[serde(rename = "AS_PART_OF_MULTI_ORDER")]
    AsPartOfMultiOrder,
    #[serde(rename = "READY_FOR_LAST_MILE")]
    ReadyForLastMile,
    #[serde(rename = "LAST_MILE_STARTED")]
    LastMileStarted,
    #[serde(rename = "ANTIFRAUD")]
    Antifraud,
    #[serde(rename = "DELIVERY_USER_NOT_RECEIVED")]
    DeliveryUserNotReceived,
    #[serde(rename = "DELIVERY_SERVICE_DELIVERED")]
    DeliveryServiceDelivered,
    #[serde(rename = "DELIVERED_USER_NOT_RECEIVED")]
    DeliveredUserNotReceived,
    #[serde(rename = "USER_WANTED_ANOTHER_PAYMENT_METHOD")]
    UserWantedAnotherPaymentMethod,
    #[serde(rename = "USER_RECEIVED_TECHNICAL_ERROR")]
    UserReceivedTechnicalError,
    #[serde(rename = "USER_FORGOT_TO_USE_BONUS")]
    UserForgotToUseBonus,
    #[serde(rename = "RECEIVED_ON_DISTRIBUTION_CENTER")]
    ReceivedOnDistributionCenter,
    #[serde(rename = "DELIVERY_SERVICE_NOT_RECEIVED")]
    DeliveryServiceNotReceived,
    #[serde(rename = "DELIVERY_SERVICE_LOST")]
    DeliveryServiceLost,
    #[serde(rename = "SHIPPED_TO_WRONG_DELIVERY_SERVICE")]
    ShippedToWrongDeliveryService,
    #[serde(rename = "DELIVERED_USER_RECEIVED")]
    DeliveredUserReceived,
    #[serde(rename = "WAITING_TINKOFF_DECISION")]
    WaitingTinkoffDecision,
    #[serde(rename = "COURIER_SEARCH")]
    CourierSearch,
    #[serde(rename = "COURIER_FOUND")]
    CourierFound,
    #[serde(rename = "COURIER_IN_TRANSIT_TO_SENDER")]
    CourierInTransitToSender,
    #[serde(rename = "COURIER_ARRIVED_TO_SENDER")]
    CourierArrivedToSender,
    #[serde(rename = "COURIER_RECEIVED")]
    CourierReceived,
    #[serde(rename = "COURIER_NOT_FOUND")]
    CourierNotFound,
    #[serde(rename = "COURIER_NOT_DELIVER_ORDER")]
    CourierNotDeliverOrder,
    #[serde(rename = "COURIER_RETURNS_ORDER")]
    CourierReturnsOrder,
    #[serde(rename = "COURIER_RETURNED_ORDER")]
    CourierReturnedOrder,
    #[serde(rename = "WAITING_USER_DELIVERY_INPUT")]
    WaitingUserDeliveryInput,
    #[serde(rename = "PICKUP_SERVICE_RECEIVED")]
    PickupServiceReceived,
    #[serde(rename = "PICKUP_USER_RECEIVED")]
    PickupUserReceived,
    #[serde(rename = "CANCELLED_COURIER_NOT_FOUND")]
    CancelledCourierNotFound,
    #[serde(rename = "COURIER_NOT_COME_FOR_ORDER")]
    CourierNotComeForOrder,
    #[serde(rename = "DELIVERY_NOT_MANAGED_REGION")]
    DeliveryNotManagedRegion,
    #[serde(rename = "INCOMPLETE_CONTACT_INFORMATION")]
    IncompleteContactInformation,
    #[serde(rename = "INCOMPLETE_MULTI_ORDER")]
    IncompleteMultiOrder,
    #[serde(rename = "INAPPROPRIATE_WEIGHT_SIZE")]
    InappropriateWeightSize,
    #[serde(rename = "TECHNICAL_ERROR")]
    TechnicalError,
    #[serde(rename = "SORTING_CENTER_LOST")]
    SortingCenterLost,
    #[serde(rename = "COURIER_SEARCH_NOT_STARTED")]
    CourierSearchNotStarted,
    #[serde(rename = "LOST")]
    Lost,
    #[serde(rename = "AWAIT_PAYMENT")]
    AwaitPayment,
    #[serde(rename = "AWAIT_LAVKA_RESERVATION")]
    AwaitLavkaReservation,
    #[serde(rename = "USER_WANTS_TO_CHANGE_ADDRESS")]
    UserWantsToChangeAddress,
    #[serde(rename = "FULL_NOT_RANSOM")]
    FullNotRansom,
    #[serde(rename = "PRESCRIPTION_MISMATCH")]
    PrescriptionMismatch,
    #[serde(rename = "DROPOFF_LOST")]
    DropoffLost,
    #[serde(rename = "DROPOFF_CLOSED")]
    DropoffClosed,
    #[serde(rename = "DELIVERY_TO_STORE_STARTED")]
    DeliveryToStoreStarted,
    #[serde(rename = "USER_WANTS_TO_CHANGE_DELIVERY_DATE")]
    UserWantsToChangeDeliveryDate,
    #[serde(rename = "WRONG_ITEM_DELIVERED")]
    WrongItemDelivered,
    #[serde(rename = "DAMAGED_BOX")]
    DamagedBox,
    #[serde(rename = "AWAIT_DELIVERY_DATES")]
    AwaitDeliveryDates,
    #[serde(rename = "LAST_MILE_COURIER_SEARCH")]
    LastMileCourierSearch,
    #[serde(rename = "PICKUP_POINT_CLOSED")]
    PickupPointClosed,
    #[serde(rename = "LEGAL_INFO_CHANGED")]
    LegalInfoChanged,
    #[serde(rename = "USER_HAS_NO_TIME_TO_PICKUP_ORDER")]
    UserHasNoTimeToPickupOrder,
    #[serde(rename = "DELIVERY_CUSTOMS_ARRIVED")]
    DeliveryCustomsArrived,
    #[serde(rename = "DELIVERY_CUSTOMS_CLEARED")]
    DeliveryCustomsCleared,
    #[serde(rename = "FIRST_MILE_DELIVERY_SERVICE_RECEIVED")]
    FirstMileDeliveryServiceReceived,
    #[serde(rename = "AWAIT_AUTO_DELIVERY_DATES")]
    AwaitAutoDeliveryDates,
    #[serde(rename = "AWAIT_USER_PERSONAL_DATA")]
    AwaitUserPersonalData,
    #[serde(rename = "NO_PERSONAL_DATA_EXPIRED")]
    NoPersonalDataExpired,
    #[serde(rename = "CUSTOMS_PROBLEMS")]
    CustomsProblems,
    #[serde(rename = "AWAIT_CASHIER")]
    AwaitCashier,
    #[serde(rename = "WAITING_POSTPAID_BUDGET_RESERVATION")]
    WaitingPostpaidBudgetReservation,
    #[serde(rename = "AWAIT_SERVICEABLE_CONFIRMATION")]
    AwaitServiceableConfirmation,
    #[serde(rename = "POSTPAID_BUDGET_RESERVATION_FAILED")]
    PostpaidBudgetReservationFailed,
    #[serde(rename = "AWAIT_CUSTOM_PRICE_CONFIRMATION")]
    AwaitCustomPriceConfirmation,
    #[serde(rename = "READY_FOR_PICKUP")]
    ReadyForPickup,
    #[serde(rename = "UNKNOWN")]
    Unknown,
}

impl std::fmt::Display for OrderSubstatusType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            OrderSubstatusType::ReservationExpired => write!(f, "RESERVATION_EXPIRED"),
            OrderSubstatusType::UserNotPaid => write!(f, "USER_NOT_PAID"),
            OrderSubstatusType::UserUnreachable => write!(f, "USER_UNREACHABLE"),
            OrderSubstatusType::UserChangedMind => write!(f, "USER_CHANGED_MIND"),
            OrderSubstatusType::UserRefusedDelivery => write!(f, "USER_REFUSED_DELIVERY"),
            OrderSubstatusType::UserRefusedProduct => write!(f, "USER_REFUSED_PRODUCT"),
            OrderSubstatusType::ShopFailed => write!(f, "SHOP_FAILED"),
            OrderSubstatusType::UserRefusedQuality => write!(f, "USER_REFUSED_QUALITY"),
            OrderSubstatusType::ReplacingOrder => write!(f, "REPLACING_ORDER"),
            OrderSubstatusType::ProcessingExpired => write!(f, "PROCESSING_EXPIRED"),
            OrderSubstatusType::PendingExpired => write!(f, "PENDING_EXPIRED"),
            OrderSubstatusType::ShopPendingCancelled => write!(f, "SHOP_PENDING_CANCELLED"),
            OrderSubstatusType::PendingCancelled => write!(f, "PENDING_CANCELLED"),
            OrderSubstatusType::UserFraud => write!(f, "USER_FRAUD"),
            OrderSubstatusType::ReservationFailed => write!(f, "RESERVATION_FAILED"),
            OrderSubstatusType::UserPlacedOtherOrder => write!(f, "USER_PLACED_OTHER_ORDER"),
            OrderSubstatusType::UserBoughtCheaper => write!(f, "USER_BOUGHT_CHEAPER"),
            OrderSubstatusType::MissingItem => write!(f, "MISSING_ITEM"),
            OrderSubstatusType::BrokenItem => write!(f, "BROKEN_ITEM"),
            OrderSubstatusType::WrongItem => write!(f, "WRONG_ITEM"),
            OrderSubstatusType::PickupExpired => write!(f, "PICKUP_EXPIRED"),
            OrderSubstatusType::DeliveryProblems => write!(f, "DELIVERY_PROBLEMS"),
            OrderSubstatusType::LateContact => write!(f, "LATE_CONTACT"),
            OrderSubstatusType::Custom => write!(f, "CUSTOM"),
            OrderSubstatusType::DeliveryServiceFailed => write!(f, "DELIVERY_SERVICE_FAILED"),
            OrderSubstatusType::WarehouseFailedToShip => write!(f, "WAREHOUSE_FAILED_TO_SHIP"),
            OrderSubstatusType::DeliverySerivceUndelivered => write!(f, "DELIVERY_SERIVCE_UNDELIVERED"),
            OrderSubstatusType::DeliveryServiceUndelivered => write!(f, "DELIVERY_SERVICE_UNDELIVERED"),
            OrderSubstatusType::Preorder => write!(f, "PREORDER"),
            OrderSubstatusType::AwaitConfirmation => write!(f, "AWAIT_CONFIRMATION"),
            OrderSubstatusType::Started => write!(f, "STARTED"),
            OrderSubstatusType::Packaging => write!(f, "PACKAGING"),
            OrderSubstatusType::ReadyToShip => write!(f, "READY_TO_SHIP"),
            OrderSubstatusType::Shipped => write!(f, "SHIPPED"),
            OrderSubstatusType::AsyncProcessing => write!(f, "ASYNC_PROCESSING"),
            OrderSubstatusType::UserRefusedToProvidePersonalData => write!(f, "USER_REFUSED_TO_PROVIDE_PERSONAL_DATA"),
            OrderSubstatusType::WaitingUserInput => write!(f, "WAITING_USER_INPUT"),
            OrderSubstatusType::WaitingBankDecision => write!(f, "WAITING_BANK_DECISION"),
            OrderSubstatusType::BankRejectCreditOffer => write!(f, "BANK_REJECT_CREDIT_OFFER"),
            OrderSubstatusType::CustomerRejectCreditOffer => write!(f, "CUSTOMER_REJECT_CREDIT_OFFER"),
            OrderSubstatusType::CreditOfferFailed => write!(f, "CREDIT_OFFER_FAILED"),
            OrderSubstatusType::AwaitDeliveryDatesConfirmation => write!(f, "AWAIT_DELIVERY_DATES_CONFIRMATION"),
            OrderSubstatusType::ServiceFault => write!(f, "SERVICE_FAULT"),
            OrderSubstatusType::DeliveryServiceReceived => write!(f, "DELIVERY_SERVICE_RECEIVED"),
            OrderSubstatusType::UserReceived => write!(f, "USER_RECEIVED"),
            OrderSubstatusType::WaitingForStocks => write!(f, "WAITING_FOR_STOCKS"),
            OrderSubstatusType::AsPartOfMultiOrder => write!(f, "AS_PART_OF_MULTI_ORDER"),
            OrderSubstatusType::ReadyForLastMile => write!(f, "READY_FOR_LAST_MILE"),
            OrderSubstatusType::LastMileStarted => write!(f, "LAST_MILE_STARTED"),
            OrderSubstatusType::Antifraud => write!(f, "ANTIFRAUD"),
            OrderSubstatusType::DeliveryUserNotReceived => write!(f, "DELIVERY_USER_NOT_RECEIVED"),
            OrderSubstatusType::DeliveryServiceDelivered => write!(f, "DELIVERY_SERVICE_DELIVERED"),
            OrderSubstatusType::DeliveredUserNotReceived => write!(f, "DELIVERED_USER_NOT_RECEIVED"),
            OrderSubstatusType::UserWantedAnotherPaymentMethod => write!(f, "USER_WANTED_ANOTHER_PAYMENT_METHOD"),
            OrderSubstatusType::UserReceivedTechnicalError => write!(f, "USER_RECEIVED_TECHNICAL_ERROR"),
            OrderSubstatusType::UserForgotToUseBonus => write!(f, "USER_FORGOT_TO_USE_BONUS"),
            OrderSubstatusType::ReceivedOnDistributionCenter => write!(f, "RECEIVED_ON_DISTRIBUTION_CENTER"),
            OrderSubstatusType::DeliveryServiceNotReceived => write!(f, "DELIVERY_SERVICE_NOT_RECEIVED"),
            OrderSubstatusType::DeliveryServiceLost => write!(f, "DELIVERY_SERVICE_LOST"),
            OrderSubstatusType::ShippedToWrongDeliveryService => write!(f, "SHIPPED_TO_WRONG_DELIVERY_SERVICE"),
            OrderSubstatusType::DeliveredUserReceived => write!(f, "DELIVERED_USER_RECEIVED"),
            OrderSubstatusType::WaitingTinkoffDecision => write!(f, "WAITING_TINKOFF_DECISION"),
            OrderSubstatusType::CourierSearch => write!(f, "COURIER_SEARCH"),
            OrderSubstatusType::CourierFound => write!(f, "COURIER_FOUND"),
            OrderSubstatusType::CourierInTransitToSender => write!(f, "COURIER_IN_TRANSIT_TO_SENDER"),
            OrderSubstatusType::CourierArrivedToSender => write!(f, "COURIER_ARRIVED_TO_SENDER"),
            OrderSubstatusType::CourierReceived => write!(f, "COURIER_RECEIVED"),
            OrderSubstatusType::CourierNotFound => write!(f, "COURIER_NOT_FOUND"),
            OrderSubstatusType::CourierNotDeliverOrder => write!(f, "COURIER_NOT_DELIVER_ORDER"),
            OrderSubstatusType::CourierReturnsOrder => write!(f, "COURIER_RETURNS_ORDER"),
            OrderSubstatusType::CourierReturnedOrder => write!(f, "COURIER_RETURNED_ORDER"),
            OrderSubstatusType::WaitingUserDeliveryInput => write!(f, "WAITING_USER_DELIVERY_INPUT"),
            OrderSubstatusType::PickupServiceReceived => write!(f, "PICKUP_SERVICE_RECEIVED"),
            OrderSubstatusType::PickupUserReceived => write!(f, "PICKUP_USER_RECEIVED"),
            OrderSubstatusType::CancelledCourierNotFound => write!(f, "CANCELLED_COURIER_NOT_FOUND"),
            OrderSubstatusType::CourierNotComeForOrder => write!(f, "COURIER_NOT_COME_FOR_ORDER"),
            OrderSubstatusType::DeliveryNotManagedRegion => write!(f, "DELIVERY_NOT_MANAGED_REGION"),
            OrderSubstatusType::IncompleteContactInformation => write!(f, "INCOMPLETE_CONTACT_INFORMATION"),
            OrderSubstatusType::IncompleteMultiOrder => write!(f, "INCOMPLETE_MULTI_ORDER"),
            OrderSubstatusType::InappropriateWeightSize => write!(f, "INAPPROPRIATE_WEIGHT_SIZE"),
            OrderSubstatusType::TechnicalError => write!(f, "TECHNICAL_ERROR"),
            OrderSubstatusType::SortingCenterLost => write!(f, "SORTING_CENTER_LOST"),
            OrderSubstatusType::CourierSearchNotStarted => write!(f, "COURIER_SEARCH_NOT_STARTED"),
            OrderSubstatusType::Lost => write!(f, "LOST"),
            OrderSubstatusType::AwaitPayment => write!(f, "AWAIT_PAYMENT"),
            OrderSubstatusType::AwaitLavkaReservation => write!(f, "AWAIT_LAVKA_RESERVATION"),
            OrderSubstatusType::UserWantsToChangeAddress => write!(f, "USER_WANTS_TO_CHANGE_ADDRESS"),
            OrderSubstatusType::FullNotRansom => write!(f, "FULL_NOT_RANSOM"),
            OrderSubstatusType::PrescriptionMismatch => write!(f, "PRESCRIPTION_MISMATCH"),
            OrderSubstatusType::DropoffLost => write!(f, "DROPOFF_LOST"),
            OrderSubstatusType::DropoffClosed => write!(f, "DROPOFF_CLOSED"),
            OrderSubstatusType::DeliveryToStoreStarted => write!(f, "DELIVERY_TO_STORE_STARTED"),
            OrderSubstatusType::UserWantsToChangeDeliveryDate => write!(f, "USER_WANTS_TO_CHANGE_DELIVERY_DATE"),
            OrderSubstatusType::WrongItemDelivered => write!(f, "WRONG_ITEM_DELIVERED"),
            OrderSubstatusType::DamagedBox => write!(f, "DAMAGED_BOX"),
            OrderSubstatusType::AwaitDeliveryDates => write!(f, "AWAIT_DELIVERY_DATES"),
            OrderSubstatusType::LastMileCourierSearch => write!(f, "LAST_MILE_COURIER_SEARCH"),
            OrderSubstatusType::PickupPointClosed => write!(f, "PICKUP_POINT_CLOSED"),
            OrderSubstatusType::LegalInfoChanged => write!(f, "LEGAL_INFO_CHANGED"),
            OrderSubstatusType::UserHasNoTimeToPickupOrder => write!(f, "USER_HAS_NO_TIME_TO_PICKUP_ORDER"),
            OrderSubstatusType::DeliveryCustomsArrived => write!(f, "DELIVERY_CUSTOMS_ARRIVED"),
            OrderSubstatusType::DeliveryCustomsCleared => write!(f, "DELIVERY_CUSTOMS_CLEARED"),
            OrderSubstatusType::FirstMileDeliveryServiceReceived => write!(f, "FIRST_MILE_DELIVERY_SERVICE_RECEIVED"),
            OrderSubstatusType::AwaitAutoDeliveryDates => write!(f, "AWAIT_AUTO_DELIVERY_DATES"),
            OrderSubstatusType::AwaitUserPersonalData => write!(f, "AWAIT_USER_PERSONAL_DATA"),
            OrderSubstatusType::NoPersonalDataExpired => write!(f, "NO_PERSONAL_DATA_EXPIRED"),
            OrderSubstatusType::CustomsProblems => write!(f, "CUSTOMS_PROBLEMS"),
            OrderSubstatusType::AwaitCashier => write!(f, "AWAIT_CASHIER"),
            OrderSubstatusType::WaitingPostpaidBudgetReservation => write!(f, "WAITING_POSTPAID_BUDGET_RESERVATION"),
            OrderSubstatusType::AwaitServiceableConfirmation => write!(f, "AWAIT_SERVICEABLE_CONFIRMATION"),
            OrderSubstatusType::PostpaidBudgetReservationFailed => write!(f, "POSTPAID_BUDGET_RESERVATION_FAILED"),
            OrderSubstatusType::AwaitCustomPriceConfirmation => write!(f, "AWAIT_CUSTOM_PRICE_CONFIRMATION"),
            OrderSubstatusType::ReadyForPickup => write!(f, "READY_FOR_PICKUP"),
            OrderSubstatusType::Unknown => write!(f, "UNKNOWN"),
        }
    }
}

impl std::str::FromStr for OrderSubstatusType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "RESERVATION_EXPIRED" => std::result::Result::Ok(OrderSubstatusType::ReservationExpired),
            "USER_NOT_PAID" => std::result::Result::Ok(OrderSubstatusType::UserNotPaid),
            "USER_UNREACHABLE" => std::result::Result::Ok(OrderSubstatusType::UserUnreachable),
            "USER_CHANGED_MIND" => std::result::Result::Ok(OrderSubstatusType::UserChangedMind),
            "USER_REFUSED_DELIVERY" => std::result::Result::Ok(OrderSubstatusType::UserRefusedDelivery),
            "USER_REFUSED_PRODUCT" => std::result::Result::Ok(OrderSubstatusType::UserRefusedProduct),
            "SHOP_FAILED" => std::result::Result::Ok(OrderSubstatusType::ShopFailed),
            "USER_REFUSED_QUALITY" => std::result::Result::Ok(OrderSubstatusType::UserRefusedQuality),
            "REPLACING_ORDER" => std::result::Result::Ok(OrderSubstatusType::ReplacingOrder),
            "PROCESSING_EXPIRED" => std::result::Result::Ok(OrderSubstatusType::ProcessingExpired),
            "PENDING_EXPIRED" => std::result::Result::Ok(OrderSubstatusType::PendingExpired),
            "SHOP_PENDING_CANCELLED" => std::result::Result::Ok(OrderSubstatusType::ShopPendingCancelled),
            "PENDING_CANCELLED" => std::result::Result::Ok(OrderSubstatusType::PendingCancelled),
            "USER_FRAUD" => std::result::Result::Ok(OrderSubstatusType::UserFraud),
            "RESERVATION_FAILED" => std::result::Result::Ok(OrderSubstatusType::ReservationFailed),
            "USER_PLACED_OTHER_ORDER" => std::result::Result::Ok(OrderSubstatusType::UserPlacedOtherOrder),
            "USER_BOUGHT_CHEAPER" => std::result::Result::Ok(OrderSubstatusType::UserBoughtCheaper),
            "MISSING_ITEM" => std::result::Result::Ok(OrderSubstatusType::MissingItem),
            "BROKEN_ITEM" => std::result::Result::Ok(OrderSubstatusType::BrokenItem),
            "WRONG_ITEM" => std::result::Result::Ok(OrderSubstatusType::WrongItem),
            "PICKUP_EXPIRED" => std::result::Result::Ok(OrderSubstatusType::PickupExpired),
            "DELIVERY_PROBLEMS" => std::result::Result::Ok(OrderSubstatusType::DeliveryProblems),
            "LATE_CONTACT" => std::result::Result::Ok(OrderSubstatusType::LateContact),
            "CUSTOM" => std::result::Result::Ok(OrderSubstatusType::Custom),
            "DELIVERY_SERVICE_FAILED" => std::result::Result::Ok(OrderSubstatusType::DeliveryServiceFailed),
            "WAREHOUSE_FAILED_TO_SHIP" => std::result::Result::Ok(OrderSubstatusType::WarehouseFailedToShip),
            "DELIVERY_SERIVCE_UNDELIVERED" => std::result::Result::Ok(OrderSubstatusType::DeliverySerivceUndelivered),
            "DELIVERY_SERVICE_UNDELIVERED" => std::result::Result::Ok(OrderSubstatusType::DeliveryServiceUndelivered),
            "PREORDER" => std::result::Result::Ok(OrderSubstatusType::Preorder),
            "AWAIT_CONFIRMATION" => std::result::Result::Ok(OrderSubstatusType::AwaitConfirmation),
            "STARTED" => std::result::Result::Ok(OrderSubstatusType::Started),
            "PACKAGING" => std::result::Result::Ok(OrderSubstatusType::Packaging),
            "READY_TO_SHIP" => std::result::Result::Ok(OrderSubstatusType::ReadyToShip),
            "SHIPPED" => std::result::Result::Ok(OrderSubstatusType::Shipped),
            "ASYNC_PROCESSING" => std::result::Result::Ok(OrderSubstatusType::AsyncProcessing),
            "USER_REFUSED_TO_PROVIDE_PERSONAL_DATA" => std::result::Result::Ok(OrderSubstatusType::UserRefusedToProvidePersonalData),
            "WAITING_USER_INPUT" => std::result::Result::Ok(OrderSubstatusType::WaitingUserInput),
            "WAITING_BANK_DECISION" => std::result::Result::Ok(OrderSubstatusType::WaitingBankDecision),
            "BANK_REJECT_CREDIT_OFFER" => std::result::Result::Ok(OrderSubstatusType::BankRejectCreditOffer),
            "CUSTOMER_REJECT_CREDIT_OFFER" => std::result::Result::Ok(OrderSubstatusType::CustomerRejectCreditOffer),
            "CREDIT_OFFER_FAILED" => std::result::Result::Ok(OrderSubstatusType::CreditOfferFailed),
            "AWAIT_DELIVERY_DATES_CONFIRMATION" => std::result::Result::Ok(OrderSubstatusType::AwaitDeliveryDatesConfirmation),
            "SERVICE_FAULT" => std::result::Result::Ok(OrderSubstatusType::ServiceFault),
            "DELIVERY_SERVICE_RECEIVED" => std::result::Result::Ok(OrderSubstatusType::DeliveryServiceReceived),
            "USER_RECEIVED" => std::result::Result::Ok(OrderSubstatusType::UserReceived),
            "WAITING_FOR_STOCKS" => std::result::Result::Ok(OrderSubstatusType::WaitingForStocks),
            "AS_PART_OF_MULTI_ORDER" => std::result::Result::Ok(OrderSubstatusType::AsPartOfMultiOrder),
            "READY_FOR_LAST_MILE" => std::result::Result::Ok(OrderSubstatusType::ReadyForLastMile),
            "LAST_MILE_STARTED" => std::result::Result::Ok(OrderSubstatusType::LastMileStarted),
            "ANTIFRAUD" => std::result::Result::Ok(OrderSubstatusType::Antifraud),
            "DELIVERY_USER_NOT_RECEIVED" => std::result::Result::Ok(OrderSubstatusType::DeliveryUserNotReceived),
            "DELIVERY_SERVICE_DELIVERED" => std::result::Result::Ok(OrderSubstatusType::DeliveryServiceDelivered),
            "DELIVERED_USER_NOT_RECEIVED" => std::result::Result::Ok(OrderSubstatusType::DeliveredUserNotReceived),
            "USER_WANTED_ANOTHER_PAYMENT_METHOD" => std::result::Result::Ok(OrderSubstatusType::UserWantedAnotherPaymentMethod),
            "USER_RECEIVED_TECHNICAL_ERROR" => std::result::Result::Ok(OrderSubstatusType::UserReceivedTechnicalError),
            "USER_FORGOT_TO_USE_BONUS" => std::result::Result::Ok(OrderSubstatusType::UserForgotToUseBonus),
            "RECEIVED_ON_DISTRIBUTION_CENTER" => std::result::Result::Ok(OrderSubstatusType::ReceivedOnDistributionCenter),
            "DELIVERY_SERVICE_NOT_RECEIVED" => std::result::Result::Ok(OrderSubstatusType::DeliveryServiceNotReceived),
            "DELIVERY_SERVICE_LOST" => std::result::Result::Ok(OrderSubstatusType::DeliveryServiceLost),
            "SHIPPED_TO_WRONG_DELIVERY_SERVICE" => std::result::Result::Ok(OrderSubstatusType::ShippedToWrongDeliveryService),
            "DELIVERED_USER_RECEIVED" => std::result::Result::Ok(OrderSubstatusType::DeliveredUserReceived),
            "WAITING_TINKOFF_DECISION" => std::result::Result::Ok(OrderSubstatusType::WaitingTinkoffDecision),
            "COURIER_SEARCH" => std::result::Result::Ok(OrderSubstatusType::CourierSearch),
            "COURIER_FOUND" => std::result::Result::Ok(OrderSubstatusType::CourierFound),
            "COURIER_IN_TRANSIT_TO_SENDER" => std::result::Result::Ok(OrderSubstatusType::CourierInTransitToSender),
            "COURIER_ARRIVED_TO_SENDER" => std::result::Result::Ok(OrderSubstatusType::CourierArrivedToSender),
            "COURIER_RECEIVED" => std::result::Result::Ok(OrderSubstatusType::CourierReceived),
            "COURIER_NOT_FOUND" => std::result::Result::Ok(OrderSubstatusType::CourierNotFound),
            "COURIER_NOT_DELIVER_ORDER" => std::result::Result::Ok(OrderSubstatusType::CourierNotDeliverOrder),
            "COURIER_RETURNS_ORDER" => std::result::Result::Ok(OrderSubstatusType::CourierReturnsOrder),
            "COURIER_RETURNED_ORDER" => std::result::Result::Ok(OrderSubstatusType::CourierReturnedOrder),
            "WAITING_USER_DELIVERY_INPUT" => std::result::Result::Ok(OrderSubstatusType::WaitingUserDeliveryInput),
            "PICKUP_SERVICE_RECEIVED" => std::result::Result::Ok(OrderSubstatusType::PickupServiceReceived),
            "PICKUP_USER_RECEIVED" => std::result::Result::Ok(OrderSubstatusType::PickupUserReceived),
            "CANCELLED_COURIER_NOT_FOUND" => std::result::Result::Ok(OrderSubstatusType::CancelledCourierNotFound),
            "COURIER_NOT_COME_FOR_ORDER" => std::result::Result::Ok(OrderSubstatusType::CourierNotComeForOrder),
            "DELIVERY_NOT_MANAGED_REGION" => std::result::Result::Ok(OrderSubstatusType::DeliveryNotManagedRegion),
            "INCOMPLETE_CONTACT_INFORMATION" => std::result::Result::Ok(OrderSubstatusType::IncompleteContactInformation),
            "INCOMPLETE_MULTI_ORDER" => std::result::Result::Ok(OrderSubstatusType::IncompleteMultiOrder),
            "INAPPROPRIATE_WEIGHT_SIZE" => std::result::Result::Ok(OrderSubstatusType::InappropriateWeightSize),
            "TECHNICAL_ERROR" => std::result::Result::Ok(OrderSubstatusType::TechnicalError),
            "SORTING_CENTER_LOST" => std::result::Result::Ok(OrderSubstatusType::SortingCenterLost),
            "COURIER_SEARCH_NOT_STARTED" => std::result::Result::Ok(OrderSubstatusType::CourierSearchNotStarted),
            "LOST" => std::result::Result::Ok(OrderSubstatusType::Lost),
            "AWAIT_PAYMENT" => std::result::Result::Ok(OrderSubstatusType::AwaitPayment),
            "AWAIT_LAVKA_RESERVATION" => std::result::Result::Ok(OrderSubstatusType::AwaitLavkaReservation),
            "USER_WANTS_TO_CHANGE_ADDRESS" => std::result::Result::Ok(OrderSubstatusType::UserWantsToChangeAddress),
            "FULL_NOT_RANSOM" => std::result::Result::Ok(OrderSubstatusType::FullNotRansom),
            "PRESCRIPTION_MISMATCH" => std::result::Result::Ok(OrderSubstatusType::PrescriptionMismatch),
            "DROPOFF_LOST" => std::result::Result::Ok(OrderSubstatusType::DropoffLost),
            "DROPOFF_CLOSED" => std::result::Result::Ok(OrderSubstatusType::DropoffClosed),
            "DELIVERY_TO_STORE_STARTED" => std::result::Result::Ok(OrderSubstatusType::DeliveryToStoreStarted),
            "USER_WANTS_TO_CHANGE_DELIVERY_DATE" => std::result::Result::Ok(OrderSubstatusType::UserWantsToChangeDeliveryDate),
            "WRONG_ITEM_DELIVERED" => std::result::Result::Ok(OrderSubstatusType::WrongItemDelivered),
            "DAMAGED_BOX" => std::result::Result::Ok(OrderSubstatusType::DamagedBox),
            "AWAIT_DELIVERY_DATES" => std::result::Result::Ok(OrderSubstatusType::AwaitDeliveryDates),
            "LAST_MILE_COURIER_SEARCH" => std::result::Result::Ok(OrderSubstatusType::LastMileCourierSearch),
            "PICKUP_POINT_CLOSED" => std::result::Result::Ok(OrderSubstatusType::PickupPointClosed),
            "LEGAL_INFO_CHANGED" => std::result::Result::Ok(OrderSubstatusType::LegalInfoChanged),
            "USER_HAS_NO_TIME_TO_PICKUP_ORDER" => std::result::Result::Ok(OrderSubstatusType::UserHasNoTimeToPickupOrder),
            "DELIVERY_CUSTOMS_ARRIVED" => std::result::Result::Ok(OrderSubstatusType::DeliveryCustomsArrived),
            "DELIVERY_CUSTOMS_CLEARED" => std::result::Result::Ok(OrderSubstatusType::DeliveryCustomsCleared),
            "FIRST_MILE_DELIVERY_SERVICE_RECEIVED" => std::result::Result::Ok(OrderSubstatusType::FirstMileDeliveryServiceReceived),
            "AWAIT_AUTO_DELIVERY_DATES" => std::result::Result::Ok(OrderSubstatusType::AwaitAutoDeliveryDates),
            "AWAIT_USER_PERSONAL_DATA" => std::result::Result::Ok(OrderSubstatusType::AwaitUserPersonalData),
            "NO_PERSONAL_DATA_EXPIRED" => std::result::Result::Ok(OrderSubstatusType::NoPersonalDataExpired),
            "CUSTOMS_PROBLEMS" => std::result::Result::Ok(OrderSubstatusType::CustomsProblems),
            "AWAIT_CASHIER" => std::result::Result::Ok(OrderSubstatusType::AwaitCashier),
            "WAITING_POSTPAID_BUDGET_RESERVATION" => std::result::Result::Ok(OrderSubstatusType::WaitingPostpaidBudgetReservation),
            "AWAIT_SERVICEABLE_CONFIRMATION" => std::result::Result::Ok(OrderSubstatusType::AwaitServiceableConfirmation),
            "POSTPAID_BUDGET_RESERVATION_FAILED" => std::result::Result::Ok(OrderSubstatusType::PostpaidBudgetReservationFailed),
            "AWAIT_CUSTOM_PRICE_CONFIRMATION" => std::result::Result::Ok(OrderSubstatusType::AwaitCustomPriceConfirmation),
            "READY_FOR_PICKUP" => std::result::Result::Ok(OrderSubstatusType::ReadyForPickup),
            "UNKNOWN" => std::result::Result::Ok(OrderSubstatusType::Unknown),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Система налогообложения (СНО) магазина на момент оформления заказа:  * `ECHN` — единый сельскохозяйственный налог (ЕСХН).  * `ENVD` — единый налог на вмененный доход (ЕНВД).  * `OSN` — общая система налогообложения (ОСН).  * `PSN` — патентная система налогообложения (ПСН).  * `USN` — упрощенная система налогообложения (УСН).  * `USN_MINUS_COST` — упрощенная система налогообложения, доходы, уменьшенные на величину расходов (УСН «Доходы минус расходы»).  * `NPD` — налог на профессиональный доход (НПД).  * `UNKNOWN_VALUE` — неизвестное значение. Используется только совместно с параметром `payment-method=YANDEX`. 
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum OrderTaxSystemType {
    #[serde(rename = "OSN")]
    Osn,
    #[serde(rename = "USN")]
    Usn,
    #[serde(rename = "USN_MINUS_COST")]
    UsnMinusCost,
    #[serde(rename = "ENVD")]
    Envd,
    #[serde(rename = "ECHN")]
    Echn,
    #[serde(rename = "PSN")]
    Psn,
    #[serde(rename = "NPD")]
    Npd,
    #[serde(rename = "UNKNOWN_VALUE")]
    UnknownValue,
}

impl std::fmt::Display for OrderTaxSystemType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            OrderTaxSystemType::Osn => write!(f, "OSN"),
            OrderTaxSystemType::Usn => write!(f, "USN"),
            OrderTaxSystemType::UsnMinusCost => write!(f, "USN_MINUS_COST"),
            OrderTaxSystemType::Envd => write!(f, "ENVD"),
            OrderTaxSystemType::Echn => write!(f, "ECHN"),
            OrderTaxSystemType::Psn => write!(f, "PSN"),
            OrderTaxSystemType::Npd => write!(f, "NPD"),
            OrderTaxSystemType::UnknownValue => write!(f, "UNKNOWN_VALUE"),
        }
    }
}

impl std::str::FromStr for OrderTaxSystemType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "OSN" => std::result::Result::Ok(OrderTaxSystemType::Osn),
            "USN" => std::result::Result::Ok(OrderTaxSystemType::Usn),
            "USN_MINUS_COST" => std::result::Result::Ok(OrderTaxSystemType::UsnMinusCost),
            "ENVD" => std::result::Result::Ok(OrderTaxSystemType::Envd),
            "ECHN" => std::result::Result::Ok(OrderTaxSystemType::Echn),
            "PSN" => std::result::Result::Ok(OrderTaxSystemType::Psn),
            "NPD" => std::result::Result::Ok(OrderTaxSystemType::Npd),
            "UNKNOWN_VALUE" => std::result::Result::Ok(OrderTaxSystemType::UnknownValue),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Информация о трек-номере посылки (DBS).
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct OrderTrackDto {
    /// Трек‑номер посылки.
    #[serde(rename = "trackCode")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub track_code: Option<String>,

    /// Идентификатор службы доставки. Информацию о службе доставки можно получить с помощью запроса [GET delivery/services](../../reference/orders/getDeliveryServices.md).
    #[serde(rename = "deliveryServiceId")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub delivery_service_id: Option<i64>,

}


impl OrderTrackDto {
    #[allow(clippy::new_without_default)]
    pub fn new() -> OrderTrackDto {
        OrderTrackDto {
            track_code: None,
            delivery_service_id: None,
        }
    }
}

/// Converts the OrderTrackDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for OrderTrackDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.track_code.as_ref().map(|track_code| {
                [
                    "trackCode".to_string(),
                    track_code.to_string(),
                ].join(",")
            }),


            self.delivery_service_id.as_ref().map(|delivery_service_id| {
                [
                    "deliveryServiceId".to_string(),
                    delivery_service_id.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a OrderTrackDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for OrderTrackDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub track_code: Vec<String>,
            pub delivery_service_id: Vec<i64>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing OrderTrackDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "trackCode" => intermediate_rep.track_code.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "deliveryServiceId" => intermediate_rep.delivery_service_id.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing OrderTrackDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(OrderTrackDto {
            track_code: intermediate_rep.track_code.into_iter().next(),
            delivery_service_id: intermediate_rep.delivery_service_id.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<OrderTrackDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<OrderTrackDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<OrderTrackDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for OrderTrackDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<OrderTrackDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <OrderTrackDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into OrderTrackDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Изменился ли статус заказа:  * `OK` — статус изменен.  * `ERROR` — статус не изменен. В этом случае появится сообщение об ошибке в параметре `errorDetails`. 
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum OrderUpdateStatusType {
    #[serde(rename = "OK")]
    Ok,
    #[serde(rename = "ERROR")]
    Error,
}

impl std::fmt::Display for OrderUpdateStatusType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            OrderUpdateStatusType::Ok => write!(f, "OK"),
            OrderUpdateStatusType::Error => write!(f, "ERROR"),
        }
    }
}

impl std::str::FromStr for OrderUpdateStatusType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "OK" => std::result::Result::Ok(OrderUpdateStatusType::Ok),
            "ERROR" => std::result::Result::Ok(OrderUpdateStatusType::Error),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Ставка налога на добавленную стоимость (НДС) на товар:  * `NO_VAT` — НДС не облагается, используется только для отдельных видов услуг.  * `VAT_0` — НДС 0%. Например, используется при продаже товаров, вывезенных в таможенной процедуре экспорта, или при оказании услуг по международной перевозке товаров.  * `VAT_10` — НДС 10%. Например, используется при реализации отдельных продовольственных и медицинских товаров.  * `VAT_10_110` — НДС 10/110. Расчетная ставка НДС 10%, применяется только при предоплате.  * `VAT_20` — НДС 20%. Основная ставка с 2019 года.  * `VAT_20_120` — НДС 20/120. Расчетная ставка НДС 20%, применяется только при предоплате.  * `VAT_18` — НДС 18%. Основная ставка до 2019 года.  * `VAT_18_118` — НДС 18/118. Ставка использовалась до 1 января 2019 года при предоплате.  * `UNKNOWN_VALUE` — неизвестный тип.  Используется только совместно с параметром `payment-method=YANDEX`. 
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum OrderVatType {
    #[serde(rename = "NO_VAT")]
    NoVat,
    #[serde(rename = "VAT_0")]
    Vat0,
    #[serde(rename = "VAT_10")]
    Vat10,
    #[serde(rename = "VAT_10_110")]
    Vat10110,
    #[serde(rename = "VAT_20")]
    Vat20,
    #[serde(rename = "VAT_20_120")]
    Vat20120,
    #[serde(rename = "VAT_18")]
    Vat18,
    #[serde(rename = "VAT_18_118")]
    Vat18118,
    #[serde(rename = "UNKNOWN_VALUE")]
    UnknownValue,
}

impl std::fmt::Display for OrderVatType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            OrderVatType::NoVat => write!(f, "NO_VAT"),
            OrderVatType::Vat0 => write!(f, "VAT_0"),
            OrderVatType::Vat10 => write!(f, "VAT_10"),
            OrderVatType::Vat10110 => write!(f, "VAT_10_110"),
            OrderVatType::Vat20 => write!(f, "VAT_20"),
            OrderVatType::Vat20120 => write!(f, "VAT_20_120"),
            OrderVatType::Vat18 => write!(f, "VAT_18"),
            OrderVatType::Vat18118 => write!(f, "VAT_18_118"),
            OrderVatType::UnknownValue => write!(f, "UNKNOWN_VALUE"),
        }
    }
}

impl std::str::FromStr for OrderVatType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "NO_VAT" => std::result::Result::Ok(OrderVatType::NoVat),
            "VAT_0" => std::result::Result::Ok(OrderVatType::Vat0),
            "VAT_10" => std::result::Result::Ok(OrderVatType::Vat10),
            "VAT_10_110" => std::result::Result::Ok(OrderVatType::Vat10110),
            "VAT_20" => std::result::Result::Ok(OrderVatType::Vat20),
            "VAT_20_120" => std::result::Result::Ok(OrderVatType::Vat20120),
            "VAT_18" => std::result::Result::Ok(OrderVatType::Vat18),
            "VAT_18_118" => std::result::Result::Ok(OrderVatType::Vat18118),
            "UNKNOWN_VALUE" => std::result::Result::Ok(OrderVatType::UnknownValue),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Годные/негодные ярлыки по заказам в отгрузке.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct OrdersShipmentInfoDto {
    /// Идентификаторы заказов в отгрузке, для которых можно распечатать ярлыки.
    #[serde(rename = "orderIdsWithLabels")]
    #[validate(
        )]
    pub order_ids_with_labels: Vec<i64>,

    /// Идентификаторы заказов в отгрузке, для которых нельзя распечатать ярлыки.
    #[serde(rename = "orderIdsWithoutLabels")]
    #[validate(
        )]
    pub order_ids_without_labels: Vec<i64>,

}


impl OrdersShipmentInfoDto {
    #[allow(clippy::new_without_default)]
    pub fn new(order_ids_with_labels: Vec<i64>, order_ids_without_labels: Vec<i64>, ) -> OrdersShipmentInfoDto {
        OrdersShipmentInfoDto {
            order_ids_with_labels,
            order_ids_without_labels,
        }
    }
}

/// Converts the OrdersShipmentInfoDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for OrdersShipmentInfoDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            Some("orderIdsWithLabels".to_string()),
            Some(self.order_ids_with_labels.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),


            Some("orderIdsWithoutLabels".to_string()),
            Some(self.order_ids_without_labels.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a OrdersShipmentInfoDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for OrdersShipmentInfoDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub order_ids_with_labels: Vec<Vec<i64>>,
            pub order_ids_without_labels: Vec<Vec<i64>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing OrdersShipmentInfoDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "orderIdsWithLabels" => return std::result::Result::Err("Parsing a container in this style is not supported in OrdersShipmentInfoDto".to_string()),
                    "orderIdsWithoutLabels" => return std::result::Result::Err("Parsing a container in this style is not supported in OrdersShipmentInfoDto".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing OrdersShipmentInfoDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(OrdersShipmentInfoDto {
            order_ids_with_labels: intermediate_rep.order_ids_with_labels.into_iter().next().ok_or_else(|| "orderIdsWithLabels missing in OrdersShipmentInfoDto".to_string())?,
            order_ids_without_labels: intermediate_rep.order_ids_without_labels.into_iter().next().ok_or_else(|| "orderIdsWithoutLabels missing in OrdersShipmentInfoDto".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<OrdersShipmentInfoDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<OrdersShipmentInfoDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<OrdersShipmentInfoDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for OrdersShipmentInfoDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<OrdersShipmentInfoDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <OrdersShipmentInfoDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into OrdersShipmentInfoDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Информация о стоимости услуг.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct OrdersStatsCommissionDto {
    #[serde(rename = "type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub r#type: Option<models::OrdersStatsCommissionType>,

    /// Сумма в рублях, которая была выставлена в момент создания заказа и которую нужно оплатить. Точность — два знака после запятой. 
    #[serde(rename = "actual")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub actual: Option<f64>,

}


impl OrdersStatsCommissionDto {
    #[allow(clippy::new_without_default)]
    pub fn new() -> OrdersStatsCommissionDto {
        OrdersStatsCommissionDto {
            r#type: None,
            actual: None,
        }
    }
}

/// Converts the OrdersStatsCommissionDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for OrdersStatsCommissionDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping type in query parameter serialization


            self.actual.as_ref().map(|actual| {
                [
                    "actual".to_string(),
                    actual.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a OrdersStatsCommissionDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for OrdersStatsCommissionDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub r#type: Vec<models::OrdersStatsCommissionType>,
            pub actual: Vec<f64>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing OrdersStatsCommissionDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r#type.push(<models::OrdersStatsCommissionType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "actual" => intermediate_rep.actual.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing OrdersStatsCommissionDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(OrdersStatsCommissionDto {
            r#type: intermediate_rep.r#type.into_iter().next(),
            actual: intermediate_rep.actual.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<OrdersStatsCommissionDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<OrdersStatsCommissionDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<OrdersStatsCommissionDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for OrdersStatsCommissionDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<OrdersStatsCommissionDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <OrdersStatsCommissionDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into OrdersStatsCommissionDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Услуга:  * `FEE` — размещение товара на Маркете. * `FULFILLMENT` — складская обработка. Не возвращается с 1 января 2024 года. * `LOYALTY_PARTICIPATION_FEE` — участие в программе лояльности и отзывы за баллы. * `AUCTION_PROMOTION` — буст продаж с оплатой за продажи. * `INSTALLMENT` — рассрочка. Не возвращается с 24 февраля 2022 года. * `DELIVERY_TO_CUSTOMER` — доставка покупателю (FBY, FBS). Для DBS и Экспресс — если заказ возвращается через логистику Маркета. * `EXPRESS_DELIVERY_TO_CUSTOMER` — экспресс-доставка покупателю (Экспресс). * `AGENCY` — прием платежа покупателя. * `PAYMENT_TRANSFER` — перевод платежа покупателя. * `RETURNED_ORDERS_STORAGE` — хранение невыкупов и возвратов (FBS). Для DBS и Экспресс — если заказ возвращается через логистику Маркета. * `SORTING` — обработка заказа (FBS). * `INTAKE_SORTING` — организация забора заказов со склада продавца (FBS). * `RETURN_PROCESSING` — обработка заказов на складе (FBS). Для DBS и Экспресс — если заказ возвращается через логистику Маркета. * `ILLIQUID_GOODS_SALE` — вознаграждение за продажу невывезенных товаров. 
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum OrdersStatsCommissionType {
    #[serde(rename = "FEE")]
    Fee,
    #[serde(rename = "FULFILLMENT")]
    Fulfillment,
    #[serde(rename = "LOYALTY_PARTICIPATION_FEE")]
    LoyaltyParticipationFee,
    #[serde(rename = "AUCTION_PROMOTION")]
    AuctionPromotion,
    #[serde(rename = "INSTALLMENT")]
    Installment,
    #[serde(rename = "DELIVERY_TO_CUSTOMER")]
    DeliveryToCustomer,
    #[serde(rename = "EXPRESS_DELIVERY_TO_CUSTOMER")]
    ExpressDeliveryToCustomer,
    #[serde(rename = "AGENCY")]
    Agency,
    #[serde(rename = "PAYMENT_TRANSFER")]
    PaymentTransfer,
    #[serde(rename = "RETURNED_ORDERS_STORAGE")]
    ReturnedOrdersStorage,
    #[serde(rename = "SORTING")]
    Sorting,
    #[serde(rename = "INTAKE_SORTING")]
    IntakeSorting,
    #[serde(rename = "RETURN_PROCESSING")]
    ReturnProcessing,
    #[serde(rename = "ILLIQUID_GOODS_SALE")]
    IlliquidGoodsSale,
}

impl std::fmt::Display for OrdersStatsCommissionType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            OrdersStatsCommissionType::Fee => write!(f, "FEE"),
            OrdersStatsCommissionType::Fulfillment => write!(f, "FULFILLMENT"),
            OrdersStatsCommissionType::LoyaltyParticipationFee => write!(f, "LOYALTY_PARTICIPATION_FEE"),
            OrdersStatsCommissionType::AuctionPromotion => write!(f, "AUCTION_PROMOTION"),
            OrdersStatsCommissionType::Installment => write!(f, "INSTALLMENT"),
            OrdersStatsCommissionType::DeliveryToCustomer => write!(f, "DELIVERY_TO_CUSTOMER"),
            OrdersStatsCommissionType::ExpressDeliveryToCustomer => write!(f, "EXPRESS_DELIVERY_TO_CUSTOMER"),
            OrdersStatsCommissionType::Agency => write!(f, "AGENCY"),
            OrdersStatsCommissionType::PaymentTransfer => write!(f, "PAYMENT_TRANSFER"),
            OrdersStatsCommissionType::ReturnedOrdersStorage => write!(f, "RETURNED_ORDERS_STORAGE"),
            OrdersStatsCommissionType::Sorting => write!(f, "SORTING"),
            OrdersStatsCommissionType::IntakeSorting => write!(f, "INTAKE_SORTING"),
            OrdersStatsCommissionType::ReturnProcessing => write!(f, "RETURN_PROCESSING"),
            OrdersStatsCommissionType::IlliquidGoodsSale => write!(f, "ILLIQUID_GOODS_SALE"),
        }
    }
}

impl std::str::FromStr for OrdersStatsCommissionType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "FEE" => std::result::Result::Ok(OrdersStatsCommissionType::Fee),
            "FULFILLMENT" => std::result::Result::Ok(OrdersStatsCommissionType::Fulfillment),
            "LOYALTY_PARTICIPATION_FEE" => std::result::Result::Ok(OrdersStatsCommissionType::LoyaltyParticipationFee),
            "AUCTION_PROMOTION" => std::result::Result::Ok(OrdersStatsCommissionType::AuctionPromotion),
            "INSTALLMENT" => std::result::Result::Ok(OrdersStatsCommissionType::Installment),
            "DELIVERY_TO_CUSTOMER" => std::result::Result::Ok(OrdersStatsCommissionType::DeliveryToCustomer),
            "EXPRESS_DELIVERY_TO_CUSTOMER" => std::result::Result::Ok(OrdersStatsCommissionType::ExpressDeliveryToCustomer),
            "AGENCY" => std::result::Result::Ok(OrdersStatsCommissionType::Agency),
            "PAYMENT_TRANSFER" => std::result::Result::Ok(OrdersStatsCommissionType::PaymentTransfer),
            "RETURNED_ORDERS_STORAGE" => std::result::Result::Ok(OrdersStatsCommissionType::ReturnedOrdersStorage),
            "SORTING" => std::result::Result::Ok(OrdersStatsCommissionType::Sorting),
            "INTAKE_SORTING" => std::result::Result::Ok(OrdersStatsCommissionType::IntakeSorting),
            "RETURN_PROCESSING" => std::result::Result::Ok(OrdersStatsCommissionType::ReturnProcessing),
            "ILLIQUID_GOODS_SALE" => std::result::Result::Ok(OrdersStatsCommissionType::IlliquidGoodsSale),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Информация о регионе доставки.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct OrdersStatsDeliveryRegionDto {
    /// Идентификатор региона доставки.
    #[serde(rename = "id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,

    /// Название региона доставки.
    #[serde(rename = "name")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

}


impl OrdersStatsDeliveryRegionDto {
    #[allow(clippy::new_without_default)]
    pub fn new() -> OrdersStatsDeliveryRegionDto {
        OrdersStatsDeliveryRegionDto {
            id: None,
            name: None,
        }
    }
}

/// Converts the OrdersStatsDeliveryRegionDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for OrdersStatsDeliveryRegionDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.id.as_ref().map(|id| {
                [
                    "id".to_string(),
                    id.to_string(),
                ].join(",")
            }),


            self.name.as_ref().map(|name| {
                [
                    "name".to_string(),
                    name.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a OrdersStatsDeliveryRegionDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for OrdersStatsDeliveryRegionDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<i64>,
            pub name: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing OrdersStatsDeliveryRegionDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing OrdersStatsDeliveryRegionDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(OrdersStatsDeliveryRegionDto {
            id: intermediate_rep.id.into_iter().next(),
            name: intermediate_rep.name.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<OrdersStatsDeliveryRegionDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<OrdersStatsDeliveryRegionDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<OrdersStatsDeliveryRegionDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for OrdersStatsDeliveryRegionDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<OrdersStatsDeliveryRegionDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <OrdersStatsDeliveryRegionDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into OrdersStatsDeliveryRegionDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Информация об удалении товара из заказа.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct OrdersStatsDetailsDto {
    #[serde(rename = "itemStatus")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub item_status: Option<models::OrdersStatsItemStatusType>,

    /// Количество товара со статусом, указанном в параметре `itemStatus`.
    #[serde(rename = "itemCount")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub item_count: Option<i64>,

    /// Дата, когда товар получил статус, указанный в параметре `itemStatus`.  Формат даты: `ГГГГ-ММ-ДД`. 
    #[serde(rename = "updateDate")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub update_date: Option<chrono::naive::NaiveDate>,

    #[serde(rename = "stockType")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub stock_type: Option<models::OrdersStatsStockType>,

}


impl OrdersStatsDetailsDto {
    #[allow(clippy::new_without_default)]
    pub fn new() -> OrdersStatsDetailsDto {
        OrdersStatsDetailsDto {
            item_status: None,
            item_count: None,
            update_date: None,
            stock_type: None,
        }
    }
}

/// Converts the OrdersStatsDetailsDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for OrdersStatsDetailsDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping itemStatus in query parameter serialization


            self.item_count.as_ref().map(|item_count| {
                [
                    "itemCount".to_string(),
                    item_count.to_string(),
                ].join(",")
            }),

            // Skipping updateDate in query parameter serialization

            // Skipping stockType in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a OrdersStatsDetailsDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for OrdersStatsDetailsDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub item_status: Vec<models::OrdersStatsItemStatusType>,
            pub item_count: Vec<i64>,
            pub update_date: Vec<chrono::naive::NaiveDate>,
            pub stock_type: Vec<models::OrdersStatsStockType>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing OrdersStatsDetailsDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "itemStatus" => intermediate_rep.item_status.push(<models::OrdersStatsItemStatusType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "itemCount" => intermediate_rep.item_count.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "updateDate" => intermediate_rep.update_date.push(<chrono::naive::NaiveDate as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "stockType" => intermediate_rep.stock_type.push(<models::OrdersStatsStockType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing OrdersStatsDetailsDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(OrdersStatsDetailsDto {
            item_status: intermediate_rep.item_status.into_iter().next(),
            item_count: intermediate_rep.item_count.into_iter().next(),
            update_date: intermediate_rep.update_date.into_iter().next(),
            stock_type: intermediate_rep.stock_type.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<OrdersStatsDetailsDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<OrdersStatsDetailsDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<OrdersStatsDetailsDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for OrdersStatsDetailsDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<OrdersStatsDetailsDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <OrdersStatsDetailsDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into OrdersStatsDetailsDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Информация по заказам.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct OrdersStatsDto {
    /// Список заказов.
    #[serde(rename = "orders")]
    pub orders: Vec<models::OrdersStatsOrderDto>,

    #[serde(rename = "paging")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub paging: Option<models::ForwardScrollingPagerDto>,

}


impl OrdersStatsDto {
    #[allow(clippy::new_without_default)]
    pub fn new(orders: Vec<models::OrdersStatsOrderDto>, ) -> OrdersStatsDto {
        OrdersStatsDto {
            orders,
            paging: None,
        }
    }
}

/// Converts the OrdersStatsDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for OrdersStatsDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping orders in query parameter serialization

            // Skipping paging in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a OrdersStatsDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for OrdersStatsDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub orders: Vec<Vec<models::OrdersStatsOrderDto>>,
            pub paging: Vec<models::ForwardScrollingPagerDto>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing OrdersStatsDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "orders" => return std::result::Result::Err("Parsing a container in this style is not supported in OrdersStatsDto".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "paging" => intermediate_rep.paging.push(<models::ForwardScrollingPagerDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing OrdersStatsDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(OrdersStatsDto {
            orders: intermediate_rep.orders.into_iter().next().ok_or_else(|| "orders missing in OrdersStatsDto".to_string())?,
            paging: intermediate_rep.paging.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<OrdersStatsDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<OrdersStatsDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<OrdersStatsDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for OrdersStatsDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<OrdersStatsDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <OrdersStatsDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into OrdersStatsDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Список товаров в заказе после возможных изменений.  В ходе обработки заказа Маркет может удалить из него единицы товаров — при проблемах на складе или по инициативе пользователя.  * Если из заказа удалены все единицы товара, его не будет в списке `items` — только в списке `initialItems`.  * Если в заказе осталась хотя бы одна единица товара, он будет и в списке `items` (с уменьшенным количеством единиц `count`), и в списке `initialItems` (с первоначальным количеством единиц `initialCount`). 
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct OrdersStatsItemDto {
    /// Название товара.
    #[serde(rename = "offerName")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub offer_name: Option<String>,

    /// SKU на Маркете.
    #[serde(rename = "marketSku")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub market_sku: Option<i64>,

    /// Ваш SKU — идентификатор товара в вашей системе.  Разрешена любая последовательность длиной до 255 знаков.  Правила использования SKU:  * У каждого товара SKU должен быть свой.  * SKU товара нельзя менять — можно только удалить товар и добавить заново с новым SKU.  * Уже заданный SKU нельзя освободить и использовать заново для другого товара. Каждый товар должен получать новый идентификатор, до того никогда не использовавшийся в вашем каталоге.  [Что такое SKU и как его назначать](https://yandex.ru/support/marketplace/assortment/add/index.html#fields) 
    #[serde(rename = "shopSku")]
    #[validate(
            length(min = 1, max = 255),
           regex = "RE_ORDERSSTATSITEMDTO_SHOP_SKU",
        )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub shop_sku: Option<String>,

    /// Количество единиц товара с учетом удаленных единиц.  Если из заказа удалены все единицы товара, он попадет только в список `initialItems`. 
    #[serde(rename = "count")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub count: Option<i32>,

    /// Цена или скидки на товар.
    #[serde(rename = "prices")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub prices: Option<swagger::Nullable<Vec<models::OrdersStatsPriceDto>>>,

    #[serde(rename = "warehouse")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub warehouse: Option<models::OrdersStatsWarehouseDto>,

    /// Информация об удалении товара из заказа.
    #[serde(rename = "details")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub details: Option<swagger::Nullable<Vec<models::OrdersStatsDetailsDto>>>,

    /// Список кодов идентификации товара [в системе «Честный ЗНАК»](https://честныйзнак.рф/).
    #[serde(rename = "cisList")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub cis_list: Option<swagger::Nullable<Vec<String>>>,

    /// Первоначальное количество единиц товара.
    #[serde(rename = "initialCount")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub initial_count: Option<i32>,

    /// Списанная ставка ближайшего конкурента.  Указывается в процентах от стоимости товара и умножается на 100. Например, ставка 5% обозначается как 500. 
    #[serde(rename = "bidFee")]
    #[validate(
            range(min = 0, max = 10000),
        )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub bid_fee: Option<u32>,

    /// Порог для скидок с Маркетом на момент оформления заказа. [Что это такое?](https://yandex.ru/support/marketplace/marketing/smart-pricing.html#sponsored-discounts)  Указан в рублях. Точность — два знака после запятой. 
    #[serde(rename = "cofinanceThreshold")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub cofinance_threshold: Option<f64>,

    /// Скидка с Маркетом. [Что это такое?](https://yandex.ru/support/marketplace/marketing/smart-pricing.html#sponsored-discounts)  Указана в рублях. Точность — два знака после запятой. 
    #[serde(rename = "cofinanceValue")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub cofinance_value: Option<f64>,

}

lazy_static::lazy_static! {
    static ref RE_ORDERSSTATSITEMDTO_SHOP_SKU: regex::Regex = regex::Regex::new(r"^[^\\x00-\\x08\\x0A-\\x1f\\x7f]{1,255}$").unwrap();
}

impl OrdersStatsItemDto {
    #[allow(clippy::new_without_default)]
    pub fn new() -> OrdersStatsItemDto {
        OrdersStatsItemDto {
            offer_name: None,
            market_sku: None,
            shop_sku: None,
            count: None,
            prices: None,
            warehouse: None,
            details: None,
            cis_list: None,
            initial_count: None,
            bid_fee: None,
            cofinance_threshold: None,
            cofinance_value: None,
        }
    }
}

/// Converts the OrdersStatsItemDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for OrdersStatsItemDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.offer_name.as_ref().map(|offer_name| {
                [
                    "offerName".to_string(),
                    offer_name.to_string(),
                ].join(",")
            }),


            self.market_sku.as_ref().map(|market_sku| {
                [
                    "marketSku".to_string(),
                    market_sku.to_string(),
                ].join(",")
            }),


            self.shop_sku.as_ref().map(|shop_sku| {
                [
                    "shopSku".to_string(),
                    shop_sku.to_string(),
                ].join(",")
            }),


            self.count.as_ref().map(|count| {
                [
                    "count".to_string(),
                    count.to_string(),
                ].join(",")
            }),

            // Skipping prices in query parameter serialization

            // Skipping warehouse in query parameter serialization

            // Skipping details in query parameter serialization


            self.cis_list.as_ref().map(|cis_list| {
                [
                    "cisList".to_string(),
                    cis_list.as_ref().map_or("null".to_string(), |x| x.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),
                ].join(",")
            }),


            self.initial_count.as_ref().map(|initial_count| {
                [
                    "initialCount".to_string(),
                    initial_count.to_string(),
                ].join(",")
            }),


            self.bid_fee.as_ref().map(|bid_fee| {
                [
                    "bidFee".to_string(),
                    bid_fee.to_string(),
                ].join(",")
            }),


            self.cofinance_threshold.as_ref().map(|cofinance_threshold| {
                [
                    "cofinanceThreshold".to_string(),
                    cofinance_threshold.to_string(),
                ].join(",")
            }),


            self.cofinance_value.as_ref().map(|cofinance_value| {
                [
                    "cofinanceValue".to_string(),
                    cofinance_value.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a OrdersStatsItemDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for OrdersStatsItemDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub offer_name: Vec<String>,
            pub market_sku: Vec<i64>,
            pub shop_sku: Vec<String>,
            pub count: Vec<i32>,
            pub prices: Vec<Vec<models::OrdersStatsPriceDto>>,
            pub warehouse: Vec<models::OrdersStatsWarehouseDto>,
            pub details: Vec<Vec<models::OrdersStatsDetailsDto>>,
            pub cis_list: Vec<Vec<String>>,
            pub initial_count: Vec<i32>,
            pub bid_fee: Vec<u32>,
            pub cofinance_threshold: Vec<f64>,
            pub cofinance_value: Vec<f64>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing OrdersStatsItemDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "offerName" => intermediate_rep.offer_name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "marketSku" => intermediate_rep.market_sku.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "shopSku" => intermediate_rep.shop_sku.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "count" => intermediate_rep.count.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "prices" => return std::result::Result::Err("Parsing a container in this style is not supported in OrdersStatsItemDto".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "warehouse" => intermediate_rep.warehouse.push(<models::OrdersStatsWarehouseDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "details" => return std::result::Result::Err("Parsing a container in this style is not supported in OrdersStatsItemDto".to_string()),
                    "cisList" => return std::result::Result::Err("Parsing a container in this style is not supported in OrdersStatsItemDto".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "initialCount" => intermediate_rep.initial_count.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "bidFee" => intermediate_rep.bid_fee.push(<u32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "cofinanceThreshold" => intermediate_rep.cofinance_threshold.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "cofinanceValue" => intermediate_rep.cofinance_value.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing OrdersStatsItemDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(OrdersStatsItemDto {
            offer_name: intermediate_rep.offer_name.into_iter().next(),
            market_sku: intermediate_rep.market_sku.into_iter().next(),
            shop_sku: intermediate_rep.shop_sku.into_iter().next(),
            count: intermediate_rep.count.into_iter().next(),
            prices: std::result::Result::Err("Nullable types not supported in OrdersStatsItemDto".to_string())?,
            warehouse: intermediate_rep.warehouse.into_iter().next(),
            details: std::result::Result::Err("Nullable types not supported in OrdersStatsItemDto".to_string())?,
            cis_list: std::result::Result::Err("Nullable types not supported in OrdersStatsItemDto".to_string())?,
            initial_count: intermediate_rep.initial_count.into_iter().next(),
            bid_fee: intermediate_rep.bid_fee.into_iter().next(),
            cofinance_threshold: intermediate_rep.cofinance_threshold.into_iter().next(),
            cofinance_value: intermediate_rep.cofinance_value.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<OrdersStatsItemDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<OrdersStatsItemDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<OrdersStatsItemDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for OrdersStatsItemDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<OrdersStatsItemDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <OrdersStatsItemDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into OrdersStatsItemDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Статус товара:  * `REJECTED` — товар был добавлен в созданный заказ, но не был оплачен. * `RETURNED` — товар вернули. 
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum OrdersStatsItemStatusType {
    #[serde(rename = "REJECTED")]
    Rejected,
    #[serde(rename = "RETURNED")]
    Returned,
}

impl std::fmt::Display for OrdersStatsItemStatusType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            OrdersStatsItemStatusType::Rejected => write!(f, "REJECTED"),
            OrdersStatsItemStatusType::Returned => write!(f, "RETURNED"),
        }
    }
}

impl std::str::FromStr for OrdersStatsItemStatusType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "REJECTED" => std::result::Result::Ok(OrdersStatsItemStatusType::Rejected),
            "RETURNED" => std::result::Result::Ok(OrdersStatsItemStatusType::Returned),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Информация о заказе.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct OrdersStatsOrderDto {
    /// Идентификатор заказа.
    #[serde(rename = "id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,

    /// Дата создания заказа.  Формат даты: `ГГГГ-ММ-ДД`. 
    #[serde(rename = "creationDate")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub creation_date: Option<chrono::naive::NaiveDate>,

    /// Дата и время, когда статус заказа был изменен в последний раз.  Формат даты и времени: ISO 8601. Например, `2017-11-21T00:00:00`. Часовой пояс — UTC+03:00 (Москва). 
    #[serde(rename = "statusUpdateDate")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub status_update_date: Option<chrono::DateTime::<chrono::Utc>>,

    #[serde(rename = "status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<models::OrderStatsStatusType>,

    /// Идентификатор заказа в информационной системе магазина.
    #[serde(rename = "partnerOrderId")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub partner_order_id: Option<String>,

    #[serde(rename = "paymentType")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub payment_type: Option<models::OrdersStatsOrderPaymentType>,

    /// Тип заказа:  * `false` — настоящий заказ покупателя.  * `true` — [тестовый](../../pushapi/concepts/sandbox.md) заказ Маркета. 
    #[serde(rename = "fake")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub fake: Option<bool>,

    #[serde(rename = "deliveryRegion")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub delivery_region: Option<models::OrdersStatsDeliveryRegionDto>,

    /// Список товаров в заказе после возможных изменений.
    #[serde(rename = "items")]
    pub items: Vec<models::OrdersStatsItemDto>,

    /// Список товаров в заказе до изменений.
    #[serde(rename = "initialItems")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub initial_items: Option<swagger::Nullable<Vec<models::OrdersStatsItemDto>>>,

    /// Информация о денежных переводах по заказу.
    #[serde(rename = "payments")]
    pub payments: Vec<models::OrdersStatsPaymentDto>,

    /// Информация о комиссиях за заказ.
    #[serde(rename = "commissions")]
    pub commissions: Vec<models::OrdersStatsCommissionDto>,

}


impl OrdersStatsOrderDto {
    #[allow(clippy::new_without_default)]
    pub fn new(items: Vec<models::OrdersStatsItemDto>, payments: Vec<models::OrdersStatsPaymentDto>, commissions: Vec<models::OrdersStatsCommissionDto>, ) -> OrdersStatsOrderDto {
        OrdersStatsOrderDto {
            id: None,
            creation_date: None,
            status_update_date: None,
            status: None,
            partner_order_id: None,
            payment_type: None,
            fake: None,
            delivery_region: None,
            items,
            initial_items: None,
            payments,
            commissions,
        }
    }
}

/// Converts the OrdersStatsOrderDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for OrdersStatsOrderDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.id.as_ref().map(|id| {
                [
                    "id".to_string(),
                    id.to_string(),
                ].join(",")
            }),

            // Skipping creationDate in query parameter serialization

            // Skipping statusUpdateDate in query parameter serialization

            // Skipping status in query parameter serialization


            self.partner_order_id.as_ref().map(|partner_order_id| {
                [
                    "partnerOrderId".to_string(),
                    partner_order_id.to_string(),
                ].join(",")
            }),

            // Skipping paymentType in query parameter serialization


            self.fake.as_ref().map(|fake| {
                [
                    "fake".to_string(),
                    fake.to_string(),
                ].join(",")
            }),

            // Skipping deliveryRegion in query parameter serialization

            // Skipping items in query parameter serialization

            // Skipping initialItems in query parameter serialization

            // Skipping payments in query parameter serialization

            // Skipping commissions in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a OrdersStatsOrderDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for OrdersStatsOrderDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<i64>,
            pub creation_date: Vec<chrono::naive::NaiveDate>,
            pub status_update_date: Vec<chrono::DateTime::<chrono::Utc>>,
            pub status: Vec<models::OrderStatsStatusType>,
            pub partner_order_id: Vec<String>,
            pub payment_type: Vec<models::OrdersStatsOrderPaymentType>,
            pub fake: Vec<bool>,
            pub delivery_region: Vec<models::OrdersStatsDeliveryRegionDto>,
            pub items: Vec<Vec<models::OrdersStatsItemDto>>,
            pub initial_items: Vec<Vec<models::OrdersStatsItemDto>>,
            pub payments: Vec<Vec<models::OrdersStatsPaymentDto>>,
            pub commissions: Vec<Vec<models::OrdersStatsCommissionDto>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing OrdersStatsOrderDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "creationDate" => intermediate_rep.creation_date.push(<chrono::naive::NaiveDate as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "statusUpdateDate" => intermediate_rep.status_update_date.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(<models::OrderStatsStatusType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "partnerOrderId" => intermediate_rep.partner_order_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "paymentType" => intermediate_rep.payment_type.push(<models::OrdersStatsOrderPaymentType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "fake" => intermediate_rep.fake.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "deliveryRegion" => intermediate_rep.delivery_region.push(<models::OrdersStatsDeliveryRegionDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "items" => return std::result::Result::Err("Parsing a container in this style is not supported in OrdersStatsOrderDto".to_string()),
                    "initialItems" => return std::result::Result::Err("Parsing a container in this style is not supported in OrdersStatsOrderDto".to_string()),
                    "payments" => return std::result::Result::Err("Parsing a container in this style is not supported in OrdersStatsOrderDto".to_string()),
                    "commissions" => return std::result::Result::Err("Parsing a container in this style is not supported in OrdersStatsOrderDto".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing OrdersStatsOrderDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(OrdersStatsOrderDto {
            id: intermediate_rep.id.into_iter().next(),
            creation_date: intermediate_rep.creation_date.into_iter().next(),
            status_update_date: intermediate_rep.status_update_date.into_iter().next(),
            status: intermediate_rep.status.into_iter().next(),
            partner_order_id: intermediate_rep.partner_order_id.into_iter().next(),
            payment_type: intermediate_rep.payment_type.into_iter().next(),
            fake: intermediate_rep.fake.into_iter().next(),
            delivery_region: intermediate_rep.delivery_region.into_iter().next(),
            items: intermediate_rep.items.into_iter().next().ok_or_else(|| "items missing in OrdersStatsOrderDto".to_string())?,
            initial_items: std::result::Result::Err("Nullable types not supported in OrdersStatsOrderDto".to_string())?,
            payments: intermediate_rep.payments.into_iter().next().ok_or_else(|| "payments missing in OrdersStatsOrderDto".to_string())?,
            commissions: intermediate_rep.commissions.into_iter().next().ok_or_else(|| "commissions missing in OrdersStatsOrderDto".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<OrdersStatsOrderDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<OrdersStatsOrderDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<OrdersStatsOrderDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for OrdersStatsOrderDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<OrdersStatsOrderDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <OrdersStatsOrderDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into OrdersStatsOrderDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Тип оплаты заказа: - `CREDIT` — заказ оформлен в кредит. - `POSTPAID` — заказ оплачен после того, как был получен. - `PREPAID` — заказ оплачен до того, как был получен. 
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum OrdersStatsOrderPaymentType {
    #[serde(rename = "CREDIT")]
    Credit,
    #[serde(rename = "POSTPAID")]
    Postpaid,
    #[serde(rename = "PREPAID")]
    Prepaid,
    #[serde(rename = "TINKOFF_CREDIT")]
    TinkoffCredit,
}

impl std::fmt::Display for OrdersStatsOrderPaymentType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            OrdersStatsOrderPaymentType::Credit => write!(f, "CREDIT"),
            OrdersStatsOrderPaymentType::Postpaid => write!(f, "POSTPAID"),
            OrdersStatsOrderPaymentType::Prepaid => write!(f, "PREPAID"),
            OrdersStatsOrderPaymentType::TinkoffCredit => write!(f, "TINKOFF_CREDIT"),
        }
    }
}

impl std::str::FromStr for OrdersStatsOrderPaymentType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "CREDIT" => std::result::Result::Ok(OrdersStatsOrderPaymentType::Credit),
            "POSTPAID" => std::result::Result::Ok(OrdersStatsOrderPaymentType::Postpaid),
            "PREPAID" => std::result::Result::Ok(OrdersStatsOrderPaymentType::Prepaid),
            "TINKOFF_CREDIT" => std::result::Result::Ok(OrdersStatsOrderPaymentType::TinkoffCredit),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Информация о денежных переводах по заказу.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct OrdersStatsPaymentDto {
    /// Идентификатор денежного перевода.
    #[serde(rename = "id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

    /// Дата денежного перевода.  Формат даты: `ГГГГ-ММ-ДД`. 
    #[serde(rename = "date")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub date: Option<chrono::naive::NaiveDate>,

    #[serde(rename = "type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub r#type: Option<models::OrdersStatsPaymentType>,

    #[serde(rename = "source")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub source: Option<models::OrdersStatsPaymentSourceType>,

    /// Сумма денежного перевода. Значение указывается в рублях независимо от способа денежного перевода. Точность — два знака после запятой. 
    #[serde(rename = "total")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub total: Option<f64>,

    #[serde(rename = "paymentOrder")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub payment_order: Option<models::OrdersStatsPaymentOrderDto>,

}


impl OrdersStatsPaymentDto {
    #[allow(clippy::new_without_default)]
    pub fn new() -> OrdersStatsPaymentDto {
        OrdersStatsPaymentDto {
            id: None,
            date: None,
            r#type: None,
            source: None,
            total: None,
            payment_order: None,
        }
    }
}

/// Converts the OrdersStatsPaymentDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for OrdersStatsPaymentDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.id.as_ref().map(|id| {
                [
                    "id".to_string(),
                    id.to_string(),
                ].join(",")
            }),

            // Skipping date in query parameter serialization

            // Skipping type in query parameter serialization

            // Skipping source in query parameter serialization


            self.total.as_ref().map(|total| {
                [
                    "total".to_string(),
                    total.to_string(),
                ].join(",")
            }),

            // Skipping paymentOrder in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a OrdersStatsPaymentDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for OrdersStatsPaymentDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub date: Vec<chrono::naive::NaiveDate>,
            pub r#type: Vec<models::OrdersStatsPaymentType>,
            pub source: Vec<models::OrdersStatsPaymentSourceType>,
            pub total: Vec<f64>,
            pub payment_order: Vec<models::OrdersStatsPaymentOrderDto>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing OrdersStatsPaymentDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "date" => intermediate_rep.date.push(<chrono::naive::NaiveDate as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r#type.push(<models::OrdersStatsPaymentType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "source" => intermediate_rep.source.push(<models::OrdersStatsPaymentSourceType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "total" => intermediate_rep.total.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "paymentOrder" => intermediate_rep.payment_order.push(<models::OrdersStatsPaymentOrderDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing OrdersStatsPaymentDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(OrdersStatsPaymentDto {
            id: intermediate_rep.id.into_iter().next(),
            date: intermediate_rep.date.into_iter().next(),
            r#type: intermediate_rep.r#type.into_iter().next(),
            source: intermediate_rep.source.into_iter().next(),
            total: intermediate_rep.total.into_iter().next(),
            payment_order: intermediate_rep.payment_order.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<OrdersStatsPaymentDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<OrdersStatsPaymentDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<OrdersStatsPaymentDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for OrdersStatsPaymentDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<OrdersStatsPaymentDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <OrdersStatsPaymentDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into OrdersStatsPaymentDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Информация о платежном получении.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct OrdersStatsPaymentOrderDto {
    /// Номер платежного поручения.
    #[serde(rename = "id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

    /// Дата платежного поручения.  Формат даты: `ГГГГ‑ММ‑ДД`. 
    #[serde(rename = "date")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub date: Option<chrono::naive::NaiveDate>,

}


impl OrdersStatsPaymentOrderDto {
    #[allow(clippy::new_without_default)]
    pub fn new() -> OrdersStatsPaymentOrderDto {
        OrdersStatsPaymentOrderDto {
            id: None,
            date: None,
        }
    }
}

/// Converts the OrdersStatsPaymentOrderDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for OrdersStatsPaymentOrderDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.id.as_ref().map(|id| {
                [
                    "id".to_string(),
                    id.to_string(),
                ].join(",")
            }),

            // Skipping date in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a OrdersStatsPaymentOrderDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for OrdersStatsPaymentOrderDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub date: Vec<chrono::naive::NaiveDate>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing OrdersStatsPaymentOrderDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "date" => intermediate_rep.date.push(<chrono::naive::NaiveDate as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing OrdersStatsPaymentOrderDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(OrdersStatsPaymentOrderDto {
            id: intermediate_rep.id.into_iter().next(),
            date: intermediate_rep.date.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<OrdersStatsPaymentOrderDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<OrdersStatsPaymentOrderDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<OrdersStatsPaymentOrderDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for OrdersStatsPaymentOrderDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<OrdersStatsPaymentOrderDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <OrdersStatsPaymentOrderDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into OrdersStatsPaymentOrderDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Способ денежного перевода: - `BUYER` — оплата или возврат деньгами. - `CASHBACK` — оплата или возврат баллами Плюса. - `MARKETPLACE` — оплата или возврат купонами. - `SPLIT` — оплата картой по частям (Сплит). 
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum OrdersStatsPaymentSourceType {
    #[serde(rename = "BUYER")]
    Buyer,
    #[serde(rename = "CASHBACK")]
    Cashback,
    #[serde(rename = "MARKETPLACE")]
    Marketplace,
    #[serde(rename = "SPLIT")]
    Split,
}

impl std::fmt::Display for OrdersStatsPaymentSourceType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            OrdersStatsPaymentSourceType::Buyer => write!(f, "BUYER"),
            OrdersStatsPaymentSourceType::Cashback => write!(f, "CASHBACK"),
            OrdersStatsPaymentSourceType::Marketplace => write!(f, "MARKETPLACE"),
            OrdersStatsPaymentSourceType::Split => write!(f, "SPLIT"),
        }
    }
}

impl std::str::FromStr for OrdersStatsPaymentSourceType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "BUYER" => std::result::Result::Ok(OrdersStatsPaymentSourceType::Buyer),
            "CASHBACK" => std::result::Result::Ok(OrdersStatsPaymentSourceType::Cashback),
            "MARKETPLACE" => std::result::Result::Ok(OrdersStatsPaymentSourceType::Marketplace),
            "SPLIT" => std::result::Result::Ok(OrdersStatsPaymentSourceType::Split),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Тип денежного перевода: - `PAYMENT` — оплата. - `REFUND` — возврат. 
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum OrdersStatsPaymentType {
    #[serde(rename = "PAYMENT")]
    Payment,
    #[serde(rename = "REFUND")]
    Refund,
    #[serde(rename = "UNKNOWN")]
    Unknown,
}

impl std::fmt::Display for OrdersStatsPaymentType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            OrdersStatsPaymentType::Payment => write!(f, "PAYMENT"),
            OrdersStatsPaymentType::Refund => write!(f, "REFUND"),
            OrdersStatsPaymentType::Unknown => write!(f, "UNKNOWN"),
        }
    }
}

impl std::str::FromStr for OrdersStatsPaymentType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "PAYMENT" => std::result::Result::Ok(OrdersStatsPaymentType::Payment),
            "REFUND" => std::result::Result::Ok(OrdersStatsPaymentType::Refund),
            "UNKNOWN" => std::result::Result::Ok(OrdersStatsPaymentType::Unknown),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Цена или скидки на товар.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct OrdersStatsPriceDto {
    #[serde(rename = "type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub r#type: Option<models::OrdersStatsPriceType>,

    /// Цена или скидка на единицу товара в заказе. Указана в рублях. Точность — два знака после запятой. 
    #[serde(rename = "costPerItem")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub cost_per_item: Option<f64>,

    /// Суммарная цена или скидка на все единицы товара в заказе. Указана в рублях. Точность — два знака после запятой. 
    #[serde(rename = "total")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub total: Option<f64>,

}


impl OrdersStatsPriceDto {
    #[allow(clippy::new_without_default)]
    pub fn new() -> OrdersStatsPriceDto {
        OrdersStatsPriceDto {
            r#type: None,
            cost_per_item: None,
            total: None,
        }
    }
}

/// Converts the OrdersStatsPriceDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for OrdersStatsPriceDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping type in query parameter serialization


            self.cost_per_item.as_ref().map(|cost_per_item| {
                [
                    "costPerItem".to_string(),
                    cost_per_item.to_string(),
                ].join(",")
            }),


            self.total.as_ref().map(|total| {
                [
                    "total".to_string(),
                    total.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a OrdersStatsPriceDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for OrdersStatsPriceDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub r#type: Vec<models::OrdersStatsPriceType>,
            pub cost_per_item: Vec<f64>,
            pub total: Vec<f64>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing OrdersStatsPriceDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r#type.push(<models::OrdersStatsPriceType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "costPerItem" => intermediate_rep.cost_per_item.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "total" => intermediate_rep.total.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing OrdersStatsPriceDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(OrdersStatsPriceDto {
            r#type: intermediate_rep.r#type.into_iter().next(),
            cost_per_item: intermediate_rep.cost_per_item.into_iter().next(),
            total: intermediate_rep.total.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<OrdersStatsPriceDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<OrdersStatsPriceDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<OrdersStatsPriceDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for OrdersStatsPriceDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<OrdersStatsPriceDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <OrdersStatsPriceDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into OrdersStatsPriceDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Тип скидки или цена на товар: - `BUYER` — цена на товар с учетом скидок, в том числе купонов. - `CASHBACK` — баллы Плюса. - `MARKETPLACE` — купоны. 
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum OrdersStatsPriceType {
    #[serde(rename = "BUYER")]
    Buyer,
    #[serde(rename = "CASHBACK")]
    Cashback,
    #[serde(rename = "MARKETPLACE")]
    Marketplace,
}

impl std::fmt::Display for OrdersStatsPriceType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            OrdersStatsPriceType::Buyer => write!(f, "BUYER"),
            OrdersStatsPriceType::Cashback => write!(f, "CASHBACK"),
            OrdersStatsPriceType::Marketplace => write!(f, "MARKETPLACE"),
        }
    }
}

impl std::str::FromStr for OrdersStatsPriceType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "BUYER" => std::result::Result::Ok(OrdersStatsPriceType::Buyer),
            "CASHBACK" => std::result::Result::Ok(OrdersStatsPriceType::Cashback),
            "MARKETPLACE" => std::result::Result::Ok(OrdersStatsPriceType::Marketplace),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Тип товара:  * `DEFECT` — товар бракованный.  * `FIT` — товар надлежащего качества. 
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum OrdersStatsStockType {
    #[serde(rename = "FIT")]
    Fit,
    #[serde(rename = "FREEZE")]
    Freeze,
    #[serde(rename = "AVAILABLE")]
    Available,
    #[serde(rename = "QUARANTINE")]
    Quarantine,
    #[serde(rename = "UTILIZATION")]
    Utilization,
    #[serde(rename = "DEFECT")]
    Defect,
    #[serde(rename = "EXPIRED")]
    Expired,
}

impl std::fmt::Display for OrdersStatsStockType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            OrdersStatsStockType::Fit => write!(f, "FIT"),
            OrdersStatsStockType::Freeze => write!(f, "FREEZE"),
            OrdersStatsStockType::Available => write!(f, "AVAILABLE"),
            OrdersStatsStockType::Quarantine => write!(f, "QUARANTINE"),
            OrdersStatsStockType::Utilization => write!(f, "UTILIZATION"),
            OrdersStatsStockType::Defect => write!(f, "DEFECT"),
            OrdersStatsStockType::Expired => write!(f, "EXPIRED"),
        }
    }
}

impl std::str::FromStr for OrdersStatsStockType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "FIT" => std::result::Result::Ok(OrdersStatsStockType::Fit),
            "FREEZE" => std::result::Result::Ok(OrdersStatsStockType::Freeze),
            "AVAILABLE" => std::result::Result::Ok(OrdersStatsStockType::Available),
            "QUARANTINE" => std::result::Result::Ok(OrdersStatsStockType::Quarantine),
            "UTILIZATION" => std::result::Result::Ok(OrdersStatsStockType::Utilization),
            "DEFECT" => std::result::Result::Ok(OrdersStatsStockType::Defect),
            "EXPIRED" => std::result::Result::Ok(OrdersStatsStockType::Expired),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Информация о складе, на котором хранится товар.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct OrdersStatsWarehouseDto {
    /// Идентификатор склада.
    #[serde(rename = "id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,

    /// Название склада.
    #[serde(rename = "name")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

}


impl OrdersStatsWarehouseDto {
    #[allow(clippy::new_without_default)]
    pub fn new() -> OrdersStatsWarehouseDto {
        OrdersStatsWarehouseDto {
            id: None,
            name: None,
        }
    }
}

/// Converts the OrdersStatsWarehouseDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for OrdersStatsWarehouseDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.id.as_ref().map(|id| {
                [
                    "id".to_string(),
                    id.to_string(),
                ].join(",")
            }),


            self.name.as_ref().map(|name| {
                [
                    "name".to_string(),
                    name.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a OrdersStatsWarehouseDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for OrdersStatsWarehouseDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<i64>,
            pub name: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing OrdersStatsWarehouseDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing OrdersStatsWarehouseDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(OrdersStatsWarehouseDto {
            id: intermediate_rep.id.into_iter().next(),
            name: intermediate_rep.name.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<OrdersStatsWarehouseDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<OrdersStatsWarehouseDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<OrdersStatsWarehouseDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for OrdersStatsWarehouseDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<OrdersStatsWarehouseDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <OrdersStatsWarehouseDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into OrdersStatsWarehouseDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Адрес точки продаж. 
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct OutletAddressDto {
    /// Идентификатор региона.  Идентификатор можно получить c помощью запроса [GET regions](../../reference/regions/searchRegionsByName.md).  {% note alert %}  При создании и редактировании точек продаж можно указывать только регионы типов `TOWN` (город), `CITY` (крупный город) и `REPUBLIC_AREA` (район субъекта федерации). Тип региона указан в выходных параметрах type запросов [GET regions](../../reference/regions/searchRegionsByName.md) и [GET regions/{regionId}](../../reference/regions/searchRegionsById.md).  {% endnote %} 
    #[serde(rename = "regionId")]
    pub region_id: i64,

    /// Улица.
    #[serde(rename = "street")]
    #[validate(
            length(max = 512),
        )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub street: Option<String>,

    /// Номер дома.
    #[serde(rename = "number")]
    #[validate(
            length(max = 256),
        )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub number: Option<String>,

    /// Номер строения.
    #[serde(rename = "building")]
    #[validate(
            length(max = 16),
        )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub building: Option<String>,

    /// Номер владения.
    #[serde(rename = "estate")]
    #[validate(
            length(max = 16),
        )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub estate: Option<String>,

    /// Номер корпуса.
    #[serde(rename = "block")]
    #[validate(
            length(max = 16),
        )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub block: Option<String>,

    /// Дополнительная информация.
    #[serde(rename = "additional")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub additional: Option<String>,

    /// Порядковый номер километра дороги, на котором располагается точка продаж, если отсутствует улица.
    #[serde(rename = "km")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub km: Option<i32>,

    /// {% note warning \"\" %}  Этот параметр устарел. Не используйте его. Город или населенный пункт возвращается в параметре `regionId`.  {% endnote %} 
    #[serde(rename = "city")]
    #[validate(
            length(max = 200),
        )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub city: Option<String>,

}


impl OutletAddressDto {
    #[allow(clippy::new_without_default)]
    pub fn new(region_id: i64, ) -> OutletAddressDto {
        OutletAddressDto {
            region_id,
            street: None,
            number: None,
            building: None,
            estate: None,
            block: None,
            additional: None,
            km: None,
            city: None,
        }
    }
}

/// Converts the OutletAddressDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for OutletAddressDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            Some("regionId".to_string()),
            Some(self.region_id.to_string()),


            self.street.as_ref().map(|street| {
                [
                    "street".to_string(),
                    street.to_string(),
                ].join(",")
            }),


            self.number.as_ref().map(|number| {
                [
                    "number".to_string(),
                    number.to_string(),
                ].join(",")
            }),


            self.building.as_ref().map(|building| {
                [
                    "building".to_string(),
                    building.to_string(),
                ].join(",")
            }),


            self.estate.as_ref().map(|estate| {
                [
                    "estate".to_string(),
                    estate.to_string(),
                ].join(",")
            }),


            self.block.as_ref().map(|block| {
                [
                    "block".to_string(),
                    block.to_string(),
                ].join(",")
            }),


            self.additional.as_ref().map(|additional| {
                [
                    "additional".to_string(),
                    additional.to_string(),
                ].join(",")
            }),


            self.km.as_ref().map(|km| {
                [
                    "km".to_string(),
                    km.to_string(),
                ].join(",")
            }),


            self.city.as_ref().map(|city| {
                [
                    "city".to_string(),
                    city.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a OutletAddressDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for OutletAddressDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub region_id: Vec<i64>,
            pub street: Vec<String>,
            pub number: Vec<String>,
            pub building: Vec<String>,
            pub estate: Vec<String>,
            pub block: Vec<String>,
            pub additional: Vec<String>,
            pub km: Vec<i32>,
            pub city: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing OutletAddressDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "regionId" => intermediate_rep.region_id.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "street" => intermediate_rep.street.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "number" => intermediate_rep.number.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "building" => intermediate_rep.building.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "estate" => intermediate_rep.estate.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "block" => intermediate_rep.block.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "additional" => intermediate_rep.additional.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "km" => intermediate_rep.km.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "city" => intermediate_rep.city.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing OutletAddressDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(OutletAddressDto {
            region_id: intermediate_rep.region_id.into_iter().next().ok_or_else(|| "regionId missing in OutletAddressDto".to_string())?,
            street: intermediate_rep.street.into_iter().next(),
            number: intermediate_rep.number.into_iter().next(),
            building: intermediate_rep.building.into_iter().next(),
            estate: intermediate_rep.estate.into_iter().next(),
            block: intermediate_rep.block.into_iter().next(),
            additional: intermediate_rep.additional.into_iter().next(),
            km: intermediate_rep.km.into_iter().next(),
            city: intermediate_rep.city.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<OutletAddressDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<OutletAddressDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<OutletAddressDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for OutletAddressDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<OutletAddressDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <OutletAddressDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into OutletAddressDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Информация об условиях доставки для данной точки продаж.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct OutletDeliveryRuleDto {
    /// Минимальный срок доставки товаров в точку продаж. Указан в рабочих днях.  Минимальное значение: `0` — доставка в день заказа.  Максимальное значение: `60`.  Допустимые сроки доставки (разница между `minDeliveryDays` и `maxDeliveryDays`) зависят от региона.  Для доставки по своему региону разница не должна превышать двух дней. Например, если `minDeliveryDays` равно 1, то для `maxDeliveryDays` допускаются значения от 1 до 3.  Для доставки в другие регионы:  * Если `minDeliveryDays` до 18 дней, разница не должна превышать четырех дней. Например, если `minDeliveryDays` равно 10, то для `maxDeliveryDays` допускаются значения от 10 до 14. * Если `minDeliveryDays` больше 18 дней, разница должна быть не больше чем в два раза. Например, если `minDeliveryDays` равно 21, то для `maxDeliveryDays` допускаются значения от 21 до 42.  Обязательный параметр, если `type=\"DEPOT\"` или `type=\"MIXED\"`.  Взаимоисключающий с параметром `unspecifiedDeliveryInterval`. 
    #[serde(rename = "minDeliveryDays")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub min_delivery_days: Option<i32>,

    /// Максимальный срок доставки товаров в точку продаж. Указан в рабочих днях.  Минимальное значение: `0` — доставка в день заказа.  Максимальное значение: `60`.  Допустимые сроки доставки (разница между `minDeliveryDays` и `maxDeliveryDays`) зависят от региона.  Для доставки по своему региону разница не должна превышать двух дней. Например, если `minDeliveryDays` равно 1, то для `maxDeliveryDays` допускаются значения от 1 до 3.  Для доставки в другие регионы:  * Если `minDeliveryDays` до 18 дней, разница не должна превышать четырех дней. Например, если `minDeliveryDays` равно 10, то для `maxDeliveryDays` допускаются значения от 10 до 14. * Если `minDeliveryDays` больше 18 дней, разница должна быть не больше чем в два раза. Например, если `minDeliveryDays` равно 21, то для `maxDeliveryDays` допускаются значения от 21 до 42.  Обязательный параметр, если `type=\"DEPOT\"` или `type=\"MIXED\"`.  Взаимоисключающий с параметром `unspecifiedDeliveryInterval`. 
    #[serde(rename = "maxDeliveryDays")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub max_delivery_days: Option<i32>,

    /// Идентификатор службы доставки товаров в точку продаж.  Информацию о службе доставки можно получить с помощью запроса [GET delivery/services](../../reference/orders/getDeliveryServices.md). 
    #[serde(rename = "deliveryServiceId")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub delivery_service_id: Option<i64>,

    /// Час, до которого покупателю нужно сделать заказ, чтобы он был доставлен в точку продаж в сроки от `minDeliveryDays` до `maxDeliveryDays`.  Если покупатель оформит заказ после указанного часа, он будет доставлен в сроки от `minDeliveryDays` + 1 рабочий день до `maxDeliveryDays` + 1 рабочий день.  Значение по умолчанию: `24`. 
    #[serde(rename = "orderBefore")]
    #[validate(
            range(min = 0, max = 24),
        )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub order_before: Option<u32>,

    /// Цена на товар, начиная с которой действует бесплатный самовывоз товара из точки продаж.
    #[serde(rename = "priceFreePickup")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub price_free_pickup: Option<f64>,

    /// Признак доставки товаров в точку продаж на заказ.  Признак выставлен, если:  * точный срок доставки в точку продаж заранее неизвестен (например, если магазин собирает несколько заказов для отправки в точку или населенный пункт); * все товары изготавливаются или поставляются на заказ.  Возможные значения: * `true` — товары доставляются в точку продаж на заказ.  Параметр указывается только со значением `true`.  Взаимоисключающий с параметрами `minDeliveryDays` и `maxDeliveryDays`. 
    #[serde(rename = "unspecifiedDeliveryInterval")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub unspecified_delivery_interval: Option<bool>,

}


impl OutletDeliveryRuleDto {
    #[allow(clippy::new_without_default)]
    pub fn new() -> OutletDeliveryRuleDto {
        OutletDeliveryRuleDto {
            min_delivery_days: None,
            max_delivery_days: None,
            delivery_service_id: None,
            order_before: None,
            price_free_pickup: None,
            unspecified_delivery_interval: None,
        }
    }
}

/// Converts the OutletDeliveryRuleDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for OutletDeliveryRuleDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.min_delivery_days.as_ref().map(|min_delivery_days| {
                [
                    "minDeliveryDays".to_string(),
                    min_delivery_days.to_string(),
                ].join(",")
            }),


            self.max_delivery_days.as_ref().map(|max_delivery_days| {
                [
                    "maxDeliveryDays".to_string(),
                    max_delivery_days.to_string(),
                ].join(",")
            }),


            self.delivery_service_id.as_ref().map(|delivery_service_id| {
                [
                    "deliveryServiceId".to_string(),
                    delivery_service_id.to_string(),
                ].join(",")
            }),


            self.order_before.as_ref().map(|order_before| {
                [
                    "orderBefore".to_string(),
                    order_before.to_string(),
                ].join(",")
            }),


            self.price_free_pickup.as_ref().map(|price_free_pickup| {
                [
                    "priceFreePickup".to_string(),
                    price_free_pickup.to_string(),
                ].join(",")
            }),


            self.unspecified_delivery_interval.as_ref().map(|unspecified_delivery_interval| {
                [
                    "unspecifiedDeliveryInterval".to_string(),
                    unspecified_delivery_interval.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a OutletDeliveryRuleDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for OutletDeliveryRuleDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub min_delivery_days: Vec<i32>,
            pub max_delivery_days: Vec<i32>,
            pub delivery_service_id: Vec<i64>,
            pub order_before: Vec<u32>,
            pub price_free_pickup: Vec<f64>,
            pub unspecified_delivery_interval: Vec<bool>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing OutletDeliveryRuleDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "minDeliveryDays" => intermediate_rep.min_delivery_days.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "maxDeliveryDays" => intermediate_rep.max_delivery_days.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "deliveryServiceId" => intermediate_rep.delivery_service_id.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "orderBefore" => intermediate_rep.order_before.push(<u32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "priceFreePickup" => intermediate_rep.price_free_pickup.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "unspecifiedDeliveryInterval" => intermediate_rep.unspecified_delivery_interval.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing OutletDeliveryRuleDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(OutletDeliveryRuleDto {
            min_delivery_days: intermediate_rep.min_delivery_days.into_iter().next(),
            max_delivery_days: intermediate_rep.max_delivery_days.into_iter().next(),
            delivery_service_id: intermediate_rep.delivery_service_id.into_iter().next(),
            order_before: intermediate_rep.order_before.into_iter().next(),
            price_free_pickup: intermediate_rep.price_free_pickup.into_iter().next(),
            unspecified_delivery_interval: intermediate_rep.unspecified_delivery_interval.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<OutletDeliveryRuleDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<OutletDeliveryRuleDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<OutletDeliveryRuleDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for OutletDeliveryRuleDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<OutletDeliveryRuleDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <OutletDeliveryRuleDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into OutletDeliveryRuleDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Информация о точке продаж.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct OutletDto {
    /// Название точки продаж. 
    #[serde(rename = "name")]
    pub name: String,

    #[serde(rename = "type")]
    pub r#type: models::OutletType,

    /// Координаты точки продаж.  Формат: долгота, широта. Разделители: запятая и / или пробел. Например, `20.4522144, 54.7104264`.  Если параметр не передан, координаты будут определены по значениям параметров, вложенных в `address`. 
    #[serde(rename = "coords")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub coords: Option<String>,

    /// Признак основной точки продаж.  Возможные значения:  * `false` — неосновная точка продаж. * `true` — основная точка продаж. 
    #[serde(rename = "isMain")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub is_main: Option<bool>,

    /// Идентификатор точки продаж, присвоенный магазином.
    #[serde(rename = "shopOutletCode")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub shop_outlet_code: Option<String>,

    #[serde(rename = "visibility")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub visibility: Option<models::OutletVisibilityType>,

    #[serde(rename = "address")]
    pub address: models::OutletAddressDto,

    /// Номера телефонов точки продаж. Передавайте в формате: `+7 (999) 999-99-99`. 
    #[serde(rename = "phones")]
    #[validate(
            length(min = 1),
        )]
    pub phones: Vec<String>,

    #[serde(rename = "workingSchedule")]
    pub working_schedule: models::OutletWorkingScheduleDto,

    /// Информация об условиях доставки для данной точки продаж.  Обязательный параметр, если параметр `type=DEPOT` или `type=MIXED`. 
    #[serde(rename = "deliveryRules")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub delivery_rules: Option<swagger::Nullable<Vec<models::OutletDeliveryRuleDto>>>,

    /// Срок хранения заказа в собственном пункте выдачи заказов. Считается в днях.
    #[serde(rename = "storagePeriod")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub storage_period: Option<i64>,

}


impl OutletDto {
    #[allow(clippy::new_without_default)]
    pub fn new(name: String, r#type: models::OutletType, address: models::OutletAddressDto, phones: Vec<String>, working_schedule: models::OutletWorkingScheduleDto, ) -> OutletDto {
        OutletDto {
            name,
            r#type,
            coords: None,
            is_main: None,
            shop_outlet_code: None,
            visibility: None,
            address,
            phones,
            working_schedule,
            delivery_rules: None,
            storage_period: None,
        }
    }
}

/// Converts the OutletDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for OutletDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            Some("name".to_string()),
            Some(self.name.to_string()),

            // Skipping type in query parameter serialization


            self.coords.as_ref().map(|coords| {
                [
                    "coords".to_string(),
                    coords.to_string(),
                ].join(",")
            }),


            self.is_main.as_ref().map(|is_main| {
                [
                    "isMain".to_string(),
                    is_main.to_string(),
                ].join(",")
            }),


            self.shop_outlet_code.as_ref().map(|shop_outlet_code| {
                [
                    "shopOutletCode".to_string(),
                    shop_outlet_code.to_string(),
                ].join(",")
            }),

            // Skipping visibility in query parameter serialization

            // Skipping address in query parameter serialization


            Some("phones".to_string()),
            Some(self.phones.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),

            // Skipping workingSchedule in query parameter serialization

            // Skipping deliveryRules in query parameter serialization


            self.storage_period.as_ref().map(|storage_period| {
                [
                    "storagePeriod".to_string(),
                    storage_period.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a OutletDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for OutletDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub name: Vec<String>,
            pub r#type: Vec<models::OutletType>,
            pub coords: Vec<String>,
            pub is_main: Vec<bool>,
            pub shop_outlet_code: Vec<String>,
            pub visibility: Vec<models::OutletVisibilityType>,
            pub address: Vec<models::OutletAddressDto>,
            pub phones: Vec<Vec<String>>,
            pub working_schedule: Vec<models::OutletWorkingScheduleDto>,
            pub delivery_rules: Vec<Vec<models::OutletDeliveryRuleDto>>,
            pub storage_period: Vec<i64>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing OutletDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r#type.push(<models::OutletType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "coords" => intermediate_rep.coords.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "isMain" => intermediate_rep.is_main.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "shopOutletCode" => intermediate_rep.shop_outlet_code.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "visibility" => intermediate_rep.visibility.push(<models::OutletVisibilityType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "address" => intermediate_rep.address.push(<models::OutletAddressDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "phones" => return std::result::Result::Err("Parsing a container in this style is not supported in OutletDto".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "workingSchedule" => intermediate_rep.working_schedule.push(<models::OutletWorkingScheduleDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "deliveryRules" => return std::result::Result::Err("Parsing a container in this style is not supported in OutletDto".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "storagePeriod" => intermediate_rep.storage_period.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing OutletDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(OutletDto {
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "name missing in OutletDto".to_string())?,
            r#type: intermediate_rep.r#type.into_iter().next().ok_or_else(|| "type missing in OutletDto".to_string())?,
            coords: intermediate_rep.coords.into_iter().next(),
            is_main: intermediate_rep.is_main.into_iter().next(),
            shop_outlet_code: intermediate_rep.shop_outlet_code.into_iter().next(),
            visibility: intermediate_rep.visibility.into_iter().next(),
            address: intermediate_rep.address.into_iter().next().ok_or_else(|| "address missing in OutletDto".to_string())?,
            phones: intermediate_rep.phones.into_iter().next().ok_or_else(|| "phones missing in OutletDto".to_string())?,
            working_schedule: intermediate_rep.working_schedule.into_iter().next().ok_or_else(|| "workingSchedule missing in OutletDto".to_string())?,
            delivery_rules: std::result::Result::Err("Nullable types not supported in OutletDto".to_string())?,
            storage_period: intermediate_rep.storage_period.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<OutletDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<OutletDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<OutletDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for OutletDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<OutletDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <OutletDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into OutletDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Информация о лицензии.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct OutletLicenseDto {
    /// Идентификатор лицензии.  Параметр указывается, только если нужно изменить информацию о существующей лицензии. Ее идентификатор можно узнать с помощью запроса [GET campaigns/{campaignId}/outlets/licenses](../../reference/outlets/getOutletLicenses.md). При передаче информации о новой лицензии указывать идентификатор не нужно.  Идентификатор лицензии присваивается Маркетом. Не путайте его с номером, указанным на лицензии: он передается в параметре `number`. 
    #[serde(rename = "id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,

    /// Идентификатор точки продаж, для которой действительна лицензия.
    #[serde(rename = "outletId")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub outlet_id: Option<i64>,

    #[serde(rename = "licenseType")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub license_type: Option<models::LicenseType>,

    /// Номер лицензии.
    #[serde(rename = "number")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub number: Option<String>,

    /// Дата выдачи лицензии.  Формат даты: ISO 8601 со смещением относительно UTC. Нужно передать дату, указанную на лицензии, время `00:00:00` и часовой пояс, соответствующий региону точки продаж. Например, если лицензия для точки продаж в Москве выдана 13 ноября 2017 года, то параметр должен иметь значение `2017-11-13T00:00:00+03:00`.  Обязательный параметр.  Не может быть позже даты окончания срока действия, указанной в параметре `dateOfExpiry`. 
    #[serde(rename = "dateOfIssue")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub date_of_issue: Option<chrono::DateTime::<chrono::Utc>>,

    /// Дата окончания действия лицензии.  Формат даты: ISO 8601 со смещением относительно UTC. Нужно передать дату, указанную на лицензии, время `00:00:00` и часовой пояс, соответствующий региону точки продаж. Например, если действие лицензии для точки продаж в Москве заканчивается 20 ноября 2022 года, то параметр должен иметь значение `2022-11-20T00:00:00+03:00`.  Обязательный параметр.  Не может быть раньше даты выдачи, указанной в параметре `dateOfIssue`. 
    #[serde(rename = "dateOfExpiry")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub date_of_expiry: Option<chrono::DateTime::<chrono::Utc>>,

}


impl OutletLicenseDto {
    #[allow(clippy::new_without_default)]
    pub fn new() -> OutletLicenseDto {
        OutletLicenseDto {
            id: None,
            outlet_id: None,
            license_type: None,
            number: None,
            date_of_issue: None,
            date_of_expiry: None,
        }
    }
}

/// Converts the OutletLicenseDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for OutletLicenseDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.id.as_ref().map(|id| {
                [
                    "id".to_string(),
                    id.to_string(),
                ].join(",")
            }),


            self.outlet_id.as_ref().map(|outlet_id| {
                [
                    "outletId".to_string(),
                    outlet_id.to_string(),
                ].join(",")
            }),

            // Skipping licenseType in query parameter serialization


            self.number.as_ref().map(|number| {
                [
                    "number".to_string(),
                    number.to_string(),
                ].join(",")
            }),

            // Skipping dateOfIssue in query parameter serialization

            // Skipping dateOfExpiry in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a OutletLicenseDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for OutletLicenseDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<i64>,
            pub outlet_id: Vec<i64>,
            pub license_type: Vec<models::LicenseType>,
            pub number: Vec<String>,
            pub date_of_issue: Vec<chrono::DateTime::<chrono::Utc>>,
            pub date_of_expiry: Vec<chrono::DateTime::<chrono::Utc>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing OutletLicenseDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "outletId" => intermediate_rep.outlet_id.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "licenseType" => intermediate_rep.license_type.push(<models::LicenseType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "number" => intermediate_rep.number.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "dateOfIssue" => intermediate_rep.date_of_issue.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "dateOfExpiry" => intermediate_rep.date_of_expiry.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing OutletLicenseDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(OutletLicenseDto {
            id: intermediate_rep.id.into_iter().next(),
            outlet_id: intermediate_rep.outlet_id.into_iter().next(),
            license_type: intermediate_rep.license_type.into_iter().next(),
            number: intermediate_rep.number.into_iter().next(),
            date_of_issue: intermediate_rep.date_of_issue.into_iter().next(),
            date_of_expiry: intermediate_rep.date_of_expiry.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<OutletLicenseDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<OutletLicenseDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<OutletLicenseDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for OutletLicenseDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<OutletLicenseDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <OutletLicenseDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into OutletLicenseDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Ответ на запрос информации о лицензиях для точек продаж.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct OutletLicensesResponseDto {
    /// Список лицензий.
    #[serde(rename = "licenses")]
    pub licenses: Vec<models::FullOutletLicenseDto>,

}


impl OutletLicensesResponseDto {
    #[allow(clippy::new_without_default)]
    pub fn new(licenses: Vec<models::FullOutletLicenseDto>, ) -> OutletLicensesResponseDto {
        OutletLicensesResponseDto {
            licenses,
        }
    }
}

/// Converts the OutletLicensesResponseDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for OutletLicensesResponseDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping licenses in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a OutletLicensesResponseDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for OutletLicensesResponseDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub licenses: Vec<Vec<models::FullOutletLicenseDto>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing OutletLicensesResponseDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "licenses" => return std::result::Result::Err("Parsing a container in this style is not supported in OutletLicensesResponseDto".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing OutletLicensesResponseDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(OutletLicensesResponseDto {
            licenses: intermediate_rep.licenses.into_iter().next().ok_or_else(|| "licenses missing in OutletLicensesResponseDto".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<OutletLicensesResponseDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<OutletLicensesResponseDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<OutletLicensesResponseDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for OutletLicensesResponseDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<OutletLicensesResponseDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <OutletLicensesResponseDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into OutletLicensesResponseDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Результат выполнения запроса. Выводится, если `status=\"OK\"`. 
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct OutletResponseDto {
    /// Идентификатор точки продаж, присвоенный Маркетом.
    #[serde(rename = "id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,

}


impl OutletResponseDto {
    #[allow(clippy::new_without_default)]
    pub fn new() -> OutletResponseDto {
        OutletResponseDto {
            id: None,
        }
    }
}

/// Converts the OutletResponseDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for OutletResponseDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.id.as_ref().map(|id| {
                [
                    "id".to_string(),
                    id.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a OutletResponseDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for OutletResponseDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<i64>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing OutletResponseDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing OutletResponseDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(OutletResponseDto {
            id: intermediate_rep.id.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<OutletResponseDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<OutletResponseDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<OutletResponseDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for OutletResponseDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<OutletResponseDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <OutletResponseDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into OutletResponseDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Статус точки продаж.  Возможные значения:  * `AT_MODERATION` — проверяется. * `FAILED` — не прошла проверку и отклонена модератором. * `MODERATED` — проверена и одобрена. * `NONMODERATED` — новая точка, нуждается в проверке. 
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum OutletStatusType {
    #[serde(rename = "AT_MODERATION")]
    AtModeration,
    #[serde(rename = "FAILED")]
    Failed,
    #[serde(rename = "MODERATED")]
    Moderated,
    #[serde(rename = "NONMODERATED")]
    Nonmoderated,
    #[serde(rename = "UNKNOWN")]
    Unknown,
}

impl std::fmt::Display for OutletStatusType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            OutletStatusType::AtModeration => write!(f, "AT_MODERATION"),
            OutletStatusType::Failed => write!(f, "FAILED"),
            OutletStatusType::Moderated => write!(f, "MODERATED"),
            OutletStatusType::Nonmoderated => write!(f, "NONMODERATED"),
            OutletStatusType::Unknown => write!(f, "UNKNOWN"),
        }
    }
}

impl std::str::FromStr for OutletStatusType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "AT_MODERATION" => std::result::Result::Ok(OutletStatusType::AtModeration),
            "FAILED" => std::result::Result::Ok(OutletStatusType::Failed),
            "MODERATED" => std::result::Result::Ok(OutletStatusType::Moderated),
            "NONMODERATED" => std::result::Result::Ok(OutletStatusType::Nonmoderated),
            "UNKNOWN" => std::result::Result::Ok(OutletStatusType::Unknown),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Тип точки продаж.  Возможные значения:  * `DEPOT` — пункт выдачи заказов. * `MIXED` — смешанный тип точки продаж (торговый зал и пункт выдачи заказов). * `RETAIL` — розничная точка продаж (торговый зал). 
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum OutletType {
    #[serde(rename = "DEPOT")]
    Depot,
    #[serde(rename = "MIXED")]
    Mixed,
    #[serde(rename = "RETAIL")]
    Retail,
    #[serde(rename = "NOT_DEFINED")]
    NotDefined,
}

impl std::fmt::Display for OutletType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            OutletType::Depot => write!(f, "DEPOT"),
            OutletType::Mixed => write!(f, "MIXED"),
            OutletType::Retail => write!(f, "RETAIL"),
            OutletType::NotDefined => write!(f, "NOT_DEFINED"),
        }
    }
}

impl std::str::FromStr for OutletType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "DEPOT" => std::result::Result::Ok(OutletType::Depot),
            "MIXED" => std::result::Result::Ok(OutletType::Mixed),
            "RETAIL" => std::result::Result::Ok(OutletType::Retail),
            "NOT_DEFINED" => std::result::Result::Ok(OutletType::NotDefined),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Состояние точки продаж.  Возможные значения:  * `HIDDEN` — точка продаж выключена. * `VISIBLE` — точка продаж включена. 
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum OutletVisibilityType {
    #[serde(rename = "HIDDEN")]
    Hidden,
    #[serde(rename = "VISIBLE")]
    Visible,
    #[serde(rename = "UNKNOWN")]
    Unknown,
}

impl std::fmt::Display for OutletVisibilityType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            OutletVisibilityType::Hidden => write!(f, "HIDDEN"),
            OutletVisibilityType::Visible => write!(f, "VISIBLE"),
            OutletVisibilityType::Unknown => write!(f, "UNKNOWN"),
        }
    }
}

impl std::str::FromStr for OutletVisibilityType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "HIDDEN" => std::result::Result::Ok(OutletVisibilityType::Hidden),
            "VISIBLE" => std::result::Result::Ok(OutletVisibilityType::Visible),
            "UNKNOWN" => std::result::Result::Ok(OutletVisibilityType::Unknown),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Список режимов работы точки продаж. 
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct OutletWorkingScheduleDto {
    /// Признак, работает ли точка продаж в дни государственных праздников.  Возможные значения:  * `false` — точка продаж не работает в дни государственных праздников. * `true` — точка продаж работает в дни государственных праздников. 
    #[serde(rename = "workInHoliday")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub work_in_holiday: Option<bool>,

    /// Список расписаний работы точки продаж. 
    #[serde(rename = "scheduleItems")]
    #[validate(
            length(min = 1),
        )]
    pub schedule_items: Vec<models::OutletWorkingScheduleItemDto>,

}


impl OutletWorkingScheduleDto {
    #[allow(clippy::new_without_default)]
    pub fn new(schedule_items: Vec<models::OutletWorkingScheduleItemDto>, ) -> OutletWorkingScheduleDto {
        OutletWorkingScheduleDto {
            work_in_holiday: None,
            schedule_items,
        }
    }
}

/// Converts the OutletWorkingScheduleDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for OutletWorkingScheduleDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.work_in_holiday.as_ref().map(|work_in_holiday| {
                [
                    "workInHoliday".to_string(),
                    work_in_holiday.to_string(),
                ].join(",")
            }),

            // Skipping scheduleItems in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a OutletWorkingScheduleDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for OutletWorkingScheduleDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub work_in_holiday: Vec<bool>,
            pub schedule_items: Vec<Vec<models::OutletWorkingScheduleItemDto>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing OutletWorkingScheduleDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "workInHoliday" => intermediate_rep.work_in_holiday.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "scheduleItems" => return std::result::Result::Err("Parsing a container in this style is not supported in OutletWorkingScheduleDto".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing OutletWorkingScheduleDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(OutletWorkingScheduleDto {
            work_in_holiday: intermediate_rep.work_in_holiday.into_iter().next(),
            schedule_items: intermediate_rep.schedule_items.into_iter().next().ok_or_else(|| "scheduleItems missing in OutletWorkingScheduleDto".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<OutletWorkingScheduleDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<OutletWorkingScheduleDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<OutletWorkingScheduleDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for OutletWorkingScheduleDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<OutletWorkingScheduleDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <OutletWorkingScheduleDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into OutletWorkingScheduleDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Расписание работы точки продаж.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct OutletWorkingScheduleItemDto {
    #[serde(rename = "startDay")]
    pub start_day: models::DayOfWeekType,

    #[serde(rename = "endDay")]
    pub end_day: models::DayOfWeekType,

    /// Точка продаж работает c указанного часа.  Формат: `ЧЧ:ММ`. 
    #[serde(rename = "startTime")]
    #[validate(
            length(min = 1),
        )]
    pub start_time: String,

    /// Точка продаж работает до указанного часа.  Формат: `ЧЧ:ММ`. 
    #[serde(rename = "endTime")]
    #[validate(
            length(min = 1),
        )]
    pub end_time: String,

}


impl OutletWorkingScheduleItemDto {
    #[allow(clippy::new_without_default)]
    pub fn new(start_day: models::DayOfWeekType, end_day: models::DayOfWeekType, start_time: String, end_time: String, ) -> OutletWorkingScheduleItemDto {
        OutletWorkingScheduleItemDto {
            start_day,
            end_day,
            start_time,
            end_time,
        }
    }
}

/// Converts the OutletWorkingScheduleItemDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for OutletWorkingScheduleItemDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping startDay in query parameter serialization

            // Skipping endDay in query parameter serialization


            Some("startTime".to_string()),
            Some(self.start_time.to_string()),


            Some("endTime".to_string()),
            Some(self.end_time.to_string()),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a OutletWorkingScheduleItemDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for OutletWorkingScheduleItemDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub start_day: Vec<models::DayOfWeekType>,
            pub end_day: Vec<models::DayOfWeekType>,
            pub start_time: Vec<String>,
            pub end_time: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing OutletWorkingScheduleItemDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "startDay" => intermediate_rep.start_day.push(<models::DayOfWeekType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "endDay" => intermediate_rep.end_day.push(<models::DayOfWeekType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "startTime" => intermediate_rep.start_time.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "endTime" => intermediate_rep.end_time.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing OutletWorkingScheduleItemDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(OutletWorkingScheduleItemDto {
            start_day: intermediate_rep.start_day.into_iter().next().ok_or_else(|| "startDay missing in OutletWorkingScheduleItemDto".to_string())?,
            end_day: intermediate_rep.end_day.into_iter().next().ok_or_else(|| "endDay missing in OutletWorkingScheduleItemDto".to_string())?,
            start_time: intermediate_rep.start_time.into_iter().next().ok_or_else(|| "startTime missing in OutletWorkingScheduleItemDto".to_string())?,
            end_time: intermediate_rep.end_time.into_iter().next().ok_or_else(|| "endTime missing in OutletWorkingScheduleItemDto".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<OutletWorkingScheduleItemDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<OutletWorkingScheduleItemDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<OutletWorkingScheduleItemDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for OutletWorkingScheduleItemDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<OutletWorkingScheduleItemDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <OutletWorkingScheduleItemDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into OutletWorkingScheduleItemDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Размещение ярлыков на странице: * `A7` — в PDF-файле будут страницы формата близкому к A7. На каждой странице размещается ярлык размером 75 × 120 мм (80,4 × 125,6 мм с учетом полей). * `A4` — в PDF-файле будут страницы формата A4. На каждой странице размещаются восемь ярлыков размером 70,6 × 99,1 мм без полей. 
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum PageFormatType {
    #[serde(rename = "A7")]
    A7,
    #[serde(rename = "A4")]
    A4,
}

impl std::fmt::Display for PageFormatType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            PageFormatType::A7 => write!(f, "A7"),
            PageFormatType::A4 => write!(f, "A4"),
        }
    }
}

impl std::str::FromStr for PageFormatType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "A7" => std::result::Result::Ok(PageFormatType::A7),
            "A4" => std::result::Result::Ok(PageFormatType::A4),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Возвраты.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PagedReturnsDto {
    #[serde(rename = "paging")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub paging: Option<models::ForwardScrollingPagerDto>,

    /// Список возвратов.
    #[serde(rename = "returns")]
    pub returns: Vec<models::ReturnDto>,

}


impl PagedReturnsDto {
    #[allow(clippy::new_without_default)]
    pub fn new(returns: Vec<models::ReturnDto>, ) -> PagedReturnsDto {
        PagedReturnsDto {
            paging: None,
            returns,
        }
    }
}

/// Converts the PagedReturnsDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for PagedReturnsDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping paging in query parameter serialization

            // Skipping returns in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PagedReturnsDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PagedReturnsDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub paging: Vec<models::ForwardScrollingPagerDto>,
            pub returns: Vec<Vec<models::ReturnDto>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PagedReturnsDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "paging" => intermediate_rep.paging.push(<models::ForwardScrollingPagerDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "returns" => return std::result::Result::Err("Parsing a container in this style is not supported in PagedReturnsDto".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing PagedReturnsDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PagedReturnsDto {
            paging: intermediate_rep.paging.into_iter().next(),
            returns: intermediate_rep.returns.into_iter().next().ok_or_else(|| "returns missing in PagedReturnsDto".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PagedReturnsDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<PagedReturnsDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PagedReturnsDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for PagedReturnsDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<PagedReturnsDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PagedReturnsDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into PagedReturnsDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Количество палет в отгрузке.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PalletsCountDto {
    /// Количество палет, которое заявил продавец.
    #[serde(rename = "planned")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub planned: Option<i32>,

    /// Количество палет, которое приняли в сортировочном центре.
    #[serde(rename = "fact")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub fact: Option<i32>,

}


impl PalletsCountDto {
    #[allow(clippy::new_without_default)]
    pub fn new() -> PalletsCountDto {
        PalletsCountDto {
            planned: None,
            fact: None,
        }
    }
}

/// Converts the PalletsCountDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for PalletsCountDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.planned.as_ref().map(|planned| {
                [
                    "planned".to_string(),
                    planned.to_string(),
                ].join(",")
            }),


            self.fact.as_ref().map(|fact| {
                [
                    "fact".to_string(),
                    fact.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PalletsCountDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PalletsCountDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub planned: Vec<i32>,
            pub fact: Vec<i32>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PalletsCountDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "planned" => intermediate_rep.planned.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "fact" => intermediate_rep.fact.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing PalletsCountDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PalletsCountDto {
            planned: intermediate_rep.planned.into_iter().next(),
            fact: intermediate_rep.fact.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PalletsCountDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<PalletsCountDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PalletsCountDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for PalletsCountDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<PalletsCountDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PalletsCountDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into PalletsCountDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Тип данных:  * `TEXT` — текст. * `ENUM` — список возможных значений. * `BOOLEAN` — `true` или `false`. * `NUMERIC` — число. 
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum ParameterType {
    #[serde(rename = "TEXT")]
    Text,
    #[serde(rename = "ENUM")]
    Enum,
    #[serde(rename = "BOOLEAN")]
    Boolean,
    #[serde(rename = "NUMERIC")]
    Numeric,
}

impl std::fmt::Display for ParameterType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            ParameterType::Text => write!(f, "TEXT"),
            ParameterType::Enum => write!(f, "ENUM"),
            ParameterType::Boolean => write!(f, "BOOLEAN"),
            ParameterType::Numeric => write!(f, "NUMERIC"),
        }
    }
}

impl std::str::FromStr for ParameterType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "TEXT" => std::result::Result::Ok(ParameterType::Text),
            "ENUM" => std::result::Result::Ok(ParameterType::Enum),
            "BOOLEAN" => std::result::Result::Ok(ParameterType::Boolean),
            "NUMERIC" => std::result::Result::Ok(ParameterType::Numeric),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Ограничения на значения характеристик.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ParameterValueConstraintsDto {
    /// Минимальное число.
    #[serde(rename = "minValue")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub min_value: Option<f64>,

    /// Максимальное число.
    #[serde(rename = "maxValue")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub max_value: Option<f64>,

    /// Максимальная длина текста.
    #[serde(rename = "maxLength")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub max_length: Option<i32>,

}


impl ParameterValueConstraintsDto {
    #[allow(clippy::new_without_default)]
    pub fn new() -> ParameterValueConstraintsDto {
        ParameterValueConstraintsDto {
            min_value: None,
            max_value: None,
            max_length: None,
        }
    }
}

/// Converts the ParameterValueConstraintsDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ParameterValueConstraintsDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.min_value.as_ref().map(|min_value| {
                [
                    "minValue".to_string(),
                    min_value.to_string(),
                ].join(",")
            }),


            self.max_value.as_ref().map(|max_value| {
                [
                    "maxValue".to_string(),
                    max_value.to_string(),
                ].join(",")
            }),


            self.max_length.as_ref().map(|max_length| {
                [
                    "maxLength".to_string(),
                    max_length.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ParameterValueConstraintsDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ParameterValueConstraintsDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub min_value: Vec<f64>,
            pub max_value: Vec<f64>,
            pub max_length: Vec<i32>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ParameterValueConstraintsDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "minValue" => intermediate_rep.min_value.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "maxValue" => intermediate_rep.max_value.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "maxLength" => intermediate_rep.max_length.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ParameterValueConstraintsDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ParameterValueConstraintsDto {
            min_value: intermediate_rep.min_value.into_iter().next(),
            max_value: intermediate_rep.max_value.into_iter().next(),
            max_length: intermediate_rep.max_length.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ParameterValueConstraintsDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<ParameterValueConstraintsDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ParameterValueConstraintsDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ParameterValueConstraintsDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<ParameterValueConstraintsDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ParameterValueConstraintsDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ParameterValueConstraintsDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Значение характеристики.  Вы можете указывать несколько значений одной характеристики при условии, что:  * Тип характеристики — `ENUM`. * В ответе на запрос [POST category/{categoryId}/parameters](../../reference/content/getCategoryContentParameters.md) у данной характеристики поле `multivalue` имеет значение `true`.  Для этого в `parameterValues` передавайте каждое значение отдельно — несколько объектов с параметрами `parameterId`, `valueId` и `value`. Параметр `parameterId` должен быть одинаковым. 
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ParameterValueDto {
    /// Идентификатор характеристики.
    #[serde(rename = "parameterId")]
    pub parameter_id: i64,

    /// Идентификатор единицы измерения. Если вы не передали параметр `unitId`, используется единица измерения по умолчанию.
    #[serde(rename = "unitId")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub unit_id: Option<i64>,

    /// Идентификатор значения.  Обязательно указывайте идентификатор, если передаете значение из перечня допустимых значений, полученного от Маркета.  Только для характеристик типа `ENUM`. 
    #[serde(rename = "valueId")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub value_id: Option<i64>,

    /// Значение.
    #[serde(rename = "value")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub value: Option<String>,

}


impl ParameterValueDto {
    #[allow(clippy::new_without_default)]
    pub fn new(parameter_id: i64, ) -> ParameterValueDto {
        ParameterValueDto {
            parameter_id,
            unit_id: None,
            value_id: None,
            value: None,
        }
    }
}

/// Converts the ParameterValueDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ParameterValueDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            Some("parameterId".to_string()),
            Some(self.parameter_id.to_string()),


            self.unit_id.as_ref().map(|unit_id| {
                [
                    "unitId".to_string(),
                    unit_id.to_string(),
                ].join(",")
            }),


            self.value_id.as_ref().map(|value_id| {
                [
                    "valueId".to_string(),
                    value_id.to_string(),
                ].join(",")
            }),


            self.value.as_ref().map(|value| {
                [
                    "value".to_string(),
                    value.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ParameterValueDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ParameterValueDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub parameter_id: Vec<i64>,
            pub unit_id: Vec<i64>,
            pub value_id: Vec<i64>,
            pub value: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ParameterValueDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "parameterId" => intermediate_rep.parameter_id.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "unitId" => intermediate_rep.unit_id.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "valueId" => intermediate_rep.value_id.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "value" => intermediate_rep.value.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ParameterValueDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ParameterValueDto {
            parameter_id: intermediate_rep.parameter_id.into_iter().next().ok_or_else(|| "parameterId missing in ParameterValueDto".to_string())?,
            unit_id: intermediate_rep.unit_id.into_iter().next(),
            value_id: intermediate_rep.value_id.into_iter().next(),
            value: intermediate_rep.value.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ParameterValueDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<ParameterValueDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ParameterValueDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ParameterValueDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<ParameterValueDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ParameterValueDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ParameterValueDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Значение характеристики.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ParameterValueOptionDto {
    /// Идентификатор значения.
    #[serde(rename = "id")]
    pub id: i64,

    /// Значение.
    #[serde(rename = "value")]
    pub value: String,

    /// Описание значения.
    #[serde(rename = "description")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,

}


impl ParameterValueOptionDto {
    #[allow(clippy::new_without_default)]
    pub fn new(id: i64, value: String, ) -> ParameterValueOptionDto {
        ParameterValueOptionDto {
            id,
            value,
            description: None,
        }
    }
}

/// Converts the ParameterValueOptionDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ParameterValueOptionDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            Some("id".to_string()),
            Some(self.id.to_string()),


            Some("value".to_string()),
            Some(self.value.to_string()),


            self.description.as_ref().map(|description| {
                [
                    "description".to_string(),
                    description.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ParameterValueOptionDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ParameterValueOptionDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<i64>,
            pub value: Vec<String>,
            pub description: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ParameterValueOptionDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "value" => intermediate_rep.value.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "description" => intermediate_rep.description.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ParameterValueOptionDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ParameterValueOptionDto {
            id: intermediate_rep.id.into_iter().next().ok_or_else(|| "id missing in ParameterValueOptionDto".to_string())?,
            value: intermediate_rep.value.into_iter().next().ok_or_else(|| "value missing in ParameterValueOptionDto".to_string())?,
            description: intermediate_rep.description.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ParameterValueOptionDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<ParameterValueOptionDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ParameterValueOptionDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ParameterValueOptionDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<ParameterValueOptionDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ParameterValueOptionDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ParameterValueOptionDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Элемент отображает одно грузовое место. Вложенные поля больше не используются, передавайте элемент пустым в запросах и не обращайте внимание на содержимое в ответах.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ParcelBoxDto {
    /// {% note warning \"\" %}  Этот параметр устарел. Не используйте его.  {% endnote %} 
    #[serde(rename = "id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,

    /// {% note warning \"\" %}  Этот параметр устарел. Не используйте его.  {% endnote %} 
    #[serde(rename = "fulfilmentId")]
    #[validate(
           regex = "RE_PARCELBOXDTO_FULFILMENT_ID",
        )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub fulfilment_id: Option<String>,

}

lazy_static::lazy_static! {
    static ref RE_PARCELBOXDTO_FULFILMENT_ID: regex::Regex = regex::Regex::new(r"^[\\p{Alnum}- ]*$").unwrap();
}

impl ParcelBoxDto {
    #[allow(clippy::new_without_default)]
    pub fn new() -> ParcelBoxDto {
        ParcelBoxDto {
            id: None,
            fulfilment_id: None,
        }
    }
}

/// Converts the ParcelBoxDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ParcelBoxDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.id.as_ref().map(|id| {
                [
                    "id".to_string(),
                    id.to_string(),
                ].join(",")
            }),


            self.fulfilment_id.as_ref().map(|fulfilment_id| {
                [
                    "fulfilmentId".to_string(),
                    fulfilment_id.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ParcelBoxDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ParcelBoxDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<i64>,
            pub fulfilment_id: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ParcelBoxDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "fulfilmentId" => intermediate_rep.fulfilment_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ParcelBoxDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ParcelBoxDto {
            id: intermediate_rep.id.into_iter().next(),
            fulfilment_id: intermediate_rep.fulfilment_id.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ParcelBoxDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<ParcelBoxDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ParcelBoxDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ParcelBoxDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<ParcelBoxDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ParcelBoxDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ParcelBoxDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Информация о ярлыке для коробки.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ParcelBoxLabelDto {
    /// Соответствует URL, по которому выполняется запрос [GET campaigns/{campaignId}/orders/{orderId}/delivery/shipments/{shipmentId}/boxes/{boxId}/label](../../reference/orders/generateOrderLabel.md). 
    #[serde(rename = "url")]
    pub url: String,

    /// Юридическое название магазина.
    #[serde(rename = "supplierName")]
    pub supplier_name: String,

    /// Юридическое название службы доставки.
    #[serde(rename = "deliveryServiceName")]
    pub delivery_service_name: String,

    /// Идентификатор заказа в системе Маркета.
    #[serde(rename = "orderId")]
    pub order_id: i64,

    /// Идентификатор заказа в информационной системе магазина.  Совпадает с `orderId`, если Маркету неизвестен номер заказа в системе магазина. 
    #[serde(rename = "orderNum")]
    pub order_num: String,

    /// Фамилия и инициалы получателя заказа.
    #[serde(rename = "recipientName")]
    pub recipient_name: String,

    /// Идентификатор коробки.
    #[serde(rename = "boxId")]
    pub box_id: i64,

    /// Идентификатор коробки в информационной системе магазина.  Возвращается в формате: `номер заказа на Маркете-номер коробки`. Например, `7206821‑1`, `7206821‑2` и т. д. 
    #[serde(rename = "fulfilmentId")]
    pub fulfilment_id: String,

    /// Номер коробки в заказе. Возвращается в формате: `номер места/общее количество мест`. 
    #[serde(rename = "place")]
    pub place: String,

    /// {% note warning \"\" %}  Этот параметр устарел. Не используйте его.  {% endnote %}  Общая масса всех товаров в заказе. Возвращается в формате: `weight кг`. 
    #[serde(rename = "weight")]
    pub weight: String,

    /// Идентификатор службы доставки. Информацию о службе доставки можно получить с помощью запроса [GET delivery/services](../../reference/orders/getDeliveryServices.md).
    #[serde(rename = "deliveryServiceId")]
    pub delivery_service_id: String,

    /// Адрес получателя.
    #[serde(rename = "deliveryAddress")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub delivery_address: Option<String>,

    /// Дата отгрузки в формате `dd.MM.yyyy`.
    #[serde(rename = "shipmentDate")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub shipment_date: Option<String>,

}


impl ParcelBoxLabelDto {
    #[allow(clippy::new_without_default)]
    pub fn new(url: String, supplier_name: String, delivery_service_name: String, order_id: i64, order_num: String, recipient_name: String, box_id: i64, fulfilment_id: String, place: String, weight: String, delivery_service_id: String, ) -> ParcelBoxLabelDto {
        ParcelBoxLabelDto {
            url,
            supplier_name,
            delivery_service_name,
            order_id,
            order_num,
            recipient_name,
            box_id,
            fulfilment_id,
            place,
            weight,
            delivery_service_id,
            delivery_address: None,
            shipment_date: None,
        }
    }
}

/// Converts the ParcelBoxLabelDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ParcelBoxLabelDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            Some("url".to_string()),
            Some(self.url.to_string()),


            Some("supplierName".to_string()),
            Some(self.supplier_name.to_string()),


            Some("deliveryServiceName".to_string()),
            Some(self.delivery_service_name.to_string()),


            Some("orderId".to_string()),
            Some(self.order_id.to_string()),


            Some("orderNum".to_string()),
            Some(self.order_num.to_string()),


            Some("recipientName".to_string()),
            Some(self.recipient_name.to_string()),


            Some("boxId".to_string()),
            Some(self.box_id.to_string()),


            Some("fulfilmentId".to_string()),
            Some(self.fulfilment_id.to_string()),


            Some("place".to_string()),
            Some(self.place.to_string()),


            Some("weight".to_string()),
            Some(self.weight.to_string()),


            Some("deliveryServiceId".to_string()),
            Some(self.delivery_service_id.to_string()),


            self.delivery_address.as_ref().map(|delivery_address| {
                [
                    "deliveryAddress".to_string(),
                    delivery_address.to_string(),
                ].join(",")
            }),


            self.shipment_date.as_ref().map(|shipment_date| {
                [
                    "shipmentDate".to_string(),
                    shipment_date.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ParcelBoxLabelDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ParcelBoxLabelDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub url: Vec<String>,
            pub supplier_name: Vec<String>,
            pub delivery_service_name: Vec<String>,
            pub order_id: Vec<i64>,
            pub order_num: Vec<String>,
            pub recipient_name: Vec<String>,
            pub box_id: Vec<i64>,
            pub fulfilment_id: Vec<String>,
            pub place: Vec<String>,
            pub weight: Vec<String>,
            pub delivery_service_id: Vec<String>,
            pub delivery_address: Vec<String>,
            pub shipment_date: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ParcelBoxLabelDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "url" => intermediate_rep.url.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "supplierName" => intermediate_rep.supplier_name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "deliveryServiceName" => intermediate_rep.delivery_service_name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "orderId" => intermediate_rep.order_id.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "orderNum" => intermediate_rep.order_num.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "recipientName" => intermediate_rep.recipient_name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "boxId" => intermediate_rep.box_id.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "fulfilmentId" => intermediate_rep.fulfilment_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "place" => intermediate_rep.place.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "weight" => intermediate_rep.weight.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "deliveryServiceId" => intermediate_rep.delivery_service_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "deliveryAddress" => intermediate_rep.delivery_address.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "shipmentDate" => intermediate_rep.shipment_date.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ParcelBoxLabelDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ParcelBoxLabelDto {
            url: intermediate_rep.url.into_iter().next().ok_or_else(|| "url missing in ParcelBoxLabelDto".to_string())?,
            supplier_name: intermediate_rep.supplier_name.into_iter().next().ok_or_else(|| "supplierName missing in ParcelBoxLabelDto".to_string())?,
            delivery_service_name: intermediate_rep.delivery_service_name.into_iter().next().ok_or_else(|| "deliveryServiceName missing in ParcelBoxLabelDto".to_string())?,
            order_id: intermediate_rep.order_id.into_iter().next().ok_or_else(|| "orderId missing in ParcelBoxLabelDto".to_string())?,
            order_num: intermediate_rep.order_num.into_iter().next().ok_or_else(|| "orderNum missing in ParcelBoxLabelDto".to_string())?,
            recipient_name: intermediate_rep.recipient_name.into_iter().next().ok_or_else(|| "recipientName missing in ParcelBoxLabelDto".to_string())?,
            box_id: intermediate_rep.box_id.into_iter().next().ok_or_else(|| "boxId missing in ParcelBoxLabelDto".to_string())?,
            fulfilment_id: intermediate_rep.fulfilment_id.into_iter().next().ok_or_else(|| "fulfilmentId missing in ParcelBoxLabelDto".to_string())?,
            place: intermediate_rep.place.into_iter().next().ok_or_else(|| "place missing in ParcelBoxLabelDto".to_string())?,
            weight: intermediate_rep.weight.into_iter().next().ok_or_else(|| "weight missing in ParcelBoxLabelDto".to_string())?,
            delivery_service_id: intermediate_rep.delivery_service_id.into_iter().next().ok_or_else(|| "deliveryServiceId missing in ParcelBoxLabelDto".to_string())?,
            delivery_address: intermediate_rep.delivery_address.into_iter().next(),
            shipment_date: intermediate_rep.shipment_date.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ParcelBoxLabelDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<ParcelBoxLabelDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ParcelBoxLabelDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ParcelBoxLabelDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<ParcelBoxLabelDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ParcelBoxLabelDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ParcelBoxLabelDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Информация о грузовых местах в заказе.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ParcelDto {
    /// Список грузовых мест. Маркет определяет количество мест по длине этого списка.
    #[serde(rename = "boxes")]
    #[validate(
            length(min = 1),
        )]
    pub boxes: Vec<models::ParcelBoxDto>,

}


impl ParcelDto {
    #[allow(clippy::new_without_default)]
    pub fn new(boxes: Vec<models::ParcelBoxDto>, ) -> ParcelDto {
        ParcelDto {
            boxes,
        }
    }
}

/// Converts the ParcelDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ParcelDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping boxes in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ParcelDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ParcelDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub boxes: Vec<Vec<models::ParcelBoxDto>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ParcelDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "boxes" => return std::result::Result::Err("Parsing a container in this style is not supported in ParcelDto".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing ParcelDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ParcelDto {
            boxes: intermediate_rep.boxes.into_iter().next().ok_or_else(|| "boxes missing in ParcelDto".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ParcelDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<ParcelDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ParcelDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ParcelDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<ParcelDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ParcelDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ParcelDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Идентификатор категории на Маркете, к которой вы относите свой товар.  Если не указать `marketCategoryId`, то маркетная категория будет определена автоматически.  При изменении информации о товаре передавайте тот же идентификатор категории. Если вы укажете другой, категория товара не поменяется. Изменить ее можно только в кабинете продавца на Маркете.  Список категорий Маркета можно получить с помощью запроса  [POST categories/tree](../../reference/categories/getCategoriesTree.md). 
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PartnerMarketCategoryId(i64);

impl std::convert::From<i64> for PartnerMarketCategoryId {
    fn from(x: i64) -> Self {
        PartnerMarketCategoryId(x)
    }
}

impl std::convert::From<PartnerMarketCategoryId> for i64 {
    fn from(x: PartnerMarketCategoryId) -> Self {
        x.0
    }
}

impl std::ops::Deref for PartnerMarketCategoryId {
    type Target = i64;
    fn deref(&self) -> &i64 {
        &self.0
    }
}

impl std::ops::DerefMut for PartnerMarketCategoryId {
    fn deref_mut(&mut self) -> &mut i64 {
        &mut self.0
    }
}


/// Данные о складе отправления.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PartnerShipmentWarehouseDto {
    /// Идентификатор склада отправления.
    #[serde(rename = "id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,

    /// Наименование склада отправления.
    #[serde(rename = "name")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

    /// Адрес склада отправления.
    #[serde(rename = "address")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub address: Option<String>,

}


impl PartnerShipmentWarehouseDto {
    #[allow(clippy::new_without_default)]
    pub fn new() -> PartnerShipmentWarehouseDto {
        PartnerShipmentWarehouseDto {
            id: None,
            name: None,
            address: None,
        }
    }
}

/// Converts the PartnerShipmentWarehouseDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for PartnerShipmentWarehouseDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.id.as_ref().map(|id| {
                [
                    "id".to_string(),
                    id.to_string(),
                ].join(",")
            }),


            self.name.as_ref().map(|name| {
                [
                    "name".to_string(),
                    name.to_string(),
                ].join(",")
            }),


            self.address.as_ref().map(|address| {
                [
                    "address".to_string(),
                    address.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PartnerShipmentWarehouseDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PartnerShipmentWarehouseDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<i64>,
            pub name: Vec<String>,
            pub address: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PartnerShipmentWarehouseDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "address" => intermediate_rep.address.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing PartnerShipmentWarehouseDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PartnerShipmentWarehouseDto {
            id: intermediate_rep.id.into_iter().next(),
            name: intermediate_rep.name.into_iter().next(),
            address: intermediate_rep.address.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PartnerShipmentWarehouseDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<PartnerShipmentWarehouseDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PartnerShipmentWarehouseDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for PartnerShipmentWarehouseDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<PartnerShipmentWarehouseDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PartnerShipmentWarehouseDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into PartnerShipmentWarehouseDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Частота выплат:  * `DAILY` — ежедневно. * `WEEKLY` — раз в неделю. * `BIWEEKLY` — раз в две недели. * `MONTHLY` — раз в месяц.  Подробнее о графике выплат читайте [в Справке Маркета для продавцов](https://yandex.ru/support/marketplace/introduction/rates/acquiring.html). 
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum PaymentFrequencyType {
    #[serde(rename = "DAILY")]
    Daily,
    #[serde(rename = "WEEKLY")]
    Weekly,
    #[serde(rename = "BIWEEKLY")]
    Biweekly,
    #[serde(rename = "MONTHLY")]
    Monthly,
}

impl std::fmt::Display for PaymentFrequencyType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            PaymentFrequencyType::Daily => write!(f, "DAILY"),
            PaymentFrequencyType::Weekly => write!(f, "WEEKLY"),
            PaymentFrequencyType::Biweekly => write!(f, "BIWEEKLY"),
            PaymentFrequencyType::Monthly => write!(f, "MONTHLY"),
        }
    }
}

impl std::str::FromStr for PaymentFrequencyType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "DAILY" => std::result::Result::Ok(PaymentFrequencyType::Daily),
            "WEEKLY" => std::result::Result::Ok(PaymentFrequencyType::Weekly),
            "BIWEEKLY" => std::result::Result::Ok(PaymentFrequencyType::Biweekly),
            "MONTHLY" => std::result::Result::Ok(PaymentFrequencyType::Monthly),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Адрес доставки.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PickupAddressDto {
    /// Страна.
    #[serde(rename = "country")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub country: Option<String>,

    /// Город.
    #[serde(rename = "city")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub city: Option<String>,

    /// Улица.
    #[serde(rename = "street")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub street: Option<String>,

    /// Номер дома.
    #[serde(rename = "house")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub house: Option<String>,

    /// Почтовый индекс.
    #[serde(rename = "postcode")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub postcode: Option<String>,

}


impl PickupAddressDto {
    #[allow(clippy::new_without_default)]
    pub fn new() -> PickupAddressDto {
        PickupAddressDto {
            country: None,
            city: None,
            street: None,
            house: None,
            postcode: None,
        }
    }
}

/// Converts the PickupAddressDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for PickupAddressDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.country.as_ref().map(|country| {
                [
                    "country".to_string(),
                    country.to_string(),
                ].join(",")
            }),


            self.city.as_ref().map(|city| {
                [
                    "city".to_string(),
                    city.to_string(),
                ].join(",")
            }),


            self.street.as_ref().map(|street| {
                [
                    "street".to_string(),
                    street.to_string(),
                ].join(",")
            }),


            self.house.as_ref().map(|house| {
                [
                    "house".to_string(),
                    house.to_string(),
                ].join(",")
            }),


            self.postcode.as_ref().map(|postcode| {
                [
                    "postcode".to_string(),
                    postcode.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PickupAddressDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PickupAddressDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub country: Vec<String>,
            pub city: Vec<String>,
            pub street: Vec<String>,
            pub house: Vec<String>,
            pub postcode: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PickupAddressDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "country" => intermediate_rep.country.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "city" => intermediate_rep.city.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "street" => intermediate_rep.street.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "house" => intermediate_rep.house.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "postcode" => intermediate_rep.postcode.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing PickupAddressDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PickupAddressDto {
            country: intermediate_rep.country.into_iter().next(),
            city: intermediate_rep.city.into_iter().next(),
            street: intermediate_rep.street.into_iter().next(),
            house: intermediate_rep.house.into_iter().next(),
            postcode: intermediate_rep.postcode.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PickupAddressDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<PickupAddressDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PickupAddressDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for PickupAddressDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<PickupAddressDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PickupAddressDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into PickupAddressDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Модель, по которой работает магазин:  * `FBS` — FBS или Экспресс. * `FBY` — FBY. * `DBS` — DBS. 
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum PlacementType {
    #[serde(rename = "FBS")]
    Fbs,
    #[serde(rename = "FBY")]
    Fby,
    #[serde(rename = "DBS")]
    Dbs,
}

impl std::fmt::Display for PlacementType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            PlacementType::Fbs => write!(f, "FBS"),
            PlacementType::Fby => write!(f, "FBY"),
            PlacementType::Dbs => write!(f, "DBS"),
        }
    }
}

impl std::str::FromStr for PlacementType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "FBS" => std::result::Result::Ok(PlacementType::Fbs),
            "FBY" => std::result::Result::Ok(PlacementType::Fby),
            "DBS" => std::result::Result::Ok(PlacementType::Dbs),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Максимальные значения цены, при которых она является привлекательной или умеренной.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PriceCompetitivenessThresholdsDto {
    #[serde(rename = "optimalPrice")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub optimal_price: Option<models::BasePriceDto>,

    #[serde(rename = "averagePrice")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub average_price: Option<models::BasePriceDto>,

}


impl PriceCompetitivenessThresholdsDto {
    #[allow(clippy::new_without_default)]
    pub fn new() -> PriceCompetitivenessThresholdsDto {
        PriceCompetitivenessThresholdsDto {
            optimal_price: None,
            average_price: None,
        }
    }
}

/// Converts the PriceCompetitivenessThresholdsDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for PriceCompetitivenessThresholdsDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping optimalPrice in query parameter serialization

            // Skipping averagePrice in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PriceCompetitivenessThresholdsDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PriceCompetitivenessThresholdsDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub optimal_price: Vec<models::BasePriceDto>,
            pub average_price: Vec<models::BasePriceDto>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PriceCompetitivenessThresholdsDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "optimalPrice" => intermediate_rep.optimal_price.push(<models::BasePriceDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "averagePrice" => intermediate_rep.average_price.push(<models::BasePriceDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing PriceCompetitivenessThresholdsDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PriceCompetitivenessThresholdsDto {
            optimal_price: intermediate_rep.optimal_price.into_iter().next(),
            average_price: intermediate_rep.average_price.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PriceCompetitivenessThresholdsDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<PriceCompetitivenessThresholdsDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PriceCompetitivenessThresholdsDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for PriceCompetitivenessThresholdsDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<PriceCompetitivenessThresholdsDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PriceCompetitivenessThresholdsDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into PriceCompetitivenessThresholdsDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Привлекательность цены:  * `OPTIMAL` — привлекательная. * `AVERAGE` — умеренная. * `LOW` — непривлекательная. 
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum PriceCompetitivenessType {
    #[serde(rename = "OPTIMAL")]
    Optimal,
    #[serde(rename = "AVERAGE")]
    Average,
    #[serde(rename = "LOW")]
    Low,
}

impl std::fmt::Display for PriceCompetitivenessType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            PriceCompetitivenessType::Optimal => write!(f, "OPTIMAL"),
            PriceCompetitivenessType::Average => write!(f, "AVERAGE"),
            PriceCompetitivenessType::Low => write!(f, "LOW"),
        }
    }
}

impl std::str::FromStr for PriceCompetitivenessType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "OPTIMAL" => std::result::Result::Ok(PriceCompetitivenessType::Optimal),
            "AVERAGE" => std::result::Result::Ok(PriceCompetitivenessType::Average),
            "LOW" => std::result::Result::Ok(PriceCompetitivenessType::Low),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Цена с указанием скидки, валюты и времени последнего обновления.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PriceDto {
    /// Цена на товар.
    #[serde(rename = "value")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub value: Option<f64>,

    /// Цена на товар без скидки.  Число должно быть целым. Вы можете указать цену со скидкой от 5 до 99%.  Передавайте этот параметр при каждом обновлении цены, если предоставляете скидку на товар. 
    #[serde(rename = "discountBase")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub discount_base: Option<f64>,

    #[serde(rename = "currencyId")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub currency_id: Option<models::CurrencyType>,

    /// Идентификатор ставки НДС, применяемой для товара:  * `2` — 10%. * `5` — 0%. * `6` — не облагается НДС. * `7` — 20%.  Если параметр не указан, используется ставка НДС, установленная в кабинете. 
    #[serde(rename = "vat")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub vat: Option<i32>,

}


impl PriceDto {
    #[allow(clippy::new_without_default)]
    pub fn new() -> PriceDto {
        PriceDto {
            value: None,
            discount_base: None,
            currency_id: None,
            vat: None,
        }
    }
}

/// Converts the PriceDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for PriceDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.value.as_ref().map(|value| {
                [
                    "value".to_string(),
                    value.to_string(),
                ].join(",")
            }),


            self.discount_base.as_ref().map(|discount_base| {
                [
                    "discountBase".to_string(),
                    discount_base.to_string(),
                ].join(",")
            }),

            // Skipping currencyId in query parameter serialization


            self.vat.as_ref().map(|vat| {
                [
                    "vat".to_string(),
                    vat.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PriceDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PriceDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub value: Vec<f64>,
            pub discount_base: Vec<f64>,
            pub currency_id: Vec<models::CurrencyType>,
            pub vat: Vec<i32>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PriceDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "value" => intermediate_rep.value.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "discountBase" => intermediate_rep.discount_base.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "currencyId" => intermediate_rep.currency_id.push(<models::CurrencyType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "vat" => intermediate_rep.vat.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing PriceDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PriceDto {
            value: intermediate_rep.value.into_iter().next(),
            discount_base: intermediate_rep.discount_base.into_iter().next(),
            currency_id: intermediate_rep.currency_id.into_iter().next(),
            vat: intermediate_rep.vat.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PriceDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<PriceDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PriceDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for PriceDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<PriceDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PriceDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into PriceDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Причина попадания товара в карантин.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PriceQuarantineVerdictDto {
    #[serde(rename = "type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub r#type: Option<models::PriceQuarantineVerdictType>,

    /// Цена, из-за которой товар попал в карантин, и значения для сравнения. Конкретный набор параметров зависит от типа карантина.
    #[serde(rename = "params")]
    pub params: Vec<models::PriceQuarantineVerdictParameterDto>,

}


impl PriceQuarantineVerdictDto {
    #[allow(clippy::new_without_default)]
    pub fn new(params: Vec<models::PriceQuarantineVerdictParameterDto>, ) -> PriceQuarantineVerdictDto {
        PriceQuarantineVerdictDto {
            r#type: None,
            params,
        }
    }
}

/// Converts the PriceQuarantineVerdictDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for PriceQuarantineVerdictDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping type in query parameter serialization

            // Skipping params in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PriceQuarantineVerdictDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PriceQuarantineVerdictDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub r#type: Vec<models::PriceQuarantineVerdictType>,
            pub params: Vec<Vec<models::PriceQuarantineVerdictParameterDto>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PriceQuarantineVerdictDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r#type.push(<models::PriceQuarantineVerdictType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "params" => return std::result::Result::Err("Parsing a container in this style is not supported in PriceQuarantineVerdictDto".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing PriceQuarantineVerdictDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PriceQuarantineVerdictDto {
            r#type: intermediate_rep.r#type.into_iter().next(),
            params: intermediate_rep.params.into_iter().next().ok_or_else(|| "params missing in PriceQuarantineVerdictDto".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PriceQuarantineVerdictDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<PriceQuarantineVerdictDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PriceQuarantineVerdictDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for PriceQuarantineVerdictDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<PriceQuarantineVerdictDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PriceQuarantineVerdictDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into PriceQuarantineVerdictDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Имя параметра причины скрытия товара по цене.  * `CURRENT_PRICE` — цена, из-за которой товар попал в карантин. * `LAST_VALID_PRICE` — последняя цена до попадания в карантин (только для карантина типа `PRICE_CHANGE`). * `MIN_PRICE` — порог попадания в карантин (только для карантина типов `LOW_PRICE` и `LOW_PRICE_PROMO`). * `CURRENCY` — валюта. 
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum PriceQuarantineVerdictParamNameType {
    #[serde(rename = "CURRENT_PRICE")]
    CurrentPrice,
    #[serde(rename = "LAST_VALID_PRICE")]
    LastValidPrice,
    #[serde(rename = "MIN_PRICE")]
    MinPrice,
    #[serde(rename = "CURRENCY")]
    Currency,
}

impl std::fmt::Display for PriceQuarantineVerdictParamNameType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            PriceQuarantineVerdictParamNameType::CurrentPrice => write!(f, "CURRENT_PRICE"),
            PriceQuarantineVerdictParamNameType::LastValidPrice => write!(f, "LAST_VALID_PRICE"),
            PriceQuarantineVerdictParamNameType::MinPrice => write!(f, "MIN_PRICE"),
            PriceQuarantineVerdictParamNameType::Currency => write!(f, "CURRENCY"),
        }
    }
}

impl std::str::FromStr for PriceQuarantineVerdictParamNameType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "CURRENT_PRICE" => std::result::Result::Ok(PriceQuarantineVerdictParamNameType::CurrentPrice),
            "LAST_VALID_PRICE" => std::result::Result::Ok(PriceQuarantineVerdictParamNameType::LastValidPrice),
            "MIN_PRICE" => std::result::Result::Ok(PriceQuarantineVerdictParamNameType::MinPrice),
            "CURRENCY" => std::result::Result::Ok(PriceQuarantineVerdictParamNameType::Currency),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Параметр карантина.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PriceQuarantineVerdictParameterDto {
    #[serde(rename = "name")]
    pub name: models::PriceQuarantineVerdictParamNameType,

    /// Значение параметра.
    #[serde(rename = "value")]
    pub value: String,

}


impl PriceQuarantineVerdictParameterDto {
    #[allow(clippy::new_without_default)]
    pub fn new(name: models::PriceQuarantineVerdictParamNameType, value: String, ) -> PriceQuarantineVerdictParameterDto {
        PriceQuarantineVerdictParameterDto {
            name,
            value,
        }
    }
}

/// Converts the PriceQuarantineVerdictParameterDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for PriceQuarantineVerdictParameterDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping name in query parameter serialization


            Some("value".to_string()),
            Some(self.value.to_string()),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PriceQuarantineVerdictParameterDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PriceQuarantineVerdictParameterDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub name: Vec<models::PriceQuarantineVerdictParamNameType>,
            pub value: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PriceQuarantineVerdictParameterDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<models::PriceQuarantineVerdictParamNameType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "value" => intermediate_rep.value.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing PriceQuarantineVerdictParameterDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PriceQuarantineVerdictParameterDto {
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "name missing in PriceQuarantineVerdictParameterDto".to_string())?,
            value: intermediate_rep.value.into_iter().next().ok_or_else(|| "value missing in PriceQuarantineVerdictParameterDto".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PriceQuarantineVerdictParameterDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<PriceQuarantineVerdictParameterDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PriceQuarantineVerdictParameterDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for PriceQuarantineVerdictParameterDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<PriceQuarantineVerdictParameterDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PriceQuarantineVerdictParameterDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into PriceQuarantineVerdictParameterDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Типы карантина:  * `PRICE_CHANGE` — новая цена слишком сильно отличается от прежней. В поле `params` будет  новая цена `CURRENT_PRICE` и последняя цена до попадания в карантин `LAST_VALID_PRICE`. * `LOW_PRICE` — установленная цена слишком сильно отличается от рыночной. В поле `params` будет установленная вами цена `CURRENT_PRICE` и порог попадания в карантин `MIN_PRICE`. * `LOW_PRICE_PROMO` — цена после применения акций слишком сильно отличается от рыночной. В поле `params` будет цена после применения акций `CURRENT_PRICE` и порог попадания в карантин `MIN_PRICE`. 
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum PriceQuarantineVerdictType {
    #[serde(rename = "PRICE_CHANGE")]
    PriceChange,
    #[serde(rename = "LOW_PRICE")]
    LowPrice,
    #[serde(rename = "LOW_PRICE_PROMO")]
    LowPricePromo,
}

impl std::fmt::Display for PriceQuarantineVerdictType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            PriceQuarantineVerdictType::PriceChange => write!(f, "PRICE_CHANGE"),
            PriceQuarantineVerdictType::LowPrice => write!(f, "LOW_PRICE"),
            PriceQuarantineVerdictType::LowPricePromo => write!(f, "LOW_PRICE_PROMO"),
        }
    }
}

impl std::str::FromStr for PriceQuarantineVerdictType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "PRICE_CHANGE" => std::result::Result::Ok(PriceQuarantineVerdictType::PriceChange),
            "LOW_PRICE" => std::result::Result::Ok(PriceQuarantineVerdictType::LowPrice),
            "LOW_PRICE_PROMO" => std::result::Result::Ok(PriceQuarantineVerdictType::LowPricePromo),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Рекомендованная цена.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PriceRecommendationItemDto {
    /// Идентификатор кампании.
    #[serde(rename = "campaignId")]
    pub campaign_id: i64,

    /// Рекомендованная цена на товар. Чтобы продвижение хорошо работало, цена на товар должна быть не выше этого значения. [Подробно о рекомендованных ценах](https://yandex.ru/support/marketplace/marketing/campaigns.html#prices) 
    #[serde(rename = "price")]
    #[validate(
            range(min = 1),
        )]
    pub price: f64,

}


impl PriceRecommendationItemDto {
    #[allow(clippy::new_without_default)]
    pub fn new(campaign_id: i64, price: f64, ) -> PriceRecommendationItemDto {
        PriceRecommendationItemDto {
            campaign_id,
            price,
        }
    }
}

/// Converts the PriceRecommendationItemDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for PriceRecommendationItemDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            Some("campaignId".to_string()),
            Some(self.campaign_id.to_string()),


            Some("price".to_string()),
            Some(self.price.to_string()),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PriceRecommendationItemDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PriceRecommendationItemDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub campaign_id: Vec<i64>,
            pub price: Vec<f64>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PriceRecommendationItemDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "campaignId" => intermediate_rep.campaign_id.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "price" => intermediate_rep.price.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing PriceRecommendationItemDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PriceRecommendationItemDto {
            campaign_id: intermediate_rep.campaign_id.into_iter().next().ok_or_else(|| "campaignId missing in PriceRecommendationItemDto".to_string())?,
            price: intermediate_rep.price.into_iter().next().ok_or_else(|| "price missing in PriceRecommendationItemDto".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PriceRecommendationItemDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<PriceRecommendationItemDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PriceRecommendationItemDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for PriceRecommendationItemDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<PriceRecommendationItemDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PriceRecommendationItemDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into PriceRecommendationItemDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Тип цены.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PriceSuggestDto {
    #[serde(rename = "type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub r#type: Option<models::PriceSuggestType>,

    /// Цена в рублях.
    #[serde(rename = "price")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub price: Option<f64>,

}


impl PriceSuggestDto {
    #[allow(clippy::new_without_default)]
    pub fn new() -> PriceSuggestDto {
        PriceSuggestDto {
            r#type: None,
            price: None,
        }
    }
}

/// Converts the PriceSuggestDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for PriceSuggestDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping type in query parameter serialization


            self.price.as_ref().map(|price| {
                [
                    "price".to_string(),
                    price.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PriceSuggestDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PriceSuggestDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub r#type: Vec<models::PriceSuggestType>,
            pub price: Vec<f64>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PriceSuggestDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r#type.push(<models::PriceSuggestType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "price" => intermediate_rep.price.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing PriceSuggestDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PriceSuggestDto {
            r#type: intermediate_rep.r#type.into_iter().next(),
            price: intermediate_rep.price.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PriceSuggestDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<PriceSuggestDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PriceSuggestDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for PriceSuggestDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<PriceSuggestDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PriceSuggestDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into PriceSuggestDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Товар с ценами для продвижения.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PriceSuggestOfferDto {
    /// SKU на Маркете.
    #[serde(rename = "marketSku")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub market_sku: Option<i64>,

    /// Ваш SKU — идентификатор товара в вашей системе.  Разрешена любая последовательность длиной до 255 знаков.  Правила использования SKU:  * У каждого товара SKU должен быть свой.  * SKU товара нельзя менять — можно только удалить товар и добавить заново с новым SKU.  * Уже заданный SKU нельзя освободить и использовать заново для другого товара. Каждый товар должен получать новый идентификатор, до того никогда не использовавшийся в вашем каталоге.  [Что такое SKU и как его назначать](https://yandex.ru/support/marketplace/assortment/add/index.html#fields) 
    #[serde(rename = "offerId")]
    #[validate(
            length(min = 1, max = 255),
           regex = "RE_PRICESUGGESTOFFERDTO_OFFER_ID",
        )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub offer_id: Option<String>,

    /// Цены для продвижения. 
    #[serde(rename = "priceSuggestion")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub price_suggestion: Option<swagger::Nullable<Vec<models::PriceSuggestDto>>>,

}

lazy_static::lazy_static! {
    static ref RE_PRICESUGGESTOFFERDTO_OFFER_ID: regex::Regex = regex::Regex::new(r"^[^\\x00-\\x08\\x0A-\\x1f\\x7f]{1,255}$").unwrap();
}

impl PriceSuggestOfferDto {
    #[allow(clippy::new_without_default)]
    pub fn new() -> PriceSuggestOfferDto {
        PriceSuggestOfferDto {
            market_sku: None,
            offer_id: None,
            price_suggestion: None,
        }
    }
}

/// Converts the PriceSuggestOfferDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for PriceSuggestOfferDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.market_sku.as_ref().map(|market_sku| {
                [
                    "marketSku".to_string(),
                    market_sku.to_string(),
                ].join(",")
            }),


            self.offer_id.as_ref().map(|offer_id| {
                [
                    "offerId".to_string(),
                    offer_id.to_string(),
                ].join(",")
            }),

            // Skipping priceSuggestion in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PriceSuggestOfferDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PriceSuggestOfferDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub market_sku: Vec<i64>,
            pub offer_id: Vec<String>,
            pub price_suggestion: Vec<Vec<models::PriceSuggestDto>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PriceSuggestOfferDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "marketSku" => intermediate_rep.market_sku.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "offerId" => intermediate_rep.offer_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "priceSuggestion" => return std::result::Result::Err("Parsing a container in this style is not supported in PriceSuggestOfferDto".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing PriceSuggestOfferDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PriceSuggestOfferDto {
            market_sku: intermediate_rep.market_sku.into_iter().next(),
            offer_id: intermediate_rep.offer_id.into_iter().next(),
            price_suggestion: std::result::Result::Err("Nullable types not supported in PriceSuggestOfferDto".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PriceSuggestOfferDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<PriceSuggestOfferDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PriceSuggestOfferDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for PriceSuggestOfferDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<PriceSuggestOfferDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PriceSuggestOfferDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into PriceSuggestOfferDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Тип цены:  * `BUYBOX` — самая низкая цена на товар, по которой он продается сейчас. Эта цена обновляется в режиме реального времени. Если вы установите цену ниже, начнет показываться ваше предложение. Если для этого значения в параметре `price` указана цена, которая совпадает с вашей, значит, ваш товар уже показывается на витрине. Если кроме вас этот товар продают другие продавцы по такой же цене, их предложения также будут отображаться вместе с вашими по очереди. * `DEFAULT_OFFER` — рекомендованная Маркетом цена, которая привлекает покупателей. Рассчитывается только для популярных на сервисе товаров и обновляется раз в четыре часа. * `MIN_PRICE_MARKET` — минимальная цена на Маркете. Самая низкая цена среди всех предложений товара на Маркете во всех регионах, включая те, которые не видны на витрине. Эта цена обновляется в режиме реального времени и обеспечивает большее количество показов на Маркете, чем самая низкая или рекомендованная цена. 
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum PriceSuggestType {
    #[serde(rename = "BUYBOX")]
    Buybox,
    #[serde(rename = "DEFAULT_OFFER")]
    DefaultOffer,
    #[serde(rename = "MIN_PRICE_MARKET")]
    MinPriceMarket,
}

impl std::fmt::Display for PriceSuggestType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            PriceSuggestType::Buybox => write!(f, "BUYBOX"),
            PriceSuggestType::DefaultOffer => write!(f, "DEFAULT_OFFER"),
            PriceSuggestType::MinPriceMarket => write!(f, "MIN_PRICE_MARKET"),
        }
    }
}

impl std::str::FromStr for PriceSuggestType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "BUYBOX" => std::result::Result::Ok(PriceSuggestType::Buybox),
            "DEFAULT_OFFER" => std::result::Result::Ok(PriceSuggestType::DefaultOffer),
            "MIN_PRICE_MARKET" => std::result::Result::Ok(PriceSuggestType::MinPriceMarket),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Информация об автоматическом добавлении товара в акцию.  Причины, по которым товар не был добавлен автоматически в других магазинах, можно узнать в кабинете продавца на Маркете на странице акции.  Об автоматическом и ручном добавлении товаров в акцию читайте [в Справке Маркета для продавцов](https://yandex.ru/support2/marketplace/ru/marketing/promos/market/index). 
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PromoOfferAutoParticipatingDetailsDto {
    /// Магазины, в которых товар добавлен в акцию автоматически.  Возвращается, если статус товара в акции — `PARTIALLY_AUTO`. 
    #[serde(rename = "campaignIds")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub campaign_ids: Option<swagger::Nullable<Vec<i64>>>,

}


impl PromoOfferAutoParticipatingDetailsDto {
    #[allow(clippy::new_without_default)]
    pub fn new() -> PromoOfferAutoParticipatingDetailsDto {
        PromoOfferAutoParticipatingDetailsDto {
            campaign_ids: None,
        }
    }
}

/// Converts the PromoOfferAutoParticipatingDetailsDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for PromoOfferAutoParticipatingDetailsDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.campaign_ids.as_ref().map(|campaign_ids| {
                [
                    "campaignIds".to_string(),
                    campaign_ids.as_ref().map_or("null".to_string(), |x| x.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PromoOfferAutoParticipatingDetailsDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PromoOfferAutoParticipatingDetailsDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub campaign_ids: Vec<Vec<i64>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PromoOfferAutoParticipatingDetailsDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "campaignIds" => return std::result::Result::Err("Parsing a container in this style is not supported in PromoOfferAutoParticipatingDetailsDto".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing PromoOfferAutoParticipatingDetailsDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PromoOfferAutoParticipatingDetailsDto {
            campaign_ids: std::result::Result::Err("Nullable types not supported in PromoOfferAutoParticipatingDetailsDto".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PromoOfferAutoParticipatingDetailsDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<PromoOfferAutoParticipatingDetailsDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PromoOfferAutoParticipatingDetailsDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for PromoOfferAutoParticipatingDetailsDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<PromoOfferAutoParticipatingDetailsDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PromoOfferAutoParticipatingDetailsDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into PromoOfferAutoParticipatingDetailsDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Параметры товара в акции с типом `DIRECT_DISCOUNT` или `BLUE_FLASH`.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PromoOfferDiscountParamsDto {
    /// Зачеркнутая цена — та, по которой товар продавался до акции.  Указывается в рублях.  Возвращается, только если товар участвует в акции. 
    #[serde(rename = "price")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub price: Option<i64>,

    /// Цена по акции — та, по которой вы хотите продавать товар.  Указывается в рублях.  Возвращается, только если товар участвует в акции. 
    #[serde(rename = "promoPrice")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub promo_price: Option<i64>,

    /// Максимально возможная цена для участия в акции.  Указывается в рублях.  Возвращается для всех товаров. 
    #[serde(rename = "maxPromoPrice")]
    pub max_promo_price: i64,

}


impl PromoOfferDiscountParamsDto {
    #[allow(clippy::new_without_default)]
    pub fn new(max_promo_price: i64, ) -> PromoOfferDiscountParamsDto {
        PromoOfferDiscountParamsDto {
            price: None,
            promo_price: None,
            max_promo_price,
        }
    }
}

/// Converts the PromoOfferDiscountParamsDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for PromoOfferDiscountParamsDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.price.as_ref().map(|price| {
                [
                    "price".to_string(),
                    price.to_string(),
                ].join(",")
            }),


            self.promo_price.as_ref().map(|promo_price| {
                [
                    "promoPrice".to_string(),
                    promo_price.to_string(),
                ].join(",")
            }),


            Some("maxPromoPrice".to_string()),
            Some(self.max_promo_price.to_string()),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PromoOfferDiscountParamsDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PromoOfferDiscountParamsDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub price: Vec<i64>,
            pub promo_price: Vec<i64>,
            pub max_promo_price: Vec<i64>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PromoOfferDiscountParamsDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "price" => intermediate_rep.price.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "promoPrice" => intermediate_rep.promo_price.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "maxPromoPrice" => intermediate_rep.max_promo_price.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing PromoOfferDiscountParamsDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PromoOfferDiscountParamsDto {
            price: intermediate_rep.price.into_iter().next(),
            promo_price: intermediate_rep.promo_price.into_iter().next(),
            max_promo_price: intermediate_rep.max_promo_price.into_iter().next().ok_or_else(|| "maxPromoPrice missing in PromoOfferDiscountParamsDto".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PromoOfferDiscountParamsDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<PromoOfferDiscountParamsDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PromoOfferDiscountParamsDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for PromoOfferDiscountParamsDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<PromoOfferDiscountParamsDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PromoOfferDiscountParamsDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into PromoOfferDiscountParamsDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Параметры товара в акции.  Возвращается параметр, который соответствует типу акции. 
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PromoOfferParamsDto {
    #[serde(rename = "discountParams")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub discount_params: Option<models::PromoOfferDiscountParamsDto>,

    #[serde(rename = "promocodeParams")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub promocode_params: Option<models::PromoOfferPromocodeParamsDto>,

}


impl PromoOfferParamsDto {
    #[allow(clippy::new_without_default)]
    pub fn new() -> PromoOfferParamsDto {
        PromoOfferParamsDto {
            discount_params: None,
            promocode_params: None,
        }
    }
}

/// Converts the PromoOfferParamsDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for PromoOfferParamsDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping discountParams in query parameter serialization

            // Skipping promocodeParams in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PromoOfferParamsDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PromoOfferParamsDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub discount_params: Vec<models::PromoOfferDiscountParamsDto>,
            pub promocode_params: Vec<models::PromoOfferPromocodeParamsDto>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PromoOfferParamsDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "discountParams" => intermediate_rep.discount_params.push(<models::PromoOfferDiscountParamsDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "promocodeParams" => intermediate_rep.promocode_params.push(<models::PromoOfferPromocodeParamsDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing PromoOfferParamsDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PromoOfferParamsDto {
            discount_params: intermediate_rep.discount_params.into_iter().next(),
            promocode_params: intermediate_rep.promocode_params.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PromoOfferParamsDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<PromoOfferParamsDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PromoOfferParamsDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for PromoOfferParamsDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<PromoOfferParamsDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PromoOfferParamsDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into PromoOfferParamsDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Фильтр для товаров, которые добавлены в акцию вручную:  * `MANUALLY_ADDED` — товары, которые добавлены вручную.  * `NOT_MANUALLY_ADDED`— товары, которые не участвуют в акции и те, которые добавлены автоматически.  Если не передать параметр `statusType`, вернутся все товары.  Об автоматическом и ручном добавлении товаров в акцию читайте [в Справке Маркета для продавцов](https://yandex.ru/support2/marketplace/ru/marketing/promos/market/index). 
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum PromoOfferParticipationStatusFilterType {
    #[serde(rename = "MANUALLY_ADDED")]
    ManuallyAdded,
    #[serde(rename = "NOT_MANUALLY_ADDED")]
    NotManuallyAdded,
}

impl std::fmt::Display for PromoOfferParticipationStatusFilterType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            PromoOfferParticipationStatusFilterType::ManuallyAdded => write!(f, "MANUALLY_ADDED"),
            PromoOfferParticipationStatusFilterType::NotManuallyAdded => write!(f, "NOT_MANUALLY_ADDED"),
        }
    }
}

impl std::str::FromStr for PromoOfferParticipationStatusFilterType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "MANUALLY_ADDED" => std::result::Result::Ok(PromoOfferParticipationStatusFilterType::ManuallyAdded),
            "NOT_MANUALLY_ADDED" => std::result::Result::Ok(PromoOfferParticipationStatusFilterType::NotManuallyAdded),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Статус товара в акции:  * `AUTO` — добавлен автоматически во всех магазинах кабинета, в которых товар доступен для покупки.  * `PARTIALLY_AUTO` — добавлен автоматически у части магазинов.  * `MANUAL` — добавлен вручную.  * `NOT_PARTICIPATING` — не участвует в акции.  Об автоматическом и ручном добавлении товаров в акцию читайте [в Справке Маркета для продавцов](https://yandex.ru/support2/marketplace/ru/marketing/promos/market/index). 
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum PromoOfferParticipationStatusType {
    #[serde(rename = "AUTO")]
    Auto,
    #[serde(rename = "PARTIALLY_AUTO")]
    PartiallyAuto,
    #[serde(rename = "MANUAL")]
    Manual,
    #[serde(rename = "NOT_PARTICIPATING")]
    NotParticipating,
}

impl std::fmt::Display for PromoOfferParticipationStatusType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            PromoOfferParticipationStatusType::Auto => write!(f, "AUTO"),
            PromoOfferParticipationStatusType::PartiallyAuto => write!(f, "PARTIALLY_AUTO"),
            PromoOfferParticipationStatusType::Manual => write!(f, "MANUAL"),
            PromoOfferParticipationStatusType::NotParticipating => write!(f, "NOT_PARTICIPATING"),
        }
    }
}

impl std::str::FromStr for PromoOfferParticipationStatusType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "AUTO" => std::result::Result::Ok(PromoOfferParticipationStatusType::Auto),
            "PARTIALLY_AUTO" => std::result::Result::Ok(PromoOfferParticipationStatusType::PartiallyAuto),
            "MANUAL" => std::result::Result::Ok(PromoOfferParticipationStatusType::Manual),
            "NOT_PARTICIPATING" => std::result::Result::Ok(PromoOfferParticipationStatusType::NotParticipating),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Параметры товара в акции с типом `MARKET_PROMOCODE`.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PromoOfferPromocodeParamsDto {
    /// Максимально возможная цена для участия в акции до применения промокода.  Указывается в рублях.  Возвращается для всех товаров. 
    #[serde(rename = "maxPrice")]
    pub max_price: i64,

}


impl PromoOfferPromocodeParamsDto {
    #[allow(clippy::new_without_default)]
    pub fn new(max_price: i64, ) -> PromoOfferPromocodeParamsDto {
        PromoOfferPromocodeParamsDto {
            max_price,
        }
    }
}

/// Converts the PromoOfferPromocodeParamsDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for PromoOfferPromocodeParamsDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            Some("maxPrice".to_string()),
            Some(self.max_price.to_string()),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PromoOfferPromocodeParamsDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PromoOfferPromocodeParamsDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub max_price: Vec<i64>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PromoOfferPromocodeParamsDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "maxPrice" => intermediate_rep.max_price.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing PromoOfferPromocodeParamsDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PromoOfferPromocodeParamsDto {
            max_price: intermediate_rep.max_price.into_iter().next().ok_or_else(|| "maxPrice missing in PromoOfferPromocodeParamsDto".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PromoOfferPromocodeParamsDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<PromoOfferPromocodeParamsDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PromoOfferPromocodeParamsDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for PromoOfferPromocodeParamsDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<PromoOfferPromocodeParamsDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PromoOfferPromocodeParamsDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into PromoOfferPromocodeParamsDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Предупреждение, которое появилось при добавлении товара:  * `DEEP_DISCOUNT_OFFER` — большая разница с ценой в каталоге. Проверьте, нет ли ошибки.  * `CATALOG_PRICE_IS_LOWER_THAN_PROMO` — [базовая цена](*basic-price) в кабинете ниже цены по акции. У товара в акции будет отображаться базовая цена.  * `SHOP_PRICES_ARE_LOWER_THAN_PROMO` — цена в отдельном магазине ниже цены по акции. У товара в акции будет отображаться цена в магазине. Для остальных магазинов будет действовать цена по акции.  * `PROMOCODE_PRICE_MORE_THAN_MAX_FAIR_PRICE` — в отдельном магазине цена с учетом промокода выше максимально возможной цены. Товар не будет участвовать в акции.  * `SHOP_OFFER_NOT_ELIGIBLE_FOR_PROMO` — товар в отдельном магазине не подходит под условия акции. 
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum PromoOfferUpdateWarningCodeType {
    #[serde(rename = "DEEP_DISCOUNT_OFFER")]
    DeepDiscountOffer,
    #[serde(rename = "CATALOG_PRICE_IS_LOWER_THAN_PROMO")]
    CatalogPriceIsLowerThanPromo,
    #[serde(rename = "SHOP_PRICES_ARE_LOWER_THAN_PROMO")]
    ShopPricesAreLowerThanPromo,
    #[serde(rename = "PROMOCODE_PRICE_MORE_THAN_MAX_FAIR_PRICE")]
    PromocodePriceMoreThanMaxFairPrice,
    #[serde(rename = "SHOP_OFFER_NOT_ELIGIBLE_FOR_PROMO")]
    ShopOfferNotEligibleForPromo,
}

impl std::fmt::Display for PromoOfferUpdateWarningCodeType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            PromoOfferUpdateWarningCodeType::DeepDiscountOffer => write!(f, "DEEP_DISCOUNT_OFFER"),
            PromoOfferUpdateWarningCodeType::CatalogPriceIsLowerThanPromo => write!(f, "CATALOG_PRICE_IS_LOWER_THAN_PROMO"),
            PromoOfferUpdateWarningCodeType::ShopPricesAreLowerThanPromo => write!(f, "SHOP_PRICES_ARE_LOWER_THAN_PROMO"),
            PromoOfferUpdateWarningCodeType::PromocodePriceMoreThanMaxFairPrice => write!(f, "PROMOCODE_PRICE_MORE_THAN_MAX_FAIR_PRICE"),
            PromoOfferUpdateWarningCodeType::ShopOfferNotEligibleForPromo => write!(f, "SHOP_OFFER_NOT_ELIGIBLE_FOR_PROMO"),
        }
    }
}

impl std::str::FromStr for PromoOfferUpdateWarningCodeType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "DEEP_DISCOUNT_OFFER" => std::result::Result::Ok(PromoOfferUpdateWarningCodeType::DeepDiscountOffer),
            "CATALOG_PRICE_IS_LOWER_THAN_PROMO" => std::result::Result::Ok(PromoOfferUpdateWarningCodeType::CatalogPriceIsLowerThanPromo),
            "SHOP_PRICES_ARE_LOWER_THAN_PROMO" => std::result::Result::Ok(PromoOfferUpdateWarningCodeType::ShopPricesAreLowerThanPromo),
            "PROMOCODE_PRICE_MORE_THAN_MAX_FAIR_PRICE" => std::result::Result::Ok(PromoOfferUpdateWarningCodeType::PromocodePriceMoreThanMaxFairPrice),
            "SHOP_OFFER_NOT_ELIGIBLE_FOR_PROMO" => std::result::Result::Ok(PromoOfferUpdateWarningCodeType::ShopOfferNotEligibleForPromo),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Предупреждение, которое появилось при добавлении товара в акцию или изменении его цен.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PromoOfferUpdateWarningDto {
    #[serde(rename = "code")]
    pub code: models::PromoOfferUpdateWarningCodeType,

    /// Идентификаторы магазинов в кабинете, для которых получены предупреждения.  Не возвращается, если предупреждения действуют для всех магазинов в кабинете. 
    #[serde(rename = "campaignIds")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub campaign_ids: Option<swagger::Nullable<Vec<i64>>>,

}


impl PromoOfferUpdateWarningDto {
    #[allow(clippy::new_without_default)]
    pub fn new(code: models::PromoOfferUpdateWarningCodeType, ) -> PromoOfferUpdateWarningDto {
        PromoOfferUpdateWarningDto {
            code,
            campaign_ids: None,
        }
    }
}

/// Converts the PromoOfferUpdateWarningDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for PromoOfferUpdateWarningDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping code in query parameter serialization


            self.campaign_ids.as_ref().map(|campaign_ids| {
                [
                    "campaignIds".to_string(),
                    campaign_ids.as_ref().map_or("null".to_string(), |x| x.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PromoOfferUpdateWarningDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PromoOfferUpdateWarningDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub code: Vec<models::PromoOfferUpdateWarningCodeType>,
            pub campaign_ids: Vec<Vec<i64>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PromoOfferUpdateWarningDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "code" => intermediate_rep.code.push(<models::PromoOfferUpdateWarningCodeType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "campaignIds" => return std::result::Result::Err("Parsing a container in this style is not supported in PromoOfferUpdateWarningDto".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing PromoOfferUpdateWarningDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PromoOfferUpdateWarningDto {
            code: intermediate_rep.code.into_iter().next().ok_or_else(|| "code missing in PromoOfferUpdateWarningDto".to_string())?,
            campaign_ids: std::result::Result::Err("Nullable types not supported in PromoOfferUpdateWarningDto".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PromoOfferUpdateWarningDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<PromoOfferUpdateWarningDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PromoOfferUpdateWarningDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for PromoOfferUpdateWarningDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<PromoOfferUpdateWarningDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PromoOfferUpdateWarningDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into PromoOfferUpdateWarningDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Какие акции вернутся:  * `PARTICIPATING_NOW` — текущие и будущие акции продавца.  * `PARTICIPATED` — завершенные акции продавца за последний год. Если за год их было меньше 15, в ответе придут 15 последних акций за все время. 
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum PromoParticipationType {
    #[serde(rename = "PARTICIPATING_NOW")]
    ParticipatingNow,
    #[serde(rename = "PARTICIPATED")]
    Participated,
}

impl std::fmt::Display for PromoParticipationType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            PromoParticipationType::ParticipatingNow => write!(f, "PARTICIPATING_NOW"),
            PromoParticipationType::Participated => write!(f, "PARTICIPATED"),
        }
    }
}

impl std::str::FromStr for PromoParticipationType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "PARTICIPATING_NOW" => std::result::Result::Ok(PromoParticipationType::ParticipatingNow),
            "PARTICIPATED" => std::result::Result::Ok(PromoParticipationType::Participated),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Время проведения акции.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PromoPeriodDto {
    /// Дата и время начала акции.
    #[serde(rename = "dateTimeFrom")]
    pub date_time_from: chrono::DateTime::<chrono::Utc>,

    /// Дата и время окончания акции.
    #[serde(rename = "dateTimeTo")]
    pub date_time_to: chrono::DateTime::<chrono::Utc>,

}


impl PromoPeriodDto {
    #[allow(clippy::new_without_default)]
    pub fn new(date_time_from: chrono::DateTime::<chrono::Utc>, date_time_to: chrono::DateTime::<chrono::Utc>, ) -> PromoPeriodDto {
        PromoPeriodDto {
            date_time_from,
            date_time_to,
        }
    }
}

/// Converts the PromoPeriodDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for PromoPeriodDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping dateTimeFrom in query parameter serialization

            // Skipping dateTimeTo in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PromoPeriodDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PromoPeriodDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub date_time_from: Vec<chrono::DateTime::<chrono::Utc>>,
            pub date_time_to: Vec<chrono::DateTime::<chrono::Utc>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PromoPeriodDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "dateTimeFrom" => intermediate_rep.date_time_from.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "dateTimeTo" => intermediate_rep.date_time_to.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing PromoPeriodDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PromoPeriodDto {
            date_time_from: intermediate_rep.date_time_from.into_iter().next().ok_or_else(|| "dateTimeFrom missing in PromoPeriodDto".to_string())?,
            date_time_to: intermediate_rep.date_time_to.into_iter().next().ok_or_else(|| "dateTimeTo missing in PromoPeriodDto".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PromoPeriodDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<PromoPeriodDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PromoPeriodDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for PromoPeriodDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<PromoPeriodDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PromoPeriodDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into PromoPeriodDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Запрос на передачу ключей цифровых товаров.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ProvideOrderDigitalCodesRequest {
    /// Список проданных ключей.  Если в заказе есть несколько **одинаковых** товаров (например, несколько ключей к одной и той же подписке), передайте каждый в виде отдельного элемента массива. `id` у этих элементов должен быть один и тот же. 
    #[serde(rename = "items")]
    pub items: Vec<models::OrderDigitalItemDto>,

}


impl ProvideOrderDigitalCodesRequest {
    #[allow(clippy::new_without_default)]
    pub fn new(items: Vec<models::OrderDigitalItemDto>, ) -> ProvideOrderDigitalCodesRequest {
        ProvideOrderDigitalCodesRequest {
            items,
        }
    }
}

/// Converts the ProvideOrderDigitalCodesRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ProvideOrderDigitalCodesRequest {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping items in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ProvideOrderDigitalCodesRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ProvideOrderDigitalCodesRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub items: Vec<Vec<models::OrderDigitalItemDto>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ProvideOrderDigitalCodesRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "items" => return std::result::Result::Err("Parsing a container in this style is not supported in ProvideOrderDigitalCodesRequest".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing ProvideOrderDigitalCodesRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ProvideOrderDigitalCodesRequest {
            items: intermediate_rep.items.into_iter().next().ok_or_else(|| "items missing in ProvideOrderDigitalCodesRequest".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ProvideOrderDigitalCodesRequest> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<ProvideOrderDigitalCodesRequest>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ProvideOrderDigitalCodesRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ProvideOrderDigitalCodesRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<ProvideOrderDigitalCodesRequest> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ProvideOrderDigitalCodesRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ProvideOrderDigitalCodesRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ProvideOrderItemIdentifiersRequest {
    /// Список позиций, требующих маркировки. 
    #[serde(rename = "items")]
    pub items: Vec<models::OrderItemInstanceModificationDto>,

}


impl ProvideOrderItemIdentifiersRequest {
    #[allow(clippy::new_without_default)]
    pub fn new(items: Vec<models::OrderItemInstanceModificationDto>, ) -> ProvideOrderItemIdentifiersRequest {
        ProvideOrderItemIdentifiersRequest {
            items,
        }
    }
}

/// Converts the ProvideOrderItemIdentifiersRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ProvideOrderItemIdentifiersRequest {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping items in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ProvideOrderItemIdentifiersRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ProvideOrderItemIdentifiersRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub items: Vec<Vec<models::OrderItemInstanceModificationDto>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ProvideOrderItemIdentifiersRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "items" => return std::result::Result::Err("Parsing a container in this style is not supported in ProvideOrderItemIdentifiersRequest".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing ProvideOrderItemIdentifiersRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ProvideOrderItemIdentifiersRequest {
            items: intermediate_rep.items.into_iter().next().ok_or_else(|| "items missing in ProvideOrderItemIdentifiersRequest".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ProvideOrderItemIdentifiersRequest> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<ProvideOrderItemIdentifiersRequest>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ProvideOrderItemIdentifiersRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ProvideOrderItemIdentifiersRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<ProvideOrderItemIdentifiersRequest> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ProvideOrderItemIdentifiersRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ProvideOrderItemIdentifiersRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ProvideOrderItemIdentifiersResponse {
    #[serde(rename = "status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<models::ApiResponseStatusType>,

    #[serde(rename = "result")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub result: Option<models::OrderItemsModificationResultDto>,

}


impl ProvideOrderItemIdentifiersResponse {
    #[allow(clippy::new_without_default)]
    pub fn new() -> ProvideOrderItemIdentifiersResponse {
        ProvideOrderItemIdentifiersResponse {
            status: None,
            result: None,
        }
    }
}

/// Converts the ProvideOrderItemIdentifiersResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ProvideOrderItemIdentifiersResponse {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping status in query parameter serialization

            // Skipping result in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ProvideOrderItemIdentifiersResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ProvideOrderItemIdentifiersResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub status: Vec<models::ApiResponseStatusType>,
            pub result: Vec<models::OrderItemsModificationResultDto>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ProvideOrderItemIdentifiersResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(<models::ApiResponseStatusType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "result" => intermediate_rep.result.push(<models::OrderItemsModificationResultDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ProvideOrderItemIdentifiersResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ProvideOrderItemIdentifiersResponse {
            status: intermediate_rep.status.into_iter().next(),
            result: intermediate_rep.result.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ProvideOrderItemIdentifiersResponse> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<ProvideOrderItemIdentifiersResponse>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ProvideOrderItemIdentifiersResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ProvideOrderItemIdentifiersResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<ProvideOrderItemIdentifiersResponse> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ProvideOrderItemIdentifiersResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ProvideOrderItemIdentifiersResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// description.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PutSkuBidsRequest {
    /// Список товаров и ставки для продвижения, которые на них нужно установить.
    #[serde(rename = "bids")]
    #[validate(
            length(min = 1, max = 1500),
        )]
    pub bids: Vec<models::SkuBidItemDto>,

}


impl PutSkuBidsRequest {
    #[allow(clippy::new_without_default)]
    pub fn new(bids: Vec<models::SkuBidItemDto>, ) -> PutSkuBidsRequest {
        PutSkuBidsRequest {
            bids,
        }
    }
}

/// Converts the PutSkuBidsRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for PutSkuBidsRequest {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping bids in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PutSkuBidsRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PutSkuBidsRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub bids: Vec<Vec<models::SkuBidItemDto>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PutSkuBidsRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "bids" => return std::result::Result::Err("Parsing a container in this style is not supported in PutSkuBidsRequest".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing PutSkuBidsRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PutSkuBidsRequest {
            bids: intermediate_rep.bids.into_iter().next().ok_or_else(|| "bids missing in PutSkuBidsRequest".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PutSkuBidsRequest> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<PutSkuBidsRequest>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PutSkuBidsRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for PutSkuBidsRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<PutSkuBidsRequest> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PutSkuBidsRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into PutSkuBidsRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Информация о заказе, который повлиял на индекс качества.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct QualityRatingAffectedOrderDto {
    /// Идентификатор заказа.
    #[serde(rename = "orderId")]
    #[validate(
            range(min = 0),
        )]
    pub order_id: i64,

    /// Описание проблемы.
    #[serde(rename = "description")]
    pub description: String,

    #[serde(rename = "componentType")]
    pub component_type: models::AffectedOrderQualityRatingComponentType,

}


impl QualityRatingAffectedOrderDto {
    #[allow(clippy::new_without_default)]
    pub fn new(order_id: i64, description: String, component_type: models::AffectedOrderQualityRatingComponentType, ) -> QualityRatingAffectedOrderDto {
        QualityRatingAffectedOrderDto {
            order_id,
            description,
            component_type,
        }
    }
}

/// Converts the QualityRatingAffectedOrderDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for QualityRatingAffectedOrderDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            Some("orderId".to_string()),
            Some(self.order_id.to_string()),


            Some("description".to_string()),
            Some(self.description.to_string()),

            // Skipping componentType in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a QualityRatingAffectedOrderDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for QualityRatingAffectedOrderDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub order_id: Vec<i64>,
            pub description: Vec<String>,
            pub component_type: Vec<models::AffectedOrderQualityRatingComponentType>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing QualityRatingAffectedOrderDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "orderId" => intermediate_rep.order_id.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "description" => intermediate_rep.description.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "componentType" => intermediate_rep.component_type.push(<models::AffectedOrderQualityRatingComponentType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing QualityRatingAffectedOrderDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(QualityRatingAffectedOrderDto {
            order_id: intermediate_rep.order_id.into_iter().next().ok_or_else(|| "orderId missing in QualityRatingAffectedOrderDto".to_string())?,
            description: intermediate_rep.description.into_iter().next().ok_or_else(|| "description missing in QualityRatingAffectedOrderDto".to_string())?,
            component_type: intermediate_rep.component_type.into_iter().next().ok_or_else(|| "componentType missing in QualityRatingAffectedOrderDto".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<QualityRatingAffectedOrderDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<QualityRatingAffectedOrderDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<QualityRatingAffectedOrderDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for QualityRatingAffectedOrderDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<QualityRatingAffectedOrderDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <QualityRatingAffectedOrderDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into QualityRatingAffectedOrderDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Составляющая индекса качества.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct QualityRatingComponentDto {
    /// Значение составляющей в процентах.
    #[serde(rename = "value")]
    #[validate(
            range(min = 0, max = 100),
        )]
    pub value: f64,

    #[serde(rename = "componentType")]
    pub component_type: models::QualityRatingComponentType,

}


impl QualityRatingComponentDto {
    #[allow(clippy::new_without_default)]
    pub fn new(value: f64, component_type: models::QualityRatingComponentType, ) -> QualityRatingComponentDto {
        QualityRatingComponentDto {
            value,
            component_type,
        }
    }
}

/// Converts the QualityRatingComponentDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for QualityRatingComponentDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            Some("value".to_string()),
            Some(self.value.to_string()),

            // Skipping componentType in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a QualityRatingComponentDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for QualityRatingComponentDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub value: Vec<f64>,
            pub component_type: Vec<models::QualityRatingComponentType>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing QualityRatingComponentDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "value" => intermediate_rep.value.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "componentType" => intermediate_rep.component_type.push(<models::QualityRatingComponentType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing QualityRatingComponentDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(QualityRatingComponentDto {
            value: intermediate_rep.value.into_iter().next().ok_or_else(|| "value missing in QualityRatingComponentDto".to_string())?,
            component_type: intermediate_rep.component_type.into_iter().next().ok_or_else(|| "componentType missing in QualityRatingComponentDto".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<QualityRatingComponentDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<QualityRatingComponentDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<QualityRatingComponentDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for QualityRatingComponentDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<QualityRatingComponentDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <QualityRatingComponentDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into QualityRatingComponentDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Составляющие индекса качества.  **Для модели DBS:** * `DBS_CANCELLATION_RATE` — доля отмененных товаров. * `DBS_LATE_DELIVERY_RATE` — доля заказов, доставленных после плановой даты.  **Для моделей FBS и Экспресс:** * `FBS_CANCELLATION_RATE` — доля отмененных товаров. * `FBS_LATE_SHIP_RATE` — доля не вовремя отгруженных заказов.  **Для модели FBY:** * `FBY_LATE_DELIVERY_RATE` — доля товаров, которые приехали на склад с опозданием. * `FBY_CANCELLATION_RATE` — доля отмененных или недоставленных товаров. * `FBY_DELIVERY_DIFF_RATE` — доля товаров, которые не прибыли вместе с поставкой или которые не приняли. * `FBY_LATE_EDITING_RATE` — доля товаров, которые поздно убрали из заявки. 
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum QualityRatingComponentType {
    #[serde(rename = "DBS_CANCELLATION_RATE")]
    DbsCancellationRate,
    #[serde(rename = "DBS_LATE_DELIVERY_RATE")]
    DbsLateDeliveryRate,
    #[serde(rename = "FBS_CANCELLATION_RATE")]
    FbsCancellationRate,
    #[serde(rename = "FBS_LATE_SHIP_RATE")]
    FbsLateShipRate,
    #[serde(rename = "FBY_LATE_DELIVERY_RATE")]
    FbyLateDeliveryRate,
    #[serde(rename = "FBY_CANCELLATION_RATE")]
    FbyCancellationRate,
    #[serde(rename = "FBY_DELIVERY_DIFF_RATE")]
    FbyDeliveryDiffRate,
    #[serde(rename = "FBY_LATE_EDITING_RATE")]
    FbyLateEditingRate,
}

impl std::fmt::Display for QualityRatingComponentType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            QualityRatingComponentType::DbsCancellationRate => write!(f, "DBS_CANCELLATION_RATE"),
            QualityRatingComponentType::DbsLateDeliveryRate => write!(f, "DBS_LATE_DELIVERY_RATE"),
            QualityRatingComponentType::FbsCancellationRate => write!(f, "FBS_CANCELLATION_RATE"),
            QualityRatingComponentType::FbsLateShipRate => write!(f, "FBS_LATE_SHIP_RATE"),
            QualityRatingComponentType::FbyLateDeliveryRate => write!(f, "FBY_LATE_DELIVERY_RATE"),
            QualityRatingComponentType::FbyCancellationRate => write!(f, "FBY_CANCELLATION_RATE"),
            QualityRatingComponentType::FbyDeliveryDiffRate => write!(f, "FBY_DELIVERY_DIFF_RATE"),
            QualityRatingComponentType::FbyLateEditingRate => write!(f, "FBY_LATE_EDITING_RATE"),
        }
    }
}

impl std::str::FromStr for QualityRatingComponentType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "DBS_CANCELLATION_RATE" => std::result::Result::Ok(QualityRatingComponentType::DbsCancellationRate),
            "DBS_LATE_DELIVERY_RATE" => std::result::Result::Ok(QualityRatingComponentType::DbsLateDeliveryRate),
            "FBS_CANCELLATION_RATE" => std::result::Result::Ok(QualityRatingComponentType::FbsCancellationRate),
            "FBS_LATE_SHIP_RATE" => std::result::Result::Ok(QualityRatingComponentType::FbsLateShipRate),
            "FBY_LATE_DELIVERY_RATE" => std::result::Result::Ok(QualityRatingComponentType::FbyLateDeliveryRate),
            "FBY_CANCELLATION_RATE" => std::result::Result::Ok(QualityRatingComponentType::FbyCancellationRate),
            "FBY_DELIVERY_DIFF_RATE" => std::result::Result::Ok(QualityRatingComponentType::FbyDeliveryDiffRate),
            "FBY_LATE_EDITING_RATE" => std::result::Result::Ok(QualityRatingComponentType::FbyLateEditingRate),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Информация о заказах, которые повлияли на индекс качества.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct QualityRatingDetailsDto {
    /// Список заказов, которые повлияли на индекс качества.
    #[serde(rename = "affectedOrders")]
    pub affected_orders: Vec<models::QualityRatingAffectedOrderDto>,

}


impl QualityRatingDetailsDto {
    #[allow(clippy::new_without_default)]
    pub fn new(affected_orders: Vec<models::QualityRatingAffectedOrderDto>, ) -> QualityRatingDetailsDto {
        QualityRatingDetailsDto {
            affected_orders,
        }
    }
}

/// Converts the QualityRatingDetailsDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for QualityRatingDetailsDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping affectedOrders in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a QualityRatingDetailsDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for QualityRatingDetailsDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub affected_orders: Vec<Vec<models::QualityRatingAffectedOrderDto>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing QualityRatingDetailsDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "affectedOrders" => return std::result::Result::Err("Parsing a container in this style is not supported in QualityRatingDetailsDto".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing QualityRatingDetailsDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(QualityRatingDetailsDto {
            affected_orders: intermediate_rep.affected_orders.into_iter().next().ok_or_else(|| "affectedOrders missing in QualityRatingDetailsDto".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<QualityRatingDetailsDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<QualityRatingDetailsDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<QualityRatingDetailsDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for QualityRatingDetailsDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<QualityRatingDetailsDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <QualityRatingDetailsDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into QualityRatingDetailsDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Информация об индексе качества.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct QualityRatingDto {
    /// Значение индекса качества.
    #[serde(rename = "rating")]
    #[validate(
            range(min = 0, max = 100),
        )]
    pub rating: i64,

    /// Дата вычисления.  Формат даты: `ГГГГ‑ММ‑ДД`. 
    #[serde(rename = "calculationDate")]
    pub calculation_date: chrono::naive::NaiveDate,

    /// Составляющие индекса качества.
    #[serde(rename = "components")]
    pub components: Vec<models::QualityRatingComponentDto>,

}


impl QualityRatingDto {
    #[allow(clippy::new_without_default)]
    pub fn new(rating: i64, calculation_date: chrono::naive::NaiveDate, components: Vec<models::QualityRatingComponentDto>, ) -> QualityRatingDto {
        QualityRatingDto {
            rating,
            calculation_date,
            components,
        }
    }
}

/// Converts the QualityRatingDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for QualityRatingDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            Some("rating".to_string()),
            Some(self.rating.to_string()),

            // Skipping calculationDate in query parameter serialization

            // Skipping components in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a QualityRatingDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for QualityRatingDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub rating: Vec<i64>,
            pub calculation_date: Vec<chrono::naive::NaiveDate>,
            pub components: Vec<Vec<models::QualityRatingComponentDto>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing QualityRatingDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "rating" => intermediate_rep.rating.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "calculationDate" => intermediate_rep.calculation_date.push(<chrono::naive::NaiveDate as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "components" => return std::result::Result::Err("Parsing a container in this style is not supported in QualityRatingDto".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing QualityRatingDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(QualityRatingDto {
            rating: intermediate_rep.rating.into_iter().next().ok_or_else(|| "rating missing in QualityRatingDto".to_string())?,
            calculation_date: intermediate_rep.calculation_date.into_iter().next().ok_or_else(|| "calculationDate missing in QualityRatingDto".to_string())?,
            components: intermediate_rep.components.into_iter().next().ok_or_else(|| "components missing in QualityRatingDto".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<QualityRatingDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<QualityRatingDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<QualityRatingDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for QualityRatingDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<QualityRatingDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <QualityRatingDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into QualityRatingDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Настройка продажи квантами.  Чтобы сбросить установленные ранее значения, передайте пустой параметр `quantum`.  {% cut \"Пример\" %}  ```json {   \"offers\": [     {       \"offerId\": \"08e35dc1-89a2-11e3-8055-0015e9b8c48d\",       \"quantum\": {}     }   ] } ```  {% endcut %} 
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct QuantumDto {
    /// Минимальное количество единиц товара в заказе. Например, если указать 10, покупатель сможет добавить в корзину не меньше 10 единиц.  ⚠️ Если количество товара на складе меньше заданного, ограничение не сработает и покупатель сможет его заказать. 
    #[serde(rename = "minQuantity")]
    #[validate(
            range(min = 1),
        )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub min_quantity: Option<u32>,

    /// На сколько единиц покупатель сможет увеличить количество товара в корзине.  Например, если задать 5, покупатель сможет добавить к заказу только 5, 10, 15, ... единиц товара.  ⚠️ Если количество товара на складе не дотягивает до кванта, ограничение не сработает и покупатель сможет заказать количество, не кратное кванту. 
    #[serde(rename = "stepQuantity")]
    #[validate(
            range(min = 1, max = 100),
        )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub step_quantity: Option<u32>,

}


impl QuantumDto {
    #[allow(clippy::new_without_default)]
    pub fn new() -> QuantumDto {
        QuantumDto {
            min_quantity: None,
            step_quantity: None,
        }
    }
}

/// Converts the QuantumDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for QuantumDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.min_quantity.as_ref().map(|min_quantity| {
                [
                    "minQuantity".to_string(),
                    min_quantity.to_string(),
                ].join(",")
            }),


            self.step_quantity.as_ref().map(|step_quantity| {
                [
                    "stepQuantity".to_string(),
                    step_quantity.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a QuantumDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for QuantumDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub min_quantity: Vec<u32>,
            pub step_quantity: Vec<u32>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing QuantumDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "minQuantity" => intermediate_rep.min_quantity.push(<u32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "stepQuantity" => intermediate_rep.step_quantity.push(<u32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing QuantumDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(QuantumDto {
            min_quantity: intermediate_rep.min_quantity.into_iter().next(),
            step_quantity: intermediate_rep.step_quantity.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<QuantumDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<QuantumDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<QuantumDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for QuantumDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<QuantumDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <QuantumDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into QuantumDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Товар в карантине.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct QuarantineOfferDto {
    /// Ваш SKU — идентификатор товара в вашей системе.  Разрешена любая последовательность длиной до 255 знаков.  Правила использования SKU:  * У каждого товара SKU должен быть свой.  * SKU товара нельзя менять — можно только удалить товар и добавить заново с новым SKU.  * Уже заданный SKU нельзя освободить и использовать заново для другого товара. Каждый товар должен получать новый идентификатор, до того никогда не использовавшийся в вашем каталоге.  [Что такое SKU и как его назначать](https://yandex.ru/support/marketplace/assortment/add/index.html#fields) 
    #[serde(rename = "offerId")]
    #[validate(
            length(min = 1, max = 255),
           regex = "RE_QUARANTINEOFFERDTO_OFFER_ID",
        )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub offer_id: Option<String>,

    #[serde(rename = "currentPrice")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub current_price: Option<models::BasePriceDto>,

    #[serde(rename = "lastValidPrice")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub last_valid_price: Option<models::BasePriceDto>,

    /// Причины попадания товара в карантин.
    #[serde(rename = "verdicts")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub verdicts: Option<swagger::Nullable<Vec<models::PriceQuarantineVerdictDto>>>,

}

lazy_static::lazy_static! {
    static ref RE_QUARANTINEOFFERDTO_OFFER_ID: regex::Regex = regex::Regex::new(r"^[^\\x00-\\x08\\x0A-\\x1f\\x7f]{1,255}$").unwrap();
}

impl QuarantineOfferDto {
    #[allow(clippy::new_without_default)]
    pub fn new() -> QuarantineOfferDto {
        QuarantineOfferDto {
            offer_id: None,
            current_price: None,
            last_valid_price: None,
            verdicts: None,
        }
    }
}

/// Converts the QuarantineOfferDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for QuarantineOfferDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.offer_id.as_ref().map(|offer_id| {
                [
                    "offerId".to_string(),
                    offer_id.to_string(),
                ].join(",")
            }),

            // Skipping currentPrice in query parameter serialization

            // Skipping lastValidPrice in query parameter serialization

            // Skipping verdicts in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a QuarantineOfferDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for QuarantineOfferDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub offer_id: Vec<String>,
            pub current_price: Vec<models::BasePriceDto>,
            pub last_valid_price: Vec<models::BasePriceDto>,
            pub verdicts: Vec<Vec<models::PriceQuarantineVerdictDto>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing QuarantineOfferDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "offerId" => intermediate_rep.offer_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "currentPrice" => intermediate_rep.current_price.push(<models::BasePriceDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "lastValidPrice" => intermediate_rep.last_valid_price.push(<models::BasePriceDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "verdicts" => return std::result::Result::Err("Parsing a container in this style is not supported in QuarantineOfferDto".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing QuarantineOfferDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(QuarantineOfferDto {
            offer_id: intermediate_rep.offer_id.into_iter().next(),
            current_price: intermediate_rep.current_price.into_iter().next(),
            last_valid_price: intermediate_rep.last_valid_price.into_iter().next(),
            verdicts: std::result::Result::Err("Nullable types not supported in QuarantineOfferDto".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<QuarantineOfferDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<QuarantineOfferDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<QuarantineOfferDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for QuarantineOfferDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<QuarantineOfferDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <QuarantineOfferDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into QuarantineOfferDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Способ возврата товара покупателем:  * `SHOP` — в точку возврата магазина.  * `DELIVERY_SERVICE` — отправить курьером.  * `POST` — почта. 
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum RecipientType {
    #[serde(rename = "SHOP")]
    Shop,
    #[serde(rename = "DELIVERY_SERVICE")]
    DeliveryService,
    #[serde(rename = "POST")]
    Post,
}

impl std::fmt::Display for RecipientType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            RecipientType::Shop => write!(f, "SHOP"),
            RecipientType::DeliveryService => write!(f, "DELIVERY_SERVICE"),
            RecipientType::Post => write!(f, "POST"),
        }
    }
}

impl std::str::FromStr for RecipientType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "SHOP" => std::result::Result::Ok(RecipientType::Shop),
            "DELIVERY_SERVICE" => std::result::Result::Ok(RecipientType::DeliveryService),
            "POST" => std::result::Result::Ok(RecipientType::Post),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Cтатус возврата денег:  * `STARTED_BY_USER` — создан клиентом из личного кабинета.  * `REFUND_IN_PROGRESS` — ждет решение о возврате денег.  * `REFUNDED` — по возврату проведены все возвратные денежные транзакции.  * `FAILED` — невозможно провести возврат покупателю.  * `WAITING_FOR_DECISION` — ожидает решения.  * `DECISION_MADE` — по возврату принято решение.  * `REFUNDED_WITH_BONUSES` — возврат осуществлен баллами Плюса или промокодом.  * `REFUNDED_BY_SHOP` — магазин сделал самостоятельно возврат денег.  * `COMPLETE_WITHOUT_REFUND` — возврат денег не требуется.  * `CANCELLED` — возврат отменен. 
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum RefundStatusType {
    #[serde(rename = "STARTED_BY_USER")]
    StartedByUser,
    #[serde(rename = "REFUND_IN_PROGRESS")]
    RefundInProgress,
    #[serde(rename = "REFUNDED")]
    Refunded,
    #[serde(rename = "FAILED")]
    Failed,
    #[serde(rename = "WAITING_FOR_DECISION")]
    WaitingForDecision,
    #[serde(rename = "DECISION_MADE")]
    DecisionMade,
    #[serde(rename = "REFUNDED_WITH_BONUSES")]
    RefundedWithBonuses,
    #[serde(rename = "REFUNDED_BY_SHOP")]
    RefundedByShop,
    #[serde(rename = "CANCELLED")]
    Cancelled,
    #[serde(rename = "COMPLETE_WITHOUT_REFUND")]
    CompleteWithoutRefund,
    #[serde(rename = "UNKNOWN")]
    Unknown,
}

impl std::fmt::Display for RefundStatusType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            RefundStatusType::StartedByUser => write!(f, "STARTED_BY_USER"),
            RefundStatusType::RefundInProgress => write!(f, "REFUND_IN_PROGRESS"),
            RefundStatusType::Refunded => write!(f, "REFUNDED"),
            RefundStatusType::Failed => write!(f, "FAILED"),
            RefundStatusType::WaitingForDecision => write!(f, "WAITING_FOR_DECISION"),
            RefundStatusType::DecisionMade => write!(f, "DECISION_MADE"),
            RefundStatusType::RefundedWithBonuses => write!(f, "REFUNDED_WITH_BONUSES"),
            RefundStatusType::RefundedByShop => write!(f, "REFUNDED_BY_SHOP"),
            RefundStatusType::Cancelled => write!(f, "CANCELLED"),
            RefundStatusType::CompleteWithoutRefund => write!(f, "COMPLETE_WITHOUT_REFUND"),
            RefundStatusType::Unknown => write!(f, "UNKNOWN"),
        }
    }
}

impl std::str::FromStr for RefundStatusType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "STARTED_BY_USER" => std::result::Result::Ok(RefundStatusType::StartedByUser),
            "REFUND_IN_PROGRESS" => std::result::Result::Ok(RefundStatusType::RefundInProgress),
            "REFUNDED" => std::result::Result::Ok(RefundStatusType::Refunded),
            "FAILED" => std::result::Result::Ok(RefundStatusType::Failed),
            "WAITING_FOR_DECISION" => std::result::Result::Ok(RefundStatusType::WaitingForDecision),
            "DECISION_MADE" => std::result::Result::Ok(RefundStatusType::DecisionMade),
            "REFUNDED_WITH_BONUSES" => std::result::Result::Ok(RefundStatusType::RefundedWithBonuses),
            "REFUNDED_BY_SHOP" => std::result::Result::Ok(RefundStatusType::RefundedByShop),
            "CANCELLED" => std::result::Result::Ok(RefundStatusType::Cancelled),
            "COMPLETE_WITHOUT_REFUND" => std::result::Result::Ok(RefundStatusType::CompleteWithoutRefund),
            "UNKNOWN" => std::result::Result::Ok(RefundStatusType::Unknown),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Регион доставки.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RegionDto {
    /// Идентификатор региона.
    #[serde(rename = "id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,

    /// Название региона.
    #[serde(rename = "name")]
    pub name: String,

    #[serde(rename = "type")]
    pub r#type: models::RegionType,

    #[serde(rename = "parent")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub parent: Option<models::RegionDto>,

    /// Дочерние регионы.
    #[serde(rename = "children")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub children: Option<swagger::Nullable<Vec<models::RegionDto>>>,

}


impl RegionDto {
    #[allow(clippy::new_without_default)]
    pub fn new(name: String, r#type: models::RegionType, ) -> RegionDto {
        RegionDto {
            id: None,
            name,
            r#type,
            parent: None,
            children: None,
        }
    }
}

/// Converts the RegionDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for RegionDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.id.as_ref().map(|id| {
                [
                    "id".to_string(),
                    id.to_string(),
                ].join(",")
            }),


            Some("name".to_string()),
            Some(self.name.to_string()),

            // Skipping type in query parameter serialization

            // Skipping parent in query parameter serialization

            // Skipping children in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RegionDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RegionDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<i64>,
            pub name: Vec<String>,
            pub r#type: Vec<models::RegionType>,
            pub parent: Vec<models::RegionDto>,
            pub children: Vec<Vec<models::RegionDto>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing RegionDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r#type.push(<models::RegionType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "parent" => intermediate_rep.parent.push(<models::RegionDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "children" => return std::result::Result::Err("Parsing a container in this style is not supported in RegionDto".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing RegionDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RegionDto {
            id: intermediate_rep.id.into_iter().next(),
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "name missing in RegionDto".to_string())?,
            r#type: intermediate_rep.r#type.into_iter().next().ok_or_else(|| "type missing in RegionDto".to_string())?,
            parent: intermediate_rep.parent.into_iter().next(),
            children: std::result::Result::Err("Nullable types not supported in RegionDto".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RegionDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<RegionDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<RegionDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for RegionDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<RegionDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <RegionDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into RegionDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Тип региона.  Возможные значения:  * `CITY_DISTRICT` — район города.  * `CITY` — крупный город.  * `CONTINENT` — континент.  * `COUNTRY_DISTRICT` — область.  * `COUNTRY` — страна.  * `REGION` — регион.  * `REPUBLIC_AREA` — район субъекта федерации.  * `REPUBLIC` — субъект федерации.  * `SUBWAY_STATION` — станция метро.  * `VILLAGE` — город.  * `OTHER` — неизвестный регион. 
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum RegionType {
    #[serde(rename = "OTHER")]
    Other,
    #[serde(rename = "CONTINENT")]
    Continent,
    #[serde(rename = "REGION")]
    Region,
    #[serde(rename = "COUNTRY")]
    Country,
    #[serde(rename = "COUNTRY_DISTRICT")]
    CountryDistrict,
    #[serde(rename = "REPUBLIC")]
    Republic,
    #[serde(rename = "CITY")]
    City,
    #[serde(rename = "VILLAGE")]
    Village,
    #[serde(rename = "CITY_DISTRICT")]
    CityDistrict,
    #[serde(rename = "SUBWAY_STATION")]
    SubwayStation,
    #[serde(rename = "REPUBLIC_AREA")]
    RepublicArea,
}

impl std::fmt::Display for RegionType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            RegionType::Other => write!(f, "OTHER"),
            RegionType::Continent => write!(f, "CONTINENT"),
            RegionType::Region => write!(f, "REGION"),
            RegionType::Country => write!(f, "COUNTRY"),
            RegionType::CountryDistrict => write!(f, "COUNTRY_DISTRICT"),
            RegionType::Republic => write!(f, "REPUBLIC"),
            RegionType::City => write!(f, "CITY"),
            RegionType::Village => write!(f, "VILLAGE"),
            RegionType::CityDistrict => write!(f, "CITY_DISTRICT"),
            RegionType::SubwayStation => write!(f, "SUBWAY_STATION"),
            RegionType::RepublicArea => write!(f, "REPUBLIC_AREA"),
        }
    }
}

impl std::str::FromStr for RegionType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "OTHER" => std::result::Result::Ok(RegionType::Other),
            "CONTINENT" => std::result::Result::Ok(RegionType::Continent),
            "REGION" => std::result::Result::Ok(RegionType::Region),
            "COUNTRY" => std::result::Result::Ok(RegionType::Country),
            "COUNTRY_DISTRICT" => std::result::Result::Ok(RegionType::CountryDistrict),
            "REPUBLIC" => std::result::Result::Ok(RegionType::Republic),
            "CITY" => std::result::Result::Ok(RegionType::City),
            "VILLAGE" => std::result::Result::Ok(RegionType::Village),
            "CITY_DISTRICT" => std::result::Result::Ok(RegionType::CityDistrict),
            "SUBWAY_STATION" => std::result::Result::Ok(RegionType::SubwayStation),
            "REPUBLIC_AREA" => std::result::Result::Ok(RegionType::RepublicArea),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Региональная информация.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RegionalModelInfoDto {
    #[serde(rename = "currency")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub currency: Option<models::CurrencyType>,

    /// Идентификатор региона, для которого выводится информация о предложениях модели (доставляемых в этот регион).  Информацию о регионе по идентификатору можно получить с помощью запроса [GET regions/{regionId}](../../reference/regions/searchRegionsById.md). 
    #[serde(rename = "regionId")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub region_id: Option<i64>,

}


impl RegionalModelInfoDto {
    #[allow(clippy::new_without_default)]
    pub fn new() -> RegionalModelInfoDto {
        RegionalModelInfoDto {
            currency: None,
            region_id: None,
        }
    }
}

/// Converts the RegionalModelInfoDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for RegionalModelInfoDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping currency in query parameter serialization


            self.region_id.as_ref().map(|region_id| {
                [
                    "regionId".to_string(),
                    region_id.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RegionalModelInfoDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RegionalModelInfoDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub currency: Vec<models::CurrencyType>,
            pub region_id: Vec<i64>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing RegionalModelInfoDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "currency" => intermediate_rep.currency.push(<models::CurrencyType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "regionId" => intermediate_rep.region_id.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing RegionalModelInfoDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RegionalModelInfoDto {
            currency: intermediate_rep.currency.into_iter().next(),
            region_id: intermediate_rep.region_id.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RegionalModelInfoDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<RegionalModelInfoDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<RegionalModelInfoDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for RegionalModelInfoDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<RegionalModelInfoDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <RegionalModelInfoDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into RegionalModelInfoDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Информация о товаре и ошибки, которые появились при его удалении.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RejectedPromoOfferDeleteDto {
    /// Ваш SKU — идентификатор товара в вашей системе.  Разрешена любая последовательность длиной до 255 знаков.  Правила использования SKU:  * У каждого товара SKU должен быть свой.  * SKU товара нельзя менять — можно только удалить товар и добавить заново с новым SKU.  * Уже заданный SKU нельзя освободить и использовать заново для другого товара. Каждый товар должен получать новый идентификатор, до того никогда не использовавшийся в вашем каталоге.  [Что такое SKU и как его назначать](https://yandex.ru/support/marketplace/assortment/add/index.html#fields) 
    #[serde(rename = "offerId")]
    #[validate(
            length(min = 1, max = 255),
           regex = "RE_REJECTEDPROMOOFFERDELETEDTO_OFFER_ID",
        )]
    pub offer_id: String,

    #[serde(rename = "reason")]
    pub reason: models::RejectedPromoOfferDeleteReasonType,

}

lazy_static::lazy_static! {
    static ref RE_REJECTEDPROMOOFFERDELETEDTO_OFFER_ID: regex::Regex = regex::Regex::new(r"^[^\\x00-\\x08\\x0A-\\x1f\\x7f]{1,255}$").unwrap();
}

impl RejectedPromoOfferDeleteDto {
    #[allow(clippy::new_without_default)]
    pub fn new(offer_id: String, reason: models::RejectedPromoOfferDeleteReasonType, ) -> RejectedPromoOfferDeleteDto {
        RejectedPromoOfferDeleteDto {
            offer_id,
            reason,
        }
    }
}

/// Converts the RejectedPromoOfferDeleteDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for RejectedPromoOfferDeleteDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            Some("offerId".to_string()),
            Some(self.offer_id.to_string()),

            // Skipping reason in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RejectedPromoOfferDeleteDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RejectedPromoOfferDeleteDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub offer_id: Vec<String>,
            pub reason: Vec<models::RejectedPromoOfferDeleteReasonType>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing RejectedPromoOfferDeleteDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "offerId" => intermediate_rep.offer_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "reason" => intermediate_rep.reason.push(<models::RejectedPromoOfferDeleteReasonType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing RejectedPromoOfferDeleteDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RejectedPromoOfferDeleteDto {
            offer_id: intermediate_rep.offer_id.into_iter().next().ok_or_else(|| "offerId missing in RejectedPromoOfferDeleteDto".to_string())?,
            reason: intermediate_rep.reason.into_iter().next().ok_or_else(|| "reason missing in RejectedPromoOfferDeleteDto".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RejectedPromoOfferDeleteDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<RejectedPromoOfferDeleteDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<RejectedPromoOfferDeleteDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for RejectedPromoOfferDeleteDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<RejectedPromoOfferDeleteDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <RejectedPromoOfferDeleteDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into RejectedPromoOfferDeleteDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Описание ошибки:  * `OFFER_DOES_NOT_EXIST` — в кабинете нет товара с таким SKU. 
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum RejectedPromoOfferDeleteReasonType {
    #[serde(rename = "OFFER_DOES_NOT_EXIST")]
    OfferDoesNotExist,
}

impl std::fmt::Display for RejectedPromoOfferDeleteReasonType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            RejectedPromoOfferDeleteReasonType::OfferDoesNotExist => write!(f, "OFFER_DOES_NOT_EXIST"),
        }
    }
}

impl std::str::FromStr for RejectedPromoOfferDeleteReasonType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "OFFER_DOES_NOT_EXIST" => std::result::Result::Ok(RejectedPromoOfferDeleteReasonType::OfferDoesNotExist),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Описание отклоненного изменения.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RejectedPromoOfferUpdateDto {
    /// Ваш SKU — идентификатор товара в вашей системе.  Разрешена любая последовательность длиной до 255 знаков.  Правила использования SKU:  * У каждого товара SKU должен быть свой.  * SKU товара нельзя менять — можно только удалить товар и добавить заново с новым SKU.  * Уже заданный SKU нельзя освободить и использовать заново для другого товара. Каждый товар должен получать новый идентификатор, до того никогда не использовавшийся в вашем каталоге.  [Что такое SKU и как его назначать](https://yandex.ru/support/marketplace/assortment/add/index.html#fields) 
    #[serde(rename = "offerId")]
    #[validate(
            length(min = 1, max = 255),
           regex = "RE_REJECTEDPROMOOFFERUPDATEDTO_OFFER_ID",
        )]
    pub offer_id: String,

    #[serde(rename = "reason")]
    pub reason: models::RejectedPromoOfferUpdateReasonType,

}

lazy_static::lazy_static! {
    static ref RE_REJECTEDPROMOOFFERUPDATEDTO_OFFER_ID: regex::Regex = regex::Regex::new(r"^[^\\x00-\\x08\\x0A-\\x1f\\x7f]{1,255}$").unwrap();
}

impl RejectedPromoOfferUpdateDto {
    #[allow(clippy::new_without_default)]
    pub fn new(offer_id: String, reason: models::RejectedPromoOfferUpdateReasonType, ) -> RejectedPromoOfferUpdateDto {
        RejectedPromoOfferUpdateDto {
            offer_id,
            reason,
        }
    }
}

/// Converts the RejectedPromoOfferUpdateDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for RejectedPromoOfferUpdateDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            Some("offerId".to_string()),
            Some(self.offer_id.to_string()),

            // Skipping reason in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RejectedPromoOfferUpdateDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RejectedPromoOfferUpdateDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub offer_id: Vec<String>,
            pub reason: Vec<models::RejectedPromoOfferUpdateReasonType>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing RejectedPromoOfferUpdateDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "offerId" => intermediate_rep.offer_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "reason" => intermediate_rep.reason.push(<models::RejectedPromoOfferUpdateReasonType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing RejectedPromoOfferUpdateDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RejectedPromoOfferUpdateDto {
            offer_id: intermediate_rep.offer_id.into_iter().next().ok_or_else(|| "offerId missing in RejectedPromoOfferUpdateDto".to_string())?,
            reason: intermediate_rep.reason.into_iter().next().ok_or_else(|| "reason missing in RejectedPromoOfferUpdateDto".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RejectedPromoOfferUpdateDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<RejectedPromoOfferUpdateDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<RejectedPromoOfferUpdateDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for RejectedPromoOfferUpdateDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<RejectedPromoOfferUpdateDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <RejectedPromoOfferUpdateDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into RejectedPromoOfferUpdateDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Причина отклонения изменения:  * `OFFER_DOES_NOT_EXIST` — в кабинете нет товара с таким SKU.  * `OFFER_DUPLICATION` — один и тот же товар передан несколько раз.  * `OFFER_NOT_ELIGIBLE_FOR_PROMO` — товар не подходит под условия акции.  * `OFFER_PROMOS_MAX_BYTE_SIZE_EXCEEDED` — товар не добавлен в акцию по техническим причинам.  * `DEADLINE_FOR_FOCUS_PROMOS_EXCEEDED` — истек срок добавления товаров в акцию.  * `EMPTY_OLD_PRICE` — не указана зачеркнутая цена.  * `EMPTY_PROMO_PRICE` — не указана цена по акции.  * `MAX_PROMO_PRICE_EXCEEDED` — цена по акции превышает максимально возможную цену для участия в акции.  * `PROMO_PRICE_BIGGER_THAN_MAX` — цена по акции больше 95% от зачеркнутой цены.  * `PROMO_PRICE_SMALLER_THAN_MIN` — цена по акции меньше 1% от зачеркнутой цены. 
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum RejectedPromoOfferUpdateReasonType {
    #[serde(rename = "OFFER_DOES_NOT_EXIST")]
    OfferDoesNotExist,
    #[serde(rename = "OFFER_DUPLICATION")]
    OfferDuplication,
    #[serde(rename = "OFFER_NOT_ELIGIBLE_FOR_PROMO")]
    OfferNotEligibleForPromo,
    #[serde(rename = "OFFER_PROMOS_MAX_BYTE_SIZE_EXCEEDED")]
    OfferPromosMaxByteSizeExceeded,
    #[serde(rename = "DEADLINE_FOR_FOCUS_PROMOS_EXCEEDED")]
    DeadlineForFocusPromosExceeded,
    #[serde(rename = "EMPTY_OLD_PRICE")]
    EmptyOldPrice,
    #[serde(rename = "EMPTY_PROMO_PRICE")]
    EmptyPromoPrice,
    #[serde(rename = "MAX_PROMO_PRICE_EXCEEDED")]
    MaxPromoPriceExceeded,
    #[serde(rename = "PROMO_PRICE_BIGGER_THAN_MAX")]
    PromoPriceBiggerThanMax,
    #[serde(rename = "PROMO_PRICE_SMALLER_THAN_MIN")]
    PromoPriceSmallerThanMin,
}

impl std::fmt::Display for RejectedPromoOfferUpdateReasonType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            RejectedPromoOfferUpdateReasonType::OfferDoesNotExist => write!(f, "OFFER_DOES_NOT_EXIST"),
            RejectedPromoOfferUpdateReasonType::OfferDuplication => write!(f, "OFFER_DUPLICATION"),
            RejectedPromoOfferUpdateReasonType::OfferNotEligibleForPromo => write!(f, "OFFER_NOT_ELIGIBLE_FOR_PROMO"),
            RejectedPromoOfferUpdateReasonType::OfferPromosMaxByteSizeExceeded => write!(f, "OFFER_PROMOS_MAX_BYTE_SIZE_EXCEEDED"),
            RejectedPromoOfferUpdateReasonType::DeadlineForFocusPromosExceeded => write!(f, "DEADLINE_FOR_FOCUS_PROMOS_EXCEEDED"),
            RejectedPromoOfferUpdateReasonType::EmptyOldPrice => write!(f, "EMPTY_OLD_PRICE"),
            RejectedPromoOfferUpdateReasonType::EmptyPromoPrice => write!(f, "EMPTY_PROMO_PRICE"),
            RejectedPromoOfferUpdateReasonType::MaxPromoPriceExceeded => write!(f, "MAX_PROMO_PRICE_EXCEEDED"),
            RejectedPromoOfferUpdateReasonType::PromoPriceBiggerThanMax => write!(f, "PROMO_PRICE_BIGGER_THAN_MAX"),
            RejectedPromoOfferUpdateReasonType::PromoPriceSmallerThanMin => write!(f, "PROMO_PRICE_SMALLER_THAN_MIN"),
        }
    }
}

impl std::str::FromStr for RejectedPromoOfferUpdateReasonType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "OFFER_DOES_NOT_EXIST" => std::result::Result::Ok(RejectedPromoOfferUpdateReasonType::OfferDoesNotExist),
            "OFFER_DUPLICATION" => std::result::Result::Ok(RejectedPromoOfferUpdateReasonType::OfferDuplication),
            "OFFER_NOT_ELIGIBLE_FOR_PROMO" => std::result::Result::Ok(RejectedPromoOfferUpdateReasonType::OfferNotEligibleForPromo),
            "OFFER_PROMOS_MAX_BYTE_SIZE_EXCEEDED" => std::result::Result::Ok(RejectedPromoOfferUpdateReasonType::OfferPromosMaxByteSizeExceeded),
            "DEADLINE_FOR_FOCUS_PROMOS_EXCEEDED" => std::result::Result::Ok(RejectedPromoOfferUpdateReasonType::DeadlineForFocusPromosExceeded),
            "EMPTY_OLD_PRICE" => std::result::Result::Ok(RejectedPromoOfferUpdateReasonType::EmptyOldPrice),
            "EMPTY_PROMO_PRICE" => std::result::Result::Ok(RejectedPromoOfferUpdateReasonType::EmptyPromoPrice),
            "MAX_PROMO_PRICE_EXCEEDED" => std::result::Result::Ok(RejectedPromoOfferUpdateReasonType::MaxPromoPriceExceeded),
            "PROMO_PRICE_BIGGER_THAN_MAX" => std::result::Result::Ok(RejectedPromoOfferUpdateReasonType::PromoPriceBiggerThanMax),
            "PROMO_PRICE_SMALLER_THAN_MIN" => std::result::Result::Ok(RejectedPromoOfferUpdateReasonType::PromoPriceSmallerThanMin),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Формат отчета:  * `FILE` — файл с электронной таблицей. * `CSV` — ZIP-архив с CSV-файлами на каждый лист отчета. 
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum ReportFormatType {
    #[serde(rename = "FILE")]
    File,
    #[serde(rename = "CSV")]
    Csv,
}

impl std::fmt::Display for ReportFormatType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            ReportFormatType::File => write!(f, "FILE"),
            ReportFormatType::Csv => write!(f, "CSV"),
        }
    }
}

impl std::str::FromStr for ReportFormatType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "FILE" => std::result::Result::Ok(ReportFormatType::File),
            "CSV" => std::result::Result::Ok(ReportFormatType::Csv),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Статус генерации и ссылка на готовый отчет.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ReportInfoDto {
    #[serde(rename = "status")]
    pub status: models::ReportStatusType,

    #[serde(rename = "subStatus")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub sub_status: Option<models::ReportSubStatusType>,

    /// Дата и время запроса на генерацию.
    #[serde(rename = "generationRequestedAt")]
    pub generation_requested_at: chrono::DateTime::<chrono::Utc>,

    /// Дата и время завершения генерации.
    #[serde(rename = "generationFinishedAt")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub generation_finished_at: Option<chrono::DateTime::<chrono::Utc>>,

    /// Ссылка на готовый отчет.
    #[serde(rename = "file")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub file: Option<String>,

    /// Ожидаемая продолжительность генерации в миллисекундах.
    #[serde(rename = "estimatedGenerationTime")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub estimated_generation_time: Option<i64>,

}


impl ReportInfoDto {
    #[allow(clippy::new_without_default)]
    pub fn new(status: models::ReportStatusType, generation_requested_at: chrono::DateTime::<chrono::Utc>, ) -> ReportInfoDto {
        ReportInfoDto {
            status,
            sub_status: None,
            generation_requested_at,
            generation_finished_at: None,
            file: None,
            estimated_generation_time: None,
        }
    }
}

/// Converts the ReportInfoDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ReportInfoDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping status in query parameter serialization

            // Skipping subStatus in query parameter serialization

            // Skipping generationRequestedAt in query parameter serialization

            // Skipping generationFinishedAt in query parameter serialization


            self.file.as_ref().map(|file| {
                [
                    "file".to_string(),
                    file.to_string(),
                ].join(",")
            }),


            self.estimated_generation_time.as_ref().map(|estimated_generation_time| {
                [
                    "estimatedGenerationTime".to_string(),
                    estimated_generation_time.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ReportInfoDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ReportInfoDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub status: Vec<models::ReportStatusType>,
            pub sub_status: Vec<models::ReportSubStatusType>,
            pub generation_requested_at: Vec<chrono::DateTime::<chrono::Utc>>,
            pub generation_finished_at: Vec<chrono::DateTime::<chrono::Utc>>,
            pub file: Vec<String>,
            pub estimated_generation_time: Vec<i64>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ReportInfoDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(<models::ReportStatusType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "subStatus" => intermediate_rep.sub_status.push(<models::ReportSubStatusType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "generationRequestedAt" => intermediate_rep.generation_requested_at.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "generationFinishedAt" => intermediate_rep.generation_finished_at.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "file" => intermediate_rep.file.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "estimatedGenerationTime" => intermediate_rep.estimated_generation_time.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ReportInfoDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ReportInfoDto {
            status: intermediate_rep.status.into_iter().next().ok_or_else(|| "status missing in ReportInfoDto".to_string())?,
            sub_status: intermediate_rep.sub_status.into_iter().next(),
            generation_requested_at: intermediate_rep.generation_requested_at.into_iter().next().ok_or_else(|| "generationRequestedAt missing in ReportInfoDto".to_string())?,
            generation_finished_at: intermediate_rep.generation_finished_at.into_iter().next(),
            file: intermediate_rep.file.into_iter().next(),
            estimated_generation_time: intermediate_rep.estimated_generation_time.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ReportInfoDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<ReportInfoDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ReportInfoDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ReportInfoDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<ReportInfoDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ReportInfoDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ReportInfoDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Статус генерации отчета:  * `PENDING` — отчет ожидает генерации. * `PROCESSING` — отчет генерируется. * `FAILED` — во время генерации произошла ошибка. * `DONE` — отчет готов. 
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum ReportStatusType {
    #[serde(rename = "PENDING")]
    Pending,
    #[serde(rename = "PROCESSING")]
    Processing,
    #[serde(rename = "FAILED")]
    Failed,
    #[serde(rename = "DONE")]
    Done,
}

impl std::fmt::Display for ReportStatusType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            ReportStatusType::Pending => write!(f, "PENDING"),
            ReportStatusType::Processing => write!(f, "PROCESSING"),
            ReportStatusType::Failed => write!(f, "FAILED"),
            ReportStatusType::Done => write!(f, "DONE"),
        }
    }
}

impl std::str::FromStr for ReportStatusType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "PENDING" => std::result::Result::Ok(ReportStatusType::Pending),
            "PROCESSING" => std::result::Result::Ok(ReportStatusType::Processing),
            "FAILED" => std::result::Result::Ok(ReportStatusType::Failed),
            "DONE" => std::result::Result::Ok(ReportStatusType::Done),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Подстатус генерации отчета: * `NO_DATA` — для такого отчета нет данных. * `TOO_LARGE` — отчет превысил допустимый размер — укажите меньший период времени или уточните условия запроса. * `RESOURCE_NOT_FOUND` — для такого отчета не удалось найти часть сущностей. 
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum ReportSubStatusType {
    #[serde(rename = "NO_DATA")]
    NoData,
    #[serde(rename = "TOO_LARGE")]
    TooLarge,
    #[serde(rename = "RESOURCE_NOT_FOUND")]
    ResourceNotFound,
}

impl std::fmt::Display for ReportSubStatusType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            ReportSubStatusType::NoData => write!(f, "NO_DATA"),
            ReportSubStatusType::TooLarge => write!(f, "TOO_LARGE"),
            ReportSubStatusType::ResourceNotFound => write!(f, "RESOURCE_NOT_FOUND"),
        }
    }
}

impl std::str::FromStr for ReportSubStatusType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "NO_DATA" => std::result::Result::Ok(ReportSubStatusType::NoData),
            "TOO_LARGE" => std::result::Result::Ok(ReportSubStatusType::TooLarge),
            "RESOURCE_NOT_FOUND" => std::result::Result::Ok(ReportSubStatusType::ResourceNotFound),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Решения по возвратам.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ReturnDecisionDto {
    /// Идентификатор товара в возврате.
    #[serde(rename = "returnItemId")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub return_item_id: Option<i64>,

    /// Количество единиц товара.
    #[serde(rename = "count")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub count: Option<i32>,

    /// Комментарий.
    #[serde(rename = "comment")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub comment: Option<String>,

    #[serde(rename = "reasonType")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub reason_type: Option<models::ReturnDecisionReasonType>,

    #[serde(rename = "subreasonType")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub subreason_type: Option<models::ReturnDecisionSubreasonType>,

    #[serde(rename = "decisionType")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub decision_type: Option<models::ReturnDecisionType>,

    /// Сумма возврата.
    #[serde(rename = "refundAmount")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub refund_amount: Option<i64>,

    /// Компенсация за обратную доставку.
    #[serde(rename = "partnerCompensation")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub partner_compensation: Option<i64>,

    /// Список хеш-кодов фотографий товара от покупателя.
    #[serde(rename = "images")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub images: Option<swagger::Nullable<Vec<String>>>,

}


impl ReturnDecisionDto {
    #[allow(clippy::new_without_default)]
    pub fn new() -> ReturnDecisionDto {
        ReturnDecisionDto {
            return_item_id: None,
            count: None,
            comment: None,
            reason_type: None,
            subreason_type: None,
            decision_type: None,
            refund_amount: None,
            partner_compensation: None,
            images: None,
        }
    }
}

/// Converts the ReturnDecisionDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ReturnDecisionDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.return_item_id.as_ref().map(|return_item_id| {
                [
                    "returnItemId".to_string(),
                    return_item_id.to_string(),
                ].join(",")
            }),


            self.count.as_ref().map(|count| {
                [
                    "count".to_string(),
                    count.to_string(),
                ].join(",")
            }),


            self.comment.as_ref().map(|comment| {
                [
                    "comment".to_string(),
                    comment.to_string(),
                ].join(",")
            }),

            // Skipping reasonType in query parameter serialization

            // Skipping subreasonType in query parameter serialization

            // Skipping decisionType in query parameter serialization


            self.refund_amount.as_ref().map(|refund_amount| {
                [
                    "refundAmount".to_string(),
                    refund_amount.to_string(),
                ].join(",")
            }),


            self.partner_compensation.as_ref().map(|partner_compensation| {
                [
                    "partnerCompensation".to_string(),
                    partner_compensation.to_string(),
                ].join(",")
            }),


            self.images.as_ref().map(|images| {
                [
                    "images".to_string(),
                    images.as_ref().map_or("null".to_string(), |x| x.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ReturnDecisionDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ReturnDecisionDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub return_item_id: Vec<i64>,
            pub count: Vec<i32>,
            pub comment: Vec<String>,
            pub reason_type: Vec<models::ReturnDecisionReasonType>,
            pub subreason_type: Vec<models::ReturnDecisionSubreasonType>,
            pub decision_type: Vec<models::ReturnDecisionType>,
            pub refund_amount: Vec<i64>,
            pub partner_compensation: Vec<i64>,
            pub images: Vec<Vec<String>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ReturnDecisionDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "returnItemId" => intermediate_rep.return_item_id.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "count" => intermediate_rep.count.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "comment" => intermediate_rep.comment.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "reasonType" => intermediate_rep.reason_type.push(<models::ReturnDecisionReasonType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "subreasonType" => intermediate_rep.subreason_type.push(<models::ReturnDecisionSubreasonType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "decisionType" => intermediate_rep.decision_type.push(<models::ReturnDecisionType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "refundAmount" => intermediate_rep.refund_amount.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "partnerCompensation" => intermediate_rep.partner_compensation.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "images" => return std::result::Result::Err("Parsing a container in this style is not supported in ReturnDecisionDto".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing ReturnDecisionDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ReturnDecisionDto {
            return_item_id: intermediate_rep.return_item_id.into_iter().next(),
            count: intermediate_rep.count.into_iter().next(),
            comment: intermediate_rep.comment.into_iter().next(),
            reason_type: intermediate_rep.reason_type.into_iter().next(),
            subreason_type: intermediate_rep.subreason_type.into_iter().next(),
            decision_type: intermediate_rep.decision_type.into_iter().next(),
            refund_amount: intermediate_rep.refund_amount.into_iter().next(),
            partner_compensation: intermediate_rep.partner_compensation.into_iter().next(),
            images: std::result::Result::Err("Nullable types not supported in ReturnDecisionDto".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ReturnDecisionDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<ReturnDecisionDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ReturnDecisionDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ReturnDecisionDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<ReturnDecisionDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ReturnDecisionDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ReturnDecisionDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Причины возврата:  * `BAD_QUALITY` — бракованный товар (есть недостатки).  * `DO_NOT_FIT` — товар не подошел.  * `WRONG_ITEM` — привезли не тот товар.  * `DAMAGE_DELIVERY` — товар поврежден при доставке.  * `LOYALTY_FAIL` — невозможно установить виновного в браке/пересорте.  * `CONTENT_FAIL` — ошибочное описание товара по вине Маркета.  * `UNKNOWN` — причина не известна. 
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum ReturnDecisionReasonType {
    #[serde(rename = "BAD_QUALITY")]
    BadQuality,
    #[serde(rename = "DOES_NOT_FIT")]
    DoesNotFit,
    #[serde(rename = "WRONG_ITEM")]
    WrongItem,
    #[serde(rename = "DAMAGE_DELIVERY")]
    DamageDelivery,
    #[serde(rename = "LOYALTY_FAIL")]
    LoyaltyFail,
    #[serde(rename = "CONTENT_FAIL")]
    ContentFail,
    #[serde(rename = "UNKNOWN")]
    Unknown,
}

impl std::fmt::Display for ReturnDecisionReasonType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            ReturnDecisionReasonType::BadQuality => write!(f, "BAD_QUALITY"),
            ReturnDecisionReasonType::DoesNotFit => write!(f, "DOES_NOT_FIT"),
            ReturnDecisionReasonType::WrongItem => write!(f, "WRONG_ITEM"),
            ReturnDecisionReasonType::DamageDelivery => write!(f, "DAMAGE_DELIVERY"),
            ReturnDecisionReasonType::LoyaltyFail => write!(f, "LOYALTY_FAIL"),
            ReturnDecisionReasonType::ContentFail => write!(f, "CONTENT_FAIL"),
            ReturnDecisionReasonType::Unknown => write!(f, "UNKNOWN"),
        }
    }
}

impl std::str::FromStr for ReturnDecisionReasonType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "BAD_QUALITY" => std::result::Result::Ok(ReturnDecisionReasonType::BadQuality),
            "DOES_NOT_FIT" => std::result::Result::Ok(ReturnDecisionReasonType::DoesNotFit),
            "WRONG_ITEM" => std::result::Result::Ok(ReturnDecisionReasonType::WrongItem),
            "DAMAGE_DELIVERY" => std::result::Result::Ok(ReturnDecisionReasonType::DamageDelivery),
            "LOYALTY_FAIL" => std::result::Result::Ok(ReturnDecisionReasonType::LoyaltyFail),
            "CONTENT_FAIL" => std::result::Result::Ok(ReturnDecisionReasonType::ContentFail),
            "UNKNOWN" => std::result::Result::Ok(ReturnDecisionReasonType::Unknown),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Детали причин возврата:   * `DO_NOT_FIT`:     * `USER_DID_NOT_LIKE` — товар не понравился.     * `USER_CHANGED_MIND` — передумал покупать.     * `DELIVERED_TOO_LONG` — длительный срок доставки, поэтому передумал.    * `BAD_QUALITY`:     * `BAD_PACKAGE` — упаковка товара была нарушена.     * `DAMAGED` — царапины, сколы.     * `NOT_WORKING` — не включается / не работает.     * `INCOMPLETENESS` — некомплект (не хватает детали в наборе, к товару).    * `WRONG_ITEM`:     * `WRONG_ITEM` — не тот товар.     * `WRONG_COLOR` — не соответствует по цвету.     * `DID_NOT_MATCH_DESCRIPTION` — не соответствует заявленным характеристикам/описанию. 
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum ReturnDecisionSubreasonType {
    #[serde(rename = "USER_DID_NOT_LIKE")]
    UserDidNotLike,
    #[serde(rename = "USER_CHANGED_MIND")]
    UserChangedMind,
    #[serde(rename = "DELIVERED_TOO_LONG")]
    DeliveredTooLong,
    #[serde(rename = "BAD_PACKAGE")]
    BadPackage,
    #[serde(rename = "DAMAGED")]
    Damaged,
    #[serde(rename = "NOT_WORKING")]
    NotWorking,
    #[serde(rename = "INCOMPLETENESS")]
    Incompleteness,
    #[serde(rename = "WRONG_ITEM")]
    WrongItem,
    #[serde(rename = "WRONG_COLOR")]
    WrongColor,
    #[serde(rename = "DID_NOT_MATCH_DESCRIPTION")]
    DidNotMatchDescription,
    #[serde(rename = "UNKNOWN")]
    Unknown,
}

impl std::fmt::Display for ReturnDecisionSubreasonType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            ReturnDecisionSubreasonType::UserDidNotLike => write!(f, "USER_DID_NOT_LIKE"),
            ReturnDecisionSubreasonType::UserChangedMind => write!(f, "USER_CHANGED_MIND"),
            ReturnDecisionSubreasonType::DeliveredTooLong => write!(f, "DELIVERED_TOO_LONG"),
            ReturnDecisionSubreasonType::BadPackage => write!(f, "BAD_PACKAGE"),
            ReturnDecisionSubreasonType::Damaged => write!(f, "DAMAGED"),
            ReturnDecisionSubreasonType::NotWorking => write!(f, "NOT_WORKING"),
            ReturnDecisionSubreasonType::Incompleteness => write!(f, "INCOMPLETENESS"),
            ReturnDecisionSubreasonType::WrongItem => write!(f, "WRONG_ITEM"),
            ReturnDecisionSubreasonType::WrongColor => write!(f, "WRONG_COLOR"),
            ReturnDecisionSubreasonType::DidNotMatchDescription => write!(f, "DID_NOT_MATCH_DESCRIPTION"),
            ReturnDecisionSubreasonType::Unknown => write!(f, "UNKNOWN"),
        }
    }
}

impl std::str::FromStr for ReturnDecisionSubreasonType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "USER_DID_NOT_LIKE" => std::result::Result::Ok(ReturnDecisionSubreasonType::UserDidNotLike),
            "USER_CHANGED_MIND" => std::result::Result::Ok(ReturnDecisionSubreasonType::UserChangedMind),
            "DELIVERED_TOO_LONG" => std::result::Result::Ok(ReturnDecisionSubreasonType::DeliveredTooLong),
            "BAD_PACKAGE" => std::result::Result::Ok(ReturnDecisionSubreasonType::BadPackage),
            "DAMAGED" => std::result::Result::Ok(ReturnDecisionSubreasonType::Damaged),
            "NOT_WORKING" => std::result::Result::Ok(ReturnDecisionSubreasonType::NotWorking),
            "INCOMPLETENESS" => std::result::Result::Ok(ReturnDecisionSubreasonType::Incompleteness),
            "WRONG_ITEM" => std::result::Result::Ok(ReturnDecisionSubreasonType::WrongItem),
            "WRONG_COLOR" => std::result::Result::Ok(ReturnDecisionSubreasonType::WrongColor),
            "DID_NOT_MATCH_DESCRIPTION" => std::result::Result::Ok(ReturnDecisionSubreasonType::DidNotMatchDescription),
            "UNKNOWN" => std::result::Result::Ok(ReturnDecisionSubreasonType::Unknown),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Решение по возврату:  * `REFUND_MONEY` — вернуть деньги покупателю.  * `REFUND_MONEY_INCLUDING_SHIPMENT` — вернуть деньги за товар и пересылку.  * `REPAIR` — отремонтировать товар.  * `REPLACE` — заменить товар.  * `SEND_TO_EXAMINATION` — взять товар на экспертизу.  * `DECLINE_REFUND` — отказать в возврате.  * `OTHER_DECISION` — другое решение. 
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum ReturnDecisionType {
    #[serde(rename = "REFUND_MONEY")]
    RefundMoney,
    #[serde(rename = "REFUND_MONEY_INCLUDING_SHIPMENT")]
    RefundMoneyIncludingShipment,
    #[serde(rename = "REPAIR")]
    Repair,
    #[serde(rename = "REPLACE")]
    Replace,
    #[serde(rename = "SEND_TO_EXAMINATION")]
    SendToExamination,
    #[serde(rename = "DECLINE_REFUND")]
    DeclineRefund,
    #[serde(rename = "OTHER_DECISION")]
    OtherDecision,
    #[serde(rename = "UNKNOWN")]
    Unknown,
}

impl std::fmt::Display for ReturnDecisionType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            ReturnDecisionType::RefundMoney => write!(f, "REFUND_MONEY"),
            ReturnDecisionType::RefundMoneyIncludingShipment => write!(f, "REFUND_MONEY_INCLUDING_SHIPMENT"),
            ReturnDecisionType::Repair => write!(f, "REPAIR"),
            ReturnDecisionType::Replace => write!(f, "REPLACE"),
            ReturnDecisionType::SendToExamination => write!(f, "SEND_TO_EXAMINATION"),
            ReturnDecisionType::DeclineRefund => write!(f, "DECLINE_REFUND"),
            ReturnDecisionType::OtherDecision => write!(f, "OTHER_DECISION"),
            ReturnDecisionType::Unknown => write!(f, "UNKNOWN"),
        }
    }
}

impl std::str::FromStr for ReturnDecisionType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "REFUND_MONEY" => std::result::Result::Ok(ReturnDecisionType::RefundMoney),
            "REFUND_MONEY_INCLUDING_SHIPMENT" => std::result::Result::Ok(ReturnDecisionType::RefundMoneyIncludingShipment),
            "REPAIR" => std::result::Result::Ok(ReturnDecisionType::Repair),
            "REPLACE" => std::result::Result::Ok(ReturnDecisionType::Replace),
            "SEND_TO_EXAMINATION" => std::result::Result::Ok(ReturnDecisionType::SendToExamination),
            "DECLINE_REFUND" => std::result::Result::Ok(ReturnDecisionType::DeclineRefund),
            "OTHER_DECISION" => std::result::Result::Ok(ReturnDecisionType::OtherDecision),
            "UNKNOWN" => std::result::Result::Ok(ReturnDecisionType::Unknown),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Возврат заказа.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ReturnDto {
    /// Идентификатор возврата.
    #[serde(rename = "id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,

    /// Номер заказа.
    #[serde(rename = "orderId")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub order_id: Option<i64>,

    /// Дата создания возврата клиентом.
    #[serde(rename = "creationDate")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub creation_date: Option<chrono::DateTime::<chrono::Utc>>,

    /// Дата обновления возврата.
    #[serde(rename = "updateDate")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub update_date: Option<chrono::DateTime::<chrono::Utc>>,

    #[serde(rename = "refundStatus")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub refund_status: Option<models::RefundStatusType>,

    #[serde(rename = "logisticPickupPoint")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub logistic_pickup_point: Option<models::LogisticPickupPointDto>,

    #[serde(rename = "shipmentRecipientType")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub shipment_recipient_type: Option<models::RecipientType>,

    #[serde(rename = "shipmentStatus")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub shipment_status: Option<models::ReturnShipmentStatusType>,

    /// Сумма возврата.
    #[serde(rename = "refundAmount")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub refund_amount: Option<i64>,

    /// Список товаров в возврате.
    #[serde(rename = "items")]
    pub items: Vec<models::ReturnItemDto>,

    #[serde(rename = "returnType")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub return_type: Option<models::ReturnType>,

    /// Используется ли опция **Быстрый возврат денег за дешевый брак**. 
    #[serde(rename = "fastReturn")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub fast_return: Option<bool>,

}


impl ReturnDto {
    #[allow(clippy::new_without_default)]
    pub fn new(items: Vec<models::ReturnItemDto>, ) -> ReturnDto {
        ReturnDto {
            id: None,
            order_id: None,
            creation_date: None,
            update_date: None,
            refund_status: None,
            logistic_pickup_point: None,
            shipment_recipient_type: None,
            shipment_status: None,
            refund_amount: None,
            items,
            return_type: None,
            fast_return: None,
        }
    }
}

/// Converts the ReturnDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ReturnDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.id.as_ref().map(|id| {
                [
                    "id".to_string(),
                    id.to_string(),
                ].join(",")
            }),


            self.order_id.as_ref().map(|order_id| {
                [
                    "orderId".to_string(),
                    order_id.to_string(),
                ].join(",")
            }),

            // Skipping creationDate in query parameter serialization

            // Skipping updateDate in query parameter serialization

            // Skipping refundStatus in query parameter serialization

            // Skipping logisticPickupPoint in query parameter serialization

            // Skipping shipmentRecipientType in query parameter serialization

            // Skipping shipmentStatus in query parameter serialization


            self.refund_amount.as_ref().map(|refund_amount| {
                [
                    "refundAmount".to_string(),
                    refund_amount.to_string(),
                ].join(",")
            }),

            // Skipping items in query parameter serialization

            // Skipping returnType in query parameter serialization


            self.fast_return.as_ref().map(|fast_return| {
                [
                    "fastReturn".to_string(),
                    fast_return.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ReturnDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ReturnDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<i64>,
            pub order_id: Vec<i64>,
            pub creation_date: Vec<chrono::DateTime::<chrono::Utc>>,
            pub update_date: Vec<chrono::DateTime::<chrono::Utc>>,
            pub refund_status: Vec<models::RefundStatusType>,
            pub logistic_pickup_point: Vec<models::LogisticPickupPointDto>,
            pub shipment_recipient_type: Vec<models::RecipientType>,
            pub shipment_status: Vec<models::ReturnShipmentStatusType>,
            pub refund_amount: Vec<i64>,
            pub items: Vec<Vec<models::ReturnItemDto>>,
            pub return_type: Vec<models::ReturnType>,
            pub fast_return: Vec<bool>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ReturnDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "orderId" => intermediate_rep.order_id.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "creationDate" => intermediate_rep.creation_date.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "updateDate" => intermediate_rep.update_date.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "refundStatus" => intermediate_rep.refund_status.push(<models::RefundStatusType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "logisticPickupPoint" => intermediate_rep.logistic_pickup_point.push(<models::LogisticPickupPointDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "shipmentRecipientType" => intermediate_rep.shipment_recipient_type.push(<models::RecipientType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "shipmentStatus" => intermediate_rep.shipment_status.push(<models::ReturnShipmentStatusType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "refundAmount" => intermediate_rep.refund_amount.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "items" => return std::result::Result::Err("Parsing a container in this style is not supported in ReturnDto".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "returnType" => intermediate_rep.return_type.push(<models::ReturnType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "fastReturn" => intermediate_rep.fast_return.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ReturnDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ReturnDto {
            id: intermediate_rep.id.into_iter().next(),
            order_id: intermediate_rep.order_id.into_iter().next(),
            creation_date: intermediate_rep.creation_date.into_iter().next(),
            update_date: intermediate_rep.update_date.into_iter().next(),
            refund_status: intermediate_rep.refund_status.into_iter().next(),
            logistic_pickup_point: intermediate_rep.logistic_pickup_point.into_iter().next(),
            shipment_recipient_type: intermediate_rep.shipment_recipient_type.into_iter().next(),
            shipment_status: intermediate_rep.shipment_status.into_iter().next(),
            refund_amount: intermediate_rep.refund_amount.into_iter().next(),
            items: intermediate_rep.items.into_iter().next().ok_or_else(|| "items missing in ReturnDto".to_string())?,
            return_type: intermediate_rep.return_type.into_iter().next(),
            fast_return: intermediate_rep.fast_return.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ReturnDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<ReturnDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ReturnDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ReturnDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<ReturnDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ReturnDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ReturnDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Логистическая информация по возврату.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ReturnInstanceDto {
    #[serde(rename = "stockType")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub stock_type: Option<models::ReturnInstanceStockType>,

    #[serde(rename = "status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<models::ReturnInstanceStatusType>,

    /// Код идентификации единицы товара [в системе «Честный ЗНАК»](https://честныйзнак.рф/).
    #[serde(rename = "cis")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub cis: Option<String>,

    /// Международный идентификатор мобильного оборудования.
    #[serde(rename = "imei")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub imei: Option<String>,

}


impl ReturnInstanceDto {
    #[allow(clippy::new_without_default)]
    pub fn new() -> ReturnInstanceDto {
        ReturnInstanceDto {
            stock_type: None,
            status: None,
            cis: None,
            imei: None,
        }
    }
}

/// Converts the ReturnInstanceDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ReturnInstanceDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping stockType in query parameter serialization

            // Skipping status in query parameter serialization


            self.cis.as_ref().map(|cis| {
                [
                    "cis".to_string(),
                    cis.to_string(),
                ].join(",")
            }),


            self.imei.as_ref().map(|imei| {
                [
                    "imei".to_string(),
                    imei.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ReturnInstanceDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ReturnInstanceDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub stock_type: Vec<models::ReturnInstanceStockType>,
            pub status: Vec<models::ReturnInstanceStatusType>,
            pub cis: Vec<String>,
            pub imei: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ReturnInstanceDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "stockType" => intermediate_rep.stock_type.push(<models::ReturnInstanceStockType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(<models::ReturnInstanceStatusType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "cis" => intermediate_rep.cis.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "imei" => intermediate_rep.imei.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ReturnInstanceDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ReturnInstanceDto {
            stock_type: intermediate_rep.stock_type.into_iter().next(),
            status: intermediate_rep.status.into_iter().next(),
            cis: intermediate_rep.cis.into_iter().next(),
            imei: intermediate_rep.imei.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ReturnInstanceDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<ReturnInstanceDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ReturnInstanceDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ReturnInstanceDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<ReturnInstanceDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ReturnInstanceDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ReturnInstanceDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Логистический статус конкретного товара.
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum ReturnInstanceStatusType {
    #[serde(rename = "CREATED")]
    Created,
    #[serde(rename = "RECEIVED")]
    Received,
    #[serde(rename = "IN_TRANSIT")]
    InTransit,
    #[serde(rename = "READY_FOR_PICKUP")]
    ReadyForPickup,
    #[serde(rename = "PICKED")]
    Picked,
    #[serde(rename = "RECEIVED_ON_FULFILLMENT")]
    ReceivedOnFulfillment,
    #[serde(rename = "CANCELLED")]
    Cancelled,
    #[serde(rename = "LOST")]
    Lost,
    #[serde(rename = "UTILIZED")]
    Utilized,
    #[serde(rename = "PREPARED_FOR_UTILIZATION")]
    PreparedForUtilization,
    #[serde(rename = "EXPROPRIATED")]
    Expropriated,
    #[serde(rename = "NOT_IN_DEMAND")]
    NotInDemand,
}

impl std::fmt::Display for ReturnInstanceStatusType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            ReturnInstanceStatusType::Created => write!(f, "CREATED"),
            ReturnInstanceStatusType::Received => write!(f, "RECEIVED"),
            ReturnInstanceStatusType::InTransit => write!(f, "IN_TRANSIT"),
            ReturnInstanceStatusType::ReadyForPickup => write!(f, "READY_FOR_PICKUP"),
            ReturnInstanceStatusType::Picked => write!(f, "PICKED"),
            ReturnInstanceStatusType::ReceivedOnFulfillment => write!(f, "RECEIVED_ON_FULFILLMENT"),
            ReturnInstanceStatusType::Cancelled => write!(f, "CANCELLED"),
            ReturnInstanceStatusType::Lost => write!(f, "LOST"),
            ReturnInstanceStatusType::Utilized => write!(f, "UTILIZED"),
            ReturnInstanceStatusType::PreparedForUtilization => write!(f, "PREPARED_FOR_UTILIZATION"),
            ReturnInstanceStatusType::Expropriated => write!(f, "EXPROPRIATED"),
            ReturnInstanceStatusType::NotInDemand => write!(f, "NOT_IN_DEMAND"),
        }
    }
}

impl std::str::FromStr for ReturnInstanceStatusType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "CREATED" => std::result::Result::Ok(ReturnInstanceStatusType::Created),
            "RECEIVED" => std::result::Result::Ok(ReturnInstanceStatusType::Received),
            "IN_TRANSIT" => std::result::Result::Ok(ReturnInstanceStatusType::InTransit),
            "READY_FOR_PICKUP" => std::result::Result::Ok(ReturnInstanceStatusType::ReadyForPickup),
            "PICKED" => std::result::Result::Ok(ReturnInstanceStatusType::Picked),
            "RECEIVED_ON_FULFILLMENT" => std::result::Result::Ok(ReturnInstanceStatusType::ReceivedOnFulfillment),
            "CANCELLED" => std::result::Result::Ok(ReturnInstanceStatusType::Cancelled),
            "LOST" => std::result::Result::Ok(ReturnInstanceStatusType::Lost),
            "UTILIZED" => std::result::Result::Ok(ReturnInstanceStatusType::Utilized),
            "PREPARED_FOR_UTILIZATION" => std::result::Result::Ok(ReturnInstanceStatusType::PreparedForUtilization),
            "EXPROPRIATED" => std::result::Result::Ok(ReturnInstanceStatusType::Expropriated),
            "NOT_IN_DEMAND" => std::result::Result::Ok(ReturnInstanceStatusType::NotInDemand),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Тип остатка на складе.
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum ReturnInstanceStockType {
    #[serde(rename = "FIT")]
    Fit,
    #[serde(rename = "DEFECT")]
    Defect,
    #[serde(rename = "ANOMALY")]
    Anomaly,
    #[serde(rename = "SURPLUS")]
    Surplus,
    #[serde(rename = "EXPIRED")]
    Expired,
    #[serde(rename = "MISGRADING")]
    Misgrading,
    #[serde(rename = "UNDEFINED")]
    Undefined,
    #[serde(rename = "INCORRECT_IMEI")]
    IncorrectImei,
    #[serde(rename = "INCORRECT_SERIAL_NUMBER")]
    IncorrectSerialNumber,
    #[serde(rename = "INCORRECT_CIS")]
    IncorrectCis,
    #[serde(rename = "PART_MISSING")]
    PartMissing,
    #[serde(rename = "NON_COMPLIENT")]
    NonComplient,
    #[serde(rename = "NOT_ACCEPTABLE")]
    NotAcceptable,
    #[serde(rename = "SERVICE")]
    Service,
    #[serde(rename = "MARKDOWN")]
    Markdown,
    #[serde(rename = "DEMO")]
    Demo,
    #[serde(rename = "REPAIR")]
    Repair,
    #[serde(rename = "FIRMWARE")]
    Firmware,
    #[serde(rename = "UNKNOWN")]
    Unknown,
}

impl std::fmt::Display for ReturnInstanceStockType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            ReturnInstanceStockType::Fit => write!(f, "FIT"),
            ReturnInstanceStockType::Defect => write!(f, "DEFECT"),
            ReturnInstanceStockType::Anomaly => write!(f, "ANOMALY"),
            ReturnInstanceStockType::Surplus => write!(f, "SURPLUS"),
            ReturnInstanceStockType::Expired => write!(f, "EXPIRED"),
            ReturnInstanceStockType::Misgrading => write!(f, "MISGRADING"),
            ReturnInstanceStockType::Undefined => write!(f, "UNDEFINED"),
            ReturnInstanceStockType::IncorrectImei => write!(f, "INCORRECT_IMEI"),
            ReturnInstanceStockType::IncorrectSerialNumber => write!(f, "INCORRECT_SERIAL_NUMBER"),
            ReturnInstanceStockType::IncorrectCis => write!(f, "INCORRECT_CIS"),
            ReturnInstanceStockType::PartMissing => write!(f, "PART_MISSING"),
            ReturnInstanceStockType::NonComplient => write!(f, "NON_COMPLIENT"),
            ReturnInstanceStockType::NotAcceptable => write!(f, "NOT_ACCEPTABLE"),
            ReturnInstanceStockType::Service => write!(f, "SERVICE"),
            ReturnInstanceStockType::Markdown => write!(f, "MARKDOWN"),
            ReturnInstanceStockType::Demo => write!(f, "DEMO"),
            ReturnInstanceStockType::Repair => write!(f, "REPAIR"),
            ReturnInstanceStockType::Firmware => write!(f, "FIRMWARE"),
            ReturnInstanceStockType::Unknown => write!(f, "UNKNOWN"),
        }
    }
}

impl std::str::FromStr for ReturnInstanceStockType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "FIT" => std::result::Result::Ok(ReturnInstanceStockType::Fit),
            "DEFECT" => std::result::Result::Ok(ReturnInstanceStockType::Defect),
            "ANOMALY" => std::result::Result::Ok(ReturnInstanceStockType::Anomaly),
            "SURPLUS" => std::result::Result::Ok(ReturnInstanceStockType::Surplus),
            "EXPIRED" => std::result::Result::Ok(ReturnInstanceStockType::Expired),
            "MISGRADING" => std::result::Result::Ok(ReturnInstanceStockType::Misgrading),
            "UNDEFINED" => std::result::Result::Ok(ReturnInstanceStockType::Undefined),
            "INCORRECT_IMEI" => std::result::Result::Ok(ReturnInstanceStockType::IncorrectImei),
            "INCORRECT_SERIAL_NUMBER" => std::result::Result::Ok(ReturnInstanceStockType::IncorrectSerialNumber),
            "INCORRECT_CIS" => std::result::Result::Ok(ReturnInstanceStockType::IncorrectCis),
            "PART_MISSING" => std::result::Result::Ok(ReturnInstanceStockType::PartMissing),
            "NON_COMPLIENT" => std::result::Result::Ok(ReturnInstanceStockType::NonComplient),
            "NOT_ACCEPTABLE" => std::result::Result::Ok(ReturnInstanceStockType::NotAcceptable),
            "SERVICE" => std::result::Result::Ok(ReturnInstanceStockType::Service),
            "MARKDOWN" => std::result::Result::Ok(ReturnInstanceStockType::Markdown),
            "DEMO" => std::result::Result::Ok(ReturnInstanceStockType::Demo),
            "REPAIR" => std::result::Result::Ok(ReturnInstanceStockType::Repair),
            "FIRMWARE" => std::result::Result::Ok(ReturnInstanceStockType::Firmware),
            "UNKNOWN" => std::result::Result::Ok(ReturnInstanceStockType::Unknown),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Список товаров в возврате.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ReturnItemDto {
    /// SKU на Маркете.
    #[serde(rename = "marketSku")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub market_sku: Option<i64>,

    /// Ваш SKU — идентификатор товара в вашей системе.  Разрешена любая последовательность длиной до 255 знаков.  Правила использования SKU:  * У каждого товара SKU должен быть свой.  * SKU товара нельзя менять — можно только удалить товар и добавить заново с новым SKU.  * Уже заданный SKU нельзя освободить и использовать заново для другого товара. Каждый товар должен получать новый идентификатор, до того никогда не использовавшийся в вашем каталоге.  [Что такое SKU и как его назначать](https://yandex.ru/support/marketplace/assortment/add/index.html#fields) 
    #[serde(rename = "shopSku")]
    #[validate(
            length(min = 1, max = 255),
           regex = "RE_RETURNITEMDTO_SHOP_SKU",
        )]
    pub shop_sku: String,

    /// Количество единиц товара.
    #[serde(rename = "count")]
    pub count: i64,

    /// Список решений по возврату.
    #[serde(rename = "decisions")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub decisions: Option<swagger::Nullable<Vec<models::ReturnDecisionDto>>>,

    /// Список логистических позиций возврата.
    #[serde(rename = "instances")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub instances: Option<swagger::Nullable<Vec<models::ReturnInstanceDto>>>,

    /// Список трек-кодов для почтовых отправлений.
    #[serde(rename = "tracks")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub tracks: Option<swagger::Nullable<Vec<models::TrackDto>>>,

}

lazy_static::lazy_static! {
    static ref RE_RETURNITEMDTO_SHOP_SKU: regex::Regex = regex::Regex::new(r"^[^\\x00-\\x08\\x0A-\\x1f\\x7f]{1,255}$").unwrap();
}

impl ReturnItemDto {
    #[allow(clippy::new_without_default)]
    pub fn new(shop_sku: String, count: i64, ) -> ReturnItemDto {
        ReturnItemDto {
            market_sku: None,
            shop_sku,
            count,
            decisions: None,
            instances: None,
            tracks: None,
        }
    }
}

/// Converts the ReturnItemDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ReturnItemDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.market_sku.as_ref().map(|market_sku| {
                [
                    "marketSku".to_string(),
                    market_sku.to_string(),
                ].join(",")
            }),


            Some("shopSku".to_string()),
            Some(self.shop_sku.to_string()),


            Some("count".to_string()),
            Some(self.count.to_string()),

            // Skipping decisions in query parameter serialization

            // Skipping instances in query parameter serialization

            // Skipping tracks in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ReturnItemDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ReturnItemDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub market_sku: Vec<i64>,
            pub shop_sku: Vec<String>,
            pub count: Vec<i64>,
            pub decisions: Vec<Vec<models::ReturnDecisionDto>>,
            pub instances: Vec<Vec<models::ReturnInstanceDto>>,
            pub tracks: Vec<Vec<models::TrackDto>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ReturnItemDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "marketSku" => intermediate_rep.market_sku.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "shopSku" => intermediate_rep.shop_sku.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "count" => intermediate_rep.count.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "decisions" => return std::result::Result::Err("Parsing a container in this style is not supported in ReturnItemDto".to_string()),
                    "instances" => return std::result::Result::Err("Parsing a container in this style is not supported in ReturnItemDto".to_string()),
                    "tracks" => return std::result::Result::Err("Parsing a container in this style is not supported in ReturnItemDto".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing ReturnItemDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ReturnItemDto {
            market_sku: intermediate_rep.market_sku.into_iter().next(),
            shop_sku: intermediate_rep.shop_sku.into_iter().next().ok_or_else(|| "shopSku missing in ReturnItemDto".to_string())?,
            count: intermediate_rep.count.into_iter().next().ok_or_else(|| "count missing in ReturnItemDto".to_string())?,
            decisions: std::result::Result::Err("Nullable types not supported in ReturnItemDto".to_string())?,
            instances: std::result::Result::Err("Nullable types not supported in ReturnItemDto".to_string())?,
            tracks: std::result::Result::Err("Nullable types not supported in ReturnItemDto".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ReturnItemDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<ReturnItemDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ReturnItemDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ReturnItemDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<ReturnItemDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ReturnItemDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ReturnItemDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Решение по возврату.
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum ReturnRequestDecisionType {
    #[serde(rename = "REFUND_MONEY")]
    RefundMoney,
    #[serde(rename = "REFUND_MONEY_INCLUDING_SHIPMENT")]
    RefundMoneyIncludingShipment,
    #[serde(rename = "REPAIR")]
    Repair,
    #[serde(rename = "REPLACE")]
    Replace,
    #[serde(rename = "SEND_TO_EXAMINATION")]
    SendToExamination,
    #[serde(rename = "DECLINE_REFUND")]
    DeclineRefund,
    #[serde(rename = "OTHER_DECISION")]
    OtherDecision,
}

impl std::fmt::Display for ReturnRequestDecisionType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            ReturnRequestDecisionType::RefundMoney => write!(f, "REFUND_MONEY"),
            ReturnRequestDecisionType::RefundMoneyIncludingShipment => write!(f, "REFUND_MONEY_INCLUDING_SHIPMENT"),
            ReturnRequestDecisionType::Repair => write!(f, "REPAIR"),
            ReturnRequestDecisionType::Replace => write!(f, "REPLACE"),
            ReturnRequestDecisionType::SendToExamination => write!(f, "SEND_TO_EXAMINATION"),
            ReturnRequestDecisionType::DeclineRefund => write!(f, "DECLINE_REFUND"),
            ReturnRequestDecisionType::OtherDecision => write!(f, "OTHER_DECISION"),
        }
    }
}

impl std::str::FromStr for ReturnRequestDecisionType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "REFUND_MONEY" => std::result::Result::Ok(ReturnRequestDecisionType::RefundMoney),
            "REFUND_MONEY_INCLUDING_SHIPMENT" => std::result::Result::Ok(ReturnRequestDecisionType::RefundMoneyIncludingShipment),
            "REPAIR" => std::result::Result::Ok(ReturnRequestDecisionType::Repair),
            "REPLACE" => std::result::Result::Ok(ReturnRequestDecisionType::Replace),
            "SEND_TO_EXAMINATION" => std::result::Result::Ok(ReturnRequestDecisionType::SendToExamination),
            "DECLINE_REFUND" => std::result::Result::Ok(ReturnRequestDecisionType::DeclineRefund),
            "OTHER_DECISION" => std::result::Result::Ok(ReturnRequestDecisionType::OtherDecision),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Статус передачи возврата:  * `CREATED` — возврат создан.  * `RECEIVED` — принят у покупателя.  * `IN_TRANSIT` — возврат в пути.  * `READY_FOR_PICKUP` — возврат готов к выдаче магазину.  * `PICKED` — возврат выдан магазину.  * `LOST` — возврат утерян при транспортировке.  * `CANCELLED` — возврат отменен.  * `FULFILMENT_RECEIVED` — возврат принят на складе Маркета.  * `PREPARED_FOR_UTILIZATION` — возврат передан в утилизацию.  * `UTILIZED` — возврат утилизирован. 
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum ReturnShipmentStatusType {
    #[serde(rename = "CREATED")]
    Created,
    #[serde(rename = "RECEIVED")]
    Received,
    #[serde(rename = "IN_TRANSIT")]
    InTransit,
    #[serde(rename = "READY_FOR_PICKUP")]
    ReadyForPickup,
    #[serde(rename = "PICKED")]
    Picked,
    #[serde(rename = "LOST")]
    Lost,
    #[serde(rename = "EXPIRED")]
    Expired,
    #[serde(rename = "CANCELLED")]
    Cancelled,
    #[serde(rename = "FULFILMENT_RECEIVED")]
    FulfilmentReceived,
    #[serde(rename = "PREPARED_FOR_UTILIZATION")]
    PreparedForUtilization,
    #[serde(rename = "NOT_IN_DEMAND")]
    NotInDemand,
    #[serde(rename = "UTILIZED")]
    Utilized,
    #[serde(rename = "READY_FOR_EXPROPRIATION")]
    ReadyForExpropriation,
    #[serde(rename = "RECEIVED_FOR_EXPROPRIATION")]
    ReceivedForExpropriation,
}

impl std::fmt::Display for ReturnShipmentStatusType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            ReturnShipmentStatusType::Created => write!(f, "CREATED"),
            ReturnShipmentStatusType::Received => write!(f, "RECEIVED"),
            ReturnShipmentStatusType::InTransit => write!(f, "IN_TRANSIT"),
            ReturnShipmentStatusType::ReadyForPickup => write!(f, "READY_FOR_PICKUP"),
            ReturnShipmentStatusType::Picked => write!(f, "PICKED"),
            ReturnShipmentStatusType::Lost => write!(f, "LOST"),
            ReturnShipmentStatusType::Expired => write!(f, "EXPIRED"),
            ReturnShipmentStatusType::Cancelled => write!(f, "CANCELLED"),
            ReturnShipmentStatusType::FulfilmentReceived => write!(f, "FULFILMENT_RECEIVED"),
            ReturnShipmentStatusType::PreparedForUtilization => write!(f, "PREPARED_FOR_UTILIZATION"),
            ReturnShipmentStatusType::NotInDemand => write!(f, "NOT_IN_DEMAND"),
            ReturnShipmentStatusType::Utilized => write!(f, "UTILIZED"),
            ReturnShipmentStatusType::ReadyForExpropriation => write!(f, "READY_FOR_EXPROPRIATION"),
            ReturnShipmentStatusType::ReceivedForExpropriation => write!(f, "RECEIVED_FOR_EXPROPRIATION"),
        }
    }
}

impl std::str::FromStr for ReturnShipmentStatusType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "CREATED" => std::result::Result::Ok(ReturnShipmentStatusType::Created),
            "RECEIVED" => std::result::Result::Ok(ReturnShipmentStatusType::Received),
            "IN_TRANSIT" => std::result::Result::Ok(ReturnShipmentStatusType::InTransit),
            "READY_FOR_PICKUP" => std::result::Result::Ok(ReturnShipmentStatusType::ReadyForPickup),
            "PICKED" => std::result::Result::Ok(ReturnShipmentStatusType::Picked),
            "LOST" => std::result::Result::Ok(ReturnShipmentStatusType::Lost),
            "EXPIRED" => std::result::Result::Ok(ReturnShipmentStatusType::Expired),
            "CANCELLED" => std::result::Result::Ok(ReturnShipmentStatusType::Cancelled),
            "FULFILMENT_RECEIVED" => std::result::Result::Ok(ReturnShipmentStatusType::FulfilmentReceived),
            "PREPARED_FOR_UTILIZATION" => std::result::Result::Ok(ReturnShipmentStatusType::PreparedForUtilization),
            "NOT_IN_DEMAND" => std::result::Result::Ok(ReturnShipmentStatusType::NotInDemand),
            "UTILIZED" => std::result::Result::Ok(ReturnShipmentStatusType::Utilized),
            "READY_FOR_EXPROPRIATION" => std::result::Result::Ok(ReturnShipmentStatusType::ReadyForExpropriation),
            "RECEIVED_FOR_EXPROPRIATION" => std::result::Result::Ok(ReturnShipmentStatusType::ReceivedForExpropriation),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Тип заказа для фильтрации:  * `RETURN` — возврат.  * `UNREDEEMED` — невыкуп.  Если не указывать, в ответе будут и возвраты, и невыкупы. 
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum ReturnType {
    #[serde(rename = "UNREDEEMED")]
    Unredeemed,
    #[serde(rename = "RETURN")]
    Return,
}

impl std::fmt::Display for ReturnType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            ReturnType::Unredeemed => write!(f, "UNREDEEMED"),
            ReturnType::Return => write!(f, "RETURN"),
        }
    }
}

impl std::str::FromStr for ReturnType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "UNREDEEMED" => std::result::Result::Ok(ReturnType::Unredeemed),
            "RETURN" => std::result::Result::Ok(ReturnType::Return),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Информация о страницах результатов.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ScrollingPagerDto {
    /// Идентификатор следующей страницы результатов.
    #[serde(rename = "nextPageToken")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub next_page_token: Option<String>,

    /// Идентификатор предыдущей страницы результатов.
    #[serde(rename = "prevPageToken")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub prev_page_token: Option<String>,

}


impl ScrollingPagerDto {
    #[allow(clippy::new_without_default)]
    pub fn new() -> ScrollingPagerDto {
        ScrollingPagerDto {
            next_page_token: None,
            prev_page_token: None,
        }
    }
}

/// Converts the ScrollingPagerDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ScrollingPagerDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.next_page_token.as_ref().map(|next_page_token| {
                [
                    "nextPageToken".to_string(),
                    next_page_token.to_string(),
                ].join(",")
            }),


            self.prev_page_token.as_ref().map(|prev_page_token| {
                [
                    "prevPageToken".to_string(),
                    prev_page_token.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ScrollingPagerDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ScrollingPagerDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub next_page_token: Vec<String>,
            pub prev_page_token: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ScrollingPagerDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "nextPageToken" => intermediate_rep.next_page_token.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "prevPageToken" => intermediate_rep.prev_page_token.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ScrollingPagerDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ScrollingPagerDto {
            next_page_token: intermediate_rep.next_page_token.into_iter().next(),
            prev_page_token: intermediate_rep.prev_page_token.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ScrollingPagerDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<ScrollingPagerDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ScrollingPagerDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ScrollingPagerDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<ScrollingPagerDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ScrollingPagerDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ScrollingPagerDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct SearchModelsResponse {
    /// Список моделей товаров.
    #[serde(rename = "models")]
    pub models: Vec<models::ModelDto>,

    #[serde(rename = "currency")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub currency: Option<models::CurrencyType>,

    /// Идентификатор региона, для которого выводится информация о предложениях модели (доставляемых в этот регион).  Информацию о регионе по идентификатору можно получить с помощью запроса [GET regions/{regionId}](../../reference/regions/searchRegionsById.md). 
    #[serde(rename = "regionId")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub region_id: Option<i64>,

    #[serde(rename = "pager")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub pager: Option<models::FlippingPagerDto>,

}


impl SearchModelsResponse {
    #[allow(clippy::new_without_default)]
    pub fn new(models: Vec<models::ModelDto>, ) -> SearchModelsResponse {
        SearchModelsResponse {
            models,
            currency: None,
            region_id: None,
            pager: None,
        }
    }
}

/// Converts the SearchModelsResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for SearchModelsResponse {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping models in query parameter serialization

            // Skipping currency in query parameter serialization


            self.region_id.as_ref().map(|region_id| {
                [
                    "regionId".to_string(),
                    region_id.to_string(),
                ].join(",")
            }),

            // Skipping pager in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a SearchModelsResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for SearchModelsResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub models: Vec<Vec<models::ModelDto>>,
            pub currency: Vec<models::CurrencyType>,
            pub region_id: Vec<i64>,
            pub pager: Vec<models::FlippingPagerDto>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing SearchModelsResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "models" => return std::result::Result::Err("Parsing a container in this style is not supported in SearchModelsResponse".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "currency" => intermediate_rep.currency.push(<models::CurrencyType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "regionId" => intermediate_rep.region_id.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "pager" => intermediate_rep.pager.push(<models::FlippingPagerDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing SearchModelsResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(SearchModelsResponse {
            models: intermediate_rep.models.into_iter().next().ok_or_else(|| "models missing in SearchModelsResponse".to_string())?,
            currency: intermediate_rep.currency.into_iter().next(),
            region_id: intermediate_rep.region_id.into_iter().next(),
            pager: intermediate_rep.pager.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<SearchModelsResponse> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<SearchModelsResponse>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<SearchModelsResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for SearchModelsResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<SearchModelsResponse> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <SearchModelsResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into SearchModelsResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Запрос информации об отгрузках.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct SearchShipmentsRequest {
    /// Начальная дата для фильтрации по дате отгрузки (включительно).  Формат даты: `ДД-ММ-ГГГГ`. 
    #[serde(rename = "dateFrom")]
    pub date_from: chrono::naive::NaiveDate,

    /// Конечная дата для фильтрации по дате отгрузки (включительно).  Формат даты: `ДД-ММ-ГГГГ`. 
    #[serde(rename = "dateTo")]
    pub date_to: chrono::naive::NaiveDate,

    /// Список статусов отгрузок.
    #[serde(rename = "statuses")]
    #[validate(
            length(min = 1),
        )]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub statuses: Option<swagger::Nullable<Vec<models::ShipmentStatusType>>>,

    /// Список идентификаторов заказов из отгрузок.
    #[serde(rename = "orderIds")]
    #[validate(
            length(min = 1),
        )]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub order_ids: Option<swagger::Nullable<Vec<i64>>>,

    /// Возвращать ли отмененные заказы.  Значение по умолчанию — `true`. Если возвращать отмененные заказы не нужно, передайте значение `false`. 
    #[serde(rename = "cancelledOrders")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub cancelled_orders: Option<bool>,

}


impl SearchShipmentsRequest {
    #[allow(clippy::new_without_default)]
    pub fn new(date_from: chrono::naive::NaiveDate, date_to: chrono::naive::NaiveDate, ) -> SearchShipmentsRequest {
        SearchShipmentsRequest {
            date_from,
            date_to,
            statuses: None,
            order_ids: None,
            cancelled_orders: Some(true),
        }
    }
}

/// Converts the SearchShipmentsRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for SearchShipmentsRequest {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping dateFrom in query parameter serialization

            // Skipping dateTo in query parameter serialization

            // Skipping statuses in query parameter serialization


            self.order_ids.as_ref().map(|order_ids| {
                [
                    "orderIds".to_string(),
                    order_ids.as_ref().map_or("null".to_string(), |x| x.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),
                ].join(",")
            }),


            self.cancelled_orders.as_ref().map(|cancelled_orders| {
                [
                    "cancelledOrders".to_string(),
                    cancelled_orders.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a SearchShipmentsRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for SearchShipmentsRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub date_from: Vec<chrono::naive::NaiveDate>,
            pub date_to: Vec<chrono::naive::NaiveDate>,
            pub statuses: Vec<Vec<models::ShipmentStatusType>>,
            pub order_ids: Vec<Vec<i64>>,
            pub cancelled_orders: Vec<bool>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing SearchShipmentsRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "dateFrom" => intermediate_rep.date_from.push(<chrono::naive::NaiveDate as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "dateTo" => intermediate_rep.date_to.push(<chrono::naive::NaiveDate as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "statuses" => return std::result::Result::Err("Parsing a container in this style is not supported in SearchShipmentsRequest".to_string()),
                    "orderIds" => return std::result::Result::Err("Parsing a container in this style is not supported in SearchShipmentsRequest".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "cancelledOrders" => intermediate_rep.cancelled_orders.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing SearchShipmentsRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(SearchShipmentsRequest {
            date_from: intermediate_rep.date_from.into_iter().next().ok_or_else(|| "dateFrom missing in SearchShipmentsRequest".to_string())?,
            date_to: intermediate_rep.date_to.into_iter().next().ok_or_else(|| "dateTo missing in SearchShipmentsRequest".to_string())?,
            statuses: std::result::Result::Err("Nullable types not supported in SearchShipmentsRequest".to_string())?,
            order_ids: std::result::Result::Err("Nullable types not supported in SearchShipmentsRequest".to_string())?,
            cancelled_orders: intermediate_rep.cancelled_orders.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<SearchShipmentsRequest> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<SearchShipmentsRequest>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<SearchShipmentsRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for SearchShipmentsRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<SearchShipmentsRequest> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <SearchShipmentsRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into SearchShipmentsRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Ответ на запрос информации об отгрузках.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct SearchShipmentsResponse {
    #[serde(rename = "status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<models::ApiResponseStatusType>,

    #[serde(rename = "result")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub result: Option<models::SearchShipmentsResponseDto>,

}


impl SearchShipmentsResponse {
    #[allow(clippy::new_without_default)]
    pub fn new() -> SearchShipmentsResponse {
        SearchShipmentsResponse {
            status: None,
            result: None,
        }
    }
}

/// Converts the SearchShipmentsResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for SearchShipmentsResponse {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping status in query parameter serialization

            // Skipping result in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a SearchShipmentsResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for SearchShipmentsResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub status: Vec<models::ApiResponseStatusType>,
            pub result: Vec<models::SearchShipmentsResponseDto>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing SearchShipmentsResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(<models::ApiResponseStatusType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "result" => intermediate_rep.result.push(<models::SearchShipmentsResponseDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing SearchShipmentsResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(SearchShipmentsResponse {
            status: intermediate_rep.status.into_iter().next(),
            result: intermediate_rep.result.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<SearchShipmentsResponse> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<SearchShipmentsResponse>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<SearchShipmentsResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for SearchShipmentsResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<SearchShipmentsResponse> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <SearchShipmentsResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into SearchShipmentsResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Информация об отгрузках.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct SearchShipmentsResponseDto {
    /// Список с информацией об отгрузках.
    #[serde(rename = "shipments")]
    pub shipments: Vec<models::ShipmentInfoDto>,

    #[serde(rename = "paging")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub paging: Option<models::ForwardScrollingPagerDto>,

}


impl SearchShipmentsResponseDto {
    #[allow(clippy::new_without_default)]
    pub fn new(shipments: Vec<models::ShipmentInfoDto>, ) -> SearchShipmentsResponseDto {
        SearchShipmentsResponseDto {
            shipments,
            paging: None,
        }
    }
}

/// Converts the SearchShipmentsResponseDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for SearchShipmentsResponseDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping shipments in query parameter serialization

            // Skipping paging in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a SearchShipmentsResponseDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for SearchShipmentsResponseDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub shipments: Vec<Vec<models::ShipmentInfoDto>>,
            pub paging: Vec<models::ForwardScrollingPagerDto>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing SearchShipmentsResponseDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "shipments" => return std::result::Result::Err("Parsing a container in this style is not supported in SearchShipmentsResponseDto".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "paging" => intermediate_rep.paging.push(<models::ForwardScrollingPagerDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing SearchShipmentsResponseDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(SearchShipmentsResponseDto {
            shipments: intermediate_rep.shipments.into_iter().next().ok_or_else(|| "shipments missing in SearchShipmentsResponseDto".to_string())?,
            paging: intermediate_rep.paging.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<SearchShipmentsResponseDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<SearchShipmentsResponseDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<SearchShipmentsResponseDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for SearchShipmentsResponseDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<SearchShipmentsResponseDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <SearchShipmentsResponseDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into SearchShipmentsResponseDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Модель размещения:  * `FBY` — FBY. * `FBS` — FBS. * `DBS` — DBS. * `EXPRESS` — Экспресс. 
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum SellingProgramType {
    #[serde(rename = "FBY")]
    Fby,
    #[serde(rename = "FBS")]
    Fbs,
    #[serde(rename = "DBS")]
    Dbs,
    #[serde(rename = "EXPRESS")]
    Express,
}

impl std::fmt::Display for SellingProgramType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            SellingProgramType::Fby => write!(f, "FBY"),
            SellingProgramType::Fbs => write!(f, "FBS"),
            SellingProgramType::Dbs => write!(f, "DBS"),
            SellingProgramType::Express => write!(f, "EXPRESS"),
        }
    }
}

impl std::str::FromStr for SellingProgramType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "FBY" => std::result::Result::Ok(SellingProgramType::Fby),
            "FBS" => std::result::Result::Ok(SellingProgramType::Fbs),
            "DBS" => std::result::Result::Ok(SellingProgramType::Dbs),
            "EXPRESS" => std::result::Result::Ok(SellingProgramType::Express),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// В какой чат нужно отправить сообщение и текст сообщения.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct SendMessageToChatRequest {
    /// Текст сообщения. Максимальная длина — 4096 символа.
    #[serde(rename = "message")]
    #[validate(
            length(min = 1, max = 4096),
        )]
    pub message: String,

}


impl SendMessageToChatRequest {
    #[allow(clippy::new_without_default)]
    pub fn new(message: String, ) -> SendMessageToChatRequest {
        SendMessageToChatRequest {
            message,
        }
    }
}

/// Converts the SendMessageToChatRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for SendMessageToChatRequest {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            Some("message".to_string()),
            Some(self.message.to_string()),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a SendMessageToChatRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for SendMessageToChatRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub message: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing SendMessageToChatRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "message" => intermediate_rep.message.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing SendMessageToChatRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(SendMessageToChatRequest {
            message: intermediate_rep.message.into_iter().next().ok_or_else(|| "message missing in SendMessageToChatRequest".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<SendMessageToChatRequest> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<SendMessageToChatRequest>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<SendMessageToChatRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for SendMessageToChatRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<SendMessageToChatRequest> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <SendMessageToChatRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into SendMessageToChatRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Запрос на обновление изменение параметров прайс-листа.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct SetFeedParamsRequest {
    /// Параметры прайс-листа.  Обязательный параметр. 
    #[serde(rename = "parameters")]
    pub parameters: Vec<models::FeedParameterDto>,

}


impl SetFeedParamsRequest {
    #[allow(clippy::new_without_default)]
    pub fn new(parameters: Vec<models::FeedParameterDto>, ) -> SetFeedParamsRequest {
        SetFeedParamsRequest {
            parameters,
        }
    }
}

/// Converts the SetFeedParamsRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for SetFeedParamsRequest {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping parameters in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a SetFeedParamsRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for SetFeedParamsRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub parameters: Vec<Vec<models::FeedParameterDto>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing SetFeedParamsRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "parameters" => return std::result::Result::Err("Parsing a container in this style is not supported in SetFeedParamsRequest".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing SetFeedParamsRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(SetFeedParamsRequest {
            parameters: intermediate_rep.parameters.into_iter().next().ok_or_else(|| "parameters missing in SetFeedParamsRequest".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<SetFeedParamsRequest> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<SetFeedParamsRequest>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<SetFeedParamsRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for SetFeedParamsRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<SetFeedParamsRequest> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <SetFeedParamsRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into SetFeedParamsRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct SetOrderBoxLayoutRequest {
    /// Список коробок.
    #[serde(rename = "boxes")]
    #[validate(
            length(min = 1),
        )]
    pub boxes: Vec<models::OrderBoxLayoutDto>,

    /// Передайте `true`, если вы собираетесь удалить часть товаров из заказа.
    #[serde(rename = "allowRemove")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub allow_remove: Option<bool>,

}


impl SetOrderBoxLayoutRequest {
    #[allow(clippy::new_without_default)]
    pub fn new(boxes: Vec<models::OrderBoxLayoutDto>, ) -> SetOrderBoxLayoutRequest {
        SetOrderBoxLayoutRequest {
            boxes,
            allow_remove: Some(false),
        }
    }
}

/// Converts the SetOrderBoxLayoutRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for SetOrderBoxLayoutRequest {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping boxes in query parameter serialization


            self.allow_remove.as_ref().map(|allow_remove| {
                [
                    "allowRemove".to_string(),
                    allow_remove.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a SetOrderBoxLayoutRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for SetOrderBoxLayoutRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub boxes: Vec<Vec<models::OrderBoxLayoutDto>>,
            pub allow_remove: Vec<bool>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing SetOrderBoxLayoutRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "boxes" => return std::result::Result::Err("Parsing a container in this style is not supported in SetOrderBoxLayoutRequest".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "allowRemove" => intermediate_rep.allow_remove.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing SetOrderBoxLayoutRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(SetOrderBoxLayoutRequest {
            boxes: intermediate_rep.boxes.into_iter().next().ok_or_else(|| "boxes missing in SetOrderBoxLayoutRequest".to_string())?,
            allow_remove: intermediate_rep.allow_remove.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<SetOrderBoxLayoutRequest> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<SetOrderBoxLayoutRequest>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<SetOrderBoxLayoutRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for SetOrderBoxLayoutRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<SetOrderBoxLayoutRequest> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <SetOrderBoxLayoutRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into SetOrderBoxLayoutRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct SetOrderBoxLayoutResponse {
    #[serde(rename = "status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<models::ApiResponseStatusType>,

    #[serde(rename = "result")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub result: Option<models::OrderBoxesLayoutDto>,

}


impl SetOrderBoxLayoutResponse {
    #[allow(clippy::new_without_default)]
    pub fn new() -> SetOrderBoxLayoutResponse {
        SetOrderBoxLayoutResponse {
            status: None,
            result: None,
        }
    }
}

/// Converts the SetOrderBoxLayoutResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for SetOrderBoxLayoutResponse {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping status in query parameter serialization

            // Skipping result in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a SetOrderBoxLayoutResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for SetOrderBoxLayoutResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub status: Vec<models::ApiResponseStatusType>,
            pub result: Vec<models::OrderBoxesLayoutDto>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing SetOrderBoxLayoutResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(<models::ApiResponseStatusType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "result" => intermediate_rep.result.push(<models::OrderBoxesLayoutDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing SetOrderBoxLayoutResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(SetOrderBoxLayoutResponse {
            status: intermediate_rep.status.into_iter().next(),
            result: intermediate_rep.result.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<SetOrderBoxLayoutResponse> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<SetOrderBoxLayoutResponse>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<SetOrderBoxLayoutResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for SetOrderBoxLayoutResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<SetOrderBoxLayoutResponse> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <SetOrderBoxLayoutResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into SetOrderBoxLayoutResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct SetOrderDeliveryDateRequest {
    #[serde(rename = "dates")]
    pub dates: models::OrderDeliveryDateDto,

    #[serde(rename = "reason")]
    pub reason: models::OrderDeliveryDateReasonType,

}


impl SetOrderDeliveryDateRequest {
    #[allow(clippy::new_without_default)]
    pub fn new(dates: models::OrderDeliveryDateDto, reason: models::OrderDeliveryDateReasonType, ) -> SetOrderDeliveryDateRequest {
        SetOrderDeliveryDateRequest {
            dates,
            reason,
        }
    }
}

/// Converts the SetOrderDeliveryDateRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for SetOrderDeliveryDateRequest {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping dates in query parameter serialization

            // Skipping reason in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a SetOrderDeliveryDateRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for SetOrderDeliveryDateRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub dates: Vec<models::OrderDeliveryDateDto>,
            pub reason: Vec<models::OrderDeliveryDateReasonType>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing SetOrderDeliveryDateRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "dates" => intermediate_rep.dates.push(<models::OrderDeliveryDateDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "reason" => intermediate_rep.reason.push(<models::OrderDeliveryDateReasonType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing SetOrderDeliveryDateRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(SetOrderDeliveryDateRequest {
            dates: intermediate_rep.dates.into_iter().next().ok_or_else(|| "dates missing in SetOrderDeliveryDateRequest".to_string())?,
            reason: intermediate_rep.reason.into_iter().next().ok_or_else(|| "reason missing in SetOrderDeliveryDateRequest".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<SetOrderDeliveryDateRequest> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<SetOrderDeliveryDateRequest>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<SetOrderDeliveryDateRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for SetOrderDeliveryDateRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<SetOrderDeliveryDateRequest> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <SetOrderDeliveryDateRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into SetOrderDeliveryDateRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct SetOrderDeliveryTrackCodeRequest {
    /// Трек‑номер посылки.
    #[serde(rename = "trackCode")]
    pub track_code: String,

    /// Идентификатор службы доставки. Информацию о службе доставки можно получить с помощью запроса [GET delivery/services](../../reference/orders/getDeliveryServices.md).
    #[serde(rename = "deliveryServiceId")]
    pub delivery_service_id: i64,

}


impl SetOrderDeliveryTrackCodeRequest {
    #[allow(clippy::new_without_default)]
    pub fn new(track_code: String, delivery_service_id: i64, ) -> SetOrderDeliveryTrackCodeRequest {
        SetOrderDeliveryTrackCodeRequest {
            track_code,
            delivery_service_id,
        }
    }
}

/// Converts the SetOrderDeliveryTrackCodeRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for SetOrderDeliveryTrackCodeRequest {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            Some("trackCode".to_string()),
            Some(self.track_code.to_string()),


            Some("deliveryServiceId".to_string()),
            Some(self.delivery_service_id.to_string()),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a SetOrderDeliveryTrackCodeRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for SetOrderDeliveryTrackCodeRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub track_code: Vec<String>,
            pub delivery_service_id: Vec<i64>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing SetOrderDeliveryTrackCodeRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "trackCode" => intermediate_rep.track_code.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "deliveryServiceId" => intermediate_rep.delivery_service_id.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing SetOrderDeliveryTrackCodeRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(SetOrderDeliveryTrackCodeRequest {
            track_code: intermediate_rep.track_code.into_iter().next().ok_or_else(|| "trackCode missing in SetOrderDeliveryTrackCodeRequest".to_string())?,
            delivery_service_id: intermediate_rep.delivery_service_id.into_iter().next().ok_or_else(|| "deliveryServiceId missing in SetOrderDeliveryTrackCodeRequest".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<SetOrderDeliveryTrackCodeRequest> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<SetOrderDeliveryTrackCodeRequest>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<SetOrderDeliveryTrackCodeRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for SetOrderDeliveryTrackCodeRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<SetOrderDeliveryTrackCodeRequest> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <SetOrderDeliveryTrackCodeRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into SetOrderDeliveryTrackCodeRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct SetOrderShipmentBoxesRequest {
    /// Список грузовых мест. Маркет определяет количество мест по длине этого списка.
    #[serde(rename = "boxes")]
    #[validate(
            length(min = 1),
        )]
    pub boxes: Vec<models::ParcelBoxDto>,

}


impl SetOrderShipmentBoxesRequest {
    #[allow(clippy::new_without_default)]
    pub fn new(boxes: Vec<models::ParcelBoxDto>, ) -> SetOrderShipmentBoxesRequest {
        SetOrderShipmentBoxesRequest {
            boxes,
        }
    }
}

/// Converts the SetOrderShipmentBoxesRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for SetOrderShipmentBoxesRequest {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping boxes in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a SetOrderShipmentBoxesRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for SetOrderShipmentBoxesRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub boxes: Vec<Vec<models::ParcelBoxDto>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing SetOrderShipmentBoxesRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "boxes" => return std::result::Result::Err("Parsing a container in this style is not supported in SetOrderShipmentBoxesRequest".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing SetOrderShipmentBoxesRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(SetOrderShipmentBoxesRequest {
            boxes: intermediate_rep.boxes.into_iter().next().ok_or_else(|| "boxes missing in SetOrderShipmentBoxesRequest".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<SetOrderShipmentBoxesRequest> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<SetOrderShipmentBoxesRequest>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<SetOrderShipmentBoxesRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for SetOrderShipmentBoxesRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<SetOrderShipmentBoxesRequest> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <SetOrderShipmentBoxesRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into SetOrderShipmentBoxesRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct SetOrderShipmentBoxesResponse {
    #[serde(rename = "status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<models::ApiResponseStatusType>,

    #[serde(rename = "result")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub result: Option<models::ShipmentBoxesDto>,

}


impl SetOrderShipmentBoxesResponse {
    #[allow(clippy::new_without_default)]
    pub fn new() -> SetOrderShipmentBoxesResponse {
        SetOrderShipmentBoxesResponse {
            status: None,
            result: None,
        }
    }
}

/// Converts the SetOrderShipmentBoxesResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for SetOrderShipmentBoxesResponse {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping status in query parameter serialization

            // Skipping result in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a SetOrderShipmentBoxesResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for SetOrderShipmentBoxesResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub status: Vec<models::ApiResponseStatusType>,
            pub result: Vec<models::ShipmentBoxesDto>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing SetOrderShipmentBoxesResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(<models::ApiResponseStatusType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "result" => intermediate_rep.result.push(<models::ShipmentBoxesDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing SetOrderShipmentBoxesResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(SetOrderShipmentBoxesResponse {
            status: intermediate_rep.status.into_iter().next(),
            result: intermediate_rep.result.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<SetOrderShipmentBoxesResponse> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<SetOrderShipmentBoxesResponse>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<SetOrderShipmentBoxesResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for SetOrderShipmentBoxesResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<SetOrderShipmentBoxesResponse> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <SetOrderShipmentBoxesResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into SetOrderShipmentBoxesResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Решения по позиции в возврате.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct SetReturnDecisionRequest {
    /// Идентификатор товара в возврате.
    #[serde(rename = "returnItemId")]
    pub return_item_id: i64,

    #[serde(rename = "decisionType")]
    pub decision_type: models::ReturnRequestDecisionType,

    /// Комментарий к решению. Укажите:  * для `REFUND_MONEY_INCLUDING_SHIPMENT`— стоимость обратной пересылки;  * для `REPAIR` — когда вы устраните недостатки товара;  * для `DECLINE_REFUND` — причину отказа;  * для `OTHER_DECISION` — какое решение вы предлагаете. 
    #[serde(rename = "comment")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub comment: Option<String>,

}


impl SetReturnDecisionRequest {
    #[allow(clippy::new_without_default)]
    pub fn new(return_item_id: i64, decision_type: models::ReturnRequestDecisionType, ) -> SetReturnDecisionRequest {
        SetReturnDecisionRequest {
            return_item_id,
            decision_type,
            comment: None,
        }
    }
}

/// Converts the SetReturnDecisionRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for SetReturnDecisionRequest {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            Some("returnItemId".to_string()),
            Some(self.return_item_id.to_string()),

            // Skipping decisionType in query parameter serialization


            self.comment.as_ref().map(|comment| {
                [
                    "comment".to_string(),
                    comment.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a SetReturnDecisionRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for SetReturnDecisionRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub return_item_id: Vec<i64>,
            pub decision_type: Vec<models::ReturnRequestDecisionType>,
            pub comment: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing SetReturnDecisionRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "returnItemId" => intermediate_rep.return_item_id.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "decisionType" => intermediate_rep.decision_type.push(<models::ReturnRequestDecisionType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "comment" => intermediate_rep.comment.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing SetReturnDecisionRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(SetReturnDecisionRequest {
            return_item_id: intermediate_rep.return_item_id.into_iter().next().ok_or_else(|| "returnItemId missing in SetReturnDecisionRequest".to_string())?,
            decision_type: intermediate_rep.decision_type.into_iter().next().ok_or_else(|| "decisionType missing in SetReturnDecisionRequest".to_string())?,
            comment: intermediate_rep.comment.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<SetReturnDecisionRequest> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<SetReturnDecisionRequest>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<SetReturnDecisionRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for SetReturnDecisionRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<SetReturnDecisionRequest> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <SetReturnDecisionRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into SetReturnDecisionRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Запрос на передачу количества упаковок в отгрузке.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct SetShipmentPalletsCountRequest {
    /// Количество упаковок в отгрузке.
    #[serde(rename = "placesCount")]
    #[validate(
            range(min = 0),
        )]
    pub places_count: u32,

}


impl SetShipmentPalletsCountRequest {
    #[allow(clippy::new_without_default)]
    pub fn new(places_count: u32, ) -> SetShipmentPalletsCountRequest {
        SetShipmentPalletsCountRequest {
            places_count,
        }
    }
}

/// Converts the SetShipmentPalletsCountRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for SetShipmentPalletsCountRequest {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            Some("placesCount".to_string()),
            Some(self.places_count.to_string()),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a SetShipmentPalletsCountRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for SetShipmentPalletsCountRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub places_count: Vec<u32>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing SetShipmentPalletsCountRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "placesCount" => intermediate_rep.places_count.push(<u32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing SetShipmentPalletsCountRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(SetShipmentPalletsCountRequest {
            places_count: intermediate_rep.places_count.into_iter().next().ok_or_else(|| "placesCount missing in SetShipmentPalletsCountRequest".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<SetShipmentPalletsCountRequest> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<SetShipmentPalletsCountRequest>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<SetShipmentPalletsCountRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for SetShipmentPalletsCountRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<SetShipmentPalletsCountRequest> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <SetShipmentPalletsCountRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into SetShipmentPalletsCountRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Тип атрибуции:   * `CLICKS` — по кликам.   * `SHOWS` — по показам. <br><br>  О том, какие данные в отчете зависят и не зависят от типа атрибуции, читайте [в Справке Маркета для продавцов](https://yandex.ru/support2/marketplace/ru/marketing/shelf#stats). 
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum ShelfsStatisticsAttributionType {
    #[serde(rename = "CLICKS")]
    Clicks,
    #[serde(rename = "SHOWS")]
    Shows,
}

impl std::fmt::Display for ShelfsStatisticsAttributionType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            ShelfsStatisticsAttributionType::Clicks => write!(f, "CLICKS"),
            ShelfsStatisticsAttributionType::Shows => write!(f, "SHOWS"),
        }
    }
}

impl std::str::FromStr for ShelfsStatisticsAttributionType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "CLICKS" => std::result::Result::Ok(ShelfsStatisticsAttributionType::Clicks),
            "SHOWS" => std::result::Result::Ok(ShelfsStatisticsAttributionType::Shows),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Действия с отгрузкой:  * `CONFIRM` — подтвердить отгрузку. * `DOWNLOAD_ACT` — скачать акт приема-передачи отгрузки. * `DOWNLOAD_INBOUND_ACT` — скачать список принятых заказов. * `DOWNLOAD_DISCREPANCY_ACT` — скачать акт расхождений. * `CHANGE_PALLETS_COUNT` — указать количество палет. 
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum ShipmentActionType {
    #[serde(rename = "CONFIRM")]
    Confirm,
    #[serde(rename = "DOWNLOAD_ACT")]
    DownloadAct,
    #[serde(rename = "DOWNLOAD_INBOUND_ACT")]
    DownloadInboundAct,
    #[serde(rename = "DOWNLOAD_DISCREPANCY_ACT")]
    DownloadDiscrepancyAct,
    #[serde(rename = "CHANGE_PALLETS_COUNT")]
    ChangePalletsCount,
}

impl std::fmt::Display for ShipmentActionType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            ShipmentActionType::Confirm => write!(f, "CONFIRM"),
            ShipmentActionType::DownloadAct => write!(f, "DOWNLOAD_ACT"),
            ShipmentActionType::DownloadInboundAct => write!(f, "DOWNLOAD_INBOUND_ACT"),
            ShipmentActionType::DownloadDiscrepancyAct => write!(f, "DOWNLOAD_DISCREPANCY_ACT"),
            ShipmentActionType::ChangePalletsCount => write!(f, "CHANGE_PALLETS_COUNT"),
        }
    }
}

impl std::str::FromStr for ShipmentActionType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "CONFIRM" => std::result::Result::Ok(ShipmentActionType::Confirm),
            "DOWNLOAD_ACT" => std::result::Result::Ok(ShipmentActionType::DownloadAct),
            "DOWNLOAD_INBOUND_ACT" => std::result::Result::Ok(ShipmentActionType::DownloadInboundAct),
            "DOWNLOAD_DISCREPANCY_ACT" => std::result::Result::Ok(ShipmentActionType::DownloadDiscrepancyAct),
            "CHANGE_PALLETS_COUNT" => std::result::Result::Ok(ShipmentActionType::ChangePalletsCount),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// В ответе Маркет возвращает переданный вами список грузовых мест. Не обращайте на это поле внимания. 
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ShipmentBoxesDto {
    /// Список грузовых мест. Маркет определил количество мест по длине этого списка. 
    #[serde(rename = "boxes")]
    pub boxes: Vec<models::ParcelBoxDto>,

}


impl ShipmentBoxesDto {
    #[allow(clippy::new_without_default)]
    pub fn new(boxes: Vec<models::ParcelBoxDto>, ) -> ShipmentBoxesDto {
        ShipmentBoxesDto {
            boxes,
        }
    }
}

/// Converts the ShipmentBoxesDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ShipmentBoxesDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping boxes in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ShipmentBoxesDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ShipmentBoxesDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub boxes: Vec<Vec<models::ParcelBoxDto>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ShipmentBoxesDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "boxes" => return std::result::Result::Err("Parsing a container in this style is not supported in ShipmentBoxesDto".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing ShipmentBoxesDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ShipmentBoxesDto {
            boxes: intermediate_rep.boxes.into_iter().next().ok_or_else(|| "boxes missing in ShipmentBoxesDto".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ShipmentBoxesDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<ShipmentBoxesDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ShipmentBoxesDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ShipmentBoxesDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<ShipmentBoxesDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ShipmentBoxesDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ShipmentBoxesDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Информация об отгрузке.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ShipmentDto {
    /// Идентификатор отгрузки.
    #[serde(rename = "id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,

    /// Начало планового интервала отгрузки.
    #[serde(rename = "planIntervalFrom")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub plan_interval_from: Option<chrono::DateTime::<chrono::Utc>>,

    /// Конец планового интервала отгрузки.
    #[serde(rename = "planIntervalTo")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub plan_interval_to: Option<chrono::DateTime::<chrono::Utc>>,

    #[serde(rename = "shipmentType")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub shipment_type: Option<models::ShipmentType>,

    #[serde(rename = "warehouse")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub warehouse: Option<models::PartnerShipmentWarehouseDto>,

    #[serde(rename = "warehouseTo")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub warehouse_to: Option<models::PartnerShipmentWarehouseDto>,

    /// Идентификатор отгрузки в вашей системе. Если вы еще не передавали идентификатор, вернется идентификатор из параметра `id`.
    #[serde(rename = "externalId")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub external_id: Option<String>,

    #[serde(rename = "deliveryService")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub delivery_service: Option<models::DeliveryServiceDto>,

    #[serde(rename = "palletsCount")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub pallets_count: Option<models::PalletsCountDto>,

    /// Идентификаторы заказов в отгрузке.
    #[serde(rename = "orderIds")]
    #[validate(
        )]
    pub order_ids: Vec<i64>,

    /// Количество заказов, которое Маркет запланировал к отгрузке.
    #[serde(rename = "draftCount")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub draft_count: Option<i32>,

    /// Количество заказов, которое Маркет подтвердил к отгрузке.
    #[serde(rename = "plannedCount")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub planned_count: Option<i32>,

    /// Количество заказов, принятых в сортировочном центре или пункте приема.
    #[serde(rename = "factCount")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub fact_count: Option<i32>,

    #[serde(rename = "currentStatus")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub current_status: Option<models::ShipmentStatusChangeDto>,

    /// Доступные действия над отгрузкой.
    #[serde(rename = "availableActions")]
    #[validate(
        )]
    pub available_actions: Vec<models::ShipmentActionType>,

}


impl ShipmentDto {
    #[allow(clippy::new_without_default)]
    pub fn new(order_ids: Vec<i64>, available_actions: Vec<models::ShipmentActionType>, ) -> ShipmentDto {
        ShipmentDto {
            id: None,
            plan_interval_from: None,
            plan_interval_to: None,
            shipment_type: None,
            warehouse: None,
            warehouse_to: None,
            external_id: None,
            delivery_service: None,
            pallets_count: None,
            order_ids,
            draft_count: None,
            planned_count: None,
            fact_count: None,
            current_status: None,
            available_actions,
        }
    }
}

/// Converts the ShipmentDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ShipmentDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.id.as_ref().map(|id| {
                [
                    "id".to_string(),
                    id.to_string(),
                ].join(",")
            }),

            // Skipping planIntervalFrom in query parameter serialization

            // Skipping planIntervalTo in query parameter serialization

            // Skipping shipmentType in query parameter serialization

            // Skipping warehouse in query parameter serialization

            // Skipping warehouseTo in query parameter serialization


            self.external_id.as_ref().map(|external_id| {
                [
                    "externalId".to_string(),
                    external_id.to_string(),
                ].join(",")
            }),

            // Skipping deliveryService in query parameter serialization

            // Skipping palletsCount in query parameter serialization


            Some("orderIds".to_string()),
            Some(self.order_ids.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),


            self.draft_count.as_ref().map(|draft_count| {
                [
                    "draftCount".to_string(),
                    draft_count.to_string(),
                ].join(",")
            }),


            self.planned_count.as_ref().map(|planned_count| {
                [
                    "plannedCount".to_string(),
                    planned_count.to_string(),
                ].join(",")
            }),


            self.fact_count.as_ref().map(|fact_count| {
                [
                    "factCount".to_string(),
                    fact_count.to_string(),
                ].join(",")
            }),

            // Skipping currentStatus in query parameter serialization

            // Skipping availableActions in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ShipmentDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ShipmentDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<i64>,
            pub plan_interval_from: Vec<chrono::DateTime::<chrono::Utc>>,
            pub plan_interval_to: Vec<chrono::DateTime::<chrono::Utc>>,
            pub shipment_type: Vec<models::ShipmentType>,
            pub warehouse: Vec<models::PartnerShipmentWarehouseDto>,
            pub warehouse_to: Vec<models::PartnerShipmentWarehouseDto>,
            pub external_id: Vec<String>,
            pub delivery_service: Vec<models::DeliveryServiceDto>,
            pub pallets_count: Vec<models::PalletsCountDto>,
            pub order_ids: Vec<Vec<i64>>,
            pub draft_count: Vec<i32>,
            pub planned_count: Vec<i32>,
            pub fact_count: Vec<i32>,
            pub current_status: Vec<models::ShipmentStatusChangeDto>,
            pub available_actions: Vec<Vec<models::ShipmentActionType>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ShipmentDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "planIntervalFrom" => intermediate_rep.plan_interval_from.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "planIntervalTo" => intermediate_rep.plan_interval_to.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "shipmentType" => intermediate_rep.shipment_type.push(<models::ShipmentType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "warehouse" => intermediate_rep.warehouse.push(<models::PartnerShipmentWarehouseDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "warehouseTo" => intermediate_rep.warehouse_to.push(<models::PartnerShipmentWarehouseDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "externalId" => intermediate_rep.external_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "deliveryService" => intermediate_rep.delivery_service.push(<models::DeliveryServiceDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "palletsCount" => intermediate_rep.pallets_count.push(<models::PalletsCountDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "orderIds" => return std::result::Result::Err("Parsing a container in this style is not supported in ShipmentDto".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "draftCount" => intermediate_rep.draft_count.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "plannedCount" => intermediate_rep.planned_count.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "factCount" => intermediate_rep.fact_count.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "currentStatus" => intermediate_rep.current_status.push(<models::ShipmentStatusChangeDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "availableActions" => return std::result::Result::Err("Parsing a container in this style is not supported in ShipmentDto".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing ShipmentDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ShipmentDto {
            id: intermediate_rep.id.into_iter().next(),
            plan_interval_from: intermediate_rep.plan_interval_from.into_iter().next(),
            plan_interval_to: intermediate_rep.plan_interval_to.into_iter().next(),
            shipment_type: intermediate_rep.shipment_type.into_iter().next(),
            warehouse: intermediate_rep.warehouse.into_iter().next(),
            warehouse_to: intermediate_rep.warehouse_to.into_iter().next(),
            external_id: intermediate_rep.external_id.into_iter().next(),
            delivery_service: intermediate_rep.delivery_service.into_iter().next(),
            pallets_count: intermediate_rep.pallets_count.into_iter().next(),
            order_ids: intermediate_rep.order_ids.into_iter().next().ok_or_else(|| "orderIds missing in ShipmentDto".to_string())?,
            draft_count: intermediate_rep.draft_count.into_iter().next(),
            planned_count: intermediate_rep.planned_count.into_iter().next(),
            fact_count: intermediate_rep.fact_count.into_iter().next(),
            current_status: intermediate_rep.current_status.into_iter().next(),
            available_actions: intermediate_rep.available_actions.into_iter().next().ok_or_else(|| "availableActions missing in ShipmentDto".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ShipmentDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<ShipmentDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ShipmentDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ShipmentDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<ShipmentDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ShipmentDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ShipmentDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Список с информацией об отгрузках.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ShipmentInfoDto {
    /// Идентификатор отгрузки.
    #[serde(rename = "id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,

    /// Начало планового интервала отгрузки.
    #[serde(rename = "planIntervalFrom")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub plan_interval_from: Option<chrono::DateTime::<chrono::Utc>>,

    /// Конец планового интервала отгрузки.
    #[serde(rename = "planIntervalTo")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub plan_interval_to: Option<chrono::DateTime::<chrono::Utc>>,

    #[serde(rename = "shipmentType")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub shipment_type: Option<models::ShipmentType>,

    #[serde(rename = "warehouse")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub warehouse: Option<models::PartnerShipmentWarehouseDto>,

    #[serde(rename = "warehouseTo")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub warehouse_to: Option<models::PartnerShipmentWarehouseDto>,

    /// Идентификатор отгрузки в вашей системе. Если вы еще не передавали идентификатор, вернется идентификатор из параметра `id`.
    #[serde(rename = "externalId")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub external_id: Option<String>,

    #[serde(rename = "deliveryService")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub delivery_service: Option<models::DeliveryServiceDto>,

    #[serde(rename = "palletsCount")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub pallets_count: Option<models::PalletsCountDto>,

    /// Идентификаторы заказов в отгрузке.
    #[serde(rename = "orderIds")]
    #[validate(
        )]
    pub order_ids: Vec<i64>,

    /// Количество заказов, которое Маркет запланировал к отгрузке.
    #[serde(rename = "draftCount")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub draft_count: Option<i32>,

    /// Количество заказов, которое Маркет подтвердил к отгрузке.
    #[serde(rename = "plannedCount")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub planned_count: Option<i32>,

    /// Количество заказов, принятых в сортировочном центре или пункте приема.
    #[serde(rename = "factCount")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub fact_count: Option<i32>,

    #[serde(rename = "status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<models::ShipmentStatusType>,

    /// Описание статуса отгрузки.
    #[serde(rename = "statusDescription")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub status_description: Option<String>,

    /// Время последнего изменения статуса отгрузки.
    #[serde(rename = "statusUpdateTime")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub status_update_time: Option<chrono::DateTime::<chrono::Utc>>,

}


impl ShipmentInfoDto {
    #[allow(clippy::new_without_default)]
    pub fn new(order_ids: Vec<i64>, ) -> ShipmentInfoDto {
        ShipmentInfoDto {
            id: None,
            plan_interval_from: None,
            plan_interval_to: None,
            shipment_type: None,
            warehouse: None,
            warehouse_to: None,
            external_id: None,
            delivery_service: None,
            pallets_count: None,
            order_ids,
            draft_count: None,
            planned_count: None,
            fact_count: None,
            status: None,
            status_description: None,
            status_update_time: None,
        }
    }
}

/// Converts the ShipmentInfoDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ShipmentInfoDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.id.as_ref().map(|id| {
                [
                    "id".to_string(),
                    id.to_string(),
                ].join(",")
            }),

            // Skipping planIntervalFrom in query parameter serialization

            // Skipping planIntervalTo in query parameter serialization

            // Skipping shipmentType in query parameter serialization

            // Skipping warehouse in query parameter serialization

            // Skipping warehouseTo in query parameter serialization


            self.external_id.as_ref().map(|external_id| {
                [
                    "externalId".to_string(),
                    external_id.to_string(),
                ].join(",")
            }),

            // Skipping deliveryService in query parameter serialization

            // Skipping palletsCount in query parameter serialization


            Some("orderIds".to_string()),
            Some(self.order_ids.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),


            self.draft_count.as_ref().map(|draft_count| {
                [
                    "draftCount".to_string(),
                    draft_count.to_string(),
                ].join(",")
            }),


            self.planned_count.as_ref().map(|planned_count| {
                [
                    "plannedCount".to_string(),
                    planned_count.to_string(),
                ].join(",")
            }),


            self.fact_count.as_ref().map(|fact_count| {
                [
                    "factCount".to_string(),
                    fact_count.to_string(),
                ].join(",")
            }),

            // Skipping status in query parameter serialization


            self.status_description.as_ref().map(|status_description| {
                [
                    "statusDescription".to_string(),
                    status_description.to_string(),
                ].join(",")
            }),

            // Skipping statusUpdateTime in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ShipmentInfoDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ShipmentInfoDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<i64>,
            pub plan_interval_from: Vec<chrono::DateTime::<chrono::Utc>>,
            pub plan_interval_to: Vec<chrono::DateTime::<chrono::Utc>>,
            pub shipment_type: Vec<models::ShipmentType>,
            pub warehouse: Vec<models::PartnerShipmentWarehouseDto>,
            pub warehouse_to: Vec<models::PartnerShipmentWarehouseDto>,
            pub external_id: Vec<String>,
            pub delivery_service: Vec<models::DeliveryServiceDto>,
            pub pallets_count: Vec<models::PalletsCountDto>,
            pub order_ids: Vec<Vec<i64>>,
            pub draft_count: Vec<i32>,
            pub planned_count: Vec<i32>,
            pub fact_count: Vec<i32>,
            pub status: Vec<models::ShipmentStatusType>,
            pub status_description: Vec<String>,
            pub status_update_time: Vec<chrono::DateTime::<chrono::Utc>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ShipmentInfoDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "planIntervalFrom" => intermediate_rep.plan_interval_from.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "planIntervalTo" => intermediate_rep.plan_interval_to.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "shipmentType" => intermediate_rep.shipment_type.push(<models::ShipmentType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "warehouse" => intermediate_rep.warehouse.push(<models::PartnerShipmentWarehouseDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "warehouseTo" => intermediate_rep.warehouse_to.push(<models::PartnerShipmentWarehouseDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "externalId" => intermediate_rep.external_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "deliveryService" => intermediate_rep.delivery_service.push(<models::DeliveryServiceDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "palletsCount" => intermediate_rep.pallets_count.push(<models::PalletsCountDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "orderIds" => return std::result::Result::Err("Parsing a container in this style is not supported in ShipmentInfoDto".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "draftCount" => intermediate_rep.draft_count.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "plannedCount" => intermediate_rep.planned_count.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "factCount" => intermediate_rep.fact_count.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(<models::ShipmentStatusType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "statusDescription" => intermediate_rep.status_description.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "statusUpdateTime" => intermediate_rep.status_update_time.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ShipmentInfoDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ShipmentInfoDto {
            id: intermediate_rep.id.into_iter().next(),
            plan_interval_from: intermediate_rep.plan_interval_from.into_iter().next(),
            plan_interval_to: intermediate_rep.plan_interval_to.into_iter().next(),
            shipment_type: intermediate_rep.shipment_type.into_iter().next(),
            warehouse: intermediate_rep.warehouse.into_iter().next(),
            warehouse_to: intermediate_rep.warehouse_to.into_iter().next(),
            external_id: intermediate_rep.external_id.into_iter().next(),
            delivery_service: intermediate_rep.delivery_service.into_iter().next(),
            pallets_count: intermediate_rep.pallets_count.into_iter().next(),
            order_ids: intermediate_rep.order_ids.into_iter().next().ok_or_else(|| "orderIds missing in ShipmentInfoDto".to_string())?,
            draft_count: intermediate_rep.draft_count.into_iter().next(),
            planned_count: intermediate_rep.planned_count.into_iter().next(),
            fact_count: intermediate_rep.fact_count.into_iter().next(),
            status: intermediate_rep.status.into_iter().next(),
            status_description: intermediate_rep.status_description.into_iter().next(),
            status_update_time: intermediate_rep.status_update_time.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ShipmentInfoDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<ShipmentInfoDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ShipmentInfoDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ShipmentInfoDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<ShipmentInfoDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ShipmentInfoDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ShipmentInfoDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Формат страницы: * `A4` — формат страницы A4. * `A8` — формат страницы A8. 
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum ShipmentPalletLabelPageFormatType {
    #[serde(rename = "A4")]
    A4,
    #[serde(rename = "A8")]
    A8,
}

impl std::fmt::Display for ShipmentPalletLabelPageFormatType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            ShipmentPalletLabelPageFormatType::A4 => write!(f, "A4"),
            ShipmentPalletLabelPageFormatType::A8 => write!(f, "A8"),
        }
    }
}

impl std::str::FromStr for ShipmentPalletLabelPageFormatType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "A4" => std::result::Result::Ok(ShipmentPalletLabelPageFormatType::A4),
            "A8" => std::result::Result::Ok(ShipmentPalletLabelPageFormatType::A8),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Статус отгрузки.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ShipmentStatusChangeDto {
    #[serde(rename = "status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<models::ShipmentStatusType>,

    /// Описание статуса отгрузки.
    #[serde(rename = "description")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,

    /// Время последнего изменения статуса отгрузки.
    #[serde(rename = "updateTime")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub update_time: Option<chrono::DateTime::<chrono::Utc>>,

}


impl ShipmentStatusChangeDto {
    #[allow(clippy::new_without_default)]
    pub fn new() -> ShipmentStatusChangeDto {
        ShipmentStatusChangeDto {
            status: None,
            description: None,
            update_time: None,
        }
    }
}

/// Converts the ShipmentStatusChangeDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ShipmentStatusChangeDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping status in query parameter serialization


            self.description.as_ref().map(|description| {
                [
                    "description".to_string(),
                    description.to_string(),
                ].join(",")
            }),

            // Skipping updateTime in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ShipmentStatusChangeDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ShipmentStatusChangeDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub status: Vec<models::ShipmentStatusType>,
            pub description: Vec<String>,
            pub update_time: Vec<chrono::DateTime::<chrono::Utc>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ShipmentStatusChangeDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(<models::ShipmentStatusType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "description" => intermediate_rep.description.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "updateTime" => intermediate_rep.update_time.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ShipmentStatusChangeDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ShipmentStatusChangeDto {
            status: intermediate_rep.status.into_iter().next(),
            description: intermediate_rep.description.into_iter().next(),
            update_time: intermediate_rep.update_time.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ShipmentStatusChangeDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<ShipmentStatusChangeDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ShipmentStatusChangeDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ShipmentStatusChangeDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<ShipmentStatusChangeDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ShipmentStatusChangeDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ShipmentStatusChangeDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Статус отгрузки:  * `OUTBOUND_CREATED` — формируется. * `OUTBOUND_READY_FOR_CONFIRMATION` — можно обрабатывать. * `OUTBOUND_CONFIRMED` — подтверждена и готова к отправке. * `OUTBOUND_SIGNED` — по ней подписан электронный акт приема-передачи. * `ACCEPTED` — принята в сортировочном центре или пункте приема. * `ACCEPTED_WITH_DISCREPANCIES` — принята с расхождениями. * `FINISHED` — завершена. * `ERROR` — отменена из-за ошибки. 
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum ShipmentStatusType {
    #[serde(rename = "OUTBOUND_CREATED")]
    OutboundCreated,
    #[serde(rename = "OUTBOUND_READY_FOR_CONFIRMATION")]
    OutboundReadyForConfirmation,
    #[serde(rename = "OUTBOUND_CONFIRMED")]
    OutboundConfirmed,
    #[serde(rename = "OUTBOUND_SIGNED")]
    OutboundSigned,
    #[serde(rename = "FINISHED")]
    Finished,
    #[serde(rename = "ACCEPTED")]
    Accepted,
    #[serde(rename = "ACCEPTED_WITH_DISCREPANCIES")]
    AcceptedWithDiscrepancies,
    #[serde(rename = "ERROR")]
    Error,
}

impl std::fmt::Display for ShipmentStatusType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            ShipmentStatusType::OutboundCreated => write!(f, "OUTBOUND_CREATED"),
            ShipmentStatusType::OutboundReadyForConfirmation => write!(f, "OUTBOUND_READY_FOR_CONFIRMATION"),
            ShipmentStatusType::OutboundConfirmed => write!(f, "OUTBOUND_CONFIRMED"),
            ShipmentStatusType::OutboundSigned => write!(f, "OUTBOUND_SIGNED"),
            ShipmentStatusType::Finished => write!(f, "FINISHED"),
            ShipmentStatusType::Accepted => write!(f, "ACCEPTED"),
            ShipmentStatusType::AcceptedWithDiscrepancies => write!(f, "ACCEPTED_WITH_DISCREPANCIES"),
            ShipmentStatusType::Error => write!(f, "ERROR"),
        }
    }
}

impl std::str::FromStr for ShipmentStatusType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "OUTBOUND_CREATED" => std::result::Result::Ok(ShipmentStatusType::OutboundCreated),
            "OUTBOUND_READY_FOR_CONFIRMATION" => std::result::Result::Ok(ShipmentStatusType::OutboundReadyForConfirmation),
            "OUTBOUND_CONFIRMED" => std::result::Result::Ok(ShipmentStatusType::OutboundConfirmed),
            "OUTBOUND_SIGNED" => std::result::Result::Ok(ShipmentStatusType::OutboundSigned),
            "FINISHED" => std::result::Result::Ok(ShipmentStatusType::Finished),
            "ACCEPTED" => std::result::Result::Ok(ShipmentStatusType::Accepted),
            "ACCEPTED_WITH_DISCREPANCIES" => std::result::Result::Ok(ShipmentStatusType::AcceptedWithDiscrepancies),
            "ERROR" => std::result::Result::Ok(ShipmentStatusType::Error),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Способ отгрузки заказов:  * `IMPORT` — вы самостоятельно привозите заказы в выбранный сортировочный центр или пункт приема заказов. * `WITHDRAW` — вы отгружаете заказы со своего склада курьерам Яндекс Маркета. 
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum ShipmentType {
    #[serde(rename = "IMPORT")]
    Import,
    #[serde(rename = "WITHDRAW")]
    Withdraw,
}

impl std::fmt::Display for ShipmentType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            ShipmentType::Import => write!(f, "IMPORT"),
            ShipmentType::Withdraw => write!(f, "WITHDRAW"),
        }
    }
}

impl std::str::FromStr for ShipmentType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "IMPORT" => std::result::Result::Ok(ShipmentType::Import),
            "WITHDRAW" => std::result::Result::Ok(ShipmentType::Withdraw),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Ваш SKU — идентификатор товара в вашей системе.  Разрешена любая последовательность длиной до 255 знаков.  Правила использования SKU:  * У каждого товара SKU должен быть свой.  * SKU товара нельзя менять — можно только удалить товар и добавить заново с новым SKU.  * Уже заданный SKU нельзя освободить и использовать заново для другого товара. Каждый товар должен получать новый идентификатор, до того никогда не использовавшийся в вашем каталоге.  [Что такое SKU и как его назначать](https://yandex.ru/support/marketplace/assortment/add/index.html#fields) 
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ShopSku(String);

impl std::convert::From<String> for ShopSku {
    fn from(x: String) -> Self {
        ShopSku(x)
    }
}

impl std::string::ToString for ShopSku {
    fn to_string(&self) -> String {
       self.0.to_string()
    }
}

impl std::str::FromStr for ShopSku {
    type Err = std::string::ParseError;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(ShopSku(x.to_string()))
    }
}

impl std::convert::From<ShopSku> for String {
    fn from(x: ShopSku) -> Self {
        x.0
    }
}

impl std::ops::Deref for ShopSku {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for ShopSku {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}


/// Группировка данных отчета. Возможные значения: * `CATEGORIES` — группировка по категориям. * `OFFERS` — группировка по товарам. 
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum ShowsSalesGroupingType {
    #[serde(rename = "CATEGORIES")]
    Categories,
    #[serde(rename = "OFFERS")]
    Offers,
}

impl std::fmt::Display for ShowsSalesGroupingType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            ShowsSalesGroupingType::Categories => write!(f, "CATEGORIES"),
            ShowsSalesGroupingType::Offers => write!(f, "OFFERS"),
        }
    }
}

impl std::str::FromStr for ShowsSalesGroupingType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "CATEGORIES" => std::result::Result::Ok(ShowsSalesGroupingType::Categories),
            "OFFERS" => std::result::Result::Ok(ShowsSalesGroupingType::Offers),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Идентификаторы отзывов.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct SkipGoodsFeedbackReactionRequest {
    /// Список идентификаторов отзывов, на которые магазин не будет отвечать.
    #[serde(rename = "feedbackIds")]
    #[validate(
            length(min = 1, max = 50),
        )]
    pub feedback_ids: Vec<models::GoodsFeedbackId>,

}


impl SkipGoodsFeedbackReactionRequest {
    #[allow(clippy::new_without_default)]
    pub fn new(feedback_ids: Vec<models::GoodsFeedbackId>, ) -> SkipGoodsFeedbackReactionRequest {
        SkipGoodsFeedbackReactionRequest {
            feedback_ids,
        }
    }
}

/// Converts the SkipGoodsFeedbackReactionRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for SkipGoodsFeedbackReactionRequest {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            Some("feedbackIds".to_string()),
            Some(self.feedback_ids.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a SkipGoodsFeedbackReactionRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for SkipGoodsFeedbackReactionRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub feedback_ids: Vec<Vec<models::GoodsFeedbackId>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing SkipGoodsFeedbackReactionRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "feedbackIds" => return std::result::Result::Err("Parsing a container in this style is not supported in SkipGoodsFeedbackReactionRequest".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing SkipGoodsFeedbackReactionRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(SkipGoodsFeedbackReactionRequest {
            feedback_ids: intermediate_rep.feedback_ids.into_iter().next().ok_or_else(|| "feedbackIds missing in SkipGoodsFeedbackReactionRequest".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<SkipGoodsFeedbackReactionRequest> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<SkipGoodsFeedbackReactionRequest>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<SkipGoodsFeedbackReactionRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for SkipGoodsFeedbackReactionRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<SkipGoodsFeedbackReactionRequest> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <SkipGoodsFeedbackReactionRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into SkipGoodsFeedbackReactionRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Список товаров и ставок на них.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct SkuBidItemDto {
    /// Ваш SKU — идентификатор товара в вашей системе.  Разрешена любая последовательность длиной до 255 знаков.  Правила использования SKU:  * У каждого товара SKU должен быть свой.  * SKU товара нельзя менять — можно только удалить товар и добавить заново с новым SKU.  * Уже заданный SKU нельзя освободить и использовать заново для другого товара. Каждый товар должен получать новый идентификатор, до того никогда не использовавшийся в вашем каталоге.  [Что такое SKU и как его назначать](https://yandex.ru/support/marketplace/assortment/add/index.html#fields) 
    #[serde(rename = "sku")]
    #[validate(
            length(min = 1, max = 255),
           regex = "RE_SKUBIDITEMDTO_SKU",
        )]
    pub sku: String,

    /// Значение ставки.
    #[serde(rename = "bid")]
    #[validate(
            range(min = 0, max = 9999),
        )]
    pub bid: u32,

}

lazy_static::lazy_static! {
    static ref RE_SKUBIDITEMDTO_SKU: regex::Regex = regex::Regex::new(r"^[^\\x00-\\x08\\x0A-\\x1f\\x7f]{1,255}$").unwrap();
}

impl SkuBidItemDto {
    #[allow(clippy::new_without_default)]
    pub fn new(sku: String, bid: u32, ) -> SkuBidItemDto {
        SkuBidItemDto {
            sku,
            bid,
        }
    }
}

/// Converts the SkuBidItemDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for SkuBidItemDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            Some("sku".to_string()),
            Some(self.sku.to_string()),


            Some("bid".to_string()),
            Some(self.bid.to_string()),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a SkuBidItemDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for SkuBidItemDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub sku: Vec<String>,
            pub bid: Vec<u32>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing SkuBidItemDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "sku" => intermediate_rep.sku.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "bid" => intermediate_rep.bid.push(<u32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing SkuBidItemDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(SkuBidItemDto {
            sku: intermediate_rep.sku.into_iter().next().ok_or_else(|| "sku missing in SkuBidItemDto".to_string())?,
            bid: intermediate_rep.bid.into_iter().next().ok_or_else(|| "bid missing in SkuBidItemDto".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<SkuBidItemDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<SkuBidItemDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<SkuBidItemDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for SkuBidItemDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<SkuBidItemDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <SkuBidItemDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into SkuBidItemDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Список товаров с рекомендованными ставками.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct SkuBidRecommendationItemDto {
    /// Ваш SKU — идентификатор товара в вашей системе.  Разрешена любая последовательность длиной до 255 знаков.  Правила использования SKU:  * У каждого товара SKU должен быть свой.  * SKU товара нельзя менять — можно только удалить товар и добавить заново с новым SKU.  * Уже заданный SKU нельзя освободить и использовать заново для другого товара. Каждый товар должен получать новый идентификатор, до того никогда не использовавшийся в вашем каталоге.  [Что такое SKU и как его назначать](https://yandex.ru/support/marketplace/assortment/add/index.html#fields) 
    #[serde(rename = "sku")]
    #[validate(
            length(min = 1, max = 255),
           regex = "RE_SKUBIDRECOMMENDATIONITEMDTO_SKU",
        )]
    pub sku: String,

    /// Значение ставки.
    #[serde(rename = "bid")]
    #[validate(
            range(min = 0, max = 9999),
        )]
    pub bid: u32,

    /// Список рекомендованных ставок с соответствующими долями показов. Чем больше ставка, тем большую долю показов она помогает получить. 
    #[serde(rename = "bidRecommendations")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub bid_recommendations: Option<swagger::Nullable<Vec<models::BidRecommendationItemDto>>>,

    /// Рекомендованные цены.
    #[serde(rename = "priceRecommendations")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub price_recommendations: Option<swagger::Nullable<Vec<models::PriceRecommendationItemDto>>>,

}

lazy_static::lazy_static! {
    static ref RE_SKUBIDRECOMMENDATIONITEMDTO_SKU: regex::Regex = regex::Regex::new(r"^[^\\x00-\\x08\\x0A-\\x1f\\x7f]{1,255}$").unwrap();
}

impl SkuBidRecommendationItemDto {
    #[allow(clippy::new_without_default)]
    pub fn new(sku: String, bid: u32, ) -> SkuBidRecommendationItemDto {
        SkuBidRecommendationItemDto {
            sku,
            bid,
            bid_recommendations: None,
            price_recommendations: None,
        }
    }
}

/// Converts the SkuBidRecommendationItemDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for SkuBidRecommendationItemDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            Some("sku".to_string()),
            Some(self.sku.to_string()),


            Some("bid".to_string()),
            Some(self.bid.to_string()),

            // Skipping bidRecommendations in query parameter serialization

            // Skipping priceRecommendations in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a SkuBidRecommendationItemDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for SkuBidRecommendationItemDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub sku: Vec<String>,
            pub bid: Vec<u32>,
            pub bid_recommendations: Vec<Vec<models::BidRecommendationItemDto>>,
            pub price_recommendations: Vec<Vec<models::PriceRecommendationItemDto>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing SkuBidRecommendationItemDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "sku" => intermediate_rep.sku.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "bid" => intermediate_rep.bid.push(<u32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "bidRecommendations" => return std::result::Result::Err("Parsing a container in this style is not supported in SkuBidRecommendationItemDto".to_string()),
                    "priceRecommendations" => return std::result::Result::Err("Parsing a container in this style is not supported in SkuBidRecommendationItemDto".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing SkuBidRecommendationItemDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(SkuBidRecommendationItemDto {
            sku: intermediate_rep.sku.into_iter().next().ok_or_else(|| "sku missing in SkuBidRecommendationItemDto".to_string())?,
            bid: intermediate_rep.bid.into_iter().next().ok_or_else(|| "bid missing in SkuBidRecommendationItemDto".to_string())?,
            bid_recommendations: std::result::Result::Err("Nullable types not supported in SkuBidRecommendationItemDto".to_string())?,
            price_recommendations: std::result::Result::Err("Nullable types not supported in SkuBidRecommendationItemDto".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<SkuBidRecommendationItemDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<SkuBidRecommendationItemDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<SkuBidRecommendationItemDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for SkuBidRecommendationItemDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<SkuBidRecommendationItemDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <SkuBidRecommendationItemDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into SkuBidRecommendationItemDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Направление сортировки.  Возможные значения: - `ASC` — сортировка по возрастанию. - `DESC` — сортировка по убыванию. 
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum SortOrderType {
    #[serde(rename = "ASC")]
    Asc,
    #[serde(rename = "DESC")]
    Desc,
}

impl std::fmt::Display for SortOrderType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            SortOrderType::Asc => write!(f, "ASC"),
            SortOrderType::Desc => write!(f, "DESC"),
        }
    }
}

impl std::str::FromStr for SortOrderType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "ASC" => std::result::Result::Ok(SortOrderType::Asc),
            "DESC" => std::result::Result::Ok(SortOrderType::Desc),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Товар, для которого требуется получить цены для продвижения.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct SuggestOfferPriceDto {
    /// Ваш SKU — идентификатор товара в вашей системе.  Разрешена любая последовательность длиной до 255 знаков.  Правила использования SKU:  * У каждого товара SKU должен быть свой.  * SKU товара нельзя менять — можно только удалить товар и добавить заново с новым SKU.  * Уже заданный SKU нельзя освободить и использовать заново для другого товара. Каждый товар должен получать новый идентификатор, до того никогда не использовавшийся в вашем каталоге.  [Что такое SKU и как его назначать](https://yandex.ru/support/marketplace/assortment/add/index.html#fields) 
    #[serde(rename = "offerId")]
    #[validate(
            length(min = 1, max = 255),
           regex = "RE_SUGGESTOFFERPRICEDTO_OFFER_ID",
        )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub offer_id: Option<String>,

    /// SKU на Маркете.
    #[serde(rename = "marketSku")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub market_sku: Option<i64>,

}

lazy_static::lazy_static! {
    static ref RE_SUGGESTOFFERPRICEDTO_OFFER_ID: regex::Regex = regex::Regex::new(r"^[^\\x00-\\x08\\x0A-\\x1f\\x7f]{1,255}$").unwrap();
}

impl SuggestOfferPriceDto {
    #[allow(clippy::new_without_default)]
    pub fn new() -> SuggestOfferPriceDto {
        SuggestOfferPriceDto {
            offer_id: None,
            market_sku: None,
        }
    }
}

/// Converts the SuggestOfferPriceDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for SuggestOfferPriceDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.offer_id.as_ref().map(|offer_id| {
                [
                    "offerId".to_string(),
                    offer_id.to_string(),
                ].join(",")
            }),


            self.market_sku.as_ref().map(|market_sku| {
                [
                    "marketSku".to_string(),
                    market_sku.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a SuggestOfferPriceDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for SuggestOfferPriceDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub offer_id: Vec<String>,
            pub market_sku: Vec<i64>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing SuggestOfferPriceDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "offerId" => intermediate_rep.offer_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "marketSku" => intermediate_rep.market_sku.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing SuggestOfferPriceDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(SuggestOfferPriceDto {
            offer_id: intermediate_rep.offer_id.into_iter().next(),
            market_sku: intermediate_rep.market_sku.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<SuggestOfferPriceDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<SuggestOfferPriceDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<SuggestOfferPriceDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for SuggestOfferPriceDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<SuggestOfferPriceDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <SuggestOfferPriceDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into SuggestOfferPriceDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Запрос на получение списка цен для продвижения.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct SuggestPricesRequest {
    /// Список товаров.
    #[serde(rename = "offers")]
    #[validate(
            length(max = 1000),
        )]
    pub offers: Vec<models::SuggestOfferPriceDto>,

}


impl SuggestPricesRequest {
    #[allow(clippy::new_without_default)]
    pub fn new(offers: Vec<models::SuggestOfferPriceDto>, ) -> SuggestPricesRequest {
        SuggestPricesRequest {
            offers,
        }
    }
}

/// Converts the SuggestPricesRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for SuggestPricesRequest {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping offers in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a SuggestPricesRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for SuggestPricesRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub offers: Vec<Vec<models::SuggestOfferPriceDto>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing SuggestPricesRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "offers" => return std::result::Result::Err("Parsing a container in this style is not supported in SuggestPricesRequest".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing SuggestPricesRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(SuggestPricesRequest {
            offers: intermediate_rep.offers.into_iter().next().ok_or_else(|| "offers missing in SuggestPricesRequest".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<SuggestPricesRequest> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<SuggestPricesRequest>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<SuggestPricesRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for SuggestPricesRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<SuggestPricesRequest> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <SuggestPricesRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into SuggestPricesRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Ответ на запрос списка цен для продвижения.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct SuggestPricesResponse {
    #[serde(rename = "status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<models::ApiResponseStatusType>,

    #[serde(rename = "result")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub result: Option<models::SuggestPricesResultDto>,

}


impl SuggestPricesResponse {
    #[allow(clippy::new_without_default)]
    pub fn new() -> SuggestPricesResponse {
        SuggestPricesResponse {
            status: None,
            result: None,
        }
    }
}

/// Converts the SuggestPricesResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for SuggestPricesResponse {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping status in query parameter serialization

            // Skipping result in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a SuggestPricesResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for SuggestPricesResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub status: Vec<models::ApiResponseStatusType>,
            pub result: Vec<models::SuggestPricesResultDto>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing SuggestPricesResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(<models::ApiResponseStatusType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "result" => intermediate_rep.result.push(<models::SuggestPricesResultDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing SuggestPricesResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(SuggestPricesResponse {
            status: intermediate_rep.status.into_iter().next(),
            result: intermediate_rep.result.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<SuggestPricesResponse> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<SuggestPricesResponse>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<SuggestPricesResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for SuggestPricesResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<SuggestPricesResponse> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <SuggestPricesResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into SuggestPricesResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Результат запроса цен для продвижения.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct SuggestPricesResultDto {
    /// Список товаров с ценами для продвижения.
    #[serde(rename = "offers")]
    pub offers: Vec<models::PriceSuggestOfferDto>,

}


impl SuggestPricesResultDto {
    #[allow(clippy::new_without_default)]
    pub fn new(offers: Vec<models::PriceSuggestOfferDto>, ) -> SuggestPricesResultDto {
        SuggestPricesResultDto {
            offers,
        }
    }
}

/// Converts the SuggestPricesResultDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for SuggestPricesResultDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping offers in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a SuggestPricesResultDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for SuggestPricesResultDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub offers: Vec<Vec<models::PriceSuggestOfferDto>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing SuggestPricesResultDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "offers" => return std::result::Result::Err("Parsing a container in this style is not supported in SuggestPricesResultDto".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing SuggestPricesResultDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(SuggestPricesResultDto {
            offers: intermediate_rep.offers.into_iter().next().ok_or_else(|| "offers missing in SuggestPricesResultDto".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<SuggestPricesResultDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<SuggestPricesResultDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<SuggestPricesResultDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for SuggestPricesResultDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<SuggestPricesResultDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <SuggestPricesResultDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into SuggestPricesResultDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Информация о товаре.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct SuggestedOfferDto {
    /// Ваш SKU — идентификатор товара в вашей системе.  Разрешена любая последовательность длиной до 255 знаков.  Правила использования SKU:  * У каждого товара SKU должен быть свой.  * SKU товара нельзя менять — можно только удалить товар и добавить заново с новым SKU.  * Уже заданный SKU нельзя освободить и использовать заново для другого товара. Каждый товар должен получать новый идентификатор, до того никогда не использовавшийся в вашем каталоге.  [Что такое SKU и как его назначать](https://yandex.ru/support/marketplace/assortment/add/index.html#fields) 
    #[serde(rename = "offerId")]
    #[validate(
            length(min = 1, max = 255),
           regex = "RE_SUGGESTEDOFFERDTO_OFFER_ID",
        )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub offer_id: Option<String>,

    /// Составляйте название по схеме: тип + бренд или производитель + модель + особенности, если есть (например, цвет, размер или вес) и количество в упаковке.  Не включайте в название условия продажи (например, «скидка», «бесплатная доставка» и т. д.), эмоциональные характеристики («хит», «супер» и т. д.). Не пишите слова большими буквами — кроме устоявшихся названий брендов и моделей.  Оптимальная длина — 50–60 символов, максимальная — 256.  [Рекомендации и правила](https://yandex.ru/support/marketplace/assortment/fields/title.html) 
    #[serde(rename = "name")]
    #[validate(
            length(max = 256),
        )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

    /// Категория товара в вашем магазине. Значение будет использовано для определения категории товара на Маркете в случае, если вы не передали категорию в параметре `marketCategoryId`.  Указывайте конкретные категории — например, набор ножей лучше отнести к категории **Столовые приборы**, а не просто **Посуда**.  Выбирайте категории, которые описывают товар, а не абстрактный признак — например, **Духи**, а не **Подарки**.  Значение будет использовано для определения категории товара на Маркете в случае, если вы не передали категорию в параметре `marketCategoryId`. 
    #[serde(rename = "category")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub category: Option<String>,

    /// Название бренда или производителя. Должно быть записано так, как его пишет сам бренд.
    #[serde(rename = "vendor")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub vendor: Option<String>,

    /// Указывайте в виде последовательности цифр. Подойдут коды EAN-13, EAN-8, UPC-A, UPC-E или Code 128.  Для книг указывайте ISBN.  Для товаров [определенных категорий и торговых марок](https://yastatic.net/s3/doc-binary/src/support/market/ru/yandex-market-list-for-gtin.xlsx) штрихкод должен быть действительным кодом GTIN. Обратите внимание: внутренние штрихкоды, начинающиеся на 2 или 02, и коды формата Code 128 не являются GTIN.  [Что такое GTIN](*gtin)  
    #[serde(rename = "barcodes")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub barcodes: Option<swagger::Nullable<Vec<String>>>,

    /// Подробное описание товара: например, его преимущества и особенности.  Не давайте в описании инструкций по установке и сборке. Не используйте слова «скидка», «распродажа», «дешевый», «подарок» (кроме подарочных категорий), «бесплатно», «акция», «специальная цена», «новинка», «new», «аналог», «заказ», «хит». Не указывайте никакой контактной информации и не давайте ссылок.  Можно использовать теги:  * \\<h>, \\<h1>, \\<h2> и так далее — для заголовков; * \\<br> и \\<p> — для переноса строки; * \\<ol> — для нумерованного списка; * \\<ul> — для маркированного списка; * \\<li> — для создания элементов списка (должен находиться внутри \\<ol> или \\<ul>); * \\<div> — поддерживается, но не влияет на отображение текста.  Оптимальная длина — 400–600 символов, максимальная — 6000.  [Рекомендации и правила](https://yandex.ru/support/marketplace/assortment/fields/description.html) 
    #[serde(rename = "description")]
    #[validate(
            length(max = 6000),
        )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,

    /// Артикул товара от производителя.
    #[serde(rename = "vendorCode")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub vendor_code: Option<String>,

    #[serde(rename = "basicPrice")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub basic_price: Option<models::BasePriceDto>,

}

lazy_static::lazy_static! {
    static ref RE_SUGGESTEDOFFERDTO_OFFER_ID: regex::Regex = regex::Regex::new(r"^[^\\x00-\\x08\\x0A-\\x1f\\x7f]{1,255}$").unwrap();
}

impl SuggestedOfferDto {
    #[allow(clippy::new_without_default)]
    pub fn new() -> SuggestedOfferDto {
        SuggestedOfferDto {
            offer_id: None,
            name: None,
            category: None,
            vendor: None,
            barcodes: None,
            description: None,
            vendor_code: None,
            basic_price: None,
        }
    }
}

/// Converts the SuggestedOfferDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for SuggestedOfferDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.offer_id.as_ref().map(|offer_id| {
                [
                    "offerId".to_string(),
                    offer_id.to_string(),
                ].join(",")
            }),


            self.name.as_ref().map(|name| {
                [
                    "name".to_string(),
                    name.to_string(),
                ].join(",")
            }),


            self.category.as_ref().map(|category| {
                [
                    "category".to_string(),
                    category.to_string(),
                ].join(",")
            }),


            self.vendor.as_ref().map(|vendor| {
                [
                    "vendor".to_string(),
                    vendor.to_string(),
                ].join(",")
            }),


            self.barcodes.as_ref().map(|barcodes| {
                [
                    "barcodes".to_string(),
                    barcodes.as_ref().map_or("null".to_string(), |x| x.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),
                ].join(",")
            }),


            self.description.as_ref().map(|description| {
                [
                    "description".to_string(),
                    description.to_string(),
                ].join(",")
            }),


            self.vendor_code.as_ref().map(|vendor_code| {
                [
                    "vendorCode".to_string(),
                    vendor_code.to_string(),
                ].join(",")
            }),

            // Skipping basicPrice in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a SuggestedOfferDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for SuggestedOfferDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub offer_id: Vec<String>,
            pub name: Vec<String>,
            pub category: Vec<String>,
            pub vendor: Vec<String>,
            pub barcodes: Vec<Vec<String>>,
            pub description: Vec<String>,
            pub vendor_code: Vec<String>,
            pub basic_price: Vec<models::BasePriceDto>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing SuggestedOfferDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "offerId" => intermediate_rep.offer_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "category" => intermediate_rep.category.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "vendor" => intermediate_rep.vendor.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "barcodes" => return std::result::Result::Err("Parsing a container in this style is not supported in SuggestedOfferDto".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "description" => intermediate_rep.description.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "vendorCode" => intermediate_rep.vendor_code.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "basicPrice" => intermediate_rep.basic_price.push(<models::BasePriceDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing SuggestedOfferDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(SuggestedOfferDto {
            offer_id: intermediate_rep.offer_id.into_iter().next(),
            name: intermediate_rep.name.into_iter().next(),
            category: intermediate_rep.category.into_iter().next(),
            vendor: intermediate_rep.vendor.into_iter().next(),
            barcodes: std::result::Result::Err("Nullable types not supported in SuggestedOfferDto".to_string())?,
            description: intermediate_rep.description.into_iter().next(),
            vendor_code: intermediate_rep.vendor_code.into_iter().next(),
            basic_price: intermediate_rep.basic_price.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<SuggestedOfferDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<SuggestedOfferDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<SuggestedOfferDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for SuggestedOfferDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<SuggestedOfferDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <SuggestedOfferDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into SuggestedOfferDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Товар с соответствующей карточкой на Маркете.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct SuggestedOfferMappingDto {
    #[serde(rename = "offer")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub offer: Option<models::SuggestedOfferDto>,

    #[serde(rename = "mapping")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub mapping: Option<models::GetMappingDto>,

}


impl SuggestedOfferMappingDto {
    #[allow(clippy::new_without_default)]
    pub fn new() -> SuggestedOfferMappingDto {
        SuggestedOfferMappingDto {
            offer: None,
            mapping: None,
        }
    }
}

/// Converts the SuggestedOfferMappingDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for SuggestedOfferMappingDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping offer in query parameter serialization

            // Skipping mapping in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a SuggestedOfferMappingDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for SuggestedOfferMappingDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub offer: Vec<models::SuggestedOfferDto>,
            pub mapping: Vec<models::GetMappingDto>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing SuggestedOfferMappingDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "offer" => intermediate_rep.offer.push(<models::SuggestedOfferDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "mapping" => intermediate_rep.mapping.push(<models::GetMappingDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing SuggestedOfferMappingDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(SuggestedOfferMappingDto {
            offer: intermediate_rep.offer.into_iter().next(),
            mapping: intermediate_rep.mapping.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<SuggestedOfferMappingDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<SuggestedOfferMappingDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<SuggestedOfferMappingDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for SuggestedOfferMappingDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<SuggestedOfferMappingDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <SuggestedOfferMappingDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into SuggestedOfferMappingDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Информация о тарифах, по которым нужно заплатить за услуги Маркета.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct TariffDto {
    #[serde(rename = "type")]
    pub r#type: models::TariffType,

    /// {% note warning \"\" %}  Этот параметр устарел. Не используйте его.  {% endnote %}  Значение тарифа в процентах. 
    #[serde(rename = "percent")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub percent: Option<f64>,

    /// Значение тарифа в рублях.
    #[serde(rename = "amount")]
    pub amount: f64,

    /// Параметры расчета тарифа.
    #[serde(rename = "parameters")]
    pub parameters: Vec<models::TariffParameterDto>,

}


impl TariffDto {
    #[allow(clippy::new_without_default)]
    pub fn new(r#type: models::TariffType, amount: f64, parameters: Vec<models::TariffParameterDto>, ) -> TariffDto {
        TariffDto {
            r#type,
            percent: None,
            amount,
            parameters,
        }
    }
}

/// Converts the TariffDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for TariffDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping type in query parameter serialization


            self.percent.as_ref().map(|percent| {
                [
                    "percent".to_string(),
                    percent.to_string(),
                ].join(",")
            }),


            Some("amount".to_string()),
            Some(self.amount.to_string()),

            // Skipping parameters in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a TariffDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for TariffDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub r#type: Vec<models::TariffType>,
            pub percent: Vec<f64>,
            pub amount: Vec<f64>,
            pub parameters: Vec<Vec<models::TariffParameterDto>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing TariffDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r#type.push(<models::TariffType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "percent" => intermediate_rep.percent.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "amount" => intermediate_rep.amount.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "parameters" => return std::result::Result::Err("Parsing a container in this style is not supported in TariffDto".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing TariffDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(TariffDto {
            r#type: intermediate_rep.r#type.into_iter().next().ok_or_else(|| "type missing in TariffDto".to_string())?,
            percent: intermediate_rep.percent.into_iter().next(),
            amount: intermediate_rep.amount.into_iter().next().ok_or_else(|| "amount missing in TariffDto".to_string())?,
            parameters: intermediate_rep.parameters.into_iter().next().ok_or_else(|| "parameters missing in TariffDto".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<TariffDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<TariffDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<TariffDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for TariffDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<TariffDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <TariffDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into TariffDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Детали расчета конкретной услуги Маркета.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct TariffParameterDto {
    /// Название параметра.
    #[serde(rename = "name")]
    pub name: String,

    /// Значение параметра.
    #[serde(rename = "value")]
    pub value: String,

}


impl TariffParameterDto {
    #[allow(clippy::new_without_default)]
    pub fn new(name: String, value: String, ) -> TariffParameterDto {
        TariffParameterDto {
            name,
            value,
        }
    }
}

/// Converts the TariffParameterDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for TariffParameterDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            Some("name".to_string()),
            Some(self.name.to_string()),


            Some("value".to_string()),
            Some(self.value.to_string()),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a TariffParameterDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for TariffParameterDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub name: Vec<String>,
            pub value: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing TariffParameterDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "value" => intermediate_rep.value.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing TariffParameterDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(TariffParameterDto {
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "name missing in TariffParameterDto".to_string())?,
            value: intermediate_rep.value.into_iter().next().ok_or_else(|| "value missing in TariffParameterDto".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<TariffParameterDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<TariffParameterDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<TariffParameterDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for TariffParameterDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<TariffParameterDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <TariffParameterDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into TariffParameterDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Услуга Маркета или дополнительный тариф к услуге размещения:  * `AGENCY_COMMISSION` — прием платежа покупателя.  * `PAYMENT_TRANSFER` — перевод платежа покупателя.  * `STORAGE` — хранение товара на складе Маркета в течение суток.  * `SURPLUS` — хранение излишков на складе Маркета.  * `WITHDRAW` — вывоз товара со склада Маркета.  * `FEE` — размещение товара на Маркете.  * `DELIVERY_TO_CUSTOMER` — доставка покупателю.  * `CROSSREGIONAL_DELIVERY` — доставка в федеральный округ, город или населенный пункт.  * `CROSSREGIONAL_DELIVERY_RETURN` — доставка невыкупов и возвратов.  * `DISPOSAL` — утилизация.  * `SORTING_CENTER_STORAGE` — хранение невыкупов и возвратов.  * `EXPRESS_DELIVERY` — экспресс-доставка покупателю.  * `FF_XDOC_SUPPLY_BOX` — поставка товара через транзитный склад (за короб).  * `FF_XDOC_SUPPLY_PALLET` — поставка товара через транзитный склад (за палету).  * `SORTING` — обработка заказа.  * `MIDDLE_MILE` — средняя миля.  * `RETURN_PROCESSING` — обработка невыкупов и возвратов.  * `EXPRESS_CANCELLED_BY_PARTNER` — отмена заказа с экспресс-доставкой.  * `DELIVERY_TO_CUSTOMER_RETURN` — возврат доставляемого товара на склад.  * `CROSSBORDER_DELIVERY` — доставка из-за рубежа.  * `INTAKE_SORTING_BULKY_CARGO` — сортировка заказов с крупногабаритными товарами, которые Маркет забрал со склада продавца.  * `INTAKE_SORTING_SMALL_GOODS` — сортировка заказов с малогабаритными товарами, которые Маркет забрал со склада продавца.  * `INTAKE_SORTING_DAILY` — организация забора заказов со склада продавца.  * `FF_STORAGE_BILLING` — хранения товаров на складе.  * `CANCELLED_ORDER_FEE_QI` — отмена заказа по вине продавца.  * `LATE_ORDER_EXECUTION_FEE_QI` — несвоевременная отгрузка или доставка.  Подробнее об услугах Маркета читайте [в Справке Маркета для продавцов](https://yandex.ru/support/marketplace/introduction/rates/index.html). 
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum TariffType {
    #[serde(rename = "AGENCY_COMMISSION")]
    AgencyCommission,
    #[serde(rename = "PAYMENT_TRANSFER")]
    PaymentTransfer,
    #[serde(rename = "STORAGE")]
    Storage,
    #[serde(rename = "WITHDRAW")]
    Withdraw,
    #[serde(rename = "SURPLUS")]
    Surplus,
    #[serde(rename = "FEE")]
    Fee,
    #[serde(rename = "DELIVERY_TO_CUSTOMER")]
    DeliveryToCustomer,
    #[serde(rename = "CROSSREGIONAL_DELIVERY")]
    CrossregionalDelivery,
    #[serde(rename = "CROSSREGIONAL_DELIVERY_RETURN")]
    CrossregionalDeliveryReturn,
    #[serde(rename = "DISPOSAL")]
    Disposal,
    #[serde(rename = "SORTING_CENTER_STORAGE")]
    SortingCenterStorage,
    #[serde(rename = "EXPRESS_DELIVERY")]
    ExpressDelivery,
    #[serde(rename = "FF_XDOC_SUPPLY_BOX")]
    FfXdocSupplyBox,
    #[serde(rename = "FF_XDOC_SUPPLY_PALLET")]
    FfXdocSupplyPallet,
    #[serde(rename = "SORTING")]
    Sorting,
    #[serde(rename = "MIDDLE_MILE")]
    MiddleMile,
    #[serde(rename = "RETURN_PROCESSING")]
    ReturnProcessing,
    #[serde(rename = "EXPRESS_CANCELLED_BY_PARTNER")]
    ExpressCancelledByPartner,
    #[serde(rename = "DELIVERY_TO_CUSTOMER_RETURN")]
    DeliveryToCustomerReturn,
    #[serde(rename = "CROSSBORDER_DELIVERY")]
    CrossborderDelivery,
    #[serde(rename = "INTAKE_SORTING_BULKY_CARGO")]
    IntakeSortingBulkyCargo,
    #[serde(rename = "INTAKE_SORTING_SMALL_GOODS")]
    IntakeSortingSmallGoods,
    #[serde(rename = "INTAKE_SORTING_DAILY")]
    IntakeSortingDaily,
    #[serde(rename = "FF_STORAGE_BILLING")]
    FfStorageBilling,
    #[serde(rename = "CANCELLED_ORDER_FEE_QI")]
    CancelledOrderFeeQi,
    #[serde(rename = "LATE_ORDER_EXECUTION_FEE_QI")]
    LateOrderExecutionFeeQi,
}

impl std::fmt::Display for TariffType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            TariffType::AgencyCommission => write!(f, "AGENCY_COMMISSION"),
            TariffType::PaymentTransfer => write!(f, "PAYMENT_TRANSFER"),
            TariffType::Storage => write!(f, "STORAGE"),
            TariffType::Withdraw => write!(f, "WITHDRAW"),
            TariffType::Surplus => write!(f, "SURPLUS"),
            TariffType::Fee => write!(f, "FEE"),
            TariffType::DeliveryToCustomer => write!(f, "DELIVERY_TO_CUSTOMER"),
            TariffType::CrossregionalDelivery => write!(f, "CROSSREGIONAL_DELIVERY"),
            TariffType::CrossregionalDeliveryReturn => write!(f, "CROSSREGIONAL_DELIVERY_RETURN"),
            TariffType::Disposal => write!(f, "DISPOSAL"),
            TariffType::SortingCenterStorage => write!(f, "SORTING_CENTER_STORAGE"),
            TariffType::ExpressDelivery => write!(f, "EXPRESS_DELIVERY"),
            TariffType::FfXdocSupplyBox => write!(f, "FF_XDOC_SUPPLY_BOX"),
            TariffType::FfXdocSupplyPallet => write!(f, "FF_XDOC_SUPPLY_PALLET"),
            TariffType::Sorting => write!(f, "SORTING"),
            TariffType::MiddleMile => write!(f, "MIDDLE_MILE"),
            TariffType::ReturnProcessing => write!(f, "RETURN_PROCESSING"),
            TariffType::ExpressCancelledByPartner => write!(f, "EXPRESS_CANCELLED_BY_PARTNER"),
            TariffType::DeliveryToCustomerReturn => write!(f, "DELIVERY_TO_CUSTOMER_RETURN"),
            TariffType::CrossborderDelivery => write!(f, "CROSSBORDER_DELIVERY"),
            TariffType::IntakeSortingBulkyCargo => write!(f, "INTAKE_SORTING_BULKY_CARGO"),
            TariffType::IntakeSortingSmallGoods => write!(f, "INTAKE_SORTING_SMALL_GOODS"),
            TariffType::IntakeSortingDaily => write!(f, "INTAKE_SORTING_DAILY"),
            TariffType::FfStorageBilling => write!(f, "FF_STORAGE_BILLING"),
            TariffType::CancelledOrderFeeQi => write!(f, "CANCELLED_ORDER_FEE_QI"),
            TariffType::LateOrderExecutionFeeQi => write!(f, "LATE_ORDER_EXECUTION_FEE_QI"),
        }
    }
}

impl std::str::FromStr for TariffType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "AGENCY_COMMISSION" => std::result::Result::Ok(TariffType::AgencyCommission),
            "PAYMENT_TRANSFER" => std::result::Result::Ok(TariffType::PaymentTransfer),
            "STORAGE" => std::result::Result::Ok(TariffType::Storage),
            "WITHDRAW" => std::result::Result::Ok(TariffType::Withdraw),
            "SURPLUS" => std::result::Result::Ok(TariffType::Surplus),
            "FEE" => std::result::Result::Ok(TariffType::Fee),
            "DELIVERY_TO_CUSTOMER" => std::result::Result::Ok(TariffType::DeliveryToCustomer),
            "CROSSREGIONAL_DELIVERY" => std::result::Result::Ok(TariffType::CrossregionalDelivery),
            "CROSSREGIONAL_DELIVERY_RETURN" => std::result::Result::Ok(TariffType::CrossregionalDeliveryReturn),
            "DISPOSAL" => std::result::Result::Ok(TariffType::Disposal),
            "SORTING_CENTER_STORAGE" => std::result::Result::Ok(TariffType::SortingCenterStorage),
            "EXPRESS_DELIVERY" => std::result::Result::Ok(TariffType::ExpressDelivery),
            "FF_XDOC_SUPPLY_BOX" => std::result::Result::Ok(TariffType::FfXdocSupplyBox),
            "FF_XDOC_SUPPLY_PALLET" => std::result::Result::Ok(TariffType::FfXdocSupplyPallet),
            "SORTING" => std::result::Result::Ok(TariffType::Sorting),
            "MIDDLE_MILE" => std::result::Result::Ok(TariffType::MiddleMile),
            "RETURN_PROCESSING" => std::result::Result::Ok(TariffType::ReturnProcessing),
            "EXPRESS_CANCELLED_BY_PARTNER" => std::result::Result::Ok(TariffType::ExpressCancelledByPartner),
            "DELIVERY_TO_CUSTOMER_RETURN" => std::result::Result::Ok(TariffType::DeliveryToCustomerReturn),
            "CROSSBORDER_DELIVERY" => std::result::Result::Ok(TariffType::CrossborderDelivery),
            "INTAKE_SORTING_BULKY_CARGO" => std::result::Result::Ok(TariffType::IntakeSortingBulkyCargo),
            "INTAKE_SORTING_SMALL_GOODS" => std::result::Result::Ok(TariffType::IntakeSortingSmallGoods),
            "INTAKE_SORTING_DAILY" => std::result::Result::Ok(TariffType::IntakeSortingDaily),
            "FF_STORAGE_BILLING" => std::result::Result::Ok(TariffType::FfStorageBilling),
            "CANCELLED_ORDER_FEE_QI" => std::result::Result::Ok(TariffType::CancelledOrderFeeQi),
            "LATE_ORDER_EXECUTION_FEE_QI" => std::result::Result::Ok(TariffType::LateOrderExecutionFeeQi),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Временной отрезок с комментарием. Требования к содержанию комментария зависят от контекста использования параметра и указаны в описании поля, которое его содержит.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct TimePeriodDto {
    /// Продолжительность в указанных единицах.
    #[serde(rename = "timePeriod")]
    pub time_period: i32,

    #[serde(rename = "timeUnit")]
    pub time_unit: models::TimeUnitType,

    /// Комментарий.
    #[serde(rename = "comment")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub comment: Option<String>,

}


impl TimePeriodDto {
    #[allow(clippy::new_without_default)]
    pub fn new(time_period: i32, time_unit: models::TimeUnitType, ) -> TimePeriodDto {
        TimePeriodDto {
            time_period,
            time_unit,
            comment: None,
        }
    }
}

/// Converts the TimePeriodDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for TimePeriodDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            Some("timePeriod".to_string()),
            Some(self.time_period.to_string()),

            // Skipping timeUnit in query parameter serialization


            self.comment.as_ref().map(|comment| {
                [
                    "comment".to_string(),
                    comment.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a TimePeriodDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for TimePeriodDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub time_period: Vec<i32>,
            pub time_unit: Vec<models::TimeUnitType>,
            pub comment: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing TimePeriodDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "timePeriod" => intermediate_rep.time_period.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "timeUnit" => intermediate_rep.time_unit.push(<models::TimeUnitType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "comment" => intermediate_rep.comment.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing TimePeriodDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(TimePeriodDto {
            time_period: intermediate_rep.time_period.into_iter().next().ok_or_else(|| "timePeriod missing in TimePeriodDto".to_string())?,
            time_unit: intermediate_rep.time_unit.into_iter().next().ok_or_else(|| "timeUnit missing in TimePeriodDto".to_string())?,
            comment: intermediate_rep.comment.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<TimePeriodDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<TimePeriodDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<TimePeriodDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for TimePeriodDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<TimePeriodDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <TimePeriodDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into TimePeriodDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Единица измерения времени:  * `HOUR` — час. * `DAY` — сутки. * `WEEK` — неделя. * `MONTH` — месяц. * `YEAR` — год. 
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum TimeUnitType {
    #[serde(rename = "HOUR")]
    Hour,
    #[serde(rename = "DAY")]
    Day,
    #[serde(rename = "WEEK")]
    Week,
    #[serde(rename = "MONTH")]
    Month,
    #[serde(rename = "YEAR")]
    Year,
}

impl std::fmt::Display for TimeUnitType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            TimeUnitType::Hour => write!(f, "HOUR"),
            TimeUnitType::Day => write!(f, "DAY"),
            TimeUnitType::Week => write!(f, "WEEK"),
            TimeUnitType::Month => write!(f, "MONTH"),
            TimeUnitType::Year => write!(f, "YEAR"),
        }
    }
}

impl std::str::FromStr for TimeUnitType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "HOUR" => std::result::Result::Ok(TimeUnitType::Hour),
            "DAY" => std::result::Result::Ok(TimeUnitType::Day),
            "WEEK" => std::result::Result::Ok(TimeUnitType::Week),
            "MONTH" => std::result::Result::Ok(TimeUnitType::Month),
            "YEAR" => std::result::Result::Ok(TimeUnitType::Year),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Информация о трек-номерах.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct TrackDto {
    /// Трек-код почтового отправления.
    #[serde(rename = "trackCode")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub track_code: Option<String>,

}


impl TrackDto {
    #[allow(clippy::new_without_default)]
    pub fn new() -> TrackDto {
        TrackDto {
            track_code: None,
        }
    }
}

/// Converts the TrackDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for TrackDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.track_code.as_ref().map(|track_code| {
                [
                    "trackCode".to_string(),
                    track_code.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a TrackDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for TrackDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub track_code: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing TrackDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "trackCode" => intermediate_rep.track_code.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing TrackDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(TrackDto {
            track_code: intermediate_rep.track_code.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<TrackDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<TrackDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<TrackDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for TrackDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<TrackDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <TrackDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into TrackDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Запрос переноса заказов из отгрузки.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct TransferOrdersFromShipmentRequest {
    /// Список заказов, которые вы не успеваете подготовить.
    #[serde(rename = "orderIds")]
    #[validate(
            length(min = 1, max = 500),
        )]
    pub order_ids: Vec<i64>,

}


impl TransferOrdersFromShipmentRequest {
    #[allow(clippy::new_without_default)]
    pub fn new(order_ids: Vec<i64>, ) -> TransferOrdersFromShipmentRequest {
        TransferOrdersFromShipmentRequest {
            order_ids,
        }
    }
}

/// Converts the TransferOrdersFromShipmentRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for TransferOrdersFromShipmentRequest {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            Some("orderIds".to_string()),
            Some(self.order_ids.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a TransferOrdersFromShipmentRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for TransferOrdersFromShipmentRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub order_ids: Vec<Vec<i64>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing TransferOrdersFromShipmentRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "orderIds" => return std::result::Result::Err("Parsing a container in this style is not supported in TransferOrdersFromShipmentRequest".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing TransferOrdersFromShipmentRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(TransferOrdersFromShipmentRequest {
            order_ids: intermediate_rep.order_ids.into_iter().next().ok_or_else(|| "orderIds missing in TransferOrdersFromShipmentRequest".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<TransferOrdersFromShipmentRequest> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<TransferOrdersFromShipmentRequest>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<TransferOrdersFromShipmentRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for TransferOrdersFromShipmentRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<TransferOrdersFromShipmentRequest> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <TransferOrdersFromShipmentRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into TransferOrdersFromShipmentRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Информация об оборачиваемости товара.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct TurnoverDto {
    #[serde(rename = "turnover")]
    pub turnover: models::TurnoverType,

    /// Значение в днях. [Что это за число?](https://yandex.ru/support/marketplace/analytics/turnover.html)
    #[serde(rename = "turnoverDays")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub turnover_days: Option<f64>,

}


impl TurnoverDto {
    #[allow(clippy::new_without_default)]
    pub fn new(turnover: models::TurnoverType, ) -> TurnoverDto {
        TurnoverDto {
            turnover,
            turnover_days: None,
        }
    }
}

/// Converts the TurnoverDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for TurnoverDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping turnover in query parameter serialization


            self.turnover_days.as_ref().map(|turnover_days| {
                [
                    "turnoverDays".to_string(),
                    turnover_days.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a TurnoverDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for TurnoverDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub turnover: Vec<models::TurnoverType>,
            pub turnover_days: Vec<f64>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing TurnoverDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "turnover" => intermediate_rep.turnover.push(<models::TurnoverType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "turnoverDays" => intermediate_rep.turnover_days.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing TurnoverDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(TurnoverDto {
            turnover: intermediate_rep.turnover.into_iter().next().ok_or_else(|| "turnover missing in TurnoverDto".to_string())?,
            turnover_days: intermediate_rep.turnover_days.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<TurnoverDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<TurnoverDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<TurnoverDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for TurnoverDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<TurnoverDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <TurnoverDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into TurnoverDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Оценка оборачиваемости.  |enum|Диапазон оборачиваемости|Комментарий| |-|-|-| |`LOW`|`turnoverDays` ≥ 120|| |`ALMOST_LOW`|100 ≤ `turnoverDays` < 120|| |`HIGH`|45 ≤ `turnoverDays` < 100|| |`VERY_HIGH`|0 ≤ `turnoverDays` < 45|| |`NO_SALES`|—|Продаж нет.| |`FREE_STORE`|Любое значение.|Товары этой категории сейчас хранятся бесплатно.| 
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum TurnoverType {
    #[serde(rename = "LOW")]
    Low,
    #[serde(rename = "ALMOST_LOW")]
    AlmostLow,
    #[serde(rename = "HIGH")]
    High,
    #[serde(rename = "VERY_HIGH")]
    VeryHigh,
    #[serde(rename = "NO_SALES")]
    NoSales,
    #[serde(rename = "FREE_STORE")]
    FreeStore,
}

impl std::fmt::Display for TurnoverType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            TurnoverType::Low => write!(f, "LOW"),
            TurnoverType::AlmostLow => write!(f, "ALMOST_LOW"),
            TurnoverType::High => write!(f, "HIGH"),
            TurnoverType::VeryHigh => write!(f, "VERY_HIGH"),
            TurnoverType::NoSales => write!(f, "NO_SALES"),
            TurnoverType::FreeStore => write!(f, "FREE_STORE"),
        }
    }
}

impl std::str::FromStr for TurnoverType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "LOW" => std::result::Result::Ok(TurnoverType::Low),
            "ALMOST_LOW" => std::result::Result::Ok(TurnoverType::AlmostLow),
            "HIGH" => std::result::Result::Ok(TurnoverType::High),
            "VERY_HIGH" => std::result::Result::Ok(TurnoverType::VeryHigh),
            "NO_SALES" => std::result::Result::Ok(TurnoverType::NoSales),
            "FREE_STORE" => std::result::Result::Ok(TurnoverType::FreeStore),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Единица измерения.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct UnitDto {
    /// Идентификатор единицы измерения.
    #[serde(rename = "id")]
    pub id: i64,

    /// Сокращенное название единицы измерения.
    #[serde(rename = "name")]
    pub name: String,

    /// Полное название единицы измерения.
    #[serde(rename = "fullName")]
    pub full_name: String,

}


impl UnitDto {
    #[allow(clippy::new_without_default)]
    pub fn new(id: i64, name: String, full_name: String, ) -> UnitDto {
        UnitDto {
            id,
            name,
            full_name,
        }
    }
}

/// Converts the UnitDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for UnitDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            Some("id".to_string()),
            Some(self.id.to_string()),


            Some("name".to_string()),
            Some(self.name.to_string()),


            Some("fullName".to_string()),
            Some(self.full_name.to_string()),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a UnitDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for UnitDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<i64>,
            pub name: Vec<String>,
            pub full_name: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing UnitDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "fullName" => intermediate_rep.full_name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing UnitDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(UnitDto {
            id: intermediate_rep.id.into_iter().next().ok_or_else(|| "id missing in UnitDto".to_string())?,
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "name missing in UnitDto".to_string())?,
            full_name: intermediate_rep.full_name.into_iter().next().ok_or_else(|| "fullName missing in UnitDto".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<UnitDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<UnitDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<UnitDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for UnitDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<UnitDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <UnitDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into UnitDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Товар с новой ценой.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct UpdateBusinessOfferPriceDto {
    /// Ваш SKU — идентификатор товара в вашей системе.  Разрешена любая последовательность длиной до 255 знаков.  Правила использования SKU:  * У каждого товара SKU должен быть свой.  * SKU товара нельзя менять — можно только удалить товар и добавить заново с новым SKU.  * Уже заданный SKU нельзя освободить и использовать заново для другого товара. Каждый товар должен получать новый идентификатор, до того никогда не использовавшийся в вашем каталоге.  [Что такое SKU и как его назначать](https://yandex.ru/support/marketplace/assortment/add/index.html#fields) 
    #[serde(rename = "offerId")]
    #[validate(
            length(min = 1, max = 255),
           regex = "RE_UPDATEBUSINESSOFFERPRICEDTO_OFFER_ID",
        )]
    pub offer_id: String,

    #[serde(rename = "price")]
    pub price: models::UpdatePriceWithDiscountDto,

}

lazy_static::lazy_static! {
    static ref RE_UPDATEBUSINESSOFFERPRICEDTO_OFFER_ID: regex::Regex = regex::Regex::new(r"^[^\\x00-\\x08\\x0A-\\x1f\\x7f]{1,255}$").unwrap();
}

impl UpdateBusinessOfferPriceDto {
    #[allow(clippy::new_without_default)]
    pub fn new(offer_id: String, price: models::UpdatePriceWithDiscountDto, ) -> UpdateBusinessOfferPriceDto {
        UpdateBusinessOfferPriceDto {
            offer_id,
            price,
        }
    }
}

/// Converts the UpdateBusinessOfferPriceDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for UpdateBusinessOfferPriceDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            Some("offerId".to_string()),
            Some(self.offer_id.to_string()),

            // Skipping price in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a UpdateBusinessOfferPriceDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for UpdateBusinessOfferPriceDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub offer_id: Vec<String>,
            pub price: Vec<models::UpdatePriceWithDiscountDto>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing UpdateBusinessOfferPriceDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "offerId" => intermediate_rep.offer_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "price" => intermediate_rep.price.push(<models::UpdatePriceWithDiscountDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing UpdateBusinessOfferPriceDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(UpdateBusinessOfferPriceDto {
            offer_id: intermediate_rep.offer_id.into_iter().next().ok_or_else(|| "offerId missing in UpdateBusinessOfferPriceDto".to_string())?,
            price: intermediate_rep.price.into_iter().next().ok_or_else(|| "price missing in UpdateBusinessOfferPriceDto".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<UpdateBusinessOfferPriceDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<UpdateBusinessOfferPriceDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<UpdateBusinessOfferPriceDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for UpdateBusinessOfferPriceDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<UpdateBusinessOfferPriceDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <UpdateBusinessOfferPriceDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into UpdateBusinessOfferPriceDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Запрос на установку базовых цен на товары.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct UpdateBusinessPricesRequest {
    /// Список товаров с ценами.
    #[serde(rename = "offers")]
    #[validate(
            length(min = 1, max = 500),
        )]
    pub offers: Vec<models::UpdateBusinessOfferPriceDto>,

}


impl UpdateBusinessPricesRequest {
    #[allow(clippy::new_without_default)]
    pub fn new(offers: Vec<models::UpdateBusinessOfferPriceDto>, ) -> UpdateBusinessPricesRequest {
        UpdateBusinessPricesRequest {
            offers,
        }
    }
}

/// Converts the UpdateBusinessPricesRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for UpdateBusinessPricesRequest {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping offers in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a UpdateBusinessPricesRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for UpdateBusinessPricesRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub offers: Vec<Vec<models::UpdateBusinessOfferPriceDto>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing UpdateBusinessPricesRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "offers" => return std::result::Result::Err("Parsing a container in this style is not supported in UpdateBusinessPricesRequest".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing UpdateBusinessPricesRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(UpdateBusinessPricesRequest {
            offers: intermediate_rep.offers.into_iter().next().ok_or_else(|| "offers missing in UpdateBusinessPricesRequest".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<UpdateBusinessPricesRequest> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<UpdateBusinessPricesRequest>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<UpdateBusinessPricesRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for UpdateBusinessPricesRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<UpdateBusinessPricesRequest> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <UpdateBusinessPricesRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into UpdateBusinessPricesRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Параметры размещения товара в магазине.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct UpdateCampaignOfferDto {
    /// Ваш SKU — идентификатор товара в вашей системе.  Разрешена любая последовательность длиной до 255 знаков.  Правила использования SKU:  * У каждого товара SKU должен быть свой.  * SKU товара нельзя менять — можно только удалить товар и добавить заново с новым SKU.  * Уже заданный SKU нельзя освободить и использовать заново для другого товара. Каждый товар должен получать новый идентификатор, до того никогда не использовавшийся в вашем каталоге.  [Что такое SKU и как его назначать](https://yandex.ru/support/marketplace/assortment/add/index.html#fields) 
    #[serde(rename = "offerId")]
    #[validate(
            length(min = 1, max = 255),
           regex = "RE_UPDATECAMPAIGNOFFERDTO_OFFER_ID",
        )]
    pub offer_id: String,

    #[serde(rename = "quantum")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub quantum: Option<models::QuantumDto>,

    /// Есть ли товар в продаже. 
    #[serde(rename = "available")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub available: Option<bool>,

    /// Ставка НДС, применяемая для товара. Задается цифрой:  * `2` — 10%. * `5` — 0%. * `6` — не облагается НДС. * `7` — 20%.  Если параметр не указан, используется ставка НДС, установленная в кабинете продавца на Маркете. 
    #[serde(rename = "vat")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub vat: Option<i32>,

}

lazy_static::lazy_static! {
    static ref RE_UPDATECAMPAIGNOFFERDTO_OFFER_ID: regex::Regex = regex::Regex::new(r"^[^\\x00-\\x08\\x0A-\\x1f\\x7f]{1,255}$").unwrap();
}

impl UpdateCampaignOfferDto {
    #[allow(clippy::new_without_default)]
    pub fn new(offer_id: String, ) -> UpdateCampaignOfferDto {
        UpdateCampaignOfferDto {
            offer_id,
            quantum: None,
            available: None,
            vat: None,
        }
    }
}

/// Converts the UpdateCampaignOfferDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for UpdateCampaignOfferDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            Some("offerId".to_string()),
            Some(self.offer_id.to_string()),

            // Skipping quantum in query parameter serialization


            self.available.as_ref().map(|available| {
                [
                    "available".to_string(),
                    available.to_string(),
                ].join(",")
            }),


            self.vat.as_ref().map(|vat| {
                [
                    "vat".to_string(),
                    vat.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a UpdateCampaignOfferDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for UpdateCampaignOfferDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub offer_id: Vec<String>,
            pub quantum: Vec<models::QuantumDto>,
            pub available: Vec<bool>,
            pub vat: Vec<i32>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing UpdateCampaignOfferDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "offerId" => intermediate_rep.offer_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "quantum" => intermediate_rep.quantum.push(<models::QuantumDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "available" => intermediate_rep.available.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "vat" => intermediate_rep.vat.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing UpdateCampaignOfferDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(UpdateCampaignOfferDto {
            offer_id: intermediate_rep.offer_id.into_iter().next().ok_or_else(|| "offerId missing in UpdateCampaignOfferDto".to_string())?,
            quantum: intermediate_rep.quantum.into_iter().next(),
            available: intermediate_rep.available.into_iter().next(),
            vat: intermediate_rep.vat.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<UpdateCampaignOfferDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<UpdateCampaignOfferDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<UpdateCampaignOfferDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for UpdateCampaignOfferDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<UpdateCampaignOfferDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <UpdateCampaignOfferDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into UpdateCampaignOfferDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Запрос на обновление предложений товаров магазина.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct UpdateCampaignOffersRequest {
    /// Параметры размещения товаров в заданном магазине.
    #[serde(rename = "offers")]
    #[validate(
            length(min = 1, max = 500),
        )]
    pub offers: Vec<models::UpdateCampaignOfferDto>,

}


impl UpdateCampaignOffersRequest {
    #[allow(clippy::new_without_default)]
    pub fn new(offers: Vec<models::UpdateCampaignOfferDto>, ) -> UpdateCampaignOffersRequest {
        UpdateCampaignOffersRequest {
            offers,
        }
    }
}

/// Converts the UpdateCampaignOffersRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for UpdateCampaignOffersRequest {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping offers in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a UpdateCampaignOffersRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for UpdateCampaignOffersRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub offers: Vec<Vec<models::UpdateCampaignOfferDto>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing UpdateCampaignOffersRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "offers" => return std::result::Result::Err("Parsing a container in this style is not supported in UpdateCampaignOffersRequest".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing UpdateCampaignOffersRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(UpdateCampaignOffersRequest {
            offers: intermediate_rep.offers.into_iter().next().ok_or_else(|| "offers missing in UpdateCampaignOffersRequest".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<UpdateCampaignOffersRequest> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<UpdateCampaignOffersRequest>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<UpdateCampaignOffersRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for UpdateCampaignOffersRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<UpdateCampaignOffersRequest> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <UpdateCampaignOffersRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into UpdateCampaignOffersRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Комментарий к отзыву или другому комментарию.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct UpdateGoodsFeedbackCommentDto {
    /// Идентификатор комментария к отзыву. 
    #[serde(rename = "id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,

    /// Идентификатор комментария к отзыву. 
    #[serde(rename = "parentId")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub parent_id: Option<i64>,

    /// Текст комментария.
    #[serde(rename = "text")]
    #[validate(
            length(min = 1, max = 4096),
        )]
    pub text: String,

}


impl UpdateGoodsFeedbackCommentDto {
    #[allow(clippy::new_without_default)]
    pub fn new(text: String, ) -> UpdateGoodsFeedbackCommentDto {
        UpdateGoodsFeedbackCommentDto {
            id: None,
            parent_id: None,
            text,
        }
    }
}

/// Converts the UpdateGoodsFeedbackCommentDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for UpdateGoodsFeedbackCommentDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.id.as_ref().map(|id| {
                [
                    "id".to_string(),
                    id.to_string(),
                ].join(",")
            }),


            self.parent_id.as_ref().map(|parent_id| {
                [
                    "parentId".to_string(),
                    parent_id.to_string(),
                ].join(",")
            }),


            Some("text".to_string()),
            Some(self.text.to_string()),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a UpdateGoodsFeedbackCommentDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for UpdateGoodsFeedbackCommentDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<i64>,
            pub parent_id: Vec<i64>,
            pub text: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing UpdateGoodsFeedbackCommentDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "parentId" => intermediate_rep.parent_id.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "text" => intermediate_rep.text.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing UpdateGoodsFeedbackCommentDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(UpdateGoodsFeedbackCommentDto {
            id: intermediate_rep.id.into_iter().next(),
            parent_id: intermediate_rep.parent_id.into_iter().next(),
            text: intermediate_rep.text.into_iter().next().ok_or_else(|| "text missing in UpdateGoodsFeedbackCommentDto".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<UpdateGoodsFeedbackCommentDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<UpdateGoodsFeedbackCommentDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<UpdateGoodsFeedbackCommentDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for UpdateGoodsFeedbackCommentDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<UpdateGoodsFeedbackCommentDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <UpdateGoodsFeedbackCommentDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into UpdateGoodsFeedbackCommentDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Комментарий к отзыву.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct UpdateGoodsFeedbackCommentRequest {
    /// Идентификатор отзыва. 
    #[serde(rename = "feedbackId")]
    pub feedback_id: i64,

    #[serde(rename = "comment")]
    pub comment: models::UpdateGoodsFeedbackCommentDto,

}


impl UpdateGoodsFeedbackCommentRequest {
    #[allow(clippy::new_without_default)]
    pub fn new(feedback_id: i64, comment: models::UpdateGoodsFeedbackCommentDto, ) -> UpdateGoodsFeedbackCommentRequest {
        UpdateGoodsFeedbackCommentRequest {
            feedback_id,
            comment,
        }
    }
}

/// Converts the UpdateGoodsFeedbackCommentRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for UpdateGoodsFeedbackCommentRequest {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            Some("feedbackId".to_string()),
            Some(self.feedback_id.to_string()),

            // Skipping comment in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a UpdateGoodsFeedbackCommentRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for UpdateGoodsFeedbackCommentRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub feedback_id: Vec<i64>,
            pub comment: Vec<models::UpdateGoodsFeedbackCommentDto>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing UpdateGoodsFeedbackCommentRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "feedbackId" => intermediate_rep.feedback_id.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "comment" => intermediate_rep.comment.push(<models::UpdateGoodsFeedbackCommentDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing UpdateGoodsFeedbackCommentRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(UpdateGoodsFeedbackCommentRequest {
            feedback_id: intermediate_rep.feedback_id.into_iter().next().ok_or_else(|| "feedbackId missing in UpdateGoodsFeedbackCommentRequest".to_string())?,
            comment: intermediate_rep.comment.into_iter().next().ok_or_else(|| "comment missing in UpdateGoodsFeedbackCommentRequest".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<UpdateGoodsFeedbackCommentRequest> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<UpdateGoodsFeedbackCommentRequest>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<UpdateGoodsFeedbackCommentRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for UpdateGoodsFeedbackCommentRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<UpdateGoodsFeedbackCommentRequest> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <UpdateGoodsFeedbackCommentRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into UpdateGoodsFeedbackCommentRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct UpdateGoodsFeedbackCommentResponse {
    #[serde(rename = "status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<models::ApiResponseStatusType>,

    #[serde(rename = "result")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub result: Option<models::GoodsFeedbackCommentDto>,

}


impl UpdateGoodsFeedbackCommentResponse {
    #[allow(clippy::new_without_default)]
    pub fn new() -> UpdateGoodsFeedbackCommentResponse {
        UpdateGoodsFeedbackCommentResponse {
            status: None,
            result: None,
        }
    }
}

/// Converts the UpdateGoodsFeedbackCommentResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for UpdateGoodsFeedbackCommentResponse {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping status in query parameter serialization

            // Skipping result in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a UpdateGoodsFeedbackCommentResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for UpdateGoodsFeedbackCommentResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub status: Vec<models::ApiResponseStatusType>,
            pub result: Vec<models::GoodsFeedbackCommentDto>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing UpdateGoodsFeedbackCommentResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(<models::ApiResponseStatusType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "result" => intermediate_rep.result.push(<models::GoodsFeedbackCommentDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing UpdateGoodsFeedbackCommentResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(UpdateGoodsFeedbackCommentResponse {
            status: intermediate_rep.status.into_iter().next(),
            result: intermediate_rep.result.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<UpdateGoodsFeedbackCommentResponse> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<UpdateGoodsFeedbackCommentResponse>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<UpdateGoodsFeedbackCommentResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for UpdateGoodsFeedbackCommentResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<UpdateGoodsFeedbackCommentResponse> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <UpdateGoodsFeedbackCommentResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into UpdateGoodsFeedbackCommentResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Карточка на Маркете, которая, с вашей точки зрения, подходит товару. Чтобы определить идентификатор подходящей карточки, воспользуйтесь поиском в кабинете (**Товары** → **Каталог** → **Загрузить товары**).  По результатам проверки Маркет может привязать товар к более подходящей карточке. 
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct UpdateMappingDto {
    /// SKU на Маркете.
    #[serde(rename = "marketSku")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub market_sku: Option<i64>,

}


impl UpdateMappingDto {
    #[allow(clippy::new_without_default)]
    pub fn new() -> UpdateMappingDto {
        UpdateMappingDto {
            market_sku: None,
        }
    }
}

/// Converts the UpdateMappingDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for UpdateMappingDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.market_sku.as_ref().map(|market_sku| {
                [
                    "marketSku".to_string(),
                    market_sku.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a UpdateMappingDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for UpdateMappingDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub market_sku: Vec<i64>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing UpdateMappingDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "marketSku" => intermediate_rep.market_sku.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing UpdateMappingDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(UpdateMappingDto {
            market_sku: intermediate_rep.market_sku.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<UpdateMappingDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<UpdateMappingDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<UpdateMappingDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for UpdateMappingDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<UpdateMappingDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <UpdateMappingDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into UpdateMappingDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Информация о товарах в каталоге.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct UpdateMappingsOfferDto {
    /// Составляйте название по схеме: тип + бренд или производитель + модель + особенности, если есть (например, цвет, размер или вес) и количество в упаковке.  Не включайте в название условия продажи (например, «скидка», «бесплатная доставка» и т. д.), эмоциональные характеристики («хит», «супер» и т. д.). Не пишите слова большими буквами — кроме устоявшихся названий брендов и моделей.  Оптимальная длина — 50–60 символов, максимальная — 256.  [Рекомендации и правила](https://yandex.ru/support/marketplace/assortment/fields/title.html) 
    #[serde(rename = "name")]
    #[validate(
            length(max = 256),
        )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

    /// Ваш SKU — идентификатор товара в вашей системе.  Разрешена любая последовательность длиной до 255 знаков.  Правила использования SKU:  * У каждого товара SKU должен быть свой.  * SKU товара нельзя менять — можно только удалить товар и добавить заново с новым SKU.  * Уже заданный SKU нельзя освободить и использовать заново для другого товара. Каждый товар должен получать новый идентификатор, до того никогда не использовавшийся в вашем каталоге.  [Что такое SKU и как его назначать](https://yandex.ru/support/marketplace/assortment/add/index.html#fields) 
    #[serde(rename = "shopSku")]
    #[validate(
            length(min = 1, max = 255),
           regex = "RE_UPDATEMAPPINGSOFFERDTO_SHOP_SKU",
        )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub shop_sku: Option<String>,

    /// Категория товара в вашем магазине. Значение будет использовано для определения категории товара на Маркете в случае, если вы не передали категорию в параметре `marketCategoryId`.  Указывайте конкретные категории — например, набор ножей лучше отнести к категории **Столовые приборы**, а не просто **Посуда**.  Выбирайте категории, которые описывают товар, а не абстрактный признак — например, **Духи**, а не **Подарки**.  Значение будет использовано для определения категории товара на Маркете в случае, если вы не передали категорию в параметре `marketCategoryId`. 
    #[serde(rename = "category")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub category: Option<String>,

    /// Название бренда или производителя. Должно быть записано так, как его пишет сам бренд.
    #[serde(rename = "vendor")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub vendor: Option<String>,

    /// Артикул товара от производителя.
    #[serde(rename = "vendorCode")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub vendor_code: Option<String>,

    /// Подробное описание товара: например, его преимущества и особенности.  Не давайте в описании инструкций по установке и сборке. Не используйте слова «скидка», «распродажа», «дешевый», «подарок» (кроме подарочных категорий), «бесплатно», «акция», «специальная цена», «новинка», «new», «аналог», «заказ», «хит». Не указывайте никакой контактной информации и не давайте ссылок.  Можно использовать теги:  * \\<h>, \\<h1>, \\<h2> и так далее — для заголовков; * \\<br> и \\<p> — для переноса строки; * \\<ol> — для нумерованного списка; * \\<ul> — для маркированного списка; * \\<li> — для создания элементов списка (должен находиться внутри \\<ol> или \\<ul>); * \\<div> — поддерживается, но не влияет на отображение текста.  Оптимальная длина — 400–600 символов, максимальная — 6000.  [Рекомендации и правила](https://yandex.ru/support/marketplace/assortment/fields/description.html) 
    #[serde(rename = "description")]
    #[validate(
            length(max = 6000),
        )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,

    /// Ваш SKU — идентификатор товара в вашей системе.  Разрешена любая последовательность длиной до 255 знаков.  Правила использования SKU:  * У каждого товара SKU должен быть свой.  * SKU товара нельзя менять — можно только удалить товар и добавить заново с новым SKU.  * Уже заданный SKU нельзя освободить и использовать заново для другого товара. Каждый товар должен получать новый идентификатор, до того никогда не использовавшийся в вашем каталоге.  [Что такое SKU и как его назначать](https://yandex.ru/support/marketplace/assortment/add/index.html#fields) 
    #[serde(rename = "id")]
    #[validate(
            length(min = 1, max = 255),
           regex = "RE_UPDATEMAPPINGSOFFERDTO_ID",
        )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

    /// Идентификатор фида.
    #[serde(rename = "feedId")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub feed_id: Option<i64>,

    /// Указывайте в виде последовательности цифр. Подойдут коды EAN-13, EAN-8, UPC-A, UPC-E или Code 128.  Для книг указывайте ISBN.  Для товаров [определенных категорий и торговых марок](https://yastatic.net/s3/doc-binary/src/support/market/ru/yandex-market-list-for-gtin.xlsx) штрихкод должен быть действительным кодом GTIN. Обратите внимание: внутренние штрихкоды, начинающиеся на 2 или 02, и коды формата Code 128 не являются GTIN.  [Что такое GTIN](*gtin)  
    #[serde(rename = "barcodes")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub barcodes: Option<swagger::Nullable<Vec<String>>>,

    /// URL фотографии товара или страницы с описанием на вашем сайте.  Переданные данные не будут отображаться на витрине, но они помогут специалистам Маркета найти карточку для вашего товара.  Должен содержать один вложенный параметр url. 
    #[serde(rename = "urls")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub urls: Option<swagger::Nullable<Vec<String>>>,

    /// Ссылки (URL) изображений товара в хорошем качестве.  Можно указать до 30 ссылок. При этом изображение по первой ссылке будет основным. Оно используется в качестве изображения товара в поиске Маркета и на карточке товара. Другие изображения товара доступны в режиме просмотра увеличенных изображений.  Обязательный параметр.  Должен содержать хотя бы один вложенный параметр `picture`. 
    #[serde(rename = "pictures")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub pictures: Option<swagger::Nullable<Vec<String>>>,

    /// Изготовитель товара: компания, которая произвела товар, ее адрес и регистрационный номер (если есть).  Необязательный параметр. 
    #[serde(rename = "manufacturer")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub manufacturer: Option<String>,

    /// Список стран, в которых произведен товар.  Обязательный параметр.  Должен содержать хотя бы одну, но не больше 5 стран. 
    #[serde(rename = "manufacturerCountries")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub manufacturer_countries: Option<swagger::Nullable<Vec<String>>>,

    /// Минимальное количество единиц товара, которое вы поставляете на склад.  Например, если вы поставляете детское питание партиями минимум по 10 коробок, а в каждой коробке по 6 баночек, укажите значение 60. 
    #[serde(rename = "minShipment")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub min_shipment: Option<i32>,

    /// Количество единиц товара в одной упаковке, которую вы поставляете на склад.  Например, если вы поставляете детское питание коробками по 6 баночек, укажите значение 6. 
    #[serde(rename = "transportUnitSize")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub transport_unit_size: Option<i32>,

    /// Добавочная партия: по сколько единиц товара можно добавлять к минимальному количеству minShipment.  Например, если вы поставляете детское питание партиями минимум по 10 коробок и хотите добавлять к минимальной партии по 2 коробки, а в каждой коробке по 6 баночек, укажите значение 12. 
    #[serde(rename = "quantumOfSupply")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub quantum_of_supply: Option<i32>,

    /// Срок, за который продавец поставляет товары на склад, в днях.
    #[serde(rename = "deliveryDurationDays")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub delivery_duration_days: Option<i32>,

    /// Сколько мест (если больше одного) занимает товар.  Параметр указывается, только если товар занимает больше одного места (например, кондиционер занимает два места: внешний и внутренний блоки в двух коробках). Если товар занимает одно место, не указывайте этот параметр. 
    #[serde(rename = "boxCount")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub box_count: Option<i32>,

    /// Список кодов товара в единой Товарной номенклатуре внешнеэкономической деятельности (ТН ВЭД).  Обязательный параметр, если товар подлежит особому учету (например, в системе «Меркурий» как продукция животного происхождения или в системе «Честный ЗНАК»).  Может содержать только один вложенный код ТН ВЭД. 
    #[serde(rename = "customsCommodityCodes")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub customs_commodity_codes: Option<swagger::Nullable<Vec<String>>>,

    #[serde(rename = "weightDimensions")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub weight_dimensions: Option<models::OfferWeightDimensionsDto>,

    /// Дни недели, в которые продавец поставляет товары на склад.
    #[serde(rename = "supplyScheduleDays")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub supply_schedule_days: Option<swagger::Nullable<Vec<models::DayOfWeekType>>>,

    /// {% note warning \"\" %}  Этот параметр устарел. Вместо него используйте `shelfLife`. Совместное использование обоих параметров приведет к ошибке.  {% endnote %}  Срок годности: через сколько дней товар станет непригоден для использования. 
    #[serde(rename = "shelfLifeDays")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub shelf_life_days: Option<i32>,

    /// {% note warning \"\" %}  Этот параметр устарел. Вместо него используйте `lifeTime`. Совместное использование обоих параметров приведет к ошибке.  {% endnote %}  Срок службы: сколько дней товар будет исправно выполнять свою функцию, а изготовитель — нести ответственность за его существенные недостатки. 
    #[serde(rename = "lifeTimeDays")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub life_time_days: Option<i32>,

    /// Гарантийный срок товара: сколько дней возможно обслуживание и ремонт товара или возврат денег, а изготовитель или продавец будет нести ответственность за недостатки товара. 
    #[serde(rename = "guaranteePeriodDays")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub guarantee_period_days: Option<i32>,

    #[serde(rename = "processingState")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub processing_state: Option<models::OfferProcessingStateDto>,

    #[serde(rename = "availability")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub availability: Option<models::OfferAvailabilityStatusType>,

    #[serde(rename = "shelfLife")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub shelf_life: Option<models::TimePeriodDto>,

    #[serde(rename = "lifeTime")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub life_time: Option<models::TimePeriodDto>,

    #[serde(rename = "guaranteePeriod")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub guarantee_period: Option<models::TimePeriodDto>,

    /// Номер документа на товар.  Перед указанием номера документ нужно загрузить в кабинете продавца на Маркете. [Инструкция](https://yandex.ru/support/marketplace/assortment/restrictions/certificates.html) 
    #[serde(rename = "certificate")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub certificate: Option<String>,

}

lazy_static::lazy_static! {
    static ref RE_UPDATEMAPPINGSOFFERDTO_SHOP_SKU: regex::Regex = regex::Regex::new(r"^[^\\x00-\\x08\\x0A-\\x1f\\x7f]{1,255}$").unwrap();
}
lazy_static::lazy_static! {
    static ref RE_UPDATEMAPPINGSOFFERDTO_ID: regex::Regex = regex::Regex::new(r"^[^\\x00-\\x08\\x0A-\\x1f\\x7f]{1,255}$").unwrap();
}

impl UpdateMappingsOfferDto {
    #[allow(clippy::new_without_default)]
    pub fn new() -> UpdateMappingsOfferDto {
        UpdateMappingsOfferDto {
            name: None,
            shop_sku: None,
            category: None,
            vendor: None,
            vendor_code: None,
            description: None,
            id: None,
            feed_id: None,
            barcodes: None,
            urls: None,
            pictures: None,
            manufacturer: None,
            manufacturer_countries: None,
            min_shipment: None,
            transport_unit_size: None,
            quantum_of_supply: None,
            delivery_duration_days: None,
            box_count: None,
            customs_commodity_codes: None,
            weight_dimensions: None,
            supply_schedule_days: None,
            shelf_life_days: None,
            life_time_days: None,
            guarantee_period_days: None,
            processing_state: None,
            availability: None,
            shelf_life: None,
            life_time: None,
            guarantee_period: None,
            certificate: None,
        }
    }
}

/// Converts the UpdateMappingsOfferDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for UpdateMappingsOfferDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.name.as_ref().map(|name| {
                [
                    "name".to_string(),
                    name.to_string(),
                ].join(",")
            }),


            self.shop_sku.as_ref().map(|shop_sku| {
                [
                    "shopSku".to_string(),
                    shop_sku.to_string(),
                ].join(",")
            }),


            self.category.as_ref().map(|category| {
                [
                    "category".to_string(),
                    category.to_string(),
                ].join(",")
            }),


            self.vendor.as_ref().map(|vendor| {
                [
                    "vendor".to_string(),
                    vendor.to_string(),
                ].join(",")
            }),


            self.vendor_code.as_ref().map(|vendor_code| {
                [
                    "vendorCode".to_string(),
                    vendor_code.to_string(),
                ].join(",")
            }),


            self.description.as_ref().map(|description| {
                [
                    "description".to_string(),
                    description.to_string(),
                ].join(",")
            }),


            self.id.as_ref().map(|id| {
                [
                    "id".to_string(),
                    id.to_string(),
                ].join(",")
            }),


            self.feed_id.as_ref().map(|feed_id| {
                [
                    "feedId".to_string(),
                    feed_id.to_string(),
                ].join(",")
            }),


            self.barcodes.as_ref().map(|barcodes| {
                [
                    "barcodes".to_string(),
                    barcodes.as_ref().map_or("null".to_string(), |x| x.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),
                ].join(",")
            }),


            self.urls.as_ref().map(|urls| {
                [
                    "urls".to_string(),
                    urls.as_ref().map_or("null".to_string(), |x| x.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),
                ].join(",")
            }),


            self.pictures.as_ref().map(|pictures| {
                [
                    "pictures".to_string(),
                    pictures.as_ref().map_or("null".to_string(), |x| x.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),
                ].join(",")
            }),


            self.manufacturer.as_ref().map(|manufacturer| {
                [
                    "manufacturer".to_string(),
                    manufacturer.to_string(),
                ].join(",")
            }),


            self.manufacturer_countries.as_ref().map(|manufacturer_countries| {
                [
                    "manufacturerCountries".to_string(),
                    manufacturer_countries.as_ref().map_or("null".to_string(), |x| x.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),
                ].join(",")
            }),


            self.min_shipment.as_ref().map(|min_shipment| {
                [
                    "minShipment".to_string(),
                    min_shipment.to_string(),
                ].join(",")
            }),


            self.transport_unit_size.as_ref().map(|transport_unit_size| {
                [
                    "transportUnitSize".to_string(),
                    transport_unit_size.to_string(),
                ].join(",")
            }),


            self.quantum_of_supply.as_ref().map(|quantum_of_supply| {
                [
                    "quantumOfSupply".to_string(),
                    quantum_of_supply.to_string(),
                ].join(",")
            }),


            self.delivery_duration_days.as_ref().map(|delivery_duration_days| {
                [
                    "deliveryDurationDays".to_string(),
                    delivery_duration_days.to_string(),
                ].join(",")
            }),


            self.box_count.as_ref().map(|box_count| {
                [
                    "boxCount".to_string(),
                    box_count.to_string(),
                ].join(",")
            }),


            self.customs_commodity_codes.as_ref().map(|customs_commodity_codes| {
                [
                    "customsCommodityCodes".to_string(),
                    customs_commodity_codes.as_ref().map_or("null".to_string(), |x| x.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),
                ].join(",")
            }),

            // Skipping weightDimensions in query parameter serialization

            // Skipping supplyScheduleDays in query parameter serialization


            self.shelf_life_days.as_ref().map(|shelf_life_days| {
                [
                    "shelfLifeDays".to_string(),
                    shelf_life_days.to_string(),
                ].join(",")
            }),


            self.life_time_days.as_ref().map(|life_time_days| {
                [
                    "lifeTimeDays".to_string(),
                    life_time_days.to_string(),
                ].join(",")
            }),


            self.guarantee_period_days.as_ref().map(|guarantee_period_days| {
                [
                    "guaranteePeriodDays".to_string(),
                    guarantee_period_days.to_string(),
                ].join(",")
            }),

            // Skipping processingState in query parameter serialization

            // Skipping availability in query parameter serialization

            // Skipping shelfLife in query parameter serialization

            // Skipping lifeTime in query parameter serialization

            // Skipping guaranteePeriod in query parameter serialization


            self.certificate.as_ref().map(|certificate| {
                [
                    "certificate".to_string(),
                    certificate.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a UpdateMappingsOfferDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for UpdateMappingsOfferDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub name: Vec<String>,
            pub shop_sku: Vec<String>,
            pub category: Vec<String>,
            pub vendor: Vec<String>,
            pub vendor_code: Vec<String>,
            pub description: Vec<String>,
            pub id: Vec<String>,
            pub feed_id: Vec<i64>,
            pub barcodes: Vec<Vec<String>>,
            pub urls: Vec<Vec<String>>,
            pub pictures: Vec<Vec<String>>,
            pub manufacturer: Vec<String>,
            pub manufacturer_countries: Vec<Vec<String>>,
            pub min_shipment: Vec<i32>,
            pub transport_unit_size: Vec<i32>,
            pub quantum_of_supply: Vec<i32>,
            pub delivery_duration_days: Vec<i32>,
            pub box_count: Vec<i32>,
            pub customs_commodity_codes: Vec<Vec<String>>,
            pub weight_dimensions: Vec<models::OfferWeightDimensionsDto>,
            pub supply_schedule_days: Vec<Vec<models::DayOfWeekType>>,
            pub shelf_life_days: Vec<i32>,
            pub life_time_days: Vec<i32>,
            pub guarantee_period_days: Vec<i32>,
            pub processing_state: Vec<models::OfferProcessingStateDto>,
            pub availability: Vec<models::OfferAvailabilityStatusType>,
            pub shelf_life: Vec<models::TimePeriodDto>,
            pub life_time: Vec<models::TimePeriodDto>,
            pub guarantee_period: Vec<models::TimePeriodDto>,
            pub certificate: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing UpdateMappingsOfferDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "shopSku" => intermediate_rep.shop_sku.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "category" => intermediate_rep.category.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "vendor" => intermediate_rep.vendor.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "vendorCode" => intermediate_rep.vendor_code.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "description" => intermediate_rep.description.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "feedId" => intermediate_rep.feed_id.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "barcodes" => return std::result::Result::Err("Parsing a container in this style is not supported in UpdateMappingsOfferDto".to_string()),
                    "urls" => return std::result::Result::Err("Parsing a container in this style is not supported in UpdateMappingsOfferDto".to_string()),
                    "pictures" => return std::result::Result::Err("Parsing a container in this style is not supported in UpdateMappingsOfferDto".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "manufacturer" => intermediate_rep.manufacturer.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "manufacturerCountries" => return std::result::Result::Err("Parsing a container in this style is not supported in UpdateMappingsOfferDto".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "minShipment" => intermediate_rep.min_shipment.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "transportUnitSize" => intermediate_rep.transport_unit_size.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "quantumOfSupply" => intermediate_rep.quantum_of_supply.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "deliveryDurationDays" => intermediate_rep.delivery_duration_days.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "boxCount" => intermediate_rep.box_count.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "customsCommodityCodes" => return std::result::Result::Err("Parsing a container in this style is not supported in UpdateMappingsOfferDto".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "weightDimensions" => intermediate_rep.weight_dimensions.push(<models::OfferWeightDimensionsDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "supplyScheduleDays" => return std::result::Result::Err("Parsing a container in this style is not supported in UpdateMappingsOfferDto".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "shelfLifeDays" => intermediate_rep.shelf_life_days.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "lifeTimeDays" => intermediate_rep.life_time_days.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "guaranteePeriodDays" => intermediate_rep.guarantee_period_days.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "processingState" => intermediate_rep.processing_state.push(<models::OfferProcessingStateDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "availability" => intermediate_rep.availability.push(<models::OfferAvailabilityStatusType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "shelfLife" => intermediate_rep.shelf_life.push(<models::TimePeriodDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "lifeTime" => intermediate_rep.life_time.push(<models::TimePeriodDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "guaranteePeriod" => intermediate_rep.guarantee_period.push(<models::TimePeriodDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "certificate" => intermediate_rep.certificate.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing UpdateMappingsOfferDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(UpdateMappingsOfferDto {
            name: intermediate_rep.name.into_iter().next(),
            shop_sku: intermediate_rep.shop_sku.into_iter().next(),
            category: intermediate_rep.category.into_iter().next(),
            vendor: intermediate_rep.vendor.into_iter().next(),
            vendor_code: intermediate_rep.vendor_code.into_iter().next(),
            description: intermediate_rep.description.into_iter().next(),
            id: intermediate_rep.id.into_iter().next(),
            feed_id: intermediate_rep.feed_id.into_iter().next(),
            barcodes: std::result::Result::Err("Nullable types not supported in UpdateMappingsOfferDto".to_string())?,
            urls: std::result::Result::Err("Nullable types not supported in UpdateMappingsOfferDto".to_string())?,
            pictures: std::result::Result::Err("Nullable types not supported in UpdateMappingsOfferDto".to_string())?,
            manufacturer: intermediate_rep.manufacturer.into_iter().next(),
            manufacturer_countries: std::result::Result::Err("Nullable types not supported in UpdateMappingsOfferDto".to_string())?,
            min_shipment: intermediate_rep.min_shipment.into_iter().next(),
            transport_unit_size: intermediate_rep.transport_unit_size.into_iter().next(),
            quantum_of_supply: intermediate_rep.quantum_of_supply.into_iter().next(),
            delivery_duration_days: intermediate_rep.delivery_duration_days.into_iter().next(),
            box_count: intermediate_rep.box_count.into_iter().next(),
            customs_commodity_codes: std::result::Result::Err("Nullable types not supported in UpdateMappingsOfferDto".to_string())?,
            weight_dimensions: intermediate_rep.weight_dimensions.into_iter().next(),
            supply_schedule_days: std::result::Result::Err("Nullable types not supported in UpdateMappingsOfferDto".to_string())?,
            shelf_life_days: intermediate_rep.shelf_life_days.into_iter().next(),
            life_time_days: intermediate_rep.life_time_days.into_iter().next(),
            guarantee_period_days: intermediate_rep.guarantee_period_days.into_iter().next(),
            processing_state: intermediate_rep.processing_state.into_iter().next(),
            availability: intermediate_rep.availability.into_iter().next(),
            shelf_life: intermediate_rep.shelf_life.into_iter().next(),
            life_time: intermediate_rep.life_time.into_iter().next(),
            guarantee_period: intermediate_rep.guarantee_period.into_iter().next(),
            certificate: intermediate_rep.certificate.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<UpdateMappingsOfferDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<UpdateMappingsOfferDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<UpdateMappingsOfferDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for UpdateMappingsOfferDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<UpdateMappingsOfferDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <UpdateMappingsOfferDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into UpdateMappingsOfferDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Запрос на установку новых значений для параметров.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct UpdateOfferContentRequest {
    /// Список товаров с указанными характеристиками.
    #[serde(rename = "offersContent")]
    #[validate(
            length(min = 1, max = 100),
        )]
    pub offers_content: Vec<models::OfferContentDto>,

}


impl UpdateOfferContentRequest {
    #[allow(clippy::new_without_default)]
    pub fn new(offers_content: Vec<models::OfferContentDto>, ) -> UpdateOfferContentRequest {
        UpdateOfferContentRequest {
            offers_content,
        }
    }
}

/// Converts the UpdateOfferContentRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for UpdateOfferContentRequest {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping offersContent in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a UpdateOfferContentRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for UpdateOfferContentRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub offers_content: Vec<Vec<models::OfferContentDto>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing UpdateOfferContentRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "offersContent" => return std::result::Result::Err("Parsing a container in this style is not supported in UpdateOfferContentRequest".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing UpdateOfferContentRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(UpdateOfferContentRequest {
            offers_content: intermediate_rep.offers_content.into_iter().next().ok_or_else(|| "offersContent missing in UpdateOfferContentRequest".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<UpdateOfferContentRequest> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<UpdateOfferContentRequest>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<UpdateOfferContentRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for UpdateOfferContentRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<UpdateOfferContentRequest> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <UpdateOfferContentRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into UpdateOfferContentRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Описывает проблемы, которые появились при сохранении товара.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct UpdateOfferContentResponse {
    #[serde(rename = "status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<models::ApiResponseStatusType>,

    /// Ошибки и предупреждения, которые появились при обработке переданных значений. Каждый элемент списка соответствует одному товару.  Если ошибок и предупреждений нет, поле не передается. 
    #[serde(rename = "results")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub results: Option<swagger::Nullable<Vec<models::UpdateOfferContentResultDto>>>,

}


impl UpdateOfferContentResponse {
    #[allow(clippy::new_without_default)]
    pub fn new() -> UpdateOfferContentResponse {
        UpdateOfferContentResponse {
            status: None,
            results: None,
        }
    }
}

/// Converts the UpdateOfferContentResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for UpdateOfferContentResponse {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping status in query parameter serialization

            // Skipping results in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a UpdateOfferContentResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for UpdateOfferContentResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub status: Vec<models::ApiResponseStatusType>,
            pub results: Vec<Vec<models::UpdateOfferContentResultDto>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing UpdateOfferContentResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(<models::ApiResponseStatusType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "results" => return std::result::Result::Err("Parsing a container in this style is not supported in UpdateOfferContentResponse".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing UpdateOfferContentResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(UpdateOfferContentResponse {
            status: intermediate_rep.status.into_iter().next(),
            results: std::result::Result::Err("Nullable types not supported in UpdateOfferContentResponse".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<UpdateOfferContentResponse> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<UpdateOfferContentResponse>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<UpdateOfferContentResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for UpdateOfferContentResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<UpdateOfferContentResponse> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <UpdateOfferContentResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into UpdateOfferContentResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Ошибки и предупреждения, которые появились из-за переданных характеристик.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct UpdateOfferContentResultDto {
    /// Ваш SKU — идентификатор товара в вашей системе.  Разрешена любая последовательность длиной до 255 знаков.  Правила использования SKU:  * У каждого товара SKU должен быть свой.  * SKU товара нельзя менять — можно только удалить товар и добавить заново с новым SKU.  * Уже заданный SKU нельзя освободить и использовать заново для другого товара. Каждый товар должен получать новый идентификатор, до того никогда не использовавшийся в вашем каталоге.  [Что такое SKU и как его назначать](https://yandex.ru/support/marketplace/assortment/add/index.html#fields) 
    #[serde(rename = "offerId")]
    #[validate(
            length(min = 1, max = 255),
           regex = "RE_UPDATEOFFERCONTENTRESULTDTO_OFFER_ID",
        )]
    pub offer_id: String,

    /// Ошибки — информация в каталоге не обновится.
    #[serde(rename = "errors")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub errors: Option<swagger::Nullable<Vec<models::OfferContentErrorDto>>>,

    /// Предупреждения — информация в каталоге обновится.
    #[serde(rename = "warnings")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub warnings: Option<swagger::Nullable<Vec<models::OfferContentErrorDto>>>,

}

lazy_static::lazy_static! {
    static ref RE_UPDATEOFFERCONTENTRESULTDTO_OFFER_ID: regex::Regex = regex::Regex::new(r"^[^\\x00-\\x08\\x0A-\\x1f\\x7f]{1,255}$").unwrap();
}

impl UpdateOfferContentResultDto {
    #[allow(clippy::new_without_default)]
    pub fn new(offer_id: String, ) -> UpdateOfferContentResultDto {
        UpdateOfferContentResultDto {
            offer_id,
            errors: None,
            warnings: None,
        }
    }
}

/// Converts the UpdateOfferContentResultDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for UpdateOfferContentResultDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            Some("offerId".to_string()),
            Some(self.offer_id.to_string()),

            // Skipping errors in query parameter serialization

            // Skipping warnings in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a UpdateOfferContentResultDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for UpdateOfferContentResultDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub offer_id: Vec<String>,
            pub errors: Vec<Vec<models::OfferContentErrorDto>>,
            pub warnings: Vec<Vec<models::OfferContentErrorDto>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing UpdateOfferContentResultDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "offerId" => intermediate_rep.offer_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "errors" => return std::result::Result::Err("Parsing a container in this style is not supported in UpdateOfferContentResultDto".to_string()),
                    "warnings" => return std::result::Result::Err("Parsing a container in this style is not supported in UpdateOfferContentResultDto".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing UpdateOfferContentResultDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(UpdateOfferContentResultDto {
            offer_id: intermediate_rep.offer_id.into_iter().next().ok_or_else(|| "offerId missing in UpdateOfferContentResultDto".to_string())?,
            errors: std::result::Result::Err("Nullable types not supported in UpdateOfferContentResultDto".to_string())?,
            warnings: std::result::Result::Err("Nullable types not supported in UpdateOfferContentResultDto".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<UpdateOfferContentResultDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<UpdateOfferContentResultDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<UpdateOfferContentResultDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for UpdateOfferContentResultDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<UpdateOfferContentResultDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <UpdateOfferContentResultDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into UpdateOfferContentResultDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Параметры товара.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct UpdateOfferDto {
    /// Ваш SKU — идентификатор товара в вашей системе.  Разрешена любая последовательность длиной до 255 знаков.  Правила использования SKU:  * У каждого товара SKU должен быть свой.  * SKU товара нельзя менять — можно только удалить товар и добавить заново с новым SKU.  * Уже заданный SKU нельзя освободить и использовать заново для другого товара. Каждый товар должен получать новый идентификатор, до того никогда не использовавшийся в вашем каталоге.  [Что такое SKU и как его назначать](https://yandex.ru/support/marketplace/assortment/add/index.html#fields) 
    #[serde(rename = "offerId")]
    #[validate(
            length(min = 1, max = 255),
           regex = "RE_UPDATEOFFERDTO_OFFER_ID",
        )]
    pub offer_id: String,

    /// Составляйте название по схеме: тип + бренд или производитель + модель + особенности, если есть (например, цвет, размер или вес) и количество в упаковке.  Не включайте в название условия продажи (например, «скидка», «бесплатная доставка» и т. д.), эмоциональные характеристики («хит», «супер» и т. д.). Не пишите слова большими буквами — кроме устоявшихся названий брендов и моделей.  Оптимальная длина — 50–60 символов, максимальная — 256.  [Рекомендации и правила](https://yandex.ru/support/marketplace/assortment/fields/title.html) 
    #[serde(rename = "name")]
    #[validate(
            length(max = 256),
        )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

    /// Идентификатор категории на Маркете, к которой вы относите свой товар.  Если не указать `marketCategoryId`, то маркетная категория будет определена автоматически.  При изменении информации о товаре передавайте тот же идентификатор категории. Если вы укажете другой, категория товара не поменяется. Изменить ее можно только в кабинете продавца на Маркете.  Список категорий Маркета можно получить с помощью запроса  [POST categories/tree](../../reference/categories/getCategoriesTree.md). 
    #[serde(rename = "marketCategoryId")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub market_category_id: Option<i64>,

    /// Категория товара в вашем магазине. Значение будет использовано для определения категории товара на Маркете в случае, если вы не передали категорию в параметре `marketCategoryId`.  Указывайте конкретные категории — например, набор ножей лучше отнести к категории **Столовые приборы**, а не просто **Посуда**.  Выбирайте категории, которые описывают товар, а не абстрактный признак — например, **Духи**, а не **Подарки**.  Значение будет использовано для определения категории товара на Маркете в случае, если вы не передали категорию в параметре `marketCategoryId`. 
    #[serde(rename = "category")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub category: Option<String>,

    /// Ссылки на изображения товара. Изображение по первой ссылке считается основным, остальные дополнительными.  **Требования к ссылкам**  * Ссылок может быть до 30. * Указывайте ссылку целиком, включая протокол http или https. * Максимальная длина — 512 символов. * Русские буквы в URL можно. * Можно использовать прямые ссылки на изображения и на Яндекс Диск. Ссылки на Яндекс Диске нужно копировать с помощью функции **Поделиться**. Относительные ссылки и ссылки на другие облачные хранилища — не работают.  ✅ `https://example-shop.ru/images/sku12345.jpg`  ✅ `https://yadi.sk/i/NaBoRsimVOLov`  ❌ `/images/sku12345.jpg`  ❌ `https://www.dropbox.com/s/818f/tovar.jpg`  Ссылки на изображение должны быть постоянными. Нельзя использовать динамические ссылки, меняющиеся от выгрузки к выгрузке.  Если нужно заменить изображение, выложите новое изображение по новой ссылке, а ссылку на старое удалите. Если просто заменить изображение по старой ссылке, оно не обновится.  [Требования к изображениям](https://yandex.ru/support/marketplace/assortment/fields/images.html) 
    #[serde(rename = "pictures")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub pictures: Option<swagger::Nullable<Vec<String>>>,

    /// Ссылка (URL) на видео товара.  Максимальное количество ссылок — 6.  **Требования к ссылке**  * Указывайте ссылку целиком, включая протокол http или https. * Максимальная длина — 512 символов. * Русские буквы в URL можно. * Можно использовать прямые ссылки на видео и на Яндекс Диск. Ссылки на Яндекс Диске нужно копировать с помощью функции **Поделиться**. Относительные ссылки и ссылки на другие облачные хранилища — не работают.  ✅ `https://example-shop.ru/video/sku12345.avi`  ✅ `https://yadi.sk/i/NaBoRsimVOLov`  ❌ `/video/sku12345.avi`  ❌ `https://www.dropbox.com/s/818f/super-tovar.avi`  Ссылки на видео должны быть постоянными. Нельзя использовать динамические ссылки, меняющиеся от выгрузки к выгрузке.  Если нужно заменить видео, выложите новое видео по новой ссылке, а ссылку на старое удалите. Если просто заменить видео по старой ссылке, оно не обновится.  [Требования к видео](https://yandex.ru/support/marketplace/assortment/fields/video.html) 
    #[serde(rename = "videos")]
    #[validate(
            length(max = 6),
        )]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub videos: Option<swagger::Nullable<Vec<String>>>,

    /// Список инструкций по использованию товара.  Максимальное количество инструкций — 6.  Если вы передадите пустое поле `manuals`, загруженные ранее инструкции удалятся. 
    #[serde(rename = "manuals")]
    #[validate(
            length(max = 6),
        )]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub manuals: Option<swagger::Nullable<Vec<models::OfferManualDto>>>,

    /// Название бренда или производителя. Должно быть записано так, как его пишет сам бренд.
    #[serde(rename = "vendor")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub vendor: Option<String>,

    /// Указывайте в виде последовательности цифр. Подойдут коды EAN-13, EAN-8, UPC-A, UPC-E или Code 128.  Для книг указывайте ISBN.  Для товаров [определенных категорий и торговых марок](https://yastatic.net/s3/doc-binary/src/support/market/ru/yandex-market-list-for-gtin.xlsx) штрихкод должен быть действительным кодом GTIN. Обратите внимание: внутренние штрихкоды, начинающиеся на 2 или 02, и коды формата Code 128 не являются GTIN.  [Что такое GTIN](*gtin)  
    #[serde(rename = "barcodes")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub barcodes: Option<swagger::Nullable<Vec<String>>>,

    /// Подробное описание товара: например, его преимущества и особенности.  Не давайте в описании инструкций по установке и сборке. Не используйте слова «скидка», «распродажа», «дешевый», «подарок» (кроме подарочных категорий), «бесплатно», «акция», «специальная цена», «новинка», «new», «аналог», «заказ», «хит». Не указывайте никакой контактной информации и не давайте ссылок.  Можно использовать теги:  * \\<h>, \\<h1>, \\<h2> и так далее — для заголовков; * \\<br> и \\<p> — для переноса строки; * \\<ol> — для нумерованного списка; * \\<ul> — для маркированного списка; * \\<li> — для создания элементов списка (должен находиться внутри \\<ol> или \\<ul>); * \\<div> — поддерживается, но не влияет на отображение текста.  Оптимальная длина — 400–600 символов, максимальная — 6000.  [Рекомендации и правила](https://yandex.ru/support/marketplace/assortment/fields/description.html) 
    #[serde(rename = "description")]
    #[validate(
            length(max = 6000),
        )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,

    /// Страна, где был произведен товар.  Записывайте названия стран так, как они записаны в [списке](https://yastatic.net/s3/doc-binary/src/support/market/ru/countries.xlsx). 
    #[serde(rename = "manufacturerCountries")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub manufacturer_countries: Option<swagger::Nullable<Vec<String>>>,

    #[serde(rename = "weightDimensions")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub weight_dimensions: Option<models::OfferWeightDimensionsDto>,

    /// Артикул товара от производителя.
    #[serde(rename = "vendorCode")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub vendor_code: Option<String>,

    /// Метки товара, используемые магазином. Покупателям теги не видны. По тегам можно группировать и фильтровать разные товары в каталоге — например, товары одной серии, коллекции или линейки.  Максимальная длина тега 20 символов. У одного товара может быть максимум 10 тегов. Всего можно создать не больше 50 разных тегов. 
    #[serde(rename = "tags")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub tags: Option<swagger::Nullable<Vec<String>>>,

    #[serde(rename = "shelfLife")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub shelf_life: Option<models::TimePeriodDto>,

    #[serde(rename = "lifeTime")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub life_time: Option<models::TimePeriodDto>,

    #[serde(rename = "guaranteePeriod")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub guarantee_period: Option<models::TimePeriodDto>,

    /// Код товара в единой Товарной номенклатуре внешнеэкономической деятельности (ТН ВЭД) — 10 или 14 цифр без пробелов.  Обязательно укажите, если он есть. 
    #[serde(rename = "customsCommodityCode")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub customs_commodity_code: Option<String>,

    /// Номера документов на товар: сертификата, декларации соответствия и т. п.  Передавать можно только номера документов, сканы которого загружены в кабинете продавца по [инструкции](https://yandex.ru/support/marketplace/assortment/restrictions/certificates.html). 
    #[serde(rename = "certificates")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub certificates: Option<swagger::Nullable<Vec<String>>>,

    /// Количество грузовых мест.  Параметр используется, если товар представляет собой несколько коробок, упаковок и так далее. Например, кондиционер занимает два места — внешний и внутренний блоки в двух коробках.  Для товаров, занимающих одно место, не передавайте этот параметр. 
    #[serde(rename = "boxCount")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub box_count: Option<i32>,

    #[serde(rename = "condition")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub condition: Option<models::OfferConditionDto>,

    #[serde(rename = "type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub r#type: Option<models::OfferType>,

    /// Признак цифрового товара. Укажите `true`, если товар доставляется по электронной почте.  [Как работать с цифровыми товарами](../../step-by-step/digital.md) 
    #[serde(rename = "downloadable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub downloadable: Option<bool>,

    /// Параметр включает для товара пометку 18+. Устанавливайте ее только для товаров, которые относятся к удовлетворению сексуальных потребностей. 
    #[serde(rename = "adult")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub adult: Option<bool>,

    #[serde(rename = "age")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub age: Option<models::AgeDto>,

    /// {% note warning \"\" %}  Этот параметр устарел. При передаче характеристик используйте `parameterValues`.  {% endnote %}  Характеристики, которые есть только у товаров конкретной категории — например, диаметр колес велосипеда или материал подошвы обуви. 
    #[serde(rename = "params")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub params: Option<swagger::Nullable<Vec<models::OfferParamDto>>>,

    /// Список характеристик с их значениями.  С `parameterValues` обязательно передавайте `marketCategoryId` — идентификатор категории на Маркете, к которой относятся указанные характеристики товара.  При **изменении** характеристик передавайте только те, значение которых нужно обновить.  Чтобы **удалить** значение заданной характеристики, передайте ее `parameterId` с пустым `value`.  Максимальное количество характеристик — 300. 
    #[serde(rename = "parameterValues")]
    #[validate(
            length(max = 300),
        )]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub parameter_values: Option<swagger::Nullable<Vec<models::ParameterValueDto>>>,

    #[serde(rename = "basicPrice")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub basic_price: Option<models::UpdatePriceWithDiscountDto>,

    #[serde(rename = "purchasePrice")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub purchase_price: Option<models::BasePriceDto>,

    #[serde(rename = "additionalExpenses")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub additional_expenses: Option<models::BasePriceDto>,

    #[serde(rename = "cofinancePrice")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub cofinance_price: Option<models::BasePriceDto>,

}

lazy_static::lazy_static! {
    static ref RE_UPDATEOFFERDTO_OFFER_ID: regex::Regex = regex::Regex::new(r"^[^\\x00-\\x08\\x0A-\\x1f\\x7f]{1,255}$").unwrap();
}

impl UpdateOfferDto {
    #[allow(clippy::new_without_default)]
    pub fn new(offer_id: String, ) -> UpdateOfferDto {
        UpdateOfferDto {
            offer_id,
            name: None,
            market_category_id: None,
            category: None,
            pictures: None,
            videos: None,
            manuals: None,
            vendor: None,
            barcodes: None,
            description: None,
            manufacturer_countries: None,
            weight_dimensions: None,
            vendor_code: None,
            tags: None,
            shelf_life: None,
            life_time: None,
            guarantee_period: None,
            customs_commodity_code: None,
            certificates: None,
            box_count: None,
            condition: None,
            r#type: None,
            downloadable: None,
            adult: None,
            age: None,
            params: None,
            parameter_values: None,
            basic_price: None,
            purchase_price: None,
            additional_expenses: None,
            cofinance_price: None,
        }
    }
}

/// Converts the UpdateOfferDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for UpdateOfferDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            Some("offerId".to_string()),
            Some(self.offer_id.to_string()),


            self.name.as_ref().map(|name| {
                [
                    "name".to_string(),
                    name.to_string(),
                ].join(",")
            }),


            self.market_category_id.as_ref().map(|market_category_id| {
                [
                    "marketCategoryId".to_string(),
                    market_category_id.to_string(),
                ].join(",")
            }),


            self.category.as_ref().map(|category| {
                [
                    "category".to_string(),
                    category.to_string(),
                ].join(",")
            }),


            self.pictures.as_ref().map(|pictures| {
                [
                    "pictures".to_string(),
                    pictures.as_ref().map_or("null".to_string(), |x| x.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),
                ].join(",")
            }),


            self.videos.as_ref().map(|videos| {
                [
                    "videos".to_string(),
                    videos.as_ref().map_or("null".to_string(), |x| x.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),
                ].join(",")
            }),

            // Skipping manuals in query parameter serialization


            self.vendor.as_ref().map(|vendor| {
                [
                    "vendor".to_string(),
                    vendor.to_string(),
                ].join(",")
            }),


            self.barcodes.as_ref().map(|barcodes| {
                [
                    "barcodes".to_string(),
                    barcodes.as_ref().map_or("null".to_string(), |x| x.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),
                ].join(",")
            }),


            self.description.as_ref().map(|description| {
                [
                    "description".to_string(),
                    description.to_string(),
                ].join(",")
            }),


            self.manufacturer_countries.as_ref().map(|manufacturer_countries| {
                [
                    "manufacturerCountries".to_string(),
                    manufacturer_countries.as_ref().map_or("null".to_string(), |x| x.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),
                ].join(",")
            }),

            // Skipping weightDimensions in query parameter serialization


            self.vendor_code.as_ref().map(|vendor_code| {
                [
                    "vendorCode".to_string(),
                    vendor_code.to_string(),
                ].join(",")
            }),


            self.tags.as_ref().map(|tags| {
                [
                    "tags".to_string(),
                    tags.as_ref().map_or("null".to_string(), |x| x.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),
                ].join(",")
            }),

            // Skipping shelfLife in query parameter serialization

            // Skipping lifeTime in query parameter serialization

            // Skipping guaranteePeriod in query parameter serialization


            self.customs_commodity_code.as_ref().map(|customs_commodity_code| {
                [
                    "customsCommodityCode".to_string(),
                    customs_commodity_code.to_string(),
                ].join(",")
            }),


            self.certificates.as_ref().map(|certificates| {
                [
                    "certificates".to_string(),
                    certificates.as_ref().map_or("null".to_string(), |x| x.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),
                ].join(",")
            }),


            self.box_count.as_ref().map(|box_count| {
                [
                    "boxCount".to_string(),
                    box_count.to_string(),
                ].join(",")
            }),

            // Skipping condition in query parameter serialization

            // Skipping type in query parameter serialization


            self.downloadable.as_ref().map(|downloadable| {
                [
                    "downloadable".to_string(),
                    downloadable.to_string(),
                ].join(",")
            }),


            self.adult.as_ref().map(|adult| {
                [
                    "adult".to_string(),
                    adult.to_string(),
                ].join(",")
            }),

            // Skipping age in query parameter serialization

            // Skipping params in query parameter serialization

            // Skipping parameterValues in query parameter serialization

            // Skipping basicPrice in query parameter serialization

            // Skipping purchasePrice in query parameter serialization

            // Skipping additionalExpenses in query parameter serialization

            // Skipping cofinancePrice in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a UpdateOfferDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for UpdateOfferDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub offer_id: Vec<String>,
            pub name: Vec<String>,
            pub market_category_id: Vec<i64>,
            pub category: Vec<String>,
            pub pictures: Vec<Vec<String>>,
            pub videos: Vec<Vec<String>>,
            pub manuals: Vec<Vec<models::OfferManualDto>>,
            pub vendor: Vec<String>,
            pub barcodes: Vec<Vec<String>>,
            pub description: Vec<String>,
            pub manufacturer_countries: Vec<Vec<String>>,
            pub weight_dimensions: Vec<models::OfferWeightDimensionsDto>,
            pub vendor_code: Vec<String>,
            pub tags: Vec<Vec<String>>,
            pub shelf_life: Vec<models::TimePeriodDto>,
            pub life_time: Vec<models::TimePeriodDto>,
            pub guarantee_period: Vec<models::TimePeriodDto>,
            pub customs_commodity_code: Vec<String>,
            pub certificates: Vec<Vec<String>>,
            pub box_count: Vec<i32>,
            pub condition: Vec<models::OfferConditionDto>,
            pub r#type: Vec<models::OfferType>,
            pub downloadable: Vec<bool>,
            pub adult: Vec<bool>,
            pub age: Vec<models::AgeDto>,
            pub params: Vec<Vec<models::OfferParamDto>>,
            pub parameter_values: Vec<Vec<models::ParameterValueDto>>,
            pub basic_price: Vec<models::UpdatePriceWithDiscountDto>,
            pub purchase_price: Vec<models::BasePriceDto>,
            pub additional_expenses: Vec<models::BasePriceDto>,
            pub cofinance_price: Vec<models::BasePriceDto>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing UpdateOfferDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "offerId" => intermediate_rep.offer_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "marketCategoryId" => intermediate_rep.market_category_id.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "category" => intermediate_rep.category.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "pictures" => return std::result::Result::Err("Parsing a container in this style is not supported in UpdateOfferDto".to_string()),
                    "videos" => return std::result::Result::Err("Parsing a container in this style is not supported in UpdateOfferDto".to_string()),
                    "manuals" => return std::result::Result::Err("Parsing a container in this style is not supported in UpdateOfferDto".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "vendor" => intermediate_rep.vendor.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "barcodes" => return std::result::Result::Err("Parsing a container in this style is not supported in UpdateOfferDto".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "description" => intermediate_rep.description.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "manufacturerCountries" => return std::result::Result::Err("Parsing a container in this style is not supported in UpdateOfferDto".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "weightDimensions" => intermediate_rep.weight_dimensions.push(<models::OfferWeightDimensionsDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "vendorCode" => intermediate_rep.vendor_code.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "tags" => return std::result::Result::Err("Parsing a container in this style is not supported in UpdateOfferDto".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "shelfLife" => intermediate_rep.shelf_life.push(<models::TimePeriodDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "lifeTime" => intermediate_rep.life_time.push(<models::TimePeriodDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "guaranteePeriod" => intermediate_rep.guarantee_period.push(<models::TimePeriodDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "customsCommodityCode" => intermediate_rep.customs_commodity_code.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "certificates" => return std::result::Result::Err("Parsing a container in this style is not supported in UpdateOfferDto".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "boxCount" => intermediate_rep.box_count.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "condition" => intermediate_rep.condition.push(<models::OfferConditionDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r#type.push(<models::OfferType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "downloadable" => intermediate_rep.downloadable.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "adult" => intermediate_rep.adult.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "age" => intermediate_rep.age.push(<models::AgeDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "params" => return std::result::Result::Err("Parsing a container in this style is not supported in UpdateOfferDto".to_string()),
                    "parameterValues" => return std::result::Result::Err("Parsing a container in this style is not supported in UpdateOfferDto".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "basicPrice" => intermediate_rep.basic_price.push(<models::UpdatePriceWithDiscountDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "purchasePrice" => intermediate_rep.purchase_price.push(<models::BasePriceDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "additionalExpenses" => intermediate_rep.additional_expenses.push(<models::BasePriceDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "cofinancePrice" => intermediate_rep.cofinance_price.push(<models::BasePriceDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing UpdateOfferDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(UpdateOfferDto {
            offer_id: intermediate_rep.offer_id.into_iter().next().ok_or_else(|| "offerId missing in UpdateOfferDto".to_string())?,
            name: intermediate_rep.name.into_iter().next(),
            market_category_id: intermediate_rep.market_category_id.into_iter().next(),
            category: intermediate_rep.category.into_iter().next(),
            pictures: std::result::Result::Err("Nullable types not supported in UpdateOfferDto".to_string())?,
            videos: std::result::Result::Err("Nullable types not supported in UpdateOfferDto".to_string())?,
            manuals: std::result::Result::Err("Nullable types not supported in UpdateOfferDto".to_string())?,
            vendor: intermediate_rep.vendor.into_iter().next(),
            barcodes: std::result::Result::Err("Nullable types not supported in UpdateOfferDto".to_string())?,
            description: intermediate_rep.description.into_iter().next(),
            manufacturer_countries: std::result::Result::Err("Nullable types not supported in UpdateOfferDto".to_string())?,
            weight_dimensions: intermediate_rep.weight_dimensions.into_iter().next(),
            vendor_code: intermediate_rep.vendor_code.into_iter().next(),
            tags: std::result::Result::Err("Nullable types not supported in UpdateOfferDto".to_string())?,
            shelf_life: intermediate_rep.shelf_life.into_iter().next(),
            life_time: intermediate_rep.life_time.into_iter().next(),
            guarantee_period: intermediate_rep.guarantee_period.into_iter().next(),
            customs_commodity_code: intermediate_rep.customs_commodity_code.into_iter().next(),
            certificates: std::result::Result::Err("Nullable types not supported in UpdateOfferDto".to_string())?,
            box_count: intermediate_rep.box_count.into_iter().next(),
            condition: intermediate_rep.condition.into_iter().next(),
            r#type: intermediate_rep.r#type.into_iter().next(),
            downloadable: intermediate_rep.downloadable.into_iter().next(),
            adult: intermediate_rep.adult.into_iter().next(),
            age: intermediate_rep.age.into_iter().next(),
            params: std::result::Result::Err("Nullable types not supported in UpdateOfferDto".to_string())?,
            parameter_values: std::result::Result::Err("Nullable types not supported in UpdateOfferDto".to_string())?,
            basic_price: intermediate_rep.basic_price.into_iter().next(),
            purchase_price: intermediate_rep.purchase_price.into_iter().next(),
            additional_expenses: intermediate_rep.additional_expenses.into_iter().next(),
            cofinance_price: intermediate_rep.cofinance_price.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<UpdateOfferDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<UpdateOfferDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<UpdateOfferDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for UpdateOfferDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<UpdateOfferDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <UpdateOfferDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into UpdateOfferDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Информация о товаре.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct UpdateOfferMappingDto {
    #[serde(rename = "offer")]
    pub offer: models::UpdateOfferDto,

    #[serde(rename = "mapping")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub mapping: Option<models::UpdateMappingDto>,

}


impl UpdateOfferMappingDto {
    #[allow(clippy::new_without_default)]
    pub fn new(offer: models::UpdateOfferDto, ) -> UpdateOfferMappingDto {
        UpdateOfferMappingDto {
            offer,
            mapping: None,
        }
    }
}

/// Converts the UpdateOfferMappingDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for UpdateOfferMappingDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping offer in query parameter serialization

            // Skipping mapping in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a UpdateOfferMappingDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for UpdateOfferMappingDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub offer: Vec<models::UpdateOfferDto>,
            pub mapping: Vec<models::UpdateMappingDto>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing UpdateOfferMappingDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "offer" => intermediate_rep.offer.push(<models::UpdateOfferDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "mapping" => intermediate_rep.mapping.push(<models::UpdateMappingDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing UpdateOfferMappingDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(UpdateOfferMappingDto {
            offer: intermediate_rep.offer.into_iter().next().ok_or_else(|| "offer missing in UpdateOfferMappingDto".to_string())?,
            mapping: intermediate_rep.mapping.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<UpdateOfferMappingDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<UpdateOfferMappingDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<UpdateOfferMappingDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for UpdateOfferMappingDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<UpdateOfferMappingDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <UpdateOfferMappingDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into UpdateOfferMappingDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Список товаров.  В теле запроса можно передать от одного до 500 товаров.  Обязательный параметр. 
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct UpdateOfferMappingEntryDto {
    #[serde(rename = "mapping")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub mapping: Option<models::OfferMappingDto>,

    #[serde(rename = "awaitingModerationMapping")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub awaiting_moderation_mapping: Option<models::OfferMappingDto>,

    #[serde(rename = "rejectedMapping")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub rejected_mapping: Option<models::OfferMappingDto>,

    #[serde(rename = "offer")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub offer: Option<models::UpdateMappingsOfferDto>,

}


impl UpdateOfferMappingEntryDto {
    #[allow(clippy::new_without_default)]
    pub fn new() -> UpdateOfferMappingEntryDto {
        UpdateOfferMappingEntryDto {
            mapping: None,
            awaiting_moderation_mapping: None,
            rejected_mapping: None,
            offer: None,
        }
    }
}

/// Converts the UpdateOfferMappingEntryDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for UpdateOfferMappingEntryDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping mapping in query parameter serialization

            // Skipping awaitingModerationMapping in query parameter serialization

            // Skipping rejectedMapping in query parameter serialization

            // Skipping offer in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a UpdateOfferMappingEntryDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for UpdateOfferMappingEntryDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub mapping: Vec<models::OfferMappingDto>,
            pub awaiting_moderation_mapping: Vec<models::OfferMappingDto>,
            pub rejected_mapping: Vec<models::OfferMappingDto>,
            pub offer: Vec<models::UpdateMappingsOfferDto>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing UpdateOfferMappingEntryDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "mapping" => intermediate_rep.mapping.push(<models::OfferMappingDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "awaitingModerationMapping" => intermediate_rep.awaiting_moderation_mapping.push(<models::OfferMappingDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "rejectedMapping" => intermediate_rep.rejected_mapping.push(<models::OfferMappingDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "offer" => intermediate_rep.offer.push(<models::UpdateMappingsOfferDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing UpdateOfferMappingEntryDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(UpdateOfferMappingEntryDto {
            mapping: intermediate_rep.mapping.into_iter().next(),
            awaiting_moderation_mapping: intermediate_rep.awaiting_moderation_mapping.into_iter().next(),
            rejected_mapping: intermediate_rep.rejected_mapping.into_iter().next(),
            offer: intermediate_rep.offer.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<UpdateOfferMappingEntryDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<UpdateOfferMappingEntryDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<UpdateOfferMappingEntryDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for UpdateOfferMappingEntryDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<UpdateOfferMappingEntryDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <UpdateOfferMappingEntryDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into UpdateOfferMappingEntryDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Запрос на обновление товаров.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct UpdateOfferMappingEntryRequest {
    /// Информация о товарах в каталоге.
    #[serde(rename = "offerMappingEntries")]
    #[validate(
            length(min = 1, max = 500),
        )]
    pub offer_mapping_entries: Vec<models::UpdateOfferMappingEntryDto>,

}


impl UpdateOfferMappingEntryRequest {
    #[allow(clippy::new_without_default)]
    pub fn new(offer_mapping_entries: Vec<models::UpdateOfferMappingEntryDto>, ) -> UpdateOfferMappingEntryRequest {
        UpdateOfferMappingEntryRequest {
            offer_mapping_entries,
        }
    }
}

/// Converts the UpdateOfferMappingEntryRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for UpdateOfferMappingEntryRequest {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping offerMappingEntries in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a UpdateOfferMappingEntryRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for UpdateOfferMappingEntryRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub offer_mapping_entries: Vec<Vec<models::UpdateOfferMappingEntryDto>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing UpdateOfferMappingEntryRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "offerMappingEntries" => return std::result::Result::Err("Parsing a container in this style is not supported in UpdateOfferMappingEntryRequest".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing UpdateOfferMappingEntryRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(UpdateOfferMappingEntryRequest {
            offer_mapping_entries: intermediate_rep.offer_mapping_entries.into_iter().next().ok_or_else(|| "offerMappingEntries missing in UpdateOfferMappingEntryRequest".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<UpdateOfferMappingEntryRequest> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<UpdateOfferMappingEntryRequest>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<UpdateOfferMappingEntryRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for UpdateOfferMappingEntryRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<UpdateOfferMappingEntryRequest> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <UpdateOfferMappingEntryRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into UpdateOfferMappingEntryRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Ошибки и предупреждения, которые появились из-за переданных характеристик.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct UpdateOfferMappingResultDto {
    /// Ваш SKU — идентификатор товара в вашей системе.  Разрешена любая последовательность длиной до 255 знаков.  Правила использования SKU:  * У каждого товара SKU должен быть свой.  * SKU товара нельзя менять — можно только удалить товар и добавить заново с новым SKU.  * Уже заданный SKU нельзя освободить и использовать заново для другого товара. Каждый товар должен получать новый идентификатор, до того никогда не использовавшийся в вашем каталоге.  [Что такое SKU и как его назначать](https://yandex.ru/support/marketplace/assortment/add/index.html#fields) 
    #[serde(rename = "offerId")]
    #[validate(
            length(min = 1, max = 255),
           regex = "RE_UPDATEOFFERMAPPINGRESULTDTO_OFFER_ID",
        )]
    pub offer_id: String,

    /// Ошибки — информация в каталоге не обновится.
    #[serde(rename = "errors")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub errors: Option<swagger::Nullable<Vec<models::OfferMappingErrorDto>>>,

    /// Предупреждения — информация в каталоге обновится.
    #[serde(rename = "warnings")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub warnings: Option<swagger::Nullable<Vec<models::OfferMappingErrorDto>>>,

}

lazy_static::lazy_static! {
    static ref RE_UPDATEOFFERMAPPINGRESULTDTO_OFFER_ID: regex::Regex = regex::Regex::new(r"^[^\\x00-\\x08\\x0A-\\x1f\\x7f]{1,255}$").unwrap();
}

impl UpdateOfferMappingResultDto {
    #[allow(clippy::new_without_default)]
    pub fn new(offer_id: String, ) -> UpdateOfferMappingResultDto {
        UpdateOfferMappingResultDto {
            offer_id,
            errors: None,
            warnings: None,
        }
    }
}

/// Converts the UpdateOfferMappingResultDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for UpdateOfferMappingResultDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            Some("offerId".to_string()),
            Some(self.offer_id.to_string()),

            // Skipping errors in query parameter serialization

            // Skipping warnings in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a UpdateOfferMappingResultDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for UpdateOfferMappingResultDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub offer_id: Vec<String>,
            pub errors: Vec<Vec<models::OfferMappingErrorDto>>,
            pub warnings: Vec<Vec<models::OfferMappingErrorDto>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing UpdateOfferMappingResultDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "offerId" => intermediate_rep.offer_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "errors" => return std::result::Result::Err("Parsing a container in this style is not supported in UpdateOfferMappingResultDto".to_string()),
                    "warnings" => return std::result::Result::Err("Parsing a container in this style is not supported in UpdateOfferMappingResultDto".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing UpdateOfferMappingResultDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(UpdateOfferMappingResultDto {
            offer_id: intermediate_rep.offer_id.into_iter().next().ok_or_else(|| "offerId missing in UpdateOfferMappingResultDto".to_string())?,
            errors: std::result::Result::Err("Nullable types not supported in UpdateOfferMappingResultDto".to_string())?,
            warnings: std::result::Result::Err("Nullable types not supported in UpdateOfferMappingResultDto".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<UpdateOfferMappingResultDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<UpdateOfferMappingResultDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<UpdateOfferMappingResultDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for UpdateOfferMappingResultDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<UpdateOfferMappingResultDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <UpdateOfferMappingResultDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into UpdateOfferMappingResultDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct UpdateOfferMappingsRequest {
    /// Перечень товаров, которые нужно добавить или обновить.
    #[serde(rename = "offerMappings")]
    #[validate(
            length(min = 1, max = 500),
        )]
    pub offer_mappings: Vec<models::UpdateOfferMappingDto>,

    /// Будут использоваться только переданные вами изображения товаров.  Значение по умолчанию — `false`. Если вы хотите заменить изображения, которые добавил Маркет, передайте значение `true`. 
    #[serde(rename = "onlyPartnerMediaContent")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub only_partner_media_content: Option<bool>,

}


impl UpdateOfferMappingsRequest {
    #[allow(clippy::new_without_default)]
    pub fn new(offer_mappings: Vec<models::UpdateOfferMappingDto>, ) -> UpdateOfferMappingsRequest {
        UpdateOfferMappingsRequest {
            offer_mappings,
            only_partner_media_content: None,
        }
    }
}

/// Converts the UpdateOfferMappingsRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for UpdateOfferMappingsRequest {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping offerMappings in query parameter serialization


            self.only_partner_media_content.as_ref().map(|only_partner_media_content| {
                [
                    "onlyPartnerMediaContent".to_string(),
                    only_partner_media_content.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a UpdateOfferMappingsRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for UpdateOfferMappingsRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub offer_mappings: Vec<Vec<models::UpdateOfferMappingDto>>,
            pub only_partner_media_content: Vec<bool>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing UpdateOfferMappingsRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "offerMappings" => return std::result::Result::Err("Parsing a container in this style is not supported in UpdateOfferMappingsRequest".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "onlyPartnerMediaContent" => intermediate_rep.only_partner_media_content.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing UpdateOfferMappingsRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(UpdateOfferMappingsRequest {
            offer_mappings: intermediate_rep.offer_mappings.into_iter().next().ok_or_else(|| "offerMappings missing in UpdateOfferMappingsRequest".to_string())?,
            only_partner_media_content: intermediate_rep.only_partner_media_content.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<UpdateOfferMappingsRequest> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<UpdateOfferMappingsRequest>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<UpdateOfferMappingsRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for UpdateOfferMappingsRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<UpdateOfferMappingsRequest> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <UpdateOfferMappingsRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into UpdateOfferMappingsRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Описывает проблемы, возникшие при сохранении товара.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct UpdateOfferMappingsResponse {
    #[serde(rename = "status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<models::ApiResponseStatusType>,

    /// Ошибки и предупреждения, которые появились при обработке списка характеристик. Каждый элемент списка соответствует одному товару.  Если ошибок и предупреждений нет, поле не передается. 
    #[serde(rename = "results")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub results: Option<swagger::Nullable<Vec<models::UpdateOfferMappingResultDto>>>,

}


impl UpdateOfferMappingsResponse {
    #[allow(clippy::new_without_default)]
    pub fn new() -> UpdateOfferMappingsResponse {
        UpdateOfferMappingsResponse {
            status: None,
            results: None,
        }
    }
}

/// Converts the UpdateOfferMappingsResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for UpdateOfferMappingsResponse {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping status in query parameter serialization

            // Skipping results in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a UpdateOfferMappingsResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for UpdateOfferMappingsResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub status: Vec<models::ApiResponseStatusType>,
            pub results: Vec<Vec<models::UpdateOfferMappingResultDto>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing UpdateOfferMappingsResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(<models::ApiResponseStatusType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "results" => return std::result::Result::Err("Parsing a container in this style is not supported in UpdateOfferMappingsResponse".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing UpdateOfferMappingsResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(UpdateOfferMappingsResponse {
            status: intermediate_rep.status.into_iter().next(),
            results: std::result::Result::Err("Nullable types not supported in UpdateOfferMappingsResponse".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<UpdateOfferMappingsResponse> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<UpdateOfferMappingsResponse>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<UpdateOfferMappingsResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for UpdateOfferMappingsResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<UpdateOfferMappingsResponse> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <UpdateOfferMappingsResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into UpdateOfferMappingsResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Запрос на обновление состава заказа.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct UpdateOrderItemRequest {
    /// Список товаров в заказе.  Если магазин не передал информацию о товаре во входных данных, он будет удален из заказа.  Обязательный параметр. 
    #[serde(rename = "items")]
    #[validate(
            length(min = 1),
        )]
    pub items: Vec<models::OrderItemModificationDto>,

    #[serde(rename = "reason")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub reason: Option<models::OrderItemsModificationRequestReasonType>,

}


impl UpdateOrderItemRequest {
    #[allow(clippy::new_without_default)]
    pub fn new(items: Vec<models::OrderItemModificationDto>, ) -> UpdateOrderItemRequest {
        UpdateOrderItemRequest {
            items,
            reason: None,
        }
    }
}

/// Converts the UpdateOrderItemRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for UpdateOrderItemRequest {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping items in query parameter serialization

            // Skipping reason in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a UpdateOrderItemRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for UpdateOrderItemRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub items: Vec<Vec<models::OrderItemModificationDto>>,
            pub reason: Vec<models::OrderItemsModificationRequestReasonType>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing UpdateOrderItemRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "items" => return std::result::Result::Err("Parsing a container in this style is not supported in UpdateOrderItemRequest".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "reason" => intermediate_rep.reason.push(<models::OrderItemsModificationRequestReasonType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing UpdateOrderItemRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(UpdateOrderItemRequest {
            items: intermediate_rep.items.into_iter().next().ok_or_else(|| "items missing in UpdateOrderItemRequest".to_string())?,
            reason: intermediate_rep.reason.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<UpdateOrderItemRequest> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<UpdateOrderItemRequest>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<UpdateOrderItemRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for UpdateOrderItemRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<UpdateOrderItemRequest> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <UpdateOrderItemRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into UpdateOrderItemRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Список заказов.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct UpdateOrderStatusDto {
    /// Идентификатор заказа.
    #[serde(rename = "id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,

    #[serde(rename = "status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<models::OrderStatusType>,

    #[serde(rename = "substatus")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub substatus: Option<models::OrderSubstatusType>,

    #[serde(rename = "updateStatus")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub update_status: Option<models::OrderUpdateStatusType>,

    /// Ошибка при изменении статуса заказа. Содержит описание ошибки и идентификатор заказа.  Возвращается, если параметр `updateStatus` принимает значение `ERROR`. 
    #[serde(rename = "errorDetails")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub error_details: Option<String>,

}


impl UpdateOrderStatusDto {
    #[allow(clippy::new_without_default)]
    pub fn new() -> UpdateOrderStatusDto {
        UpdateOrderStatusDto {
            id: None,
            status: None,
            substatus: None,
            update_status: None,
            error_details: None,
        }
    }
}

/// Converts the UpdateOrderStatusDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for UpdateOrderStatusDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.id.as_ref().map(|id| {
                [
                    "id".to_string(),
                    id.to_string(),
                ].join(",")
            }),

            // Skipping status in query parameter serialization

            // Skipping substatus in query parameter serialization

            // Skipping updateStatus in query parameter serialization


            self.error_details.as_ref().map(|error_details| {
                [
                    "errorDetails".to_string(),
                    error_details.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a UpdateOrderStatusDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for UpdateOrderStatusDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<i64>,
            pub status: Vec<models::OrderStatusType>,
            pub substatus: Vec<models::OrderSubstatusType>,
            pub update_status: Vec<models::OrderUpdateStatusType>,
            pub error_details: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing UpdateOrderStatusDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(<models::OrderStatusType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "substatus" => intermediate_rep.substatus.push(<models::OrderSubstatusType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "updateStatus" => intermediate_rep.update_status.push(<models::OrderUpdateStatusType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "errorDetails" => intermediate_rep.error_details.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing UpdateOrderStatusDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(UpdateOrderStatusDto {
            id: intermediate_rep.id.into_iter().next(),
            status: intermediate_rep.status.into_iter().next(),
            substatus: intermediate_rep.substatus.into_iter().next(),
            update_status: intermediate_rep.update_status.into_iter().next(),
            error_details: intermediate_rep.error_details.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<UpdateOrderStatusDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<UpdateOrderStatusDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<UpdateOrderStatusDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for UpdateOrderStatusDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<UpdateOrderStatusDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <UpdateOrderStatusDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into UpdateOrderStatusDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct UpdateOrderStatusRequest {
    #[serde(rename = "order")]
    pub order: models::OrderStatusChangeDto,

}


impl UpdateOrderStatusRequest {
    #[allow(clippy::new_without_default)]
    pub fn new(order: models::OrderStatusChangeDto, ) -> UpdateOrderStatusRequest {
        UpdateOrderStatusRequest {
            order,
        }
    }
}

/// Converts the UpdateOrderStatusRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for UpdateOrderStatusRequest {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping order in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a UpdateOrderStatusRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for UpdateOrderStatusRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub order: Vec<models::OrderStatusChangeDto>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing UpdateOrderStatusRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "order" => intermediate_rep.order.push(<models::OrderStatusChangeDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing UpdateOrderStatusRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(UpdateOrderStatusRequest {
            order: intermediate_rep.order.into_iter().next().ok_or_else(|| "order missing in UpdateOrderStatusRequest".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<UpdateOrderStatusRequest> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<UpdateOrderStatusRequest>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<UpdateOrderStatusRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for UpdateOrderStatusRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<UpdateOrderStatusRequest> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <UpdateOrderStatusRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into UpdateOrderStatusRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Информация об изменении статуса заказа.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct UpdateOrderStatusResponse {
    #[serde(rename = "order")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub order: Option<models::OrderDto>,

}


impl UpdateOrderStatusResponse {
    #[allow(clippy::new_without_default)]
    pub fn new() -> UpdateOrderStatusResponse {
        UpdateOrderStatusResponse {
            order: None,
        }
    }
}

/// Converts the UpdateOrderStatusResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for UpdateOrderStatusResponse {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping order in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a UpdateOrderStatusResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for UpdateOrderStatusResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub order: Vec<models::OrderDto>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing UpdateOrderStatusResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "order" => intermediate_rep.order.push(<models::OrderDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing UpdateOrderStatusResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(UpdateOrderStatusResponse {
            order: intermediate_rep.order.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<UpdateOrderStatusResponse> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<UpdateOrderStatusResponse>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<UpdateOrderStatusResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for UpdateOrderStatusResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<UpdateOrderStatusResponse> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <UpdateOrderStatusResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into UpdateOrderStatusResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Список заказов, статус которых обновился.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct UpdateOrderStatusesDto {
    /// Список с обновленными заказами.
    #[serde(rename = "orders")]
    pub orders: Vec<models::UpdateOrderStatusDto>,

}


impl UpdateOrderStatusesDto {
    #[allow(clippy::new_without_default)]
    pub fn new(orders: Vec<models::UpdateOrderStatusDto>, ) -> UpdateOrderStatusesDto {
        UpdateOrderStatusesDto {
            orders,
        }
    }
}

/// Converts the UpdateOrderStatusesDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for UpdateOrderStatusesDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping orders in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a UpdateOrderStatusesDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for UpdateOrderStatusesDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub orders: Vec<Vec<models::UpdateOrderStatusDto>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing UpdateOrderStatusesDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "orders" => return std::result::Result::Err("Parsing a container in this style is not supported in UpdateOrderStatusesDto".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing UpdateOrderStatusesDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(UpdateOrderStatusesDto {
            orders: intermediate_rep.orders.into_iter().next().ok_or_else(|| "orders missing in UpdateOrderStatusesDto".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<UpdateOrderStatusesDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<UpdateOrderStatusesDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<UpdateOrderStatusesDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for UpdateOrderStatusesDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<UpdateOrderStatusesDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <UpdateOrderStatusesDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into UpdateOrderStatusesDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Список заказов.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct UpdateOrderStatusesRequest {
    /// Список заказов.
    #[serde(rename = "orders")]
    #[validate(
            length(min = 1, max = 30),
        )]
    pub orders: Vec<models::OrderStateDto>,

}


impl UpdateOrderStatusesRequest {
    #[allow(clippy::new_without_default)]
    pub fn new(orders: Vec<models::OrderStateDto>, ) -> UpdateOrderStatusesRequest {
        UpdateOrderStatusesRequest {
            orders,
        }
    }
}

/// Converts the UpdateOrderStatusesRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for UpdateOrderStatusesRequest {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping orders in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a UpdateOrderStatusesRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for UpdateOrderStatusesRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub orders: Vec<Vec<models::OrderStateDto>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing UpdateOrderStatusesRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "orders" => return std::result::Result::Err("Parsing a container in this style is not supported in UpdateOrderStatusesRequest".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing UpdateOrderStatusesRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(UpdateOrderStatusesRequest {
            orders: intermediate_rep.orders.into_iter().next().ok_or_else(|| "orders missing in UpdateOrderStatusesRequest".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<UpdateOrderStatusesRequest> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<UpdateOrderStatusesRequest>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<UpdateOrderStatusesRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for UpdateOrderStatusesRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<UpdateOrderStatusesRequest> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <UpdateOrderStatusesRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into UpdateOrderStatusesRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct UpdateOrderStatusesResponse {
    #[serde(rename = "status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<models::ApiResponseStatusType>,

    #[serde(rename = "result")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub result: Option<models::UpdateOrderStatusesDto>,

}


impl UpdateOrderStatusesResponse {
    #[allow(clippy::new_without_default)]
    pub fn new() -> UpdateOrderStatusesResponse {
        UpdateOrderStatusesResponse {
            status: None,
            result: None,
        }
    }
}

/// Converts the UpdateOrderStatusesResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for UpdateOrderStatusesResponse {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping status in query parameter serialization

            // Skipping result in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a UpdateOrderStatusesResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for UpdateOrderStatusesResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub status: Vec<models::ApiResponseStatusType>,
            pub result: Vec<models::UpdateOrderStatusesDto>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing UpdateOrderStatusesResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(<models::ApiResponseStatusType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "result" => intermediate_rep.result.push(<models::UpdateOrderStatusesDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing UpdateOrderStatusesResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(UpdateOrderStatusesResponse {
            status: intermediate_rep.status.into_iter().next(),
            result: intermediate_rep.result.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<UpdateOrderStatusesResponse> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<UpdateOrderStatusesResponse>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<UpdateOrderStatusesResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for UpdateOrderStatusesResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<UpdateOrderStatusesResponse> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <UpdateOrderStatusesResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into UpdateOrderStatusesResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Запрос на обновление срока хранения заказа в ПВЗ.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct UpdateOrderStorageLimitRequest {
    /// Новая дата, до которой заказ будет храниться в пункте выдачи.  Срок хранения можно увеличить не больше, чем на 30 дней.  Формат даты: `ГГГГ-ММ-ДД`. 
    #[serde(rename = "newDate")]
    pub new_date: chrono::naive::NaiveDate,

}


impl UpdateOrderStorageLimitRequest {
    #[allow(clippy::new_without_default)]
    pub fn new(new_date: chrono::naive::NaiveDate, ) -> UpdateOrderStorageLimitRequest {
        UpdateOrderStorageLimitRequest {
            new_date,
        }
    }
}

/// Converts the UpdateOrderStorageLimitRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for UpdateOrderStorageLimitRequest {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping newDate in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a UpdateOrderStorageLimitRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for UpdateOrderStorageLimitRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub new_date: Vec<chrono::naive::NaiveDate>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing UpdateOrderStorageLimitRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "newDate" => intermediate_rep.new_date.push(<chrono::naive::NaiveDate as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing UpdateOrderStorageLimitRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(UpdateOrderStorageLimitRequest {
            new_date: intermediate_rep.new_date.into_iter().next().ok_or_else(|| "newDate missing in UpdateOrderStorageLimitRequest".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<UpdateOrderStorageLimitRequest> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<UpdateOrderStorageLimitRequest>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<UpdateOrderStorageLimitRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for UpdateOrderStorageLimitRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<UpdateOrderStorageLimitRequest> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <UpdateOrderStorageLimitRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into UpdateOrderStorageLimitRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Запрос на создание или изменение лицензий для точек продаж.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct UpdateOutletLicenseRequest {
    /// Список лицензий. Обязательный параметр, должен содержать информацию хотя бы об одной лицензии. 
    #[serde(rename = "licenses")]
    #[validate(
            length(min = 1),
        )]
    pub licenses: Vec<models::OutletLicenseDto>,

}


impl UpdateOutletLicenseRequest {
    #[allow(clippy::new_without_default)]
    pub fn new(licenses: Vec<models::OutletLicenseDto>, ) -> UpdateOutletLicenseRequest {
        UpdateOutletLicenseRequest {
            licenses,
        }
    }
}

/// Converts the UpdateOutletLicenseRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for UpdateOutletLicenseRequest {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping licenses in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a UpdateOutletLicenseRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for UpdateOutletLicenseRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub licenses: Vec<Vec<models::OutletLicenseDto>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing UpdateOutletLicenseRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "licenses" => return std::result::Result::Err("Parsing a container in this style is not supported in UpdateOutletLicenseRequest".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing UpdateOutletLicenseRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(UpdateOutletLicenseRequest {
            licenses: intermediate_rep.licenses.into_iter().next().ok_or_else(|| "licenses missing in UpdateOutletLicenseRequest".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<UpdateOutletLicenseRequest> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<UpdateOutletLicenseRequest>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<UpdateOutletLicenseRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for UpdateOutletLicenseRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<UpdateOutletLicenseRequest> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <UpdateOutletLicenseRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into UpdateOutletLicenseRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Цена с указанием скидки.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct UpdatePriceWithDiscountDto {
    /// Значение.
    #[serde(rename = "value")]
    #[validate(
            range(min = 0),
        )]
    pub value: f64,

    #[serde(rename = "currencyId")]
    pub currency_id: models::CurrencyType,

    /// Цена до скидки.  Число должно быть целым. Вы можете указать цену со скидкой от 5 до 99%.  Передавайте этот параметр при каждом обновлении цены, если предоставляете скидку на товар. 
    #[serde(rename = "discountBase")]
    #[validate(
            range(min = 0),
        )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub discount_base: Option<f64>,

}


impl UpdatePriceWithDiscountDto {
    #[allow(clippy::new_without_default)]
    pub fn new(value: f64, currency_id: models::CurrencyType, ) -> UpdatePriceWithDiscountDto {
        UpdatePriceWithDiscountDto {
            value,
            currency_id,
            discount_base: None,
        }
    }
}

/// Converts the UpdatePriceWithDiscountDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for UpdatePriceWithDiscountDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            Some("value".to_string()),
            Some(self.value.to_string()),

            // Skipping currencyId in query parameter serialization


            self.discount_base.as_ref().map(|discount_base| {
                [
                    "discountBase".to_string(),
                    discount_base.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a UpdatePriceWithDiscountDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for UpdatePriceWithDiscountDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub value: Vec<f64>,
            pub currency_id: Vec<models::CurrencyType>,
            pub discount_base: Vec<f64>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing UpdatePriceWithDiscountDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "value" => intermediate_rep.value.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "currencyId" => intermediate_rep.currency_id.push(<models::CurrencyType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "discountBase" => intermediate_rep.discount_base.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing UpdatePriceWithDiscountDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(UpdatePriceWithDiscountDto {
            value: intermediate_rep.value.into_iter().next().ok_or_else(|| "value missing in UpdatePriceWithDiscountDto".to_string())?,
            currency_id: intermediate_rep.currency_id.into_iter().next().ok_or_else(|| "currencyId missing in UpdatePriceWithDiscountDto".to_string())?,
            discount_base: intermediate_rep.discount_base.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<UpdatePriceWithDiscountDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<UpdatePriceWithDiscountDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<UpdatePriceWithDiscountDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for UpdatePriceWithDiscountDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<UpdatePriceWithDiscountDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <UpdatePriceWithDiscountDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into UpdatePriceWithDiscountDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Запрос на установку цен на товары.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct UpdatePricesRequest {
    /// Список товаров.
    #[serde(rename = "offers")]
    #[validate(
            length(min = 1, max = 2000),
        )]
    pub offers: Vec<models::OfferPriceDto>,

}


impl UpdatePricesRequest {
    #[allow(clippy::new_without_default)]
    pub fn new(offers: Vec<models::OfferPriceDto>, ) -> UpdatePricesRequest {
        UpdatePricesRequest {
            offers,
        }
    }
}

/// Converts the UpdatePricesRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for UpdatePricesRequest {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping offers in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a UpdatePricesRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for UpdatePricesRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub offers: Vec<Vec<models::OfferPriceDto>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing UpdatePricesRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "offers" => return std::result::Result::Err("Parsing a container in this style is not supported in UpdatePricesRequest".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing UpdatePricesRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(UpdatePricesRequest {
            offers: intermediate_rep.offers.into_iter().next().ok_or_else(|| "offers missing in UpdatePricesRequest".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<UpdatePricesRequest> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<UpdatePricesRequest>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<UpdatePricesRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for UpdatePricesRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<UpdatePricesRequest> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <UpdatePricesRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into UpdatePricesRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Параметры товара в акции с типом `DIRECT_DISCOUNT` или `BLUE_FLASH`.  Обязательный параметр для акций с этими типами. 
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct UpdatePromoOfferDiscountParamsDto {
    /// Зачеркнутая цена — та, по которой товар продавался до акции.  Указывается в рублях.  Число должно быть целым. 
    #[serde(rename = "price")]
    #[validate(
            range(min = 1),
        )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub price: Option<i64>,

    /// Цена по акции — та, по которой вы хотите продавать товар.  Указывается в рублях.  Число должно быть целым. 
    #[serde(rename = "promoPrice")]
    #[validate(
            range(min = 1),
        )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub promo_price: Option<i64>,

}


impl UpdatePromoOfferDiscountParamsDto {
    #[allow(clippy::new_without_default)]
    pub fn new() -> UpdatePromoOfferDiscountParamsDto {
        UpdatePromoOfferDiscountParamsDto {
            price: None,
            promo_price: None,
        }
    }
}

/// Converts the UpdatePromoOfferDiscountParamsDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for UpdatePromoOfferDiscountParamsDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.price.as_ref().map(|price| {
                [
                    "price".to_string(),
                    price.to_string(),
                ].join(",")
            }),


            self.promo_price.as_ref().map(|promo_price| {
                [
                    "promoPrice".to_string(),
                    promo_price.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a UpdatePromoOfferDiscountParamsDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for UpdatePromoOfferDiscountParamsDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub price: Vec<i64>,
            pub promo_price: Vec<i64>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing UpdatePromoOfferDiscountParamsDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "price" => intermediate_rep.price.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "promoPrice" => intermediate_rep.promo_price.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing UpdatePromoOfferDiscountParamsDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(UpdatePromoOfferDiscountParamsDto {
            price: intermediate_rep.price.into_iter().next(),
            promo_price: intermediate_rep.promo_price.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<UpdatePromoOfferDiscountParamsDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<UpdatePromoOfferDiscountParamsDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<UpdatePromoOfferDiscountParamsDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for UpdatePromoOfferDiscountParamsDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<UpdatePromoOfferDiscountParamsDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <UpdatePromoOfferDiscountParamsDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into UpdatePromoOfferDiscountParamsDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Описание товаров, которые участвуют в акции.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct UpdatePromoOfferDto {
    /// Ваш SKU — идентификатор товара в вашей системе.  Разрешена любая последовательность длиной до 255 знаков.  Правила использования SKU:  * У каждого товара SKU должен быть свой.  * SKU товара нельзя менять — можно только удалить товар и добавить заново с новым SKU.  * Уже заданный SKU нельзя освободить и использовать заново для другого товара. Каждый товар должен получать новый идентификатор, до того никогда не использовавшийся в вашем каталоге.  [Что такое SKU и как его назначать](https://yandex.ru/support/marketplace/assortment/add/index.html#fields) 
    #[serde(rename = "offerId")]
    #[validate(
            length(min = 1, max = 255),
           regex = "RE_UPDATEPROMOOFFERDTO_OFFER_ID",
        )]
    pub offer_id: String,

    #[serde(rename = "params")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub params: Option<models::UpdatePromoOfferParamsDto>,

}

lazy_static::lazy_static! {
    static ref RE_UPDATEPROMOOFFERDTO_OFFER_ID: regex::Regex = regex::Regex::new(r"^[^\\x00-\\x08\\x0A-\\x1f\\x7f]{1,255}$").unwrap();
}

impl UpdatePromoOfferDto {
    #[allow(clippy::new_without_default)]
    pub fn new(offer_id: String, ) -> UpdatePromoOfferDto {
        UpdatePromoOfferDto {
            offer_id,
            params: None,
        }
    }
}

/// Converts the UpdatePromoOfferDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for UpdatePromoOfferDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            Some("offerId".to_string()),
            Some(self.offer_id.to_string()),

            // Skipping params in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a UpdatePromoOfferDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for UpdatePromoOfferDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub offer_id: Vec<String>,
            pub params: Vec<models::UpdatePromoOfferParamsDto>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing UpdatePromoOfferDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "offerId" => intermediate_rep.offer_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "params" => intermediate_rep.params.push(<models::UpdatePromoOfferParamsDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing UpdatePromoOfferDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(UpdatePromoOfferDto {
            offer_id: intermediate_rep.offer_id.into_iter().next().ok_or_else(|| "offerId missing in UpdatePromoOfferDto".to_string())?,
            params: intermediate_rep.params.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<UpdatePromoOfferDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<UpdatePromoOfferDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<UpdatePromoOfferDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for UpdatePromoOfferDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<UpdatePromoOfferDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <UpdatePromoOfferDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into UpdatePromoOfferDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Параметры товара, который участвует в акции.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct UpdatePromoOfferParamsDto {
    #[serde(rename = "discountParams")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub discount_params: Option<models::UpdatePromoOfferDiscountParamsDto>,

}


impl UpdatePromoOfferParamsDto {
    #[allow(clippy::new_without_default)]
    pub fn new() -> UpdatePromoOfferParamsDto {
        UpdatePromoOfferParamsDto {
            discount_params: None,
        }
    }
}

/// Converts the UpdatePromoOfferParamsDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for UpdatePromoOfferParamsDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping discountParams in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a UpdatePromoOfferParamsDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for UpdatePromoOfferParamsDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub discount_params: Vec<models::UpdatePromoOfferDiscountParamsDto>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing UpdatePromoOfferParamsDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "discountParams" => intermediate_rep.discount_params.push(<models::UpdatePromoOfferDiscountParamsDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing UpdatePromoOfferParamsDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(UpdatePromoOfferParamsDto {
            discount_params: intermediate_rep.discount_params.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<UpdatePromoOfferParamsDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<UpdatePromoOfferParamsDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<UpdatePromoOfferParamsDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for UpdatePromoOfferParamsDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<UpdatePromoOfferParamsDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <UpdatePromoOfferParamsDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into UpdatePromoOfferParamsDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Добавление товаров в акцию или обновление их параметров.  Чтобы добавить товары в акцию или обновить параметры каких-то товаров, передайте их в параметре `offers`. 
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct UpdatePromoOffersRequest {
    /// Идентификатор акции.
    #[serde(rename = "promoId")]
    pub promo_id: String,

    /// Товары, которые необходимо добавить в акцию или цены которых нужно изменить.
    #[serde(rename = "offers")]
    #[validate(
            length(min = 1, max = 500),
        )]
    pub offers: Vec<models::UpdatePromoOfferDto>,

}


impl UpdatePromoOffersRequest {
    #[allow(clippy::new_without_default)]
    pub fn new(promo_id: String, offers: Vec<models::UpdatePromoOfferDto>, ) -> UpdatePromoOffersRequest {
        UpdatePromoOffersRequest {
            promo_id,
            offers,
        }
    }
}

/// Converts the UpdatePromoOffersRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for UpdatePromoOffersRequest {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            Some("promoId".to_string()),
            Some(self.promo_id.to_string()),

            // Skipping offers in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a UpdatePromoOffersRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for UpdatePromoOffersRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub promo_id: Vec<String>,
            pub offers: Vec<Vec<models::UpdatePromoOfferDto>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing UpdatePromoOffersRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "promoId" => intermediate_rep.promo_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "offers" => return std::result::Result::Err("Parsing a container in this style is not supported in UpdatePromoOffersRequest".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing UpdatePromoOffersRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(UpdatePromoOffersRequest {
            promo_id: intermediate_rep.promo_id.into_iter().next().ok_or_else(|| "promoId missing in UpdatePromoOffersRequest".to_string())?,
            offers: intermediate_rep.offers.into_iter().next().ok_or_else(|| "offers missing in UpdatePromoOffersRequest".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<UpdatePromoOffersRequest> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<UpdatePromoOffersRequest>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<UpdatePromoOffersRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for UpdatePromoOffersRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<UpdatePromoOffersRequest> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <UpdatePromoOffersRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into UpdatePromoOffersRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Результат добавления товаров в акцию.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct UpdatePromoOffersResponse {
    #[serde(rename = "status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<models::ApiResponseStatusType>,

    #[serde(rename = "result")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub result: Option<models::UpdatePromoOffersResultDto>,

}


impl UpdatePromoOffersResponse {
    #[allow(clippy::new_without_default)]
    pub fn new() -> UpdatePromoOffersResponse {
        UpdatePromoOffersResponse {
            status: None,
            result: None,
        }
    }
}

/// Converts the UpdatePromoOffersResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for UpdatePromoOffersResponse {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping status in query parameter serialization

            // Skipping result in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a UpdatePromoOffersResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for UpdatePromoOffersResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub status: Vec<models::ApiResponseStatusType>,
            pub result: Vec<models::UpdatePromoOffersResultDto>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing UpdatePromoOffersResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(<models::ApiResponseStatusType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "result" => intermediate_rep.result.push(<models::UpdatePromoOffersResultDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing UpdatePromoOffersResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(UpdatePromoOffersResponse {
            status: intermediate_rep.status.into_iter().next(),
            result: intermediate_rep.result.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<UpdatePromoOffersResponse> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<UpdatePromoOffersResponse>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<UpdatePromoOffersResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for UpdatePromoOffersResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<UpdatePromoOffersResponse> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <UpdatePromoOffersResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into UpdatePromoOffersResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Ошибки и предупреждения, которые появились при добавлении товаров в акцию.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct UpdatePromoOffersResultDto {
    /// Изменения, которые были отклонены.  Возвращается, только если есть отклоненные изменения. 
    #[serde(rename = "rejectedOffers")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub rejected_offers: Option<swagger::Nullable<Vec<models::RejectedPromoOfferUpdateDto>>>,

    /// Изменения, по которым есть предупреждения. Они информируют о возможных проблемах. Информация о товарах обновится.  Возвращается, только если есть предупреждения. 
    #[serde(rename = "warningOffers")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub warning_offers: Option<swagger::Nullable<Vec<models::WarningPromoOfferUpdateDto>>>,

}


impl UpdatePromoOffersResultDto {
    #[allow(clippy::new_without_default)]
    pub fn new() -> UpdatePromoOffersResultDto {
        UpdatePromoOffersResultDto {
            rejected_offers: None,
            warning_offers: None,
        }
    }
}

/// Converts the UpdatePromoOffersResultDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for UpdatePromoOffersResultDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping rejectedOffers in query parameter serialization

            // Skipping warningOffers in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a UpdatePromoOffersResultDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for UpdatePromoOffersResultDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub rejected_offers: Vec<Vec<models::RejectedPromoOfferUpdateDto>>,
            pub warning_offers: Vec<Vec<models::WarningPromoOfferUpdateDto>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing UpdatePromoOffersResultDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "rejectedOffers" => return std::result::Result::Err("Parsing a container in this style is not supported in UpdatePromoOffersResultDto".to_string()),
                    "warningOffers" => return std::result::Result::Err("Parsing a container in this style is not supported in UpdatePromoOffersResultDto".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing UpdatePromoOffersResultDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(UpdatePromoOffersResultDto {
            rejected_offers: std::result::Result::Err("Nullable types not supported in UpdatePromoOffersResultDto".to_string())?,
            warning_offers: std::result::Result::Err("Nullable types not supported in UpdatePromoOffersResultDto".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<UpdatePromoOffersResultDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<UpdatePromoOffersResultDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<UpdatePromoOffersResultDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for UpdatePromoOffersResultDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<UpdatePromoOffersResultDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <UpdatePromoOffersResultDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into UpdatePromoOffersResultDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Информация об остатках одного товара на одном из складов.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct UpdateStockDto {
    /// Ваш SKU — идентификатор товара в вашей системе.  Разрешена любая последовательность длиной до 255 знаков.  Правила использования SKU:  * У каждого товара SKU должен быть свой.  * SKU товара нельзя менять — можно только удалить товар и добавить заново с новым SKU.  * Уже заданный SKU нельзя освободить и использовать заново для другого товара. Каждый товар должен получать новый идентификатор, до того никогда не использовавшийся в вашем каталоге.  [Что такое SKU и как его назначать](https://yandex.ru/support/marketplace/assortment/add/index.html#fields) 
    #[serde(rename = "sku")]
    #[validate(
            length(min = 1, max = 255),
           regex = "RE_UPDATESTOCKDTO_SKU",
        )]
    pub sku: String,

    /// Информация об остатках товара. 
    #[serde(rename = "items")]
    #[validate(
            length(min = 1, max = 1),
        )]
    pub items: Vec<models::UpdateStockItemDto>,

}

lazy_static::lazy_static! {
    static ref RE_UPDATESTOCKDTO_SKU: regex::Regex = regex::Regex::new(r"^[^\\x00-\\x08\\x0A-\\x1f\\x7f]{1,255}$").unwrap();
}

impl UpdateStockDto {
    #[allow(clippy::new_without_default)]
    pub fn new(sku: String, items: Vec<models::UpdateStockItemDto>, ) -> UpdateStockDto {
        UpdateStockDto {
            sku,
            items,
        }
    }
}

/// Converts the UpdateStockDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for UpdateStockDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            Some("sku".to_string()),
            Some(self.sku.to_string()),

            // Skipping items in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a UpdateStockDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for UpdateStockDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub sku: Vec<String>,
            pub items: Vec<Vec<models::UpdateStockItemDto>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing UpdateStockDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "sku" => intermediate_rep.sku.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "items" => return std::result::Result::Err("Parsing a container in this style is not supported in UpdateStockDto".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing UpdateStockDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(UpdateStockDto {
            sku: intermediate_rep.sku.into_iter().next().ok_or_else(|| "sku missing in UpdateStockDto".to_string())?,
            items: intermediate_rep.items.into_iter().next().ok_or_else(|| "items missing in UpdateStockDto".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<UpdateStockDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<UpdateStockDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<UpdateStockDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for UpdateStockDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<UpdateStockDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <UpdateStockDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into UpdateStockDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Информация об остатках товара. 
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct UpdateStockItemDto {
    /// Количество доступного товара. 
    #[serde(rename = "count")]
    #[validate(
            range(min = 0, max = 2000000000),
        )]
    pub count: i64,

    /// Дата и время последнего обновления информации об остатках. <br><br> Если вы не передали параметр `updatedAt`, используется текущее время. <br><br> Формат даты и времени: ISO 8601 со смещением относительно UTC. Например, `2017-11-21T00:42:42+03:00`. 
    #[serde(rename = "updatedAt")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime::<chrono::Utc>>,

}


impl UpdateStockItemDto {
    #[allow(clippy::new_without_default)]
    pub fn new(count: i64, ) -> UpdateStockItemDto {
        UpdateStockItemDto {
            count,
            updated_at: None,
        }
    }
}

/// Converts the UpdateStockItemDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for UpdateStockItemDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            Some("count".to_string()),
            Some(self.count.to_string()),

            // Skipping updatedAt in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a UpdateStockItemDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for UpdateStockItemDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub count: Vec<i64>,
            pub updated_at: Vec<chrono::DateTime::<chrono::Utc>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing UpdateStockItemDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "count" => intermediate_rep.count.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "updatedAt" => intermediate_rep.updated_at.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing UpdateStockItemDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(UpdateStockItemDto {
            count: intermediate_rep.count.into_iter().next().ok_or_else(|| "count missing in UpdateStockItemDto".to_string())?,
            updated_at: intermediate_rep.updated_at.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<UpdateStockItemDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<UpdateStockItemDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<UpdateStockItemDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for UpdateStockItemDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<UpdateStockItemDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <UpdateStockItemDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into UpdateStockItemDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Запрос на изменение информации по остаткам товаров.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct UpdateStocksRequest {
    /// Данные об остатках товаров. 
    #[serde(rename = "skus")]
    #[validate(
            length(min = 1, max = 2000),
        )]
    pub skus: Vec<models::UpdateStockDto>,

}


impl UpdateStocksRequest {
    #[allow(clippy::new_without_default)]
    pub fn new(skus: Vec<models::UpdateStockDto>, ) -> UpdateStocksRequest {
        UpdateStocksRequest {
            skus,
        }
    }
}

/// Converts the UpdateStocksRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for UpdateStocksRequest {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping skus in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a UpdateStocksRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for UpdateStocksRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub skus: Vec<Vec<models::UpdateStockDto>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing UpdateStocksRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "skus" => return std::result::Result::Err("Parsing a container in this style is not supported in UpdateStocksRequest".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing UpdateStocksRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(UpdateStocksRequest {
            skus: intermediate_rep.skus.into_iter().next().ok_or_else(|| "skus missing in UpdateStocksRequest".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<UpdateStocksRequest> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<UpdateStocksRequest>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<UpdateStocksRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for UpdateStocksRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<UpdateStocksRequest> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <UpdateStocksRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into UpdateStocksRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Время последнего обновления.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct UpdateTimeDto {
    /// Время последнего обновления.
    #[serde(rename = "updatedAt")]
    pub updated_at: chrono::DateTime::<chrono::Utc>,

}


impl UpdateTimeDto {
    #[allow(clippy::new_without_default)]
    pub fn new(updated_at: chrono::DateTime::<chrono::Utc>, ) -> UpdateTimeDto {
        UpdateTimeDto {
            updated_at,
        }
    }
}

/// Converts the UpdateTimeDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for UpdateTimeDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping updatedAt in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a UpdateTimeDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for UpdateTimeDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub updated_at: Vec<chrono::DateTime::<chrono::Utc>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing UpdateTimeDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "updatedAt" => intermediate_rep.updated_at.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing UpdateTimeDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(UpdateTimeDto {
            updated_at: intermediate_rep.updated_at.into_iter().next().ok_or_else(|| "updatedAt missing in UpdateTimeDto".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<UpdateTimeDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<UpdateTimeDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<UpdateTimeDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for UpdateTimeDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<UpdateTimeDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <UpdateTimeDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into UpdateTimeDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Ограничение на возможные значения, накладываемое другой характеристикой.  Если ограничивающая характеристика принимает определенное значение, список возможных значений ограничиваемой характеристики сокращается.  **Пример**  Характеристика **размер** сама по себе может принимать девять разных значений: `S`, `M`, `L`, `44`, `46`, `48`, `42/164`, `46/176`, `44S`.  Если ограничивающая характеристика **размерная сетка** принимает значение `RU`, список возможных значений размера сокращается до `44`, `46`, `48`. 
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ValueRestrictionDto {
    /// Идентификатор ограничивающей характеристики.
    #[serde(rename = "limitingParameterId")]
    pub limiting_parameter_id: i64,

    /// Значения ограничивающей характеристики и соответствующие допустимые значения текущей характеристики.
    #[serde(rename = "limitedValues")]
    pub limited_values: Vec<models::OptionValuesLimitedDto>,

}


impl ValueRestrictionDto {
    #[allow(clippy::new_without_default)]
    pub fn new(limiting_parameter_id: i64, limited_values: Vec<models::OptionValuesLimitedDto>, ) -> ValueRestrictionDto {
        ValueRestrictionDto {
            limiting_parameter_id,
            limited_values,
        }
    }
}

/// Converts the ValueRestrictionDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ValueRestrictionDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            Some("limitingParameterId".to_string()),
            Some(self.limiting_parameter_id.to_string()),

            // Skipping limitedValues in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ValueRestrictionDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ValueRestrictionDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub limiting_parameter_id: Vec<i64>,
            pub limited_values: Vec<Vec<models::OptionValuesLimitedDto>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ValueRestrictionDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "limitingParameterId" => intermediate_rep.limiting_parameter_id.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "limitedValues" => return std::result::Result::Err("Parsing a container in this style is not supported in ValueRestrictionDto".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing ValueRestrictionDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ValueRestrictionDto {
            limiting_parameter_id: intermediate_rep.limiting_parameter_id.into_iter().next().ok_or_else(|| "limitingParameterId missing in ValueRestrictionDto".to_string())?,
            limited_values: intermediate_rep.limited_values.into_iter().next().ok_or_else(|| "limitedValues missing in ValueRestrictionDto".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ValueRestrictionDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<ValueRestrictionDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ValueRestrictionDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ValueRestrictionDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<ValueRestrictionDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ValueRestrictionDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ValueRestrictionDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct VerifyOrderEacRequest {
    /// Код для подтверждения ЭАПП.
    #[serde(rename = "code")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub code: Option<String>,

}


impl VerifyOrderEacRequest {
    #[allow(clippy::new_without_default)]
    pub fn new() -> VerifyOrderEacRequest {
        VerifyOrderEacRequest {
            code: None,
        }
    }
}

/// Converts the VerifyOrderEacRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for VerifyOrderEacRequest {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            self.code.as_ref().map(|code| {
                [
                    "code".to_string(),
                    code.to_string(),
                ].join(",")
            }),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a VerifyOrderEacRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for VerifyOrderEacRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub code: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing VerifyOrderEacRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "code" => intermediate_rep.code.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing VerifyOrderEacRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(VerifyOrderEacRequest {
            code: intermediate_rep.code.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<VerifyOrderEacRequest> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<VerifyOrderEacRequest>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<VerifyOrderEacRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for VerifyOrderEacRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<VerifyOrderEacRequest> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <VerifyOrderEacRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into VerifyOrderEacRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct VerifyOrderEacResponse {
    #[serde(rename = "status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<models::ApiResponseStatusType>,

    #[serde(rename = "result")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub result: Option<models::EacVerificationResultDto>,

}


impl VerifyOrderEacResponse {
    #[allow(clippy::new_without_default)]
    pub fn new() -> VerifyOrderEacResponse {
        VerifyOrderEacResponse {
            status: None,
            result: None,
        }
    }
}

/// Converts the VerifyOrderEacResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for VerifyOrderEacResponse {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping status in query parameter serialization

            // Skipping result in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a VerifyOrderEacResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for VerifyOrderEacResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub status: Vec<models::ApiResponseStatusType>,
            pub result: Vec<models::EacVerificationResultDto>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing VerifyOrderEacResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(<models::ApiResponseStatusType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "result" => intermediate_rep.result.push(<models::EacVerificationResultDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing VerifyOrderEacResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(VerifyOrderEacResponse {
            status: intermediate_rep.status.into_iter().next(),
            result: intermediate_rep.result.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<VerifyOrderEacResponse> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<VerifyOrderEacResponse>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<VerifyOrderEacResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for VerifyOrderEacResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<VerifyOrderEacResponse> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <VerifyOrderEacResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into VerifyOrderEacResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Адрес склада.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct WarehouseAddressDto {
    /// Город.
    #[serde(rename = "city")]
    #[validate(
            length(max = 200),
        )]
    pub city: String,

    /// Улица.
    #[serde(rename = "street")]
    #[validate(
            length(max = 512),
        )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub street: Option<String>,

    /// Номер дома.
    #[serde(rename = "number")]
    #[validate(
            length(max = 256),
        )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub number: Option<String>,

    /// Номер строения.
    #[serde(rename = "building")]
    #[validate(
            length(max = 16),
        )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub building: Option<String>,

    /// Номер корпуса.
    #[serde(rename = "block")]
    #[validate(
            length(max = 16),
        )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub block: Option<String>,

    #[serde(rename = "gps")]
    pub gps: models::GpsDto,

}


impl WarehouseAddressDto {
    #[allow(clippy::new_without_default)]
    pub fn new(city: String, gps: models::GpsDto, ) -> WarehouseAddressDto {
        WarehouseAddressDto {
            city,
            street: None,
            number: None,
            building: None,
            block: None,
            gps,
        }
    }
}

/// Converts the WarehouseAddressDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for WarehouseAddressDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            Some("city".to_string()),
            Some(self.city.to_string()),


            self.street.as_ref().map(|street| {
                [
                    "street".to_string(),
                    street.to_string(),
                ].join(",")
            }),


            self.number.as_ref().map(|number| {
                [
                    "number".to_string(),
                    number.to_string(),
                ].join(",")
            }),


            self.building.as_ref().map(|building| {
                [
                    "building".to_string(),
                    building.to_string(),
                ].join(",")
            }),


            self.block.as_ref().map(|block| {
                [
                    "block".to_string(),
                    block.to_string(),
                ].join(",")
            }),

            // Skipping gps in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a WarehouseAddressDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for WarehouseAddressDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub city: Vec<String>,
            pub street: Vec<String>,
            pub number: Vec<String>,
            pub building: Vec<String>,
            pub block: Vec<String>,
            pub gps: Vec<models::GpsDto>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing WarehouseAddressDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "city" => intermediate_rep.city.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "street" => intermediate_rep.street.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "number" => intermediate_rep.number.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "building" => intermediate_rep.building.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "block" => intermediate_rep.block.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "gps" => intermediate_rep.gps.push(<models::GpsDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing WarehouseAddressDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(WarehouseAddressDto {
            city: intermediate_rep.city.into_iter().next().ok_or_else(|| "city missing in WarehouseAddressDto".to_string())?,
            street: intermediate_rep.street.into_iter().next(),
            number: intermediate_rep.number.into_iter().next(),
            building: intermediate_rep.building.into_iter().next(),
            block: intermediate_rep.block.into_iter().next(),
            gps: intermediate_rep.gps.into_iter().next().ok_or_else(|| "gps missing in WarehouseAddressDto".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<WarehouseAddressDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<WarehouseAddressDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<WarehouseAddressDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for WarehouseAddressDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<WarehouseAddressDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <WarehouseAddressDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into WarehouseAddressDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Информация о складе.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct WarehouseDto {
    /// Идентификатор склада.
    #[serde(rename = "id")]
    pub id: i64,

    /// Название склада.
    #[serde(rename = "name")]
    pub name: String,

    /// Идентификатор кампании в API и идентификатор магазина.
    #[serde(rename = "campaignId")]
    pub campaign_id: i64,

    /// Возможна ли доставка по модели Экспресс.
    #[serde(rename = "express")]
    pub express: bool,

    #[serde(rename = "address")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub address: Option<models::WarehouseAddressDto>,

}


impl WarehouseDto {
    #[allow(clippy::new_without_default)]
    pub fn new(id: i64, name: String, campaign_id: i64, express: bool, ) -> WarehouseDto {
        WarehouseDto {
            id,
            name,
            campaign_id,
            express,
            address: None,
        }
    }
}

/// Converts the WarehouseDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for WarehouseDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            Some("id".to_string()),
            Some(self.id.to_string()),


            Some("name".to_string()),
            Some(self.name.to_string()),


            Some("campaignId".to_string()),
            Some(self.campaign_id.to_string()),


            Some("express".to_string()),
            Some(self.express.to_string()),

            // Skipping address in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a WarehouseDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for WarehouseDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<i64>,
            pub name: Vec<String>,
            pub campaign_id: Vec<i64>,
            pub express: Vec<bool>,
            pub address: Vec<models::WarehouseAddressDto>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing WarehouseDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "campaignId" => intermediate_rep.campaign_id.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "express" => intermediate_rep.express.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "address" => intermediate_rep.address.push(<models::WarehouseAddressDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing WarehouseDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(WarehouseDto {
            id: intermediate_rep.id.into_iter().next().ok_or_else(|| "id missing in WarehouseDto".to_string())?,
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "name missing in WarehouseDto".to_string())?,
            campaign_id: intermediate_rep.campaign_id.into_iter().next().ok_or_else(|| "campaignId missing in WarehouseDto".to_string())?,
            express: intermediate_rep.express.into_iter().next().ok_or_else(|| "express missing in WarehouseDto".to_string())?,
            address: intermediate_rep.address.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<WarehouseDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<WarehouseDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<WarehouseDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for WarehouseDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<WarehouseDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <WarehouseDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into WarehouseDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Информация о группе складов.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct WarehouseGroupDto {
    /// Название группы складов.
    #[serde(rename = "name")]
    pub name: String,

    #[serde(rename = "mainWarehouse")]
    pub main_warehouse: models::WarehouseDto,

    /// Список складов, входящих в группу.
    #[serde(rename = "warehouses")]
    pub warehouses: Vec<models::WarehouseDto>,

}


impl WarehouseGroupDto {
    #[allow(clippy::new_without_default)]
    pub fn new(name: String, main_warehouse: models::WarehouseDto, warehouses: Vec<models::WarehouseDto>, ) -> WarehouseGroupDto {
        WarehouseGroupDto {
            name,
            main_warehouse,
            warehouses,
        }
    }
}

/// Converts the WarehouseGroupDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for WarehouseGroupDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            Some("name".to_string()),
            Some(self.name.to_string()),

            // Skipping mainWarehouse in query parameter serialization

            // Skipping warehouses in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a WarehouseGroupDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for WarehouseGroupDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub name: Vec<String>,
            pub main_warehouse: Vec<models::WarehouseDto>,
            pub warehouses: Vec<Vec<models::WarehouseDto>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing WarehouseGroupDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "mainWarehouse" => intermediate_rep.main_warehouse.push(<models::WarehouseDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "warehouses" => return std::result::Result::Err("Parsing a container in this style is not supported in WarehouseGroupDto".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing WarehouseGroupDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(WarehouseGroupDto {
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "name missing in WarehouseGroupDto".to_string())?,
            main_warehouse: intermediate_rep.main_warehouse.into_iter().next().ok_or_else(|| "mainWarehouse missing in WarehouseGroupDto".to_string())?,
            warehouses: intermediate_rep.warehouses.into_iter().next().ok_or_else(|| "warehouses missing in WarehouseGroupDto".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<WarehouseGroupDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<WarehouseGroupDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<WarehouseGroupDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for WarehouseGroupDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<WarehouseGroupDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <WarehouseGroupDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into WarehouseGroupDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Информация об остатках товара.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct WarehouseOfferDto {
    /// Ваш SKU — идентификатор товара в вашей системе.  Разрешена любая последовательность длиной до 255 знаков.  Правила использования SKU:  * У каждого товара SKU должен быть свой.  * SKU товара нельзя менять — можно только удалить товар и добавить заново с новым SKU.  * Уже заданный SKU нельзя освободить и использовать заново для другого товара. Каждый товар должен получать новый идентификатор, до того никогда не использовавшийся в вашем каталоге.  [Что такое SKU и как его назначать](https://yandex.ru/support/marketplace/assortment/add/index.html#fields) 
    #[serde(rename = "offerId")]
    #[validate(
            length(min = 1, max = 255),
           regex = "RE_WAREHOUSEOFFERDTO_OFFER_ID",
        )]
    pub offer_id: String,

    #[serde(rename = "turnoverSummary")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub turnover_summary: Option<models::TurnoverDto>,

    /// Информация об остатках.
    #[serde(rename = "stocks")]
    pub stocks: Vec<models::WarehouseStockDto>,

    /// Дата и время последнего обновления информации об остатках.  Формат даты и времени: ISO 8601 со смещением относительно UTC. Например, `2023-11-21T00:42:42+03:00`. 
    #[serde(rename = "updatedAt")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime::<chrono::Utc>>,

}

lazy_static::lazy_static! {
    static ref RE_WAREHOUSEOFFERDTO_OFFER_ID: regex::Regex = regex::Regex::new(r"^[^\\x00-\\x08\\x0A-\\x1f\\x7f]{1,255}$").unwrap();
}

impl WarehouseOfferDto {
    #[allow(clippy::new_without_default)]
    pub fn new(offer_id: String, stocks: Vec<models::WarehouseStockDto>, ) -> WarehouseOfferDto {
        WarehouseOfferDto {
            offer_id,
            turnover_summary: None,
            stocks,
            updated_at: None,
        }
    }
}

/// Converts the WarehouseOfferDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for WarehouseOfferDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            Some("offerId".to_string()),
            Some(self.offer_id.to_string()),

            // Skipping turnoverSummary in query parameter serialization

            // Skipping stocks in query parameter serialization

            // Skipping updatedAt in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a WarehouseOfferDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for WarehouseOfferDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub offer_id: Vec<String>,
            pub turnover_summary: Vec<models::TurnoverDto>,
            pub stocks: Vec<Vec<models::WarehouseStockDto>>,
            pub updated_at: Vec<chrono::DateTime::<chrono::Utc>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing WarehouseOfferDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "offerId" => intermediate_rep.offer_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "turnoverSummary" => intermediate_rep.turnover_summary.push(<models::TurnoverDto as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "stocks" => return std::result::Result::Err("Parsing a container in this style is not supported in WarehouseOfferDto".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "updatedAt" => intermediate_rep.updated_at.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing WarehouseOfferDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(WarehouseOfferDto {
            offer_id: intermediate_rep.offer_id.into_iter().next().ok_or_else(|| "offerId missing in WarehouseOfferDto".to_string())?,
            turnover_summary: intermediate_rep.turnover_summary.into_iter().next(),
            stocks: intermediate_rep.stocks.into_iter().next().ok_or_else(|| "stocks missing in WarehouseOfferDto".to_string())?,
            updated_at: intermediate_rep.updated_at.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<WarehouseOfferDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<WarehouseOfferDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<WarehouseOfferDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for WarehouseOfferDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<WarehouseOfferDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <WarehouseOfferDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into WarehouseOfferDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Информация об остатках товаров на складе.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct WarehouseOffersDto {
    /// Идентификатор склада.
    #[serde(rename = "warehouseId")]
    pub warehouse_id: i64,

    /// Информация об остатках.
    #[serde(rename = "offers")]
    pub offers: Vec<models::WarehouseOfferDto>,

}


impl WarehouseOffersDto {
    #[allow(clippy::new_without_default)]
    pub fn new(warehouse_id: i64, offers: Vec<models::WarehouseOfferDto>, ) -> WarehouseOffersDto {
        WarehouseOffersDto {
            warehouse_id,
            offers,
        }
    }
}

/// Converts the WarehouseOffersDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for WarehouseOffersDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            Some("warehouseId".to_string()),
            Some(self.warehouse_id.to_string()),

            // Skipping offers in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a WarehouseOffersDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for WarehouseOffersDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub warehouse_id: Vec<i64>,
            pub offers: Vec<Vec<models::WarehouseOfferDto>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing WarehouseOffersDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "warehouseId" => intermediate_rep.warehouse_id.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "offers" => return std::result::Result::Err("Parsing a container in this style is not supported in WarehouseOffersDto".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing WarehouseOffersDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(WarehouseOffersDto {
            warehouse_id: intermediate_rep.warehouse_id.into_iter().next().ok_or_else(|| "warehouseId missing in WarehouseOffersDto".to_string())?,
            offers: intermediate_rep.offers.into_iter().next().ok_or_else(|| "offers missing in WarehouseOffersDto".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<WarehouseOffersDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<WarehouseOffersDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<WarehouseOffersDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for WarehouseOffersDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<WarehouseOffersDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <WarehouseOffersDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into WarehouseOffersDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Информация об остатках товара.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct WarehouseStockDto {
    #[serde(rename = "type")]
    pub r#type: models::WarehouseStockType,

    /// Значение остатков.
    #[serde(rename = "count")]
    pub count: i64,

}


impl WarehouseStockDto {
    #[allow(clippy::new_without_default)]
    pub fn new(r#type: models::WarehouseStockType, count: i64, ) -> WarehouseStockDto {
        WarehouseStockDto {
            r#type,
            count,
        }
    }
}

/// Converts the WarehouseStockDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for WarehouseStockDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping type in query parameter serialization


            Some("count".to_string()),
            Some(self.count.to_string()),

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a WarehouseStockDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for WarehouseStockDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub r#type: Vec<models::WarehouseStockType>,
            pub count: Vec<i64>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing WarehouseStockDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r#type.push(<models::WarehouseStockType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "count" => intermediate_rep.count.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing WarehouseStockDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(WarehouseStockDto {
            r#type: intermediate_rep.r#type.into_iter().next().ok_or_else(|| "type missing in WarehouseStockDto".to_string())?,
            count: intermediate_rep.count.into_iter().next().ok_or_else(|| "count missing in WarehouseStockDto".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<WarehouseStockDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<WarehouseStockDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<WarehouseStockDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for WarehouseStockDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<WarehouseStockDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <WarehouseStockDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into WarehouseStockDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Тип остатков товаров на складе:  * `AVAILABLE` (соответствует типу «Доступный к заказу» в отчете «Остатки на складе» в кабинете продавца на Маркете) — товар, доступный для продажи.  * `DEFECT` (соответствует типу «Брак») — товар с браком.  * `EXPIRED` (соответствует типу «Просрочен») — товар с истекшим сроком годности.  * `FIT` (соответствует типу «Годный») — товар, который доступен для продажи или уже зарезервирован.  * `FREEZE` — товар, который зарезервирован для заказов.  * `QUARANTINE` (соответствует типу «Карантин») — товар, временно недоступный для продажи (например, товар перемещают из одного помещения склада в другое).  * `UTILIZATION` — товар, который будет утилизирован. 
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum WarehouseStockType {
    #[serde(rename = "FIT")]
    Fit,
    #[serde(rename = "FREEZE")]
    Freeze,
    #[serde(rename = "AVAILABLE")]
    Available,
    #[serde(rename = "QUARANTINE")]
    Quarantine,
    #[serde(rename = "UTILIZATION")]
    Utilization,
    #[serde(rename = "DEFECT")]
    Defect,
    #[serde(rename = "EXPIRED")]
    Expired,
}

impl std::fmt::Display for WarehouseStockType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            WarehouseStockType::Fit => write!(f, "FIT"),
            WarehouseStockType::Freeze => write!(f, "FREEZE"),
            WarehouseStockType::Available => write!(f, "AVAILABLE"),
            WarehouseStockType::Quarantine => write!(f, "QUARANTINE"),
            WarehouseStockType::Utilization => write!(f, "UTILIZATION"),
            WarehouseStockType::Defect => write!(f, "DEFECT"),
            WarehouseStockType::Expired => write!(f, "EXPIRED"),
        }
    }
}

impl std::str::FromStr for WarehouseStockType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "FIT" => std::result::Result::Ok(WarehouseStockType::Fit),
            "FREEZE" => std::result::Result::Ok(WarehouseStockType::Freeze),
            "AVAILABLE" => std::result::Result::Ok(WarehouseStockType::Available),
            "QUARANTINE" => std::result::Result::Ok(WarehouseStockType::Quarantine),
            "UTILIZATION" => std::result::Result::Ok(WarehouseStockType::Utilization),
            "DEFECT" => std::result::Result::Ok(WarehouseStockType::Defect),
            "EXPIRED" => std::result::Result::Ok(WarehouseStockType::Expired),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Информация о складах и группах складов.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct WarehousesDto {
    /// Список складов, не входящих в группы.
    #[serde(rename = "warehouses")]
    pub warehouses: Vec<models::WarehouseDto>,

    /// Список групп складов.
    #[serde(rename = "warehouseGroups")]
    pub warehouse_groups: Vec<models::WarehouseGroupDto>,

}


impl WarehousesDto {
    #[allow(clippy::new_without_default)]
    pub fn new(warehouses: Vec<models::WarehouseDto>, warehouse_groups: Vec<models::WarehouseGroupDto>, ) -> WarehousesDto {
        WarehousesDto {
            warehouses,
            warehouse_groups,
        }
    }
}

/// Converts the WarehousesDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for WarehousesDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping warehouses in query parameter serialization

            // Skipping warehouseGroups in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a WarehousesDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for WarehousesDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub warehouses: Vec<Vec<models::WarehouseDto>>,
            pub warehouse_groups: Vec<Vec<models::WarehouseGroupDto>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing WarehousesDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "warehouses" => return std::result::Result::Err("Parsing a container in this style is not supported in WarehousesDto".to_string()),
                    "warehouseGroups" => return std::result::Result::Err("Parsing a container in this style is not supported in WarehousesDto".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing WarehousesDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(WarehousesDto {
            warehouses: intermediate_rep.warehouses.into_iter().next().ok_or_else(|| "warehouses missing in WarehousesDto".to_string())?,
            warehouse_groups: intermediate_rep.warehouse_groups.into_iter().next().ok_or_else(|| "warehouseGroups missing in WarehousesDto".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<WarehousesDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<WarehousesDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<WarehousesDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for WarehousesDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<WarehousesDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <WarehousesDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into WarehousesDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Описание предупреждения, которое появилось при добавлении товара.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct WarningPromoOfferUpdateDto {
    /// Ваш SKU — идентификатор товара в вашей системе.  Разрешена любая последовательность длиной до 255 знаков.  Правила использования SKU:  * У каждого товара SKU должен быть свой.  * SKU товара нельзя менять — можно только удалить товар и добавить заново с новым SKU.  * Уже заданный SKU нельзя освободить и использовать заново для другого товара. Каждый товар должен получать новый идентификатор, до того никогда не использовавшийся в вашем каталоге.  [Что такое SKU и как его назначать](https://yandex.ru/support/marketplace/assortment/add/index.html#fields) 
    #[serde(rename = "offerId")]
    #[validate(
            length(min = 1, max = 255),
           regex = "RE_WARNINGPROMOOFFERUPDATEDTO_OFFER_ID",
        )]
    pub offer_id: String,

    /// Предупреждения, которые появились при добавлении товара в акцию или изменении его цен.
    #[serde(rename = "warnings")]
    pub warnings: Vec<models::PromoOfferUpdateWarningDto>,

}

lazy_static::lazy_static! {
    static ref RE_WARNINGPROMOOFFERUPDATEDTO_OFFER_ID: regex::Regex = regex::Regex::new(r"^[^\\x00-\\x08\\x0A-\\x1f\\x7f]{1,255}$").unwrap();
}

impl WarningPromoOfferUpdateDto {
    #[allow(clippy::new_without_default)]
    pub fn new(offer_id: String, warnings: Vec<models::PromoOfferUpdateWarningDto>, ) -> WarningPromoOfferUpdateDto {
        WarningPromoOfferUpdateDto {
            offer_id,
            warnings,
        }
    }
}

/// Converts the WarningPromoOfferUpdateDto value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for WarningPromoOfferUpdateDto {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![

            Some("offerId".to_string()),
            Some(self.offer_id.to_string()),

            // Skipping warnings in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a WarningPromoOfferUpdateDto value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for WarningPromoOfferUpdateDto {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub offer_id: Vec<String>,
            pub warnings: Vec<Vec<models::PromoOfferUpdateWarningDto>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing WarningPromoOfferUpdateDto".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "offerId" => intermediate_rep.offer_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "warnings" => return std::result::Result::Err("Parsing a container in this style is not supported in WarningPromoOfferUpdateDto".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing WarningPromoOfferUpdateDto".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(WarningPromoOfferUpdateDto {
            offer_id: intermediate_rep.offer_id.into_iter().next().ok_or_else(|| "offerId missing in WarningPromoOfferUpdateDto".to_string())?,
            warnings: intermediate_rep.warnings.into_iter().next().ok_or_else(|| "warnings missing in WarningPromoOfferUpdateDto".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<WarningPromoOfferUpdateDto> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<WarningPromoOfferUpdateDto>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<WarningPromoOfferUpdateDto>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for WarningPromoOfferUpdateDto - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<WarningPromoOfferUpdateDto> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <WarningPromoOfferUpdateDto as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into WarningPromoOfferUpdateDto - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}

