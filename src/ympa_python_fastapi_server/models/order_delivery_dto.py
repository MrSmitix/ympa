# coding: utf-8

"""
    Партнерский API Маркета

    API Яндекс Маркета помогает продавцам автоматизировать и упростить работу с маркетплейсом.  В числе возможностей интеграции:  * управление каталогом товаров и витриной,  * обработка заказов,  * изменение настроек магазина,  * получение отчетов. 

    The version of the OpenAPI document: LATEST
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json




from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictFloat, StrictInt, StrictStr
from typing import Any, ClassVar, Dict, List, Optional, Union
from ympa_python_fastapi_server.models.order_courier_dto import OrderCourierDTO
from ympa_python_fastapi_server.models.order_delivery_address_dto import OrderDeliveryAddressDTO
from ympa_python_fastapi_server.models.order_delivery_dates_dto import OrderDeliveryDatesDTO
from ympa_python_fastapi_server.models.order_delivery_dispatch_type import OrderDeliveryDispatchType
from ympa_python_fastapi_server.models.order_delivery_eac_type import OrderDeliveryEacType
from ympa_python_fastapi_server.models.order_delivery_partner_type import OrderDeliveryPartnerType
from ympa_python_fastapi_server.models.order_delivery_type import OrderDeliveryType
from ympa_python_fastapi_server.models.order_lift_type import OrderLiftType
from ympa_python_fastapi_server.models.order_shipment_dto import OrderShipmentDTO
from ympa_python_fastapi_server.models.order_track_dto import OrderTrackDTO
from ympa_python_fastapi_server.models.order_vat_type import OrderVatType
from ympa_python_fastapi_server.models.region_dto import RegionDTO
try:
    from typing import Self
except ImportError:
    from typing_extensions import Self

class OrderDeliveryDTO(BaseModel):
    """
    Информация о доставке.
    """ # noqa: E501
    id: Optional[StrictStr] = Field(default=None, description="Идентификатор доставки, присвоенный магазином.  Указывается, только если магазин передал данный идентификатор в ответе на запрос методом [POST cart](../../pushapi/reference/cart.md). ")
    type: Optional[OrderDeliveryType] = None
    service_name: Optional[StrictStr] = Field(default=None, description="Наименование службы доставки.", alias="serviceName")
    price: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="{% note warning \"\" %}  Этот параметр устарел. Стоимость доставки смотрите в параметре `deliveryTotal`.  {% endnote %}  Стоимость доставки в валюте заказа. ")
    delivery_partner_type: Optional[OrderDeliveryPartnerType] = Field(default=None, alias="deliveryPartnerType")
    courier: Optional[OrderCourierDTO] = None
    dates: Optional[OrderDeliveryDatesDTO] = None
    region: Optional[RegionDTO] = None
    address: Optional[OrderDeliveryAddressDTO] = None
    vat: Optional[OrderVatType] = None
    delivery_service_id: Optional[StrictInt] = Field(default=None, description="Идентификатор службы доставки.", alias="deliveryServiceId")
    lift_type: Optional[OrderLiftType] = Field(default=None, alias="liftType")
    lift_price: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="Стоимость подъема на этаж.", alias="liftPrice")
    outlet_code: Optional[StrictStr] = Field(default=None, description="Идентификатор пункта самовывоза, присвоенный магазином.", alias="outletCode")
    outlet_storage_limit_date: Optional[StrictStr] = Field(default=None, description="Формат даты: `ДД-ММ-ГГГГ`. ", alias="outletStorageLimitDate")
    dispatch_type: Optional[OrderDeliveryDispatchType] = Field(default=None, alias="dispatchType")
    tracks: Optional[List[OrderTrackDTO]] = Field(default=None, description="Информация для отслеживания перемещений посылки.")
    shipments: Optional[List[OrderShipmentDTO]] = Field(default=None, description="Информация о посылках.")
    estimated: Optional[StrictBool] = Field(default=None, description="Приблизительная ли дата доставки.")
    eac_type: Optional[OrderDeliveryEacType] = Field(default=None, alias="eacType")
    eac_code: Optional[StrictStr] = Field(default=None, description="Код подтверждения ЭАПП (для типа `MERCHANT_TO_COURIER`). ", alias="eacCode")
    __properties: ClassVar[List[str]] = ["id", "type", "serviceName", "price", "deliveryPartnerType", "courier", "dates", "region", "address", "vat", "deliveryServiceId", "liftType", "liftPrice", "outletCode", "outletStorageLimitDate", "dispatchType", "tracks", "shipments", "estimated", "eacType", "eacCode"]

    model_config = {
        "populate_by_name": True,
        "validate_assignment": True,
        "protected_namespaces": (),
    }


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Self:
        """Create an instance of OrderDeliveryDTO from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        _dict = self.model_dump(
            by_alias=True,
            exclude={
            },
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of courier
        if self.courier:
            _dict['courier'] = self.courier.to_dict()
        # override the default output from pydantic by calling `to_dict()` of dates
        if self.dates:
            _dict['dates'] = self.dates.to_dict()
        # override the default output from pydantic by calling `to_dict()` of region
        if self.region:
            _dict['region'] = self.region.to_dict()
        # override the default output from pydantic by calling `to_dict()` of address
        if self.address:
            _dict['address'] = self.address.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in tracks (list)
        _items = []
        if self.tracks:
            for _item in self.tracks:
                if _item:
                    _items.append(_item.to_dict())
            _dict['tracks'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in shipments (list)
        _items = []
        if self.shipments:
            for _item in self.shipments:
                if _item:
                    _items.append(_item.to_dict())
            _dict['shipments'] = _items
        # set to None if tracks (nullable) is None
        # and model_fields_set contains the field
        if self.tracks is None and "tracks" in self.model_fields_set:
            _dict['tracks'] = None

        # set to None if shipments (nullable) is None
        # and model_fields_set contains the field
        if self.shipments is None and "shipments" in self.model_fields_set:
            _dict['shipments'] = None

        return _dict

    @classmethod
    def from_dict(cls, obj: Dict) -> Self:
        """Create an instance of OrderDeliveryDTO from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "id": obj.get("id"),
            "type": obj.get("type"),
            "serviceName": obj.get("serviceName"),
            "price": obj.get("price"),
            "deliveryPartnerType": obj.get("deliveryPartnerType"),
            "courier": OrderCourierDTO.from_dict(obj.get("courier")) if obj.get("courier") is not None else None,
            "dates": OrderDeliveryDatesDTO.from_dict(obj.get("dates")) if obj.get("dates") is not None else None,
            "region": RegionDTO.from_dict(obj.get("region")) if obj.get("region") is not None else None,
            "address": OrderDeliveryAddressDTO.from_dict(obj.get("address")) if obj.get("address") is not None else None,
            "vat": obj.get("vat"),
            "deliveryServiceId": obj.get("deliveryServiceId"),
            "liftType": obj.get("liftType"),
            "liftPrice": obj.get("liftPrice"),
            "outletCode": obj.get("outletCode"),
            "outletStorageLimitDate": obj.get("outletStorageLimitDate"),
            "dispatchType": obj.get("dispatchType"),
            "tracks": [OrderTrackDTO.from_dict(_item) for _item in obj.get("tracks")] if obj.get("tracks") is not None else None,
            "shipments": [OrderShipmentDTO.from_dict(_item) for _item in obj.get("shipments")] if obj.get("shipments") is not None else None,
            "estimated": obj.get("estimated"),
            "eacType": obj.get("eacType"),
            "eacCode": obj.get("eacCode")
        })
        return _obj


