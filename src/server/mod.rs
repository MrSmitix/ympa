use futures::{future, future::BoxFuture, Stream, stream, future::FutureExt, stream::TryStreamExt};
use hyper::{Request, Response, StatusCode, Body, HeaderMap};
use hyper::header::{HeaderName, HeaderValue, CONTENT_TYPE};
use log::warn;
#[allow(unused_imports)]
use std::convert::{TryFrom, TryInto};
use std::error::Error;
use std::future::Future;
use std::marker::PhantomData;
use std::task::{Context, Poll};
use swagger::{ApiError, BodyExt, Has, RequestParser, XSpanIdString};
pub use swagger::auth::Authorization;
use swagger::auth::Scopes;
use url::form_urlencoded;
use multipart::server::Multipart;
use multipart::server::save::{PartialReason, SaveResult};

#[allow(unused_imports)]
use crate::{models, header, AuthenticationApi};

pub use crate::context;

type ServiceFuture = BoxFuture<'static, Result<Response<Body>, crate::ServiceError>>;

use crate::{Api,
     GetBidsInfoForBusinessResponse,
     GetBidsRecommendationsResponse,
     PutBidsForBusinessResponse,
     PutBidsForCampaignResponse,
     AddOffersToArchiveResponse,
     DeleteOffersResponse,
     DeleteOffersFromArchiveResponse,
     GetOfferMappingsResponse,
     GetSuggestedOfferMappingsResponse,
     UpdateOfferMappingsResponse,
     GetBusinessSettingsResponse,
     GetCampaignsResponse,
     GetCampaignResponse,
     GetCampaignLoginsResponse,
     GetCampaignRegionResponse,
     GetCampaignSettingsResponse,
     GetCampaignsByLoginResponse,
     GetCategoriesMaxSaleQuantumResponse,
     GetCategoriesTreeResponse,
     CreateChatResponse,
     GetChatHistoryResponse,
     GetChatsResponse,
     SendFileToChatResponse,
     SendMessageToChatResponse,
     GetCategoryContentParametersResponse,
     GetOfferCardsContentStatusResponse,
     UpdateOfferContentResponse,
     GetDeliveryServicesResponse,
     GetFeedbackAndCommentUpdatesResponse,
     GetFeedsResponse,
     GetFeedResponse,
     GetFeedIndexLogsResponse,
     RefreshFeedResponse,
     SetFeedParamsResponse,
     DeleteGoodsFeedbackCommentResponse,
     GetGoodsFeedbackCommentsResponse,
     GetGoodsFeedbacksResponse,
     SkipGoodsFeedbacksReactionResponse,
     UpdateGoodsFeedbackCommentResponse,
     GetGoodsStatsResponse,
     AddHiddenOffersResponse,
     DeleteHiddenOffersResponse,
     GetHiddenOffersResponse,
     GetModelsResponse,
     GetModelsOffersResponse,
     SearchModelsResponse,
     GetModelResponse,
     GetModelOffersResponse,
     GetOfferMappingEntriesResponse,
     GetSuggestedOfferMappingEntriesResponse,
     UpdateOfferMappingEntriesResponse,
     DeleteCampaignOffersResponse,
     GetAllOffersResponse,
     GetCampaignOffersResponse,
     GetOfferRecommendationsResponse,
     GetOffersResponse,
     UpdateCampaignOffersResponse,
     GetOrderBusinessBuyerInfoResponse,
     GetOrderBusinessDocumentsInfoResponse,
     GetOrderBuyerInfoResponse,
     SetOrderDeliveryDateResponse,
     SetOrderDeliveryTrackCodeResponse,
     UpdateOrderStorageLimitResponse,
     VerifyOrderEacResponse,
     GenerateOrderLabelsResponse,
     GetOrderLabelsDataResponse,
     GenerateOrderLabelResponse,
     GetOrdersResponse,
     UpdateOrderStatusesResponse,
     AcceptOrderCancellationResponse,
     GetOrderResponse,
     ProvideOrderDigitalCodesResponse,
     ProvideOrderItemIdentifiersResponse,
     SetOrderBoxLayoutResponse,
     UpdateOrderItemsResponse,
     UpdateOrderStatusResponse,
     SetOrderShipmentBoxesResponse,
     GetOrdersStatsResponse,
     DeleteOutletLicensesResponse,
     GetOutletLicensesResponse,
     UpdateOutletLicensesResponse,
     CreateOutletResponse,
     GetOutletsResponse,
     DeleteOutletResponse,
     GetOutletResponse,
     UpdateOutletResponse,
     ConfirmBusinessPricesResponse,
     ConfirmCampaignPricesResponse,
     GetBusinessQuarantineOffersResponse,
     GetCampaignQuarantineOffersResponse,
     GetPricesResponse,
     GetPricesByOfferIdsResponse,
     GetSuggestedPricesResponse,
     UpdateBusinessPricesResponse,
     UpdatePricesResponse,
     DeletePromoOffersResponse,
     GetPromoOffersResponse,
     GetPromosResponse,
     UpdatePromoOffersResponse,
     GetQualityRatingDetailsResponse,
     GetQualityRatingsResponse,
     SearchRegionsByNameResponse,
     SearchRegionChildrenResponse,
     SearchRegionsByIdResponse,
     GenerateBoostConsolidatedReportResponse,
     GenerateCompetitorsPositionReportResponse,
     GenerateGoodsFeedbackReportResponse,
     GenerateGoodsMovementReportResponse,
     GenerateGoodsRealizationReportResponse,
     GenerateGoodsTurnoverReportResponse,
     GenerateMassOrderLabelsReportResponse,
     GeneratePricesReportResponse,
     GenerateShelfsStatisticsReportResponse,
     GenerateShipmentListDocumentReportResponse,
     GenerateShowsSalesReportResponse,
     GenerateStocksOnWarehousesReportResponse,
     GenerateUnitedMarketplaceServicesReportResponse,
     GenerateUnitedNettingReportResponse,
     GenerateUnitedOrdersReportResponse,
     GetReportInfoResponse,
     GetReturnsResponse,
     GetReturnResponse,
     GetReturnApplicationResponse,
     SetReturnDecisionResponse,
     SubmitReturnDecisionResponse,
     GetReturnPhotoResponse,
     DownloadShipmentReceptionTransferActResponse,
     SearchShipmentsResponse,
     ConfirmShipmentResponse,
     DownloadShipmentActResponse,
     DownloadShipmentDiscrepancyActResponse,
     DownloadShipmentInboundActResponse,
     DownloadShipmentPalletLabelsResponse,
     DownloadShipmentTransportationWaybillResponse,
     GetShipmentResponse,
     GetShipmentOrdersInfoResponse,
     SetShipmentPalletsCountResponse,
     TransferOrdersFromShipmentResponse,
     GetStocksResponse,
     UpdateStocksResponse,
     CalculateTariffsResponse,
     GetFulfillmentWarehousesResponse,
     GetWarehousesResponse
};

mod server_auth;

mod paths {
    use lazy_static::lazy_static;

    lazy_static! {
        pub static ref GLOBAL_REGEX_SET: regex::RegexSet = regex::RegexSet::new(vec![
            r"^/businesses/(?P<businessId>[^/?#]*)/bids$",
            r"^/businesses/(?P<businessId>[^/?#]*)/bids/info$",
            r"^/businesses/(?P<businessId>[^/?#]*)/bids/recommendations$",
            r"^/businesses/(?P<businessId>[^/?#]*)/chats$",
            r"^/businesses/(?P<businessId>[^/?#]*)/chats/file/send$",
            r"^/businesses/(?P<businessId>[^/?#]*)/chats/history$",
            r"^/businesses/(?P<businessId>[^/?#]*)/chats/message$",
            r"^/businesses/(?P<businessId>[^/?#]*)/chats/new$",
            r"^/businesses/(?P<businessId>[^/?#]*)/goods-feedback$",
            r"^/businesses/(?P<businessId>[^/?#]*)/goods-feedback/comments$",
            r"^/businesses/(?P<businessId>[^/?#]*)/goods-feedback/comments/delete$",
            r"^/businesses/(?P<businessId>[^/?#]*)/goods-feedback/comments/update$",
            r"^/businesses/(?P<businessId>[^/?#]*)/goods-feedback/skip-reaction$",
            r"^/businesses/(?P<businessId>[^/?#]*)/offer-cards$",
            r"^/businesses/(?P<businessId>[^/?#]*)/offer-cards/update$",
            r"^/businesses/(?P<businessId>[^/?#]*)/offer-mappings$",
            r"^/businesses/(?P<businessId>[^/?#]*)/offer-mappings/archive$",
            r"^/businesses/(?P<businessId>[^/?#]*)/offer-mappings/delete$",
            r"^/businesses/(?P<businessId>[^/?#]*)/offer-mappings/suggestions$",
            r"^/businesses/(?P<businessId>[^/?#]*)/offer-mappings/unarchive$",
            r"^/businesses/(?P<businessId>[^/?#]*)/offer-mappings/update$",
            r"^/businesses/(?P<businessId>[^/?#]*)/offer-prices/updates$",
            r"^/businesses/(?P<businessId>[^/?#]*)/offers/recommendations$",
            r"^/businesses/(?P<businessId>[^/?#]*)/price-quarantine$",
            r"^/businesses/(?P<businessId>[^/?#]*)/price-quarantine/confirm$",
            r"^/businesses/(?P<businessId>[^/?#]*)/promos$",
            r"^/businesses/(?P<businessId>[^/?#]*)/promos/offers$",
            r"^/businesses/(?P<businessId>[^/?#]*)/promos/offers/delete$",
            r"^/businesses/(?P<businessId>[^/?#]*)/promos/offers/update$",
            r"^/businesses/(?P<businessId>[^/?#]*)/ratings/quality$",
            r"^/businesses/(?P<businessId>[^/?#]*)/settings$",
            r"^/businesses/(?P<businessId>[^/?#]*)/warehouses$",
            r"^/campaigns$",
            r"^/campaigns/by_login/(?P<login>[^/?#]*)$",
            r"^/campaigns/(?P<campaignId>[^/?#]*)$",
            r"^/campaigns/(?P<campaignId>[^/?#]*)/bids$",
            r"^/campaigns/(?P<campaignId>[^/?#]*)/feedback/updates$",
            r"^/campaigns/(?P<campaignId>[^/?#]*)/feeds$",
            r"^/campaigns/(?P<campaignId>[^/?#]*)/feeds/(?P<feedId>[^/?#]*)$",
            r"^/campaigns/(?P<campaignId>[^/?#]*)/feeds/(?P<feedId>[^/?#]*)/index-logs$",
            r"^/campaigns/(?P<campaignId>[^/?#]*)/feeds/(?P<feedId>[^/?#]*)/params$",
            r"^/campaigns/(?P<campaignId>[^/?#]*)/feeds/(?P<feedId>[^/?#]*)/refresh$",
            r"^/campaigns/(?P<campaignId>[^/?#]*)/first-mile/shipments$",
            r"^/campaigns/(?P<campaignId>[^/?#]*)/first-mile/shipments/(?P<shipmentId>[^/?#]*)$",
            r"^/campaigns/(?P<campaignId>[^/?#]*)/first-mile/shipments/(?P<shipmentId>[^/?#]*)/act$",
            r"^/campaigns/(?P<campaignId>[^/?#]*)/first-mile/shipments/(?P<shipmentId>[^/?#]*)/confirm$",
            r"^/campaigns/(?P<campaignId>[^/?#]*)/first-mile/shipments/(?P<shipmentId>[^/?#]*)/discrepancy-act$",
            r"^/campaigns/(?P<campaignId>[^/?#]*)/first-mile/shipments/(?P<shipmentId>[^/?#]*)/inbound-act$",
            r"^/campaigns/(?P<campaignId>[^/?#]*)/first-mile/shipments/(?P<shipmentId>[^/?#]*)/orders/info$",
            r"^/campaigns/(?P<campaignId>[^/?#]*)/first-mile/shipments/(?P<shipmentId>[^/?#]*)/orders/transfer$",
            r"^/campaigns/(?P<campaignId>[^/?#]*)/first-mile/shipments/(?P<shipmentId>[^/?#]*)/pallet/labels$",
            r"^/campaigns/(?P<campaignId>[^/?#]*)/first-mile/shipments/(?P<shipmentId>[^/?#]*)/pallets$",
            r"^/campaigns/(?P<campaignId>[^/?#]*)/first-mile/shipments/(?P<shipmentId>[^/?#]*)/transportation-waybill$",
            r"^/campaigns/(?P<campaignId>[^/?#]*)/hidden-offers$",
            r"^/campaigns/(?P<campaignId>[^/?#]*)/hidden-offers/delete$",
            r"^/campaigns/(?P<campaignId>[^/?#]*)/logins$",
            r"^/campaigns/(?P<campaignId>[^/?#]*)/offer-mapping-entries$",
            r"^/campaigns/(?P<campaignId>[^/?#]*)/offer-mapping-entries/suggestions$",
            r"^/campaigns/(?P<campaignId>[^/?#]*)/offer-mapping-entries/updates$",
            r"^/campaigns/(?P<campaignId>[^/?#]*)/offer-prices$",
            r"^/campaigns/(?P<campaignId>[^/?#]*)/offer-prices/suggestions$",
            r"^/campaigns/(?P<campaignId>[^/?#]*)/offer-prices/updates$",
            r"^/campaigns/(?P<campaignId>[^/?#]*)/offers$",
            r"^/campaigns/(?P<campaignId>[^/?#]*)/offers/all$",
            r"^/campaigns/(?P<campaignId>[^/?#]*)/offers/delete$",
            r"^/campaigns/(?P<campaignId>[^/?#]*)/offers/stocks$",
            r"^/campaigns/(?P<campaignId>[^/?#]*)/offers/update$",
            r"^/campaigns/(?P<campaignId>[^/?#]*)/orders$",
            r"^/campaigns/(?P<campaignId>[^/?#]*)/orders/status-update$",
            r"^/campaigns/(?P<campaignId>[^/?#]*)/orders/(?P<orderId>[^/?#]*)$",
            r"^/campaigns/(?P<campaignId>[^/?#]*)/orders/(?P<orderId>[^/?#]*)/boxes$",
            r"^/campaigns/(?P<campaignId>[^/?#]*)/orders/(?P<orderId>[^/?#]*)/business-buyer$",
            r"^/campaigns/(?P<campaignId>[^/?#]*)/orders/(?P<orderId>[^/?#]*)/buyer$",
            r"^/campaigns/(?P<campaignId>[^/?#]*)/orders/(?P<orderId>[^/?#]*)/cancellation/accept$",
            r"^/campaigns/(?P<campaignId>[^/?#]*)/orders/(?P<orderId>[^/?#]*)/deliverDigitalGoods$",
            r"^/campaigns/(?P<campaignId>[^/?#]*)/orders/(?P<orderId>[^/?#]*)/delivery/date$",
            r"^/campaigns/(?P<campaignId>[^/?#]*)/orders/(?P<orderId>[^/?#]*)/delivery/labels$",
            r"^/campaigns/(?P<campaignId>[^/?#]*)/orders/(?P<orderId>[^/?#]*)/delivery/labels/data$",
            r"^/campaigns/(?P<campaignId>[^/?#]*)/orders/(?P<orderId>[^/?#]*)/delivery/shipments/(?P<shipmentId>[^/?#]*)/boxes$",
            r"^/campaigns/(?P<campaignId>[^/?#]*)/orders/(?P<orderId>[^/?#]*)/delivery/shipments/(?P<shipmentId>[^/?#]*)/boxes/(?P<boxId>[^/?#]*)/label$",
            r"^/campaigns/(?P<campaignId>[^/?#]*)/orders/(?P<orderId>[^/?#]*)/delivery/storage-limit$",
            r"^/campaigns/(?P<campaignId>[^/?#]*)/orders/(?P<orderId>[^/?#]*)/delivery/track$",
            r"^/campaigns/(?P<campaignId>[^/?#]*)/orders/(?P<orderId>[^/?#]*)/documents$",
            r"^/campaigns/(?P<campaignId>[^/?#]*)/orders/(?P<orderId>[^/?#]*)/identifiers$",
            r"^/campaigns/(?P<campaignId>[^/?#]*)/orders/(?P<orderId>[^/?#]*)/items$",
            r"^/campaigns/(?P<campaignId>[^/?#]*)/orders/(?P<orderId>[^/?#]*)/returns/(?P<returnId>[^/?#]*)$",
            r"^/campaigns/(?P<campaignId>[^/?#]*)/orders/(?P<orderId>[^/?#]*)/returns/(?P<returnId>[^/?#]*)/application$",
            r"^/campaigns/(?P<campaignId>[^/?#]*)/orders/(?P<orderId>[^/?#]*)/returns/(?P<returnId>[^/?#]*)/decision$",
            r"^/campaigns/(?P<campaignId>[^/?#]*)/orders/(?P<orderId>[^/?#]*)/returns/(?P<returnId>[^/?#]*)/decision/submit$",
            r"^/campaigns/(?P<campaignId>[^/?#]*)/orders/(?P<orderId>[^/?#]*)/returns/(?P<returnId>[^/?#]*)/decision/(?P<itemId>[^/?#]*)/image/(?P<imageHash>[^/?#]*)$",
            r"^/campaigns/(?P<campaignId>[^/?#]*)/orders/(?P<orderId>[^/?#]*)/status$",
            r"^/campaigns/(?P<campaignId>[^/?#]*)/orders/(?P<orderId>[^/?#]*)/verifyEac$",
            r"^/campaigns/(?P<campaignId>[^/?#]*)/outlets$",
            r"^/campaigns/(?P<campaignId>[^/?#]*)/outlets/licenses$",
            r"^/campaigns/(?P<campaignId>[^/?#]*)/outlets/(?P<outletId>[^/?#]*)$",
            r"^/campaigns/(?P<campaignId>[^/?#]*)/price-quarantine$",
            r"^/campaigns/(?P<campaignId>[^/?#]*)/price-quarantine/confirm$",
            r"^/campaigns/(?P<campaignId>[^/?#]*)/ratings/quality/details$",
            r"^/campaigns/(?P<campaignId>[^/?#]*)/region$",
            r"^/campaigns/(?P<campaignId>[^/?#]*)/returns$",
            r"^/campaigns/(?P<campaignId>[^/?#]*)/settings$",
            r"^/campaigns/(?P<campaignId>[^/?#]*)/shipments/reception-transfer-act$",
            r"^/campaigns/(?P<campaignId>[^/?#]*)/stats/orders$",
            r"^/campaigns/(?P<campaignId>[^/?#]*)/stats/skus$",
            r"^/categories/max-sale-quantum$",
            r"^/categories/tree$",
            r"^/category/(?P<categoryId>[^/?#]*)/parameters$",
            r"^/delivery/services$",
            r"^/models$",
            r"^/models/offers$",
            r"^/models/(?P<modelId>[^/?#]*)$",
            r"^/models/(?P<modelId>[^/?#]*)/offers$",
            r"^/regions$",
            r"^/regions/(?P<regionId>[^/?#]*)$",
            r"^/regions/(?P<regionId>[^/?#]*)/children$",
            r"^/reports/boost-consolidated/generate$",
            r"^/reports/competitors-position/generate$",
            r"^/reports/documents/labels/generate$",
            r"^/reports/documents/shipment-list/generate$",
            r"^/reports/goods-feedback/generate$",
            r"^/reports/goods-movement/generate$",
            r"^/reports/goods-realization/generate$",
            r"^/reports/goods-turnover/generate$",
            r"^/reports/info/(?P<reportId>[^/?#]*)$",
            r"^/reports/prices/generate$",
            r"^/reports/shelf-statistics/generate$",
            r"^/reports/shows-sales/generate$",
            r"^/reports/stocks-on-warehouses/generate$",
            r"^/reports/united-marketplace-services/generate$",
            r"^/reports/united-netting/generate$",
            r"^/reports/united-orders/generate$",
            r"^/tariffs/calculate$",
            r"^/warehouses$"
        ])
        .expect("Unable to create global regex set");
    }
    pub(crate) static ID_BUSINESSES_BUSINESSID_BIDS: usize = 0;
    lazy_static! {
        pub static ref REGEX_BUSINESSES_BUSINESSID_BIDS: regex::Regex =
            #[allow(clippy::invalid_regex)]
            regex::Regex::new(r"^/businesses/(?P<businessId>[^/?#]*)/bids$")
                .expect("Unable to create regex for BUSINESSES_BUSINESSID_BIDS");
    }
    pub(crate) static ID_BUSINESSES_BUSINESSID_BIDS_INFO: usize = 1;
    lazy_static! {
        pub static ref REGEX_BUSINESSES_BUSINESSID_BIDS_INFO: regex::Regex =
            #[allow(clippy::invalid_regex)]
            regex::Regex::new(r"^/businesses/(?P<businessId>[^/?#]*)/bids/info$")
                .expect("Unable to create regex for BUSINESSES_BUSINESSID_BIDS_INFO");
    }
    pub(crate) static ID_BUSINESSES_BUSINESSID_BIDS_RECOMMENDATIONS: usize = 2;
    lazy_static! {
        pub static ref REGEX_BUSINESSES_BUSINESSID_BIDS_RECOMMENDATIONS: regex::Regex =
            #[allow(clippy::invalid_regex)]
            regex::Regex::new(r"^/businesses/(?P<businessId>[^/?#]*)/bids/recommendations$")
                .expect("Unable to create regex for BUSINESSES_BUSINESSID_BIDS_RECOMMENDATIONS");
    }
    pub(crate) static ID_BUSINESSES_BUSINESSID_CHATS: usize = 3;
    lazy_static! {
        pub static ref REGEX_BUSINESSES_BUSINESSID_CHATS: regex::Regex =
            #[allow(clippy::invalid_regex)]
            regex::Regex::new(r"^/businesses/(?P<businessId>[^/?#]*)/chats$")
                .expect("Unable to create regex for BUSINESSES_BUSINESSID_CHATS");
    }
    pub(crate) static ID_BUSINESSES_BUSINESSID_CHATS_FILE_SEND: usize = 4;
    lazy_static! {
        pub static ref REGEX_BUSINESSES_BUSINESSID_CHATS_FILE_SEND: regex::Regex =
            #[allow(clippy::invalid_regex)]
            regex::Regex::new(r"^/businesses/(?P<businessId>[^/?#]*)/chats/file/send$")
                .expect("Unable to create regex for BUSINESSES_BUSINESSID_CHATS_FILE_SEND");
    }
    pub(crate) static ID_BUSINESSES_BUSINESSID_CHATS_HISTORY: usize = 5;
    lazy_static! {
        pub static ref REGEX_BUSINESSES_BUSINESSID_CHATS_HISTORY: regex::Regex =
            #[allow(clippy::invalid_regex)]
            regex::Regex::new(r"^/businesses/(?P<businessId>[^/?#]*)/chats/history$")
                .expect("Unable to create regex for BUSINESSES_BUSINESSID_CHATS_HISTORY");
    }
    pub(crate) static ID_BUSINESSES_BUSINESSID_CHATS_MESSAGE: usize = 6;
    lazy_static! {
        pub static ref REGEX_BUSINESSES_BUSINESSID_CHATS_MESSAGE: regex::Regex =
            #[allow(clippy::invalid_regex)]
            regex::Regex::new(r"^/businesses/(?P<businessId>[^/?#]*)/chats/message$")
                .expect("Unable to create regex for BUSINESSES_BUSINESSID_CHATS_MESSAGE");
    }
    pub(crate) static ID_BUSINESSES_BUSINESSID_CHATS_NEW: usize = 7;
    lazy_static! {
        pub static ref REGEX_BUSINESSES_BUSINESSID_CHATS_NEW: regex::Regex =
            #[allow(clippy::invalid_regex)]
            regex::Regex::new(r"^/businesses/(?P<businessId>[^/?#]*)/chats/new$")
                .expect("Unable to create regex for BUSINESSES_BUSINESSID_CHATS_NEW");
    }
    pub(crate) static ID_BUSINESSES_BUSINESSID_GOODS_FEEDBACK: usize = 8;
    lazy_static! {
        pub static ref REGEX_BUSINESSES_BUSINESSID_GOODS_FEEDBACK: regex::Regex =
            #[allow(clippy::invalid_regex)]
            regex::Regex::new(r"^/businesses/(?P<businessId>[^/?#]*)/goods-feedback$")
                .expect("Unable to create regex for BUSINESSES_BUSINESSID_GOODS_FEEDBACK");
    }
    pub(crate) static ID_BUSINESSES_BUSINESSID_GOODS_FEEDBACK_COMMENTS: usize = 9;
    lazy_static! {
        pub static ref REGEX_BUSINESSES_BUSINESSID_GOODS_FEEDBACK_COMMENTS: regex::Regex =
            #[allow(clippy::invalid_regex)]
            regex::Regex::new(r"^/businesses/(?P<businessId>[^/?#]*)/goods-feedback/comments$")
                .expect("Unable to create regex for BUSINESSES_BUSINESSID_GOODS_FEEDBACK_COMMENTS");
    }
    pub(crate) static ID_BUSINESSES_BUSINESSID_GOODS_FEEDBACK_COMMENTS_DELETE: usize = 10;
    lazy_static! {
        pub static ref REGEX_BUSINESSES_BUSINESSID_GOODS_FEEDBACK_COMMENTS_DELETE: regex::Regex =
            #[allow(clippy::invalid_regex)]
            regex::Regex::new(r"^/businesses/(?P<businessId>[^/?#]*)/goods-feedback/comments/delete$")
                .expect("Unable to create regex for BUSINESSES_BUSINESSID_GOODS_FEEDBACK_COMMENTS_DELETE");
    }
    pub(crate) static ID_BUSINESSES_BUSINESSID_GOODS_FEEDBACK_COMMENTS_UPDATE: usize = 11;
    lazy_static! {
        pub static ref REGEX_BUSINESSES_BUSINESSID_GOODS_FEEDBACK_COMMENTS_UPDATE: regex::Regex =
            #[allow(clippy::invalid_regex)]
            regex::Regex::new(r"^/businesses/(?P<businessId>[^/?#]*)/goods-feedback/comments/update$")
                .expect("Unable to create regex for BUSINESSES_BUSINESSID_GOODS_FEEDBACK_COMMENTS_UPDATE");
    }
    pub(crate) static ID_BUSINESSES_BUSINESSID_GOODS_FEEDBACK_SKIP_REACTION: usize = 12;
    lazy_static! {
        pub static ref REGEX_BUSINESSES_BUSINESSID_GOODS_FEEDBACK_SKIP_REACTION: regex::Regex =
            #[allow(clippy::invalid_regex)]
            regex::Regex::new(r"^/businesses/(?P<businessId>[^/?#]*)/goods-feedback/skip-reaction$")
                .expect("Unable to create regex for BUSINESSES_BUSINESSID_GOODS_FEEDBACK_SKIP_REACTION");
    }
    pub(crate) static ID_BUSINESSES_BUSINESSID_OFFER_CARDS: usize = 13;
    lazy_static! {
        pub static ref REGEX_BUSINESSES_BUSINESSID_OFFER_CARDS: regex::Regex =
            #[allow(clippy::invalid_regex)]
            regex::Regex::new(r"^/businesses/(?P<businessId>[^/?#]*)/offer-cards$")
                .expect("Unable to create regex for BUSINESSES_BUSINESSID_OFFER_CARDS");
    }
    pub(crate) static ID_BUSINESSES_BUSINESSID_OFFER_CARDS_UPDATE: usize = 14;
    lazy_static! {
        pub static ref REGEX_BUSINESSES_BUSINESSID_OFFER_CARDS_UPDATE: regex::Regex =
            #[allow(clippy::invalid_regex)]
            regex::Regex::new(r"^/businesses/(?P<businessId>[^/?#]*)/offer-cards/update$")
                .expect("Unable to create regex for BUSINESSES_BUSINESSID_OFFER_CARDS_UPDATE");
    }
    pub(crate) static ID_BUSINESSES_BUSINESSID_OFFER_MAPPINGS: usize = 15;
    lazy_static! {
        pub static ref REGEX_BUSINESSES_BUSINESSID_OFFER_MAPPINGS: regex::Regex =
            #[allow(clippy::invalid_regex)]
            regex::Regex::new(r"^/businesses/(?P<businessId>[^/?#]*)/offer-mappings$")
                .expect("Unable to create regex for BUSINESSES_BUSINESSID_OFFER_MAPPINGS");
    }
    pub(crate) static ID_BUSINESSES_BUSINESSID_OFFER_MAPPINGS_ARCHIVE: usize = 16;
    lazy_static! {
        pub static ref REGEX_BUSINESSES_BUSINESSID_OFFER_MAPPINGS_ARCHIVE: regex::Regex =
            #[allow(clippy::invalid_regex)]
            regex::Regex::new(r"^/businesses/(?P<businessId>[^/?#]*)/offer-mappings/archive$")
                .expect("Unable to create regex for BUSINESSES_BUSINESSID_OFFER_MAPPINGS_ARCHIVE");
    }
    pub(crate) static ID_BUSINESSES_BUSINESSID_OFFER_MAPPINGS_DELETE: usize = 17;
    lazy_static! {
        pub static ref REGEX_BUSINESSES_BUSINESSID_OFFER_MAPPINGS_DELETE: regex::Regex =
            #[allow(clippy::invalid_regex)]
            regex::Regex::new(r"^/businesses/(?P<businessId>[^/?#]*)/offer-mappings/delete$")
                .expect("Unable to create regex for BUSINESSES_BUSINESSID_OFFER_MAPPINGS_DELETE");
    }
    pub(crate) static ID_BUSINESSES_BUSINESSID_OFFER_MAPPINGS_SUGGESTIONS: usize = 18;
    lazy_static! {
        pub static ref REGEX_BUSINESSES_BUSINESSID_OFFER_MAPPINGS_SUGGESTIONS: regex::Regex =
            #[allow(clippy::invalid_regex)]
            regex::Regex::new(r"^/businesses/(?P<businessId>[^/?#]*)/offer-mappings/suggestions$")
                .expect("Unable to create regex for BUSINESSES_BUSINESSID_OFFER_MAPPINGS_SUGGESTIONS");
    }
    pub(crate) static ID_BUSINESSES_BUSINESSID_OFFER_MAPPINGS_UNARCHIVE: usize = 19;
    lazy_static! {
        pub static ref REGEX_BUSINESSES_BUSINESSID_OFFER_MAPPINGS_UNARCHIVE: regex::Regex =
            #[allow(clippy::invalid_regex)]
            regex::Regex::new(r"^/businesses/(?P<businessId>[^/?#]*)/offer-mappings/unarchive$")
                .expect("Unable to create regex for BUSINESSES_BUSINESSID_OFFER_MAPPINGS_UNARCHIVE");
    }
    pub(crate) static ID_BUSINESSES_BUSINESSID_OFFER_MAPPINGS_UPDATE: usize = 20;
    lazy_static! {
        pub static ref REGEX_BUSINESSES_BUSINESSID_OFFER_MAPPINGS_UPDATE: regex::Regex =
            #[allow(clippy::invalid_regex)]
            regex::Regex::new(r"^/businesses/(?P<businessId>[^/?#]*)/offer-mappings/update$")
                .expect("Unable to create regex for BUSINESSES_BUSINESSID_OFFER_MAPPINGS_UPDATE");
    }
    pub(crate) static ID_BUSINESSES_BUSINESSID_OFFER_PRICES_UPDATES: usize = 21;
    lazy_static! {
        pub static ref REGEX_BUSINESSES_BUSINESSID_OFFER_PRICES_UPDATES: regex::Regex =
            #[allow(clippy::invalid_regex)]
            regex::Regex::new(r"^/businesses/(?P<businessId>[^/?#]*)/offer-prices/updates$")
                .expect("Unable to create regex for BUSINESSES_BUSINESSID_OFFER_PRICES_UPDATES");
    }
    pub(crate) static ID_BUSINESSES_BUSINESSID_OFFERS_RECOMMENDATIONS: usize = 22;
    lazy_static! {
        pub static ref REGEX_BUSINESSES_BUSINESSID_OFFERS_RECOMMENDATIONS: regex::Regex =
            #[allow(clippy::invalid_regex)]
            regex::Regex::new(r"^/businesses/(?P<businessId>[^/?#]*)/offers/recommendations$")
                .expect("Unable to create regex for BUSINESSES_BUSINESSID_OFFERS_RECOMMENDATIONS");
    }
    pub(crate) static ID_BUSINESSES_BUSINESSID_PRICE_QUARANTINE: usize = 23;
    lazy_static! {
        pub static ref REGEX_BUSINESSES_BUSINESSID_PRICE_QUARANTINE: regex::Regex =
            #[allow(clippy::invalid_regex)]
            regex::Regex::new(r"^/businesses/(?P<businessId>[^/?#]*)/price-quarantine$")
                .expect("Unable to create regex for BUSINESSES_BUSINESSID_PRICE_QUARANTINE");
    }
    pub(crate) static ID_BUSINESSES_BUSINESSID_PRICE_QUARANTINE_CONFIRM: usize = 24;
    lazy_static! {
        pub static ref REGEX_BUSINESSES_BUSINESSID_PRICE_QUARANTINE_CONFIRM: regex::Regex =
            #[allow(clippy::invalid_regex)]
            regex::Regex::new(r"^/businesses/(?P<businessId>[^/?#]*)/price-quarantine/confirm$")
                .expect("Unable to create regex for BUSINESSES_BUSINESSID_PRICE_QUARANTINE_CONFIRM");
    }
    pub(crate) static ID_BUSINESSES_BUSINESSID_PROMOS: usize = 25;
    lazy_static! {
        pub static ref REGEX_BUSINESSES_BUSINESSID_PROMOS: regex::Regex =
            #[allow(clippy::invalid_regex)]
            regex::Regex::new(r"^/businesses/(?P<businessId>[^/?#]*)/promos$")
                .expect("Unable to create regex for BUSINESSES_BUSINESSID_PROMOS");
    }
    pub(crate) static ID_BUSINESSES_BUSINESSID_PROMOS_OFFERS: usize = 26;
    lazy_static! {
        pub static ref REGEX_BUSINESSES_BUSINESSID_PROMOS_OFFERS: regex::Regex =
            #[allow(clippy::invalid_regex)]
            regex::Regex::new(r"^/businesses/(?P<businessId>[^/?#]*)/promos/offers$")
                .expect("Unable to create regex for BUSINESSES_BUSINESSID_PROMOS_OFFERS");
    }
    pub(crate) static ID_BUSINESSES_BUSINESSID_PROMOS_OFFERS_DELETE: usize = 27;
    lazy_static! {
        pub static ref REGEX_BUSINESSES_BUSINESSID_PROMOS_OFFERS_DELETE: regex::Regex =
            #[allow(clippy::invalid_regex)]
            regex::Regex::new(r"^/businesses/(?P<businessId>[^/?#]*)/promos/offers/delete$")
                .expect("Unable to create regex for BUSINESSES_BUSINESSID_PROMOS_OFFERS_DELETE");
    }
    pub(crate) static ID_BUSINESSES_BUSINESSID_PROMOS_OFFERS_UPDATE: usize = 28;
    lazy_static! {
        pub static ref REGEX_BUSINESSES_BUSINESSID_PROMOS_OFFERS_UPDATE: regex::Regex =
            #[allow(clippy::invalid_regex)]
            regex::Regex::new(r"^/businesses/(?P<businessId>[^/?#]*)/promos/offers/update$")
                .expect("Unable to create regex for BUSINESSES_BUSINESSID_PROMOS_OFFERS_UPDATE");
    }
    pub(crate) static ID_BUSINESSES_BUSINESSID_RATINGS_QUALITY: usize = 29;
    lazy_static! {
        pub static ref REGEX_BUSINESSES_BUSINESSID_RATINGS_QUALITY: regex::Regex =
            #[allow(clippy::invalid_regex)]
            regex::Regex::new(r"^/businesses/(?P<businessId>[^/?#]*)/ratings/quality$")
                .expect("Unable to create regex for BUSINESSES_BUSINESSID_RATINGS_QUALITY");
    }
    pub(crate) static ID_BUSINESSES_BUSINESSID_SETTINGS: usize = 30;
    lazy_static! {
        pub static ref REGEX_BUSINESSES_BUSINESSID_SETTINGS: regex::Regex =
            #[allow(clippy::invalid_regex)]
            regex::Regex::new(r"^/businesses/(?P<businessId>[^/?#]*)/settings$")
                .expect("Unable to create regex for BUSINESSES_BUSINESSID_SETTINGS");
    }
    pub(crate) static ID_BUSINESSES_BUSINESSID_WAREHOUSES: usize = 31;
    lazy_static! {
        pub static ref REGEX_BUSINESSES_BUSINESSID_WAREHOUSES: regex::Regex =
            #[allow(clippy::invalid_regex)]
            regex::Regex::new(r"^/businesses/(?P<businessId>[^/?#]*)/warehouses$")
                .expect("Unable to create regex for BUSINESSES_BUSINESSID_WAREHOUSES");
    }
    pub(crate) static ID_CAMPAIGNS: usize = 32;
    pub(crate) static ID_CAMPAIGNS_BY_LOGIN_LOGIN: usize = 33;
    lazy_static! {
        pub static ref REGEX_CAMPAIGNS_BY_LOGIN_LOGIN: regex::Regex =
            #[allow(clippy::invalid_regex)]
            regex::Regex::new(r"^/campaigns/by_login/(?P<login>[^/?#]*)$")
                .expect("Unable to create regex for CAMPAIGNS_BY_LOGIN_LOGIN");
    }
    pub(crate) static ID_CAMPAIGNS_CAMPAIGNID: usize = 34;
    lazy_static! {
        pub static ref REGEX_CAMPAIGNS_CAMPAIGNID: regex::Regex =
            #[allow(clippy::invalid_regex)]
            regex::Regex::new(r"^/campaigns/(?P<campaignId>[^/?#]*)$")
                .expect("Unable to create regex for CAMPAIGNS_CAMPAIGNID");
    }
    pub(crate) static ID_CAMPAIGNS_CAMPAIGNID_BIDS: usize = 35;
    lazy_static! {
        pub static ref REGEX_CAMPAIGNS_CAMPAIGNID_BIDS: regex::Regex =
            #[allow(clippy::invalid_regex)]
            regex::Regex::new(r"^/campaigns/(?P<campaignId>[^/?#]*)/bids$")
                .expect("Unable to create regex for CAMPAIGNS_CAMPAIGNID_BIDS");
    }
    pub(crate) static ID_CAMPAIGNS_CAMPAIGNID_FEEDBACK_UPDATES: usize = 36;
    lazy_static! {
        pub static ref REGEX_CAMPAIGNS_CAMPAIGNID_FEEDBACK_UPDATES: regex::Regex =
            #[allow(clippy::invalid_regex)]
            regex::Regex::new(r"^/campaigns/(?P<campaignId>[^/?#]*)/feedback/updates$")
                .expect("Unable to create regex for CAMPAIGNS_CAMPAIGNID_FEEDBACK_UPDATES");
    }
    pub(crate) static ID_CAMPAIGNS_CAMPAIGNID_FEEDS: usize = 37;
    lazy_static! {
        pub static ref REGEX_CAMPAIGNS_CAMPAIGNID_FEEDS: regex::Regex =
            #[allow(clippy::invalid_regex)]
            regex::Regex::new(r"^/campaigns/(?P<campaignId>[^/?#]*)/feeds$")
                .expect("Unable to create regex for CAMPAIGNS_CAMPAIGNID_FEEDS");
    }
    pub(crate) static ID_CAMPAIGNS_CAMPAIGNID_FEEDS_FEEDID: usize = 38;
    lazy_static! {
        pub static ref REGEX_CAMPAIGNS_CAMPAIGNID_FEEDS_FEEDID: regex::Regex =
            #[allow(clippy::invalid_regex)]
            regex::Regex::new(r"^/campaigns/(?P<campaignId>[^/?#]*)/feeds/(?P<feedId>[^/?#]*)$")
                .expect("Unable to create regex for CAMPAIGNS_CAMPAIGNID_FEEDS_FEEDID");
    }
    pub(crate) static ID_CAMPAIGNS_CAMPAIGNID_FEEDS_FEEDID_INDEX_LOGS: usize = 39;
    lazy_static! {
        pub static ref REGEX_CAMPAIGNS_CAMPAIGNID_FEEDS_FEEDID_INDEX_LOGS: regex::Regex =
            #[allow(clippy::invalid_regex)]
            regex::Regex::new(r"^/campaigns/(?P<campaignId>[^/?#]*)/feeds/(?P<feedId>[^/?#]*)/index-logs$")
                .expect("Unable to create regex for CAMPAIGNS_CAMPAIGNID_FEEDS_FEEDID_INDEX_LOGS");
    }
    pub(crate) static ID_CAMPAIGNS_CAMPAIGNID_FEEDS_FEEDID_PARAMS: usize = 40;
    lazy_static! {
        pub static ref REGEX_CAMPAIGNS_CAMPAIGNID_FEEDS_FEEDID_PARAMS: regex::Regex =
            #[allow(clippy::invalid_regex)]
            regex::Regex::new(r"^/campaigns/(?P<campaignId>[^/?#]*)/feeds/(?P<feedId>[^/?#]*)/params$")
                .expect("Unable to create regex for CAMPAIGNS_CAMPAIGNID_FEEDS_FEEDID_PARAMS");
    }
    pub(crate) static ID_CAMPAIGNS_CAMPAIGNID_FEEDS_FEEDID_REFRESH: usize = 41;
    lazy_static! {
        pub static ref REGEX_CAMPAIGNS_CAMPAIGNID_FEEDS_FEEDID_REFRESH: regex::Regex =
            #[allow(clippy::invalid_regex)]
            regex::Regex::new(r"^/campaigns/(?P<campaignId>[^/?#]*)/feeds/(?P<feedId>[^/?#]*)/refresh$")
                .expect("Unable to create regex for CAMPAIGNS_CAMPAIGNID_FEEDS_FEEDID_REFRESH");
    }
    pub(crate) static ID_CAMPAIGNS_CAMPAIGNID_FIRST_MILE_SHIPMENTS: usize = 42;
    lazy_static! {
        pub static ref REGEX_CAMPAIGNS_CAMPAIGNID_FIRST_MILE_SHIPMENTS: regex::Regex =
            #[allow(clippy::invalid_regex)]
            regex::Regex::new(r"^/campaigns/(?P<campaignId>[^/?#]*)/first-mile/shipments$")
                .expect("Unable to create regex for CAMPAIGNS_CAMPAIGNID_FIRST_MILE_SHIPMENTS");
    }
    pub(crate) static ID_CAMPAIGNS_CAMPAIGNID_FIRST_MILE_SHIPMENTS_SHIPMENTID: usize = 43;
    lazy_static! {
        pub static ref REGEX_CAMPAIGNS_CAMPAIGNID_FIRST_MILE_SHIPMENTS_SHIPMENTID: regex::Regex =
            #[allow(clippy::invalid_regex)]
            regex::Regex::new(r"^/campaigns/(?P<campaignId>[^/?#]*)/first-mile/shipments/(?P<shipmentId>[^/?#]*)$")
                .expect("Unable to create regex for CAMPAIGNS_CAMPAIGNID_FIRST_MILE_SHIPMENTS_SHIPMENTID");
    }
    pub(crate) static ID_CAMPAIGNS_CAMPAIGNID_FIRST_MILE_SHIPMENTS_SHIPMENTID_ACT: usize = 44;
    lazy_static! {
        pub static ref REGEX_CAMPAIGNS_CAMPAIGNID_FIRST_MILE_SHIPMENTS_SHIPMENTID_ACT: regex::Regex =
            #[allow(clippy::invalid_regex)]
            regex::Regex::new(r"^/campaigns/(?P<campaignId>[^/?#]*)/first-mile/shipments/(?P<shipmentId>[^/?#]*)/act$")
                .expect("Unable to create regex for CAMPAIGNS_CAMPAIGNID_FIRST_MILE_SHIPMENTS_SHIPMENTID_ACT");
    }
    pub(crate) static ID_CAMPAIGNS_CAMPAIGNID_FIRST_MILE_SHIPMENTS_SHIPMENTID_CONFIRM: usize = 45;
    lazy_static! {
        pub static ref REGEX_CAMPAIGNS_CAMPAIGNID_FIRST_MILE_SHIPMENTS_SHIPMENTID_CONFIRM: regex::Regex =
            #[allow(clippy::invalid_regex)]
            regex::Regex::new(r"^/campaigns/(?P<campaignId>[^/?#]*)/first-mile/shipments/(?P<shipmentId>[^/?#]*)/confirm$")
                .expect("Unable to create regex for CAMPAIGNS_CAMPAIGNID_FIRST_MILE_SHIPMENTS_SHIPMENTID_CONFIRM");
    }
    pub(crate) static ID_CAMPAIGNS_CAMPAIGNID_FIRST_MILE_SHIPMENTS_SHIPMENTID_DISCREPANCY_ACT: usize = 46;
    lazy_static! {
        pub static ref REGEX_CAMPAIGNS_CAMPAIGNID_FIRST_MILE_SHIPMENTS_SHIPMENTID_DISCREPANCY_ACT: regex::Regex =
            #[allow(clippy::invalid_regex)]
            regex::Regex::new(r"^/campaigns/(?P<campaignId>[^/?#]*)/first-mile/shipments/(?P<shipmentId>[^/?#]*)/discrepancy-act$")
                .expect("Unable to create regex for CAMPAIGNS_CAMPAIGNID_FIRST_MILE_SHIPMENTS_SHIPMENTID_DISCREPANCY_ACT");
    }
    pub(crate) static ID_CAMPAIGNS_CAMPAIGNID_FIRST_MILE_SHIPMENTS_SHIPMENTID_INBOUND_ACT: usize = 47;
    lazy_static! {
        pub static ref REGEX_CAMPAIGNS_CAMPAIGNID_FIRST_MILE_SHIPMENTS_SHIPMENTID_INBOUND_ACT: regex::Regex =
            #[allow(clippy::invalid_regex)]
            regex::Regex::new(r"^/campaigns/(?P<campaignId>[^/?#]*)/first-mile/shipments/(?P<shipmentId>[^/?#]*)/inbound-act$")
                .expect("Unable to create regex for CAMPAIGNS_CAMPAIGNID_FIRST_MILE_SHIPMENTS_SHIPMENTID_INBOUND_ACT");
    }
    pub(crate) static ID_CAMPAIGNS_CAMPAIGNID_FIRST_MILE_SHIPMENTS_SHIPMENTID_ORDERS_INFO: usize = 48;
    lazy_static! {
        pub static ref REGEX_CAMPAIGNS_CAMPAIGNID_FIRST_MILE_SHIPMENTS_SHIPMENTID_ORDERS_INFO: regex::Regex =
            #[allow(clippy::invalid_regex)]
            regex::Regex::new(r"^/campaigns/(?P<campaignId>[^/?#]*)/first-mile/shipments/(?P<shipmentId>[^/?#]*)/orders/info$")
                .expect("Unable to create regex for CAMPAIGNS_CAMPAIGNID_FIRST_MILE_SHIPMENTS_SHIPMENTID_ORDERS_INFO");
    }
    pub(crate) static ID_CAMPAIGNS_CAMPAIGNID_FIRST_MILE_SHIPMENTS_SHIPMENTID_ORDERS_TRANSFER: usize = 49;
    lazy_static! {
        pub static ref REGEX_CAMPAIGNS_CAMPAIGNID_FIRST_MILE_SHIPMENTS_SHIPMENTID_ORDERS_TRANSFER: regex::Regex =
            #[allow(clippy::invalid_regex)]
            regex::Regex::new(r"^/campaigns/(?P<campaignId>[^/?#]*)/first-mile/shipments/(?P<shipmentId>[^/?#]*)/orders/transfer$")
                .expect("Unable to create regex for CAMPAIGNS_CAMPAIGNID_FIRST_MILE_SHIPMENTS_SHIPMENTID_ORDERS_TRANSFER");
    }
    pub(crate) static ID_CAMPAIGNS_CAMPAIGNID_FIRST_MILE_SHIPMENTS_SHIPMENTID_PALLET_LABELS: usize = 50;
    lazy_static! {
        pub static ref REGEX_CAMPAIGNS_CAMPAIGNID_FIRST_MILE_SHIPMENTS_SHIPMENTID_PALLET_LABELS: regex::Regex =
            #[allow(clippy::invalid_regex)]
            regex::Regex::new(r"^/campaigns/(?P<campaignId>[^/?#]*)/first-mile/shipments/(?P<shipmentId>[^/?#]*)/pallet/labels$")
                .expect("Unable to create regex for CAMPAIGNS_CAMPAIGNID_FIRST_MILE_SHIPMENTS_SHIPMENTID_PALLET_LABELS");
    }
    pub(crate) static ID_CAMPAIGNS_CAMPAIGNID_FIRST_MILE_SHIPMENTS_SHIPMENTID_PALLETS: usize = 51;
    lazy_static! {
        pub static ref REGEX_CAMPAIGNS_CAMPAIGNID_FIRST_MILE_SHIPMENTS_SHIPMENTID_PALLETS: regex::Regex =
            #[allow(clippy::invalid_regex)]
            regex::Regex::new(r"^/campaigns/(?P<campaignId>[^/?#]*)/first-mile/shipments/(?P<shipmentId>[^/?#]*)/pallets$")
                .expect("Unable to create regex for CAMPAIGNS_CAMPAIGNID_FIRST_MILE_SHIPMENTS_SHIPMENTID_PALLETS");
    }
    pub(crate) static ID_CAMPAIGNS_CAMPAIGNID_FIRST_MILE_SHIPMENTS_SHIPMENTID_TRANSPORTATION_WAYBILL: usize = 52;
    lazy_static! {
        pub static ref REGEX_CAMPAIGNS_CAMPAIGNID_FIRST_MILE_SHIPMENTS_SHIPMENTID_TRANSPORTATION_WAYBILL: regex::Regex =
            #[allow(clippy::invalid_regex)]
            regex::Regex::new(r"^/campaigns/(?P<campaignId>[^/?#]*)/first-mile/shipments/(?P<shipmentId>[^/?#]*)/transportation-waybill$")
                .expect("Unable to create regex for CAMPAIGNS_CAMPAIGNID_FIRST_MILE_SHIPMENTS_SHIPMENTID_TRANSPORTATION_WAYBILL");
    }
    pub(crate) static ID_CAMPAIGNS_CAMPAIGNID_HIDDEN_OFFERS: usize = 53;
    lazy_static! {
        pub static ref REGEX_CAMPAIGNS_CAMPAIGNID_HIDDEN_OFFERS: regex::Regex =
            #[allow(clippy::invalid_regex)]
            regex::Regex::new(r"^/campaigns/(?P<campaignId>[^/?#]*)/hidden-offers$")
                .expect("Unable to create regex for CAMPAIGNS_CAMPAIGNID_HIDDEN_OFFERS");
    }
    pub(crate) static ID_CAMPAIGNS_CAMPAIGNID_HIDDEN_OFFERS_DELETE: usize = 54;
    lazy_static! {
        pub static ref REGEX_CAMPAIGNS_CAMPAIGNID_HIDDEN_OFFERS_DELETE: regex::Regex =
            #[allow(clippy::invalid_regex)]
            regex::Regex::new(r"^/campaigns/(?P<campaignId>[^/?#]*)/hidden-offers/delete$")
                .expect("Unable to create regex for CAMPAIGNS_CAMPAIGNID_HIDDEN_OFFERS_DELETE");
    }
    pub(crate) static ID_CAMPAIGNS_CAMPAIGNID_LOGINS: usize = 55;
    lazy_static! {
        pub static ref REGEX_CAMPAIGNS_CAMPAIGNID_LOGINS: regex::Regex =
            #[allow(clippy::invalid_regex)]
            regex::Regex::new(r"^/campaigns/(?P<campaignId>[^/?#]*)/logins$")
                .expect("Unable to create regex for CAMPAIGNS_CAMPAIGNID_LOGINS");
    }
    pub(crate) static ID_CAMPAIGNS_CAMPAIGNID_OFFER_MAPPING_ENTRIES: usize = 56;
    lazy_static! {
        pub static ref REGEX_CAMPAIGNS_CAMPAIGNID_OFFER_MAPPING_ENTRIES: regex::Regex =
            #[allow(clippy::invalid_regex)]
            regex::Regex::new(r"^/campaigns/(?P<campaignId>[^/?#]*)/offer-mapping-entries$")
                .expect("Unable to create regex for CAMPAIGNS_CAMPAIGNID_OFFER_MAPPING_ENTRIES");
    }
    pub(crate) static ID_CAMPAIGNS_CAMPAIGNID_OFFER_MAPPING_ENTRIES_SUGGESTIONS: usize = 57;
    lazy_static! {
        pub static ref REGEX_CAMPAIGNS_CAMPAIGNID_OFFER_MAPPING_ENTRIES_SUGGESTIONS: regex::Regex =
            #[allow(clippy::invalid_regex)]
            regex::Regex::new(r"^/campaigns/(?P<campaignId>[^/?#]*)/offer-mapping-entries/suggestions$")
                .expect("Unable to create regex for CAMPAIGNS_CAMPAIGNID_OFFER_MAPPING_ENTRIES_SUGGESTIONS");
    }
    pub(crate) static ID_CAMPAIGNS_CAMPAIGNID_OFFER_MAPPING_ENTRIES_UPDATES: usize = 58;
    lazy_static! {
        pub static ref REGEX_CAMPAIGNS_CAMPAIGNID_OFFER_MAPPING_ENTRIES_UPDATES: regex::Regex =
            #[allow(clippy::invalid_regex)]
            regex::Regex::new(r"^/campaigns/(?P<campaignId>[^/?#]*)/offer-mapping-entries/updates$")
                .expect("Unable to create regex for CAMPAIGNS_CAMPAIGNID_OFFER_MAPPING_ENTRIES_UPDATES");
    }
    pub(crate) static ID_CAMPAIGNS_CAMPAIGNID_OFFER_PRICES: usize = 59;
    lazy_static! {
        pub static ref REGEX_CAMPAIGNS_CAMPAIGNID_OFFER_PRICES: regex::Regex =
            #[allow(clippy::invalid_regex)]
            regex::Regex::new(r"^/campaigns/(?P<campaignId>[^/?#]*)/offer-prices$")
                .expect("Unable to create regex for CAMPAIGNS_CAMPAIGNID_OFFER_PRICES");
    }
    pub(crate) static ID_CAMPAIGNS_CAMPAIGNID_OFFER_PRICES_SUGGESTIONS: usize = 60;
    lazy_static! {
        pub static ref REGEX_CAMPAIGNS_CAMPAIGNID_OFFER_PRICES_SUGGESTIONS: regex::Regex =
            #[allow(clippy::invalid_regex)]
            regex::Regex::new(r"^/campaigns/(?P<campaignId>[^/?#]*)/offer-prices/suggestions$")
                .expect("Unable to create regex for CAMPAIGNS_CAMPAIGNID_OFFER_PRICES_SUGGESTIONS");
    }
    pub(crate) static ID_CAMPAIGNS_CAMPAIGNID_OFFER_PRICES_UPDATES: usize = 61;
    lazy_static! {
        pub static ref REGEX_CAMPAIGNS_CAMPAIGNID_OFFER_PRICES_UPDATES: regex::Regex =
            #[allow(clippy::invalid_regex)]
            regex::Regex::new(r"^/campaigns/(?P<campaignId>[^/?#]*)/offer-prices/updates$")
                .expect("Unable to create regex for CAMPAIGNS_CAMPAIGNID_OFFER_PRICES_UPDATES");
    }
    pub(crate) static ID_CAMPAIGNS_CAMPAIGNID_OFFERS: usize = 62;
    lazy_static! {
        pub static ref REGEX_CAMPAIGNS_CAMPAIGNID_OFFERS: regex::Regex =
            #[allow(clippy::invalid_regex)]
            regex::Regex::new(r"^/campaigns/(?P<campaignId>[^/?#]*)/offers$")
                .expect("Unable to create regex for CAMPAIGNS_CAMPAIGNID_OFFERS");
    }
    pub(crate) static ID_CAMPAIGNS_CAMPAIGNID_OFFERS_ALL: usize = 63;
    lazy_static! {
        pub static ref REGEX_CAMPAIGNS_CAMPAIGNID_OFFERS_ALL: regex::Regex =
            #[allow(clippy::invalid_regex)]
            regex::Regex::new(r"^/campaigns/(?P<campaignId>[^/?#]*)/offers/all$")
                .expect("Unable to create regex for CAMPAIGNS_CAMPAIGNID_OFFERS_ALL");
    }
    pub(crate) static ID_CAMPAIGNS_CAMPAIGNID_OFFERS_DELETE: usize = 64;
    lazy_static! {
        pub static ref REGEX_CAMPAIGNS_CAMPAIGNID_OFFERS_DELETE: regex::Regex =
            #[allow(clippy::invalid_regex)]
            regex::Regex::new(r"^/campaigns/(?P<campaignId>[^/?#]*)/offers/delete$")
                .expect("Unable to create regex for CAMPAIGNS_CAMPAIGNID_OFFERS_DELETE");
    }
    pub(crate) static ID_CAMPAIGNS_CAMPAIGNID_OFFERS_STOCKS: usize = 65;
    lazy_static! {
        pub static ref REGEX_CAMPAIGNS_CAMPAIGNID_OFFERS_STOCKS: regex::Regex =
            #[allow(clippy::invalid_regex)]
            regex::Regex::new(r"^/campaigns/(?P<campaignId>[^/?#]*)/offers/stocks$")
                .expect("Unable to create regex for CAMPAIGNS_CAMPAIGNID_OFFERS_STOCKS");
    }
    pub(crate) static ID_CAMPAIGNS_CAMPAIGNID_OFFERS_UPDATE: usize = 66;
    lazy_static! {
        pub static ref REGEX_CAMPAIGNS_CAMPAIGNID_OFFERS_UPDATE: regex::Regex =
            #[allow(clippy::invalid_regex)]
            regex::Regex::new(r"^/campaigns/(?P<campaignId>[^/?#]*)/offers/update$")
                .expect("Unable to create regex for CAMPAIGNS_CAMPAIGNID_OFFERS_UPDATE");
    }
    pub(crate) static ID_CAMPAIGNS_CAMPAIGNID_ORDERS: usize = 67;
    lazy_static! {
        pub static ref REGEX_CAMPAIGNS_CAMPAIGNID_ORDERS: regex::Regex =
            #[allow(clippy::invalid_regex)]
            regex::Regex::new(r"^/campaigns/(?P<campaignId>[^/?#]*)/orders$")
                .expect("Unable to create regex for CAMPAIGNS_CAMPAIGNID_ORDERS");
    }
    pub(crate) static ID_CAMPAIGNS_CAMPAIGNID_ORDERS_STATUS_UPDATE: usize = 68;
    lazy_static! {
        pub static ref REGEX_CAMPAIGNS_CAMPAIGNID_ORDERS_STATUS_UPDATE: regex::Regex =
            #[allow(clippy::invalid_regex)]
            regex::Regex::new(r"^/campaigns/(?P<campaignId>[^/?#]*)/orders/status-update$")
                .expect("Unable to create regex for CAMPAIGNS_CAMPAIGNID_ORDERS_STATUS_UPDATE");
    }
    pub(crate) static ID_CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID: usize = 69;
    lazy_static! {
        pub static ref REGEX_CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID: regex::Regex =
            #[allow(clippy::invalid_regex)]
            regex::Regex::new(r"^/campaigns/(?P<campaignId>[^/?#]*)/orders/(?P<orderId>[^/?#]*)$")
                .expect("Unable to create regex for CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID");
    }
    pub(crate) static ID_CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_BOXES: usize = 70;
    lazy_static! {
        pub static ref REGEX_CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_BOXES: regex::Regex =
            #[allow(clippy::invalid_regex)]
            regex::Regex::new(r"^/campaigns/(?P<campaignId>[^/?#]*)/orders/(?P<orderId>[^/?#]*)/boxes$")
                .expect("Unable to create regex for CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_BOXES");
    }
    pub(crate) static ID_CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_BUSINESS_BUYER: usize = 71;
    lazy_static! {
        pub static ref REGEX_CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_BUSINESS_BUYER: regex::Regex =
            #[allow(clippy::invalid_regex)]
            regex::Regex::new(r"^/campaigns/(?P<campaignId>[^/?#]*)/orders/(?P<orderId>[^/?#]*)/business-buyer$")
                .expect("Unable to create regex for CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_BUSINESS_BUYER");
    }
    pub(crate) static ID_CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_BUYER: usize = 72;
    lazy_static! {
        pub static ref REGEX_CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_BUYER: regex::Regex =
            #[allow(clippy::invalid_regex)]
            regex::Regex::new(r"^/campaigns/(?P<campaignId>[^/?#]*)/orders/(?P<orderId>[^/?#]*)/buyer$")
                .expect("Unable to create regex for CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_BUYER");
    }
    pub(crate) static ID_CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_CANCELLATION_ACCEPT: usize = 73;
    lazy_static! {
        pub static ref REGEX_CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_CANCELLATION_ACCEPT: regex::Regex =
            #[allow(clippy::invalid_regex)]
            regex::Regex::new(r"^/campaigns/(?P<campaignId>[^/?#]*)/orders/(?P<orderId>[^/?#]*)/cancellation/accept$")
                .expect("Unable to create regex for CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_CANCELLATION_ACCEPT");
    }
    pub(crate) static ID_CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_DELIVERDIGITALGOODS: usize = 74;
    lazy_static! {
        pub static ref REGEX_CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_DELIVERDIGITALGOODS: regex::Regex =
            #[allow(clippy::invalid_regex)]
            regex::Regex::new(r"^/campaigns/(?P<campaignId>[^/?#]*)/orders/(?P<orderId>[^/?#]*)/deliverDigitalGoods$")
                .expect("Unable to create regex for CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_DELIVERDIGITALGOODS");
    }
    pub(crate) static ID_CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_DELIVERY_DATE: usize = 75;
    lazy_static! {
        pub static ref REGEX_CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_DELIVERY_DATE: regex::Regex =
            #[allow(clippy::invalid_regex)]
            regex::Regex::new(r"^/campaigns/(?P<campaignId>[^/?#]*)/orders/(?P<orderId>[^/?#]*)/delivery/date$")
                .expect("Unable to create regex for CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_DELIVERY_DATE");
    }
    pub(crate) static ID_CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_DELIVERY_LABELS: usize = 76;
    lazy_static! {
        pub static ref REGEX_CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_DELIVERY_LABELS: regex::Regex =
            #[allow(clippy::invalid_regex)]
            regex::Regex::new(r"^/campaigns/(?P<campaignId>[^/?#]*)/orders/(?P<orderId>[^/?#]*)/delivery/labels$")
                .expect("Unable to create regex for CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_DELIVERY_LABELS");
    }
    pub(crate) static ID_CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_DELIVERY_LABELS_DATA: usize = 77;
    lazy_static! {
        pub static ref REGEX_CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_DELIVERY_LABELS_DATA: regex::Regex =
            #[allow(clippy::invalid_regex)]
            regex::Regex::new(r"^/campaigns/(?P<campaignId>[^/?#]*)/orders/(?P<orderId>[^/?#]*)/delivery/labels/data$")
                .expect("Unable to create regex for CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_DELIVERY_LABELS_DATA");
    }
    pub(crate) static ID_CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_DELIVERY_SHIPMENTS_SHIPMENTID_BOXES: usize = 78;
    lazy_static! {
        pub static ref REGEX_CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_DELIVERY_SHIPMENTS_SHIPMENTID_BOXES: regex::Regex =
            #[allow(clippy::invalid_regex)]
            regex::Regex::new(r"^/campaigns/(?P<campaignId>[^/?#]*)/orders/(?P<orderId>[^/?#]*)/delivery/shipments/(?P<shipmentId>[^/?#]*)/boxes$")
                .expect("Unable to create regex for CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_DELIVERY_SHIPMENTS_SHIPMENTID_BOXES");
    }
    pub(crate) static ID_CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_DELIVERY_SHIPMENTS_SHIPMENTID_BOXES_BOXID_LABEL: usize = 79;
    lazy_static! {
        pub static ref REGEX_CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_DELIVERY_SHIPMENTS_SHIPMENTID_BOXES_BOXID_LABEL: regex::Regex =
            #[allow(clippy::invalid_regex)]
            regex::Regex::new(r"^/campaigns/(?P<campaignId>[^/?#]*)/orders/(?P<orderId>[^/?#]*)/delivery/shipments/(?P<shipmentId>[^/?#]*)/boxes/(?P<boxId>[^/?#]*)/label$")
                .expect("Unable to create regex for CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_DELIVERY_SHIPMENTS_SHIPMENTID_BOXES_BOXID_LABEL");
    }
    pub(crate) static ID_CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_DELIVERY_STORAGE_LIMIT: usize = 80;
    lazy_static! {
        pub static ref REGEX_CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_DELIVERY_STORAGE_LIMIT: regex::Regex =
            #[allow(clippy::invalid_regex)]
            regex::Regex::new(r"^/campaigns/(?P<campaignId>[^/?#]*)/orders/(?P<orderId>[^/?#]*)/delivery/storage-limit$")
                .expect("Unable to create regex for CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_DELIVERY_STORAGE_LIMIT");
    }
    pub(crate) static ID_CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_DELIVERY_TRACK: usize = 81;
    lazy_static! {
        pub static ref REGEX_CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_DELIVERY_TRACK: regex::Regex =
            #[allow(clippy::invalid_regex)]
            regex::Regex::new(r"^/campaigns/(?P<campaignId>[^/?#]*)/orders/(?P<orderId>[^/?#]*)/delivery/track$")
                .expect("Unable to create regex for CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_DELIVERY_TRACK");
    }
    pub(crate) static ID_CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_DOCUMENTS: usize = 82;
    lazy_static! {
        pub static ref REGEX_CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_DOCUMENTS: regex::Regex =
            #[allow(clippy::invalid_regex)]
            regex::Regex::new(r"^/campaigns/(?P<campaignId>[^/?#]*)/orders/(?P<orderId>[^/?#]*)/documents$")
                .expect("Unable to create regex for CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_DOCUMENTS");
    }
    pub(crate) static ID_CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_IDENTIFIERS: usize = 83;
    lazy_static! {
        pub static ref REGEX_CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_IDENTIFIERS: regex::Regex =
            #[allow(clippy::invalid_regex)]
            regex::Regex::new(r"^/campaigns/(?P<campaignId>[^/?#]*)/orders/(?P<orderId>[^/?#]*)/identifiers$")
                .expect("Unable to create regex for CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_IDENTIFIERS");
    }
    pub(crate) static ID_CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_ITEMS: usize = 84;
    lazy_static! {
        pub static ref REGEX_CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_ITEMS: regex::Regex =
            #[allow(clippy::invalid_regex)]
            regex::Regex::new(r"^/campaigns/(?P<campaignId>[^/?#]*)/orders/(?P<orderId>[^/?#]*)/items$")
                .expect("Unable to create regex for CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_ITEMS");
    }
    pub(crate) static ID_CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_RETURNS_RETURNID: usize = 85;
    lazy_static! {
        pub static ref REGEX_CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_RETURNS_RETURNID: regex::Regex =
            #[allow(clippy::invalid_regex)]
            regex::Regex::new(r"^/campaigns/(?P<campaignId>[^/?#]*)/orders/(?P<orderId>[^/?#]*)/returns/(?P<returnId>[^/?#]*)$")
                .expect("Unable to create regex for CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_RETURNS_RETURNID");
    }
    pub(crate) static ID_CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_RETURNS_RETURNID_APPLICATION: usize = 86;
    lazy_static! {
        pub static ref REGEX_CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_RETURNS_RETURNID_APPLICATION: regex::Regex =
            #[allow(clippy::invalid_regex)]
            regex::Regex::new(r"^/campaigns/(?P<campaignId>[^/?#]*)/orders/(?P<orderId>[^/?#]*)/returns/(?P<returnId>[^/?#]*)/application$")
                .expect("Unable to create regex for CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_RETURNS_RETURNID_APPLICATION");
    }
    pub(crate) static ID_CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_RETURNS_RETURNID_DECISION: usize = 87;
    lazy_static! {
        pub static ref REGEX_CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_RETURNS_RETURNID_DECISION: regex::Regex =
            #[allow(clippy::invalid_regex)]
            regex::Regex::new(r"^/campaigns/(?P<campaignId>[^/?#]*)/orders/(?P<orderId>[^/?#]*)/returns/(?P<returnId>[^/?#]*)/decision$")
                .expect("Unable to create regex for CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_RETURNS_RETURNID_DECISION");
    }
    pub(crate) static ID_CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_RETURNS_RETURNID_DECISION_SUBMIT: usize = 88;
    lazy_static! {
        pub static ref REGEX_CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_RETURNS_RETURNID_DECISION_SUBMIT: regex::Regex =
            #[allow(clippy::invalid_regex)]
            regex::Regex::new(r"^/campaigns/(?P<campaignId>[^/?#]*)/orders/(?P<orderId>[^/?#]*)/returns/(?P<returnId>[^/?#]*)/decision/submit$")
                .expect("Unable to create regex for CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_RETURNS_RETURNID_DECISION_SUBMIT");
    }
    pub(crate) static ID_CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_RETURNS_RETURNID_DECISION_ITEMID_IMAGE_IMAGEHASH: usize = 89;
    lazy_static! {
        pub static ref REGEX_CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_RETURNS_RETURNID_DECISION_ITEMID_IMAGE_IMAGEHASH: regex::Regex =
            #[allow(clippy::invalid_regex)]
            regex::Regex::new(r"^/campaigns/(?P<campaignId>[^/?#]*)/orders/(?P<orderId>[^/?#]*)/returns/(?P<returnId>[^/?#]*)/decision/(?P<itemId>[^/?#]*)/image/(?P<imageHash>[^/?#]*)$")
                .expect("Unable to create regex for CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_RETURNS_RETURNID_DECISION_ITEMID_IMAGE_IMAGEHASH");
    }
    pub(crate) static ID_CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_STATUS: usize = 90;
    lazy_static! {
        pub static ref REGEX_CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_STATUS: regex::Regex =
            #[allow(clippy::invalid_regex)]
            regex::Regex::new(r"^/campaigns/(?P<campaignId>[^/?#]*)/orders/(?P<orderId>[^/?#]*)/status$")
                .expect("Unable to create regex for CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_STATUS");
    }
    pub(crate) static ID_CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_VERIFYEAC: usize = 91;
    lazy_static! {
        pub static ref REGEX_CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_VERIFYEAC: regex::Regex =
            #[allow(clippy::invalid_regex)]
            regex::Regex::new(r"^/campaigns/(?P<campaignId>[^/?#]*)/orders/(?P<orderId>[^/?#]*)/verifyEac$")
                .expect("Unable to create regex for CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_VERIFYEAC");
    }
    pub(crate) static ID_CAMPAIGNS_CAMPAIGNID_OUTLETS: usize = 92;
    lazy_static! {
        pub static ref REGEX_CAMPAIGNS_CAMPAIGNID_OUTLETS: regex::Regex =
            #[allow(clippy::invalid_regex)]
            regex::Regex::new(r"^/campaigns/(?P<campaignId>[^/?#]*)/outlets$")
                .expect("Unable to create regex for CAMPAIGNS_CAMPAIGNID_OUTLETS");
    }
    pub(crate) static ID_CAMPAIGNS_CAMPAIGNID_OUTLETS_LICENSES: usize = 93;
    lazy_static! {
        pub static ref REGEX_CAMPAIGNS_CAMPAIGNID_OUTLETS_LICENSES: regex::Regex =
            #[allow(clippy::invalid_regex)]
            regex::Regex::new(r"^/campaigns/(?P<campaignId>[^/?#]*)/outlets/licenses$")
                .expect("Unable to create regex for CAMPAIGNS_CAMPAIGNID_OUTLETS_LICENSES");
    }
    pub(crate) static ID_CAMPAIGNS_CAMPAIGNID_OUTLETS_OUTLETID: usize = 94;
    lazy_static! {
        pub static ref REGEX_CAMPAIGNS_CAMPAIGNID_OUTLETS_OUTLETID: regex::Regex =
            #[allow(clippy::invalid_regex)]
            regex::Regex::new(r"^/campaigns/(?P<campaignId>[^/?#]*)/outlets/(?P<outletId>[^/?#]*)$")
                .expect("Unable to create regex for CAMPAIGNS_CAMPAIGNID_OUTLETS_OUTLETID");
    }
    pub(crate) static ID_CAMPAIGNS_CAMPAIGNID_PRICE_QUARANTINE: usize = 95;
    lazy_static! {
        pub static ref REGEX_CAMPAIGNS_CAMPAIGNID_PRICE_QUARANTINE: regex::Regex =
            #[allow(clippy::invalid_regex)]
            regex::Regex::new(r"^/campaigns/(?P<campaignId>[^/?#]*)/price-quarantine$")
                .expect("Unable to create regex for CAMPAIGNS_CAMPAIGNID_PRICE_QUARANTINE");
    }
    pub(crate) static ID_CAMPAIGNS_CAMPAIGNID_PRICE_QUARANTINE_CONFIRM: usize = 96;
    lazy_static! {
        pub static ref REGEX_CAMPAIGNS_CAMPAIGNID_PRICE_QUARANTINE_CONFIRM: regex::Regex =
            #[allow(clippy::invalid_regex)]
            regex::Regex::new(r"^/campaigns/(?P<campaignId>[^/?#]*)/price-quarantine/confirm$")
                .expect("Unable to create regex for CAMPAIGNS_CAMPAIGNID_PRICE_QUARANTINE_CONFIRM");
    }
    pub(crate) static ID_CAMPAIGNS_CAMPAIGNID_RATINGS_QUALITY_DETAILS: usize = 97;
    lazy_static! {
        pub static ref REGEX_CAMPAIGNS_CAMPAIGNID_RATINGS_QUALITY_DETAILS: regex::Regex =
            #[allow(clippy::invalid_regex)]
            regex::Regex::new(r"^/campaigns/(?P<campaignId>[^/?#]*)/ratings/quality/details$")
                .expect("Unable to create regex for CAMPAIGNS_CAMPAIGNID_RATINGS_QUALITY_DETAILS");
    }
    pub(crate) static ID_CAMPAIGNS_CAMPAIGNID_REGION: usize = 98;
    lazy_static! {
        pub static ref REGEX_CAMPAIGNS_CAMPAIGNID_REGION: regex::Regex =
            #[allow(clippy::invalid_regex)]
            regex::Regex::new(r"^/campaigns/(?P<campaignId>[^/?#]*)/region$")
                .expect("Unable to create regex for CAMPAIGNS_CAMPAIGNID_REGION");
    }
    pub(crate) static ID_CAMPAIGNS_CAMPAIGNID_RETURNS: usize = 99;
    lazy_static! {
        pub static ref REGEX_CAMPAIGNS_CAMPAIGNID_RETURNS: regex::Regex =
            #[allow(clippy::invalid_regex)]
            regex::Regex::new(r"^/campaigns/(?P<campaignId>[^/?#]*)/returns$")
                .expect("Unable to create regex for CAMPAIGNS_CAMPAIGNID_RETURNS");
    }
    pub(crate) static ID_CAMPAIGNS_CAMPAIGNID_SETTINGS: usize = 100;
    lazy_static! {
        pub static ref REGEX_CAMPAIGNS_CAMPAIGNID_SETTINGS: regex::Regex =
            #[allow(clippy::invalid_regex)]
            regex::Regex::new(r"^/campaigns/(?P<campaignId>[^/?#]*)/settings$")
                .expect("Unable to create regex for CAMPAIGNS_CAMPAIGNID_SETTINGS");
    }
    pub(crate) static ID_CAMPAIGNS_CAMPAIGNID_SHIPMENTS_RECEPTION_TRANSFER_ACT: usize = 101;
    lazy_static! {
        pub static ref REGEX_CAMPAIGNS_CAMPAIGNID_SHIPMENTS_RECEPTION_TRANSFER_ACT: regex::Regex =
            #[allow(clippy::invalid_regex)]
            regex::Regex::new(r"^/campaigns/(?P<campaignId>[^/?#]*)/shipments/reception-transfer-act$")
                .expect("Unable to create regex for CAMPAIGNS_CAMPAIGNID_SHIPMENTS_RECEPTION_TRANSFER_ACT");
    }
    pub(crate) static ID_CAMPAIGNS_CAMPAIGNID_STATS_ORDERS: usize = 102;
    lazy_static! {
        pub static ref REGEX_CAMPAIGNS_CAMPAIGNID_STATS_ORDERS: regex::Regex =
            #[allow(clippy::invalid_regex)]
            regex::Regex::new(r"^/campaigns/(?P<campaignId>[^/?#]*)/stats/orders$")
                .expect("Unable to create regex for CAMPAIGNS_CAMPAIGNID_STATS_ORDERS");
    }
    pub(crate) static ID_CAMPAIGNS_CAMPAIGNID_STATS_SKUS: usize = 103;
    lazy_static! {
        pub static ref REGEX_CAMPAIGNS_CAMPAIGNID_STATS_SKUS: regex::Regex =
            #[allow(clippy::invalid_regex)]
            regex::Regex::new(r"^/campaigns/(?P<campaignId>[^/?#]*)/stats/skus$")
                .expect("Unable to create regex for CAMPAIGNS_CAMPAIGNID_STATS_SKUS");
    }
    pub(crate) static ID_CATEGORIES_MAX_SALE_QUANTUM: usize = 104;
    pub(crate) static ID_CATEGORIES_TREE: usize = 105;
    pub(crate) static ID_CATEGORY_CATEGORYID_PARAMETERS: usize = 106;
    lazy_static! {
        pub static ref REGEX_CATEGORY_CATEGORYID_PARAMETERS: regex::Regex =
            #[allow(clippy::invalid_regex)]
            regex::Regex::new(r"^/category/(?P<categoryId>[^/?#]*)/parameters$")
                .expect("Unable to create regex for CATEGORY_CATEGORYID_PARAMETERS");
    }
    pub(crate) static ID_DELIVERY_SERVICES: usize = 107;
    pub(crate) static ID_MODELS: usize = 108;
    pub(crate) static ID_MODELS_OFFERS: usize = 109;
    pub(crate) static ID_MODELS_MODELID: usize = 110;
    lazy_static! {
        pub static ref REGEX_MODELS_MODELID: regex::Regex =
            #[allow(clippy::invalid_regex)]
            regex::Regex::new(r"^/models/(?P<modelId>[^/?#]*)$")
                .expect("Unable to create regex for MODELS_MODELID");
    }
    pub(crate) static ID_MODELS_MODELID_OFFERS: usize = 111;
    lazy_static! {
        pub static ref REGEX_MODELS_MODELID_OFFERS: regex::Regex =
            #[allow(clippy::invalid_regex)]
            regex::Regex::new(r"^/models/(?P<modelId>[^/?#]*)/offers$")
                .expect("Unable to create regex for MODELS_MODELID_OFFERS");
    }
    pub(crate) static ID_REGIONS: usize = 112;
    pub(crate) static ID_REGIONS_REGIONID: usize = 113;
    lazy_static! {
        pub static ref REGEX_REGIONS_REGIONID: regex::Regex =
            #[allow(clippy::invalid_regex)]
            regex::Regex::new(r"^/regions/(?P<regionId>[^/?#]*)$")
                .expect("Unable to create regex for REGIONS_REGIONID");
    }
    pub(crate) static ID_REGIONS_REGIONID_CHILDREN: usize = 114;
    lazy_static! {
        pub static ref REGEX_REGIONS_REGIONID_CHILDREN: regex::Regex =
            #[allow(clippy::invalid_regex)]
            regex::Regex::new(r"^/regions/(?P<regionId>[^/?#]*)/children$")
                .expect("Unable to create regex for REGIONS_REGIONID_CHILDREN");
    }
    pub(crate) static ID_REPORTS_BOOST_CONSOLIDATED_GENERATE: usize = 115;
    pub(crate) static ID_REPORTS_COMPETITORS_POSITION_GENERATE: usize = 116;
    pub(crate) static ID_REPORTS_DOCUMENTS_LABELS_GENERATE: usize = 117;
    pub(crate) static ID_REPORTS_DOCUMENTS_SHIPMENT_LIST_GENERATE: usize = 118;
    pub(crate) static ID_REPORTS_GOODS_FEEDBACK_GENERATE: usize = 119;
    pub(crate) static ID_REPORTS_GOODS_MOVEMENT_GENERATE: usize = 120;
    pub(crate) static ID_REPORTS_GOODS_REALIZATION_GENERATE: usize = 121;
    pub(crate) static ID_REPORTS_GOODS_TURNOVER_GENERATE: usize = 122;
    pub(crate) static ID_REPORTS_INFO_REPORTID: usize = 123;
    lazy_static! {
        pub static ref REGEX_REPORTS_INFO_REPORTID: regex::Regex =
            #[allow(clippy::invalid_regex)]
            regex::Regex::new(r"^/reports/info/(?P<reportId>[^/?#]*)$")
                .expect("Unable to create regex for REPORTS_INFO_REPORTID");
    }
    pub(crate) static ID_REPORTS_PRICES_GENERATE: usize = 124;
    pub(crate) static ID_REPORTS_SHELF_STATISTICS_GENERATE: usize = 125;
    pub(crate) static ID_REPORTS_SHOWS_SALES_GENERATE: usize = 126;
    pub(crate) static ID_REPORTS_STOCKS_ON_WAREHOUSES_GENERATE: usize = 127;
    pub(crate) static ID_REPORTS_UNITED_MARKETPLACE_SERVICES_GENERATE: usize = 128;
    pub(crate) static ID_REPORTS_UNITED_NETTING_GENERATE: usize = 129;
    pub(crate) static ID_REPORTS_UNITED_ORDERS_GENERATE: usize = 130;
    pub(crate) static ID_TARIFFS_CALCULATE: usize = 131;
    pub(crate) static ID_WAREHOUSES: usize = 132;
}


pub struct MakeService<T, C> where
    T: Api<C> + Clone + Send + 'static,
    C: Has<XSpanIdString> + Has<Option<Authorization>> + Send + Sync + 'static
{
    api_impl: T,
    multipart_form_size_limit: Option<u64>,
    marker: PhantomData<C>,
}

impl<T, C> MakeService<T, C> where
    T: Api<C> + Clone + Send + 'static,
    C: Has<XSpanIdString> + Has<Option<Authorization>> + Send + Sync + 'static
{
    pub fn new(api_impl: T) -> Self {
        MakeService {
            api_impl,
            multipart_form_size_limit: Some(8 * 1024 * 1024),
            marker: PhantomData
        }
    }

    /// Configure size limit when inspecting a multipart/form body.
    ///
    /// Default is 8 MiB.
    ///
    /// Set to None for no size limit, which presents a Denial of Service attack risk.
    pub fn multipart_form_size_limit(mut self, multipart_form_size_limit: Option<u64>) -> Self {
        self.multipart_form_size_limit = multipart_form_size_limit;
        self
    }
}

impl<T, C, Target> hyper::service::Service<Target> for MakeService<T, C> where
    T: Api<C> + Clone + Send + 'static,
    C: Has<XSpanIdString> + Has<Option<Authorization>> + Send + Sync + 'static
{
    type Response = Service<T, C>;
    type Error = crate::ServiceError;
    type Future = future::Ready<Result<Self::Response, Self::Error>>;

    fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
        Poll::Ready(Ok(()))
    }

    fn call(&mut self, target: Target) -> Self::Future {
        let service = Service::new(self.api_impl.clone())
            .multipart_form_size_limit(self.multipart_form_size_limit);

        future::ok(service)
    }
}

fn method_not_allowed() -> Result<Response<Body>, crate::ServiceError> {
    Ok(
        Response::builder().status(StatusCode::METHOD_NOT_ALLOWED)
            .body(Body::empty())
            .expect("Unable to create Method Not Allowed response")
    )
}

pub struct Service<T, C> where
    T: Api<C> + Clone + Send + 'static,
    C: Has<XSpanIdString> + Has<Option<Authorization>> + Send + Sync + 'static
{
    api_impl: T,
    multipart_form_size_limit: Option<u64>,
    marker: PhantomData<C>,
}

impl<T, C> Service<T, C> where
    T: Api<C> + Clone + Send + 'static,
    C: Has<XSpanIdString> + Has<Option<Authorization>> + Send + Sync + 'static
{
    pub fn new(api_impl: T) -> Self {
        Service {
            api_impl,
            multipart_form_size_limit: Some(8 * 1024 * 1024),
            marker: PhantomData
        }
    }

    /// Configure size limit when extracting a multipart/form body.
    ///
    /// Default is 8 MiB.
    ///
    /// Set to None for no size limit, which presents a Denial of Service attack risk.
    pub fn multipart_form_size_limit(mut self, multipart_form_size_limit: Option<u64>) -> Self {
        self.multipart_form_size_limit = multipart_form_size_limit;
        self
    }
}

impl<T, C> Clone for Service<T, C> where
    T: Api<C> + Clone + Send + 'static,
    C: Has<XSpanIdString> + Has<Option<Authorization>> + Send + Sync + 'static
{
    fn clone(&self) -> Self {
        Service {
            api_impl: self.api_impl.clone(),
            multipart_form_size_limit: Some(8 * 1024 * 1024),
            marker: self.marker,
        }
    }
}

impl<T, C> hyper::service::Service<(Request<Body>, C)> for Service<T, C> where
    T: Api<C> + Clone + Send + Sync + 'static,
    C: Has<XSpanIdString> + Has<Option<Authorization>> + Send + Sync + 'static
{
    type Response = Response<Body>;
    type Error = crate::ServiceError;
    type Future = ServiceFuture;

    fn poll_ready(&mut self, cx: &mut Context) -> Poll<Result<(), Self::Error>> {
        self.api_impl.poll_ready(cx)
    }

    fn call(&mut self, req: (Request<Body>, C)) -> Self::Future {
        async fn run<T, C>(
            mut api_impl: T,
            req: (Request<Body>, C),
            multipart_form_size_limit: Option<u64>,
        ) -> Result<Response<Body>, crate::ServiceError> where
            T: Api<C> + Clone + Send + 'static,
            C: Has<XSpanIdString> + Has<Option<Authorization>> + Send + Sync + 'static
        {
            let (request, context) = req;
            let (parts, body) = request.into_parts();
            let (method, uri, headers) = (parts.method, parts.uri, parts.headers);
            let path = paths::GLOBAL_REGEX_SET.matches(uri.path());

            match method {

            // GetBidsInfoForBusiness - POST /businesses/{businessId}/bids/info
            hyper::Method::POST if path.matched(paths::ID_BUSINESSES_BUSINESSID_BIDS_INFO) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "market:partner-api".to_string(), // API Яндекс.Маркета / Поиска по товарам для партнеров
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_BUSINESSES_BUSINESSID_BIDS_INFO
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE BUSINESSES_BUSINESSID_BIDS_INFO in set but failed match against \"{}\"", path, paths::REGEX_BUSINESSES_BUSINESSID_BIDS_INFO.as_str())
                    );

                let param_business_id = match percent_encoding::percent_decode(path_params["businessId"].as_bytes()).decode_utf8() {
                    Ok(param_business_id) => match param_business_id.parse::<i64>() {
                        Ok(param_business_id) => param_business_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter businessId: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["businessId"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                // Query parameters (note that non-required or collection query parameters will ignore garbage values, rather than causing a 400 response)
                let query_params = form_urlencoded::parse(uri.query().unwrap_or_default().as_bytes()).collect::<Vec<_>>();
                let param_page_token = query_params.iter().filter(|e| e.0 == "page_token").map(|e| e.1.clone())
                    .next();
                let param_page_token = match param_page_token {
                    Some(param_page_token) => {
                        let param_page_token =
                            <String as std::str::FromStr>::from_str
                                (&param_page_token);
                        match param_page_token {
                            Ok(param_page_token) => Some(param_page_token),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter page_token - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter page_token")),
                        }
                    },
                    None => None,
                };
                let param_limit = query_params.iter().filter(|e| e.0 == "limit").map(|e| e.1.clone())
                    .next();
                let param_limit = match param_limit {
                    Some(param_limit) => {
                        let param_limit =
                            <i32 as std::str::FromStr>::from_str
                                (&param_limit);
                        match param_limit {
                            Ok(param_limit) => Some(param_limit),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter limit - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter limit")),
                        }
                    },
                    None => None,
                };

                // Handle body parameters (note that non-required body parameters will ignore garbage
                // values, rather than causing a 400 response). Produce warning header and logs for
                // any unused fields.
                let result = body.into_raw().await;
                match result {
                     Ok(body) => {
                                let mut unused_elements : Vec<String> = vec![];
                                let param_get_bids_info_request: Option<models::GetBidsInfoRequest> = if !body.is_empty() {
                                    let deserializer = &mut serde_json::Deserializer::from_slice(&*body);
                                    match serde_ignored::deserialize(deserializer, |path| {
                                            warn!("Ignoring unknown field in body: {}", path);
                                            unused_elements.push(path.to_string());
                                    }) {
                                        Ok(param_get_bids_info_request) => param_get_bids_info_request,
                                        Err(_) => None,
                                    }
                                } else {
                                    None
                                };


                                let result = api_impl.get_bids_info_for_business(
                                            param_business_id,
                                            param_page_token,
                                            param_limit,
                                            param_get_bids_info_request,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        if !unused_elements.is_empty() {
                                            response.headers_mut().insert(
                                                HeaderName::from_static("warning"),
                                                HeaderValue::from_str(format!("Ignoring unknown fields in body: {:?}", unused_elements).as_str())
                                                    .expect("Unable to create Warning header value"));
                                        }
                                        match result {
                                            Ok(rsp) => match rsp {
                                                GetBidsInfoForBusinessResponse::Status200
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetBidsInfoForBusinessResponse::Status400
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetBidsInfoForBusinessResponse::Status401
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetBidsInfoForBusinessResponse::Status403
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetBidsInfoForBusinessResponse::Status404
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetBidsInfoForBusinessResponse::Status420
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(420).expect("Unable to turn 420 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetBidsInfoForBusinessResponse::Status500
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
                            },
                            Err(e) => Ok(Response::builder()
                                                .status(StatusCode::BAD_REQUEST)
                                                .body(Body::from(format!("Unable to read body: {}", e)))
                                                .expect("Unable to create Bad Request response due to unable to read body")),
                        }
            },

            // GetBidsRecommendations - POST /businesses/{businessId}/bids/recommendations
            hyper::Method::POST if path.matched(paths::ID_BUSINESSES_BUSINESSID_BIDS_RECOMMENDATIONS) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "market:partner-api".to_string(), // API Яндекс.Маркета / Поиска по товарам для партнеров
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_BUSINESSES_BUSINESSID_BIDS_RECOMMENDATIONS
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE BUSINESSES_BUSINESSID_BIDS_RECOMMENDATIONS in set but failed match against \"{}\"", path, paths::REGEX_BUSINESSES_BUSINESSID_BIDS_RECOMMENDATIONS.as_str())
                    );

                let param_business_id = match percent_encoding::percent_decode(path_params["businessId"].as_bytes()).decode_utf8() {
                    Ok(param_business_id) => match param_business_id.parse::<i64>() {
                        Ok(param_business_id) => param_business_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter businessId: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["businessId"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                // Handle body parameters (note that non-required body parameters will ignore garbage
                // values, rather than causing a 400 response). Produce warning header and logs for
                // any unused fields.
                let result = body.into_raw().await;
                match result {
                     Ok(body) => {
                                let mut unused_elements : Vec<String> = vec![];
                                let param_get_bids_recommendations_request: Option<models::GetBidsRecommendationsRequest> = if !body.is_empty() {
                                    let deserializer = &mut serde_json::Deserializer::from_slice(&*body);
                                    match serde_ignored::deserialize(deserializer, |path| {
                                            warn!("Ignoring unknown field in body: {}", path);
                                            unused_elements.push(path.to_string());
                                    }) {
                                        Ok(param_get_bids_recommendations_request) => param_get_bids_recommendations_request,
                                        Err(e) => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from(format!("Couldn't parse body parameter GetBidsRecommendationsRequest - doesn't match schema: {}", e)))
                                                        .expect("Unable to create Bad Request response for invalid body parameter GetBidsRecommendationsRequest due to schema")),
                                    }
                                } else {
                                    None
                                };
                                let param_get_bids_recommendations_request = match param_get_bids_recommendations_request {
                                    Some(param_get_bids_recommendations_request) => param_get_bids_recommendations_request,
                                    None => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from("Missing required body parameter GetBidsRecommendationsRequest"))
                                                        .expect("Unable to create Bad Request response for missing body parameter GetBidsRecommendationsRequest")),
                                };


                                let result = api_impl.get_bids_recommendations(
                                            param_business_id,
                                            param_get_bids_recommendations_request,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        if !unused_elements.is_empty() {
                                            response.headers_mut().insert(
                                                HeaderName::from_static("warning"),
                                                HeaderValue::from_str(format!("Ignoring unknown fields in body: {:?}", unused_elements).as_str())
                                                    .expect("Unable to create Warning header value"));
                                        }
                                        match result {
                                            Ok(rsp) => match rsp {
                                                GetBidsRecommendationsResponse::Status200
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetBidsRecommendationsResponse::Status400
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetBidsRecommendationsResponse::Status401
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetBidsRecommendationsResponse::Status403
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetBidsRecommendationsResponse::Status404
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetBidsRecommendationsResponse::Status420
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(420).expect("Unable to turn 420 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetBidsRecommendationsResponse::Status500
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
                            },
                            Err(e) => Ok(Response::builder()
                                                .status(StatusCode::BAD_REQUEST)
                                                .body(Body::from(format!("Unable to read body: {}", e)))
                                                .expect("Unable to create Bad Request response due to unable to read body")),
                        }
            },

            // PutBidsForBusiness - PUT /businesses/{businessId}/bids
            hyper::Method::PUT if path.matched(paths::ID_BUSINESSES_BUSINESSID_BIDS) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "market:partner-api".to_string(), // API Яндекс.Маркета / Поиска по товарам для партнеров
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_BUSINESSES_BUSINESSID_BIDS
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE BUSINESSES_BUSINESSID_BIDS in set but failed match against \"{}\"", path, paths::REGEX_BUSINESSES_BUSINESSID_BIDS.as_str())
                    );

                let param_business_id = match percent_encoding::percent_decode(path_params["businessId"].as_bytes()).decode_utf8() {
                    Ok(param_business_id) => match param_business_id.parse::<i64>() {
                        Ok(param_business_id) => param_business_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter businessId: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["businessId"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                // Handle body parameters (note that non-required body parameters will ignore garbage
                // values, rather than causing a 400 response). Produce warning header and logs for
                // any unused fields.
                let result = body.into_raw().await;
                match result {
                     Ok(body) => {
                                let mut unused_elements : Vec<String> = vec![];
                                let param_put_sku_bids_request: Option<models::PutSkuBidsRequest> = if !body.is_empty() {
                                    let deserializer = &mut serde_json::Deserializer::from_slice(&*body);
                                    match serde_ignored::deserialize(deserializer, |path| {
                                            warn!("Ignoring unknown field in body: {}", path);
                                            unused_elements.push(path.to_string());
                                    }) {
                                        Ok(param_put_sku_bids_request) => param_put_sku_bids_request,
                                        Err(e) => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from(format!("Couldn't parse body parameter PutSkuBidsRequest - doesn't match schema: {}", e)))
                                                        .expect("Unable to create Bad Request response for invalid body parameter PutSkuBidsRequest due to schema")),
                                    }
                                } else {
                                    None
                                };
                                let param_put_sku_bids_request = match param_put_sku_bids_request {
                                    Some(param_put_sku_bids_request) => param_put_sku_bids_request,
                                    None => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from("Missing required body parameter PutSkuBidsRequest"))
                                                        .expect("Unable to create Bad Request response for missing body parameter PutSkuBidsRequest")),
                                };


                                let result = api_impl.put_bids_for_business(
                                            param_business_id,
                                            param_put_sku_bids_request,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        if !unused_elements.is_empty() {
                                            response.headers_mut().insert(
                                                HeaderName::from_static("warning"),
                                                HeaderValue::from_str(format!("Ignoring unknown fields in body: {:?}", unused_elements).as_str())
                                                    .expect("Unable to create Warning header value"));
                                        }
                                        match result {
                                            Ok(rsp) => match rsp {
                                                PutBidsForBusinessResponse::Status200
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                PutBidsForBusinessResponse::Status400
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                PutBidsForBusinessResponse::Status401
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                PutBidsForBusinessResponse::Status403
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                PutBidsForBusinessResponse::Status404
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                PutBidsForBusinessResponse::Status420
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(420).expect("Unable to turn 420 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                PutBidsForBusinessResponse::Status500
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
                            },
                            Err(e) => Ok(Response::builder()
                                                .status(StatusCode::BAD_REQUEST)
                                                .body(Body::from(format!("Unable to read body: {}", e)))
                                                .expect("Unable to create Bad Request response due to unable to read body")),
                        }
            },

            // PutBidsForCampaign - PUT /campaigns/{campaignId}/bids
            hyper::Method::PUT if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_BIDS) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "market:partner-api".to_string(), // API Яндекс.Маркета / Поиска по товарам для партнеров
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_CAMPAIGNS_CAMPAIGNID_BIDS
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE CAMPAIGNS_CAMPAIGNID_BIDS in set but failed match against \"{}\"", path, paths::REGEX_CAMPAIGNS_CAMPAIGNID_BIDS.as_str())
                    );

                let param_campaign_id = match percent_encoding::percent_decode(path_params["campaignId"].as_bytes()).decode_utf8() {
                    Ok(param_campaign_id) => match param_campaign_id.parse::<i64>() {
                        Ok(param_campaign_id) => param_campaign_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter campaignId: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["campaignId"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                // Handle body parameters (note that non-required body parameters will ignore garbage
                // values, rather than causing a 400 response). Produce warning header and logs for
                // any unused fields.
                let result = body.into_raw().await;
                match result {
                     Ok(body) => {
                                let mut unused_elements : Vec<String> = vec![];
                                let param_put_sku_bids_request: Option<models::PutSkuBidsRequest> = if !body.is_empty() {
                                    let deserializer = &mut serde_json::Deserializer::from_slice(&*body);
                                    match serde_ignored::deserialize(deserializer, |path| {
                                            warn!("Ignoring unknown field in body: {}", path);
                                            unused_elements.push(path.to_string());
                                    }) {
                                        Ok(param_put_sku_bids_request) => param_put_sku_bids_request,
                                        Err(e) => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from(format!("Couldn't parse body parameter PutSkuBidsRequest - doesn't match schema: {}", e)))
                                                        .expect("Unable to create Bad Request response for invalid body parameter PutSkuBidsRequest due to schema")),
                                    }
                                } else {
                                    None
                                };
                                let param_put_sku_bids_request = match param_put_sku_bids_request {
                                    Some(param_put_sku_bids_request) => param_put_sku_bids_request,
                                    None => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from("Missing required body parameter PutSkuBidsRequest"))
                                                        .expect("Unable to create Bad Request response for missing body parameter PutSkuBidsRequest")),
                                };


                                let result = api_impl.put_bids_for_campaign(
                                            param_campaign_id,
                                            param_put_sku_bids_request,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        if !unused_elements.is_empty() {
                                            response.headers_mut().insert(
                                                HeaderName::from_static("warning"),
                                                HeaderValue::from_str(format!("Ignoring unknown fields in body: {:?}", unused_elements).as_str())
                                                    .expect("Unable to create Warning header value"));
                                        }
                                        match result {
                                            Ok(rsp) => match rsp {
                                                PutBidsForCampaignResponse::Status200
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                PutBidsForCampaignResponse::Status400
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                PutBidsForCampaignResponse::Status401
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                PutBidsForCampaignResponse::Status403
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                PutBidsForCampaignResponse::Status404
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                PutBidsForCampaignResponse::Status420
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(420).expect("Unable to turn 420 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                PutBidsForCampaignResponse::Status500
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
                            },
                            Err(e) => Ok(Response::builder()
                                                .status(StatusCode::BAD_REQUEST)
                                                .body(Body::from(format!("Unable to read body: {}", e)))
                                                .expect("Unable to create Bad Request response due to unable to read body")),
                        }
            },

            // AddOffersToArchive - POST /businesses/{businessId}/offer-mappings/archive
            hyper::Method::POST if path.matched(paths::ID_BUSINESSES_BUSINESSID_OFFER_MAPPINGS_ARCHIVE) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "market:partner-api".to_string(), // API Яндекс.Маркета / Поиска по товарам для партнеров
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_BUSINESSES_BUSINESSID_OFFER_MAPPINGS_ARCHIVE
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE BUSINESSES_BUSINESSID_OFFER_MAPPINGS_ARCHIVE in set but failed match against \"{}\"", path, paths::REGEX_BUSINESSES_BUSINESSID_OFFER_MAPPINGS_ARCHIVE.as_str())
                    );

                let param_business_id = match percent_encoding::percent_decode(path_params["businessId"].as_bytes()).decode_utf8() {
                    Ok(param_business_id) => match param_business_id.parse::<i64>() {
                        Ok(param_business_id) => param_business_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter businessId: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["businessId"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                // Handle body parameters (note that non-required body parameters will ignore garbage
                // values, rather than causing a 400 response). Produce warning header and logs for
                // any unused fields.
                let result = body.into_raw().await;
                match result {
                     Ok(body) => {
                                let mut unused_elements : Vec<String> = vec![];
                                let param_add_offers_to_archive_request: Option<models::AddOffersToArchiveRequest> = if !body.is_empty() {
                                    let deserializer = &mut serde_json::Deserializer::from_slice(&*body);
                                    match serde_ignored::deserialize(deserializer, |path| {
                                            warn!("Ignoring unknown field in body: {}", path);
                                            unused_elements.push(path.to_string());
                                    }) {
                                        Ok(param_add_offers_to_archive_request) => param_add_offers_to_archive_request,
                                        Err(e) => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from(format!("Couldn't parse body parameter AddOffersToArchiveRequest - doesn't match schema: {}", e)))
                                                        .expect("Unable to create Bad Request response for invalid body parameter AddOffersToArchiveRequest due to schema")),
                                    }
                                } else {
                                    None
                                };
                                let param_add_offers_to_archive_request = match param_add_offers_to_archive_request {
                                    Some(param_add_offers_to_archive_request) => param_add_offers_to_archive_request,
                                    None => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from("Missing required body parameter AddOffersToArchiveRequest"))
                                                        .expect("Unable to create Bad Request response for missing body parameter AddOffersToArchiveRequest")),
                                };


                                let result = api_impl.add_offers_to_archive(
                                            param_business_id,
                                            param_add_offers_to_archive_request,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        if !unused_elements.is_empty() {
                                            response.headers_mut().insert(
                                                HeaderName::from_static("warning"),
                                                HeaderValue::from_str(format!("Ignoring unknown fields in body: {:?}", unused_elements).as_str())
                                                    .expect("Unable to create Warning header value"));
                                        }
                                        match result {
                                            Ok(rsp) => match rsp {
                                                AddOffersToArchiveResponse::Status200
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                AddOffersToArchiveResponse::Status400
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                AddOffersToArchiveResponse::Status401
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                AddOffersToArchiveResponse::Status403
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                AddOffersToArchiveResponse::Status404
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                AddOffersToArchiveResponse::Status420
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(420).expect("Unable to turn 420 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                AddOffersToArchiveResponse::Status423
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(423).expect("Unable to turn 423 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                AddOffersToArchiveResponse::Status500
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
                            },
                            Err(e) => Ok(Response::builder()
                                                .status(StatusCode::BAD_REQUEST)
                                                .body(Body::from(format!("Unable to read body: {}", e)))
                                                .expect("Unable to create Bad Request response due to unable to read body")),
                        }
            },

            // DeleteOffers - POST /businesses/{businessId}/offer-mappings/delete
            hyper::Method::POST if path.matched(paths::ID_BUSINESSES_BUSINESSID_OFFER_MAPPINGS_DELETE) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "market:partner-api".to_string(), // API Яндекс.Маркета / Поиска по товарам для партнеров
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_BUSINESSES_BUSINESSID_OFFER_MAPPINGS_DELETE
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE BUSINESSES_BUSINESSID_OFFER_MAPPINGS_DELETE in set but failed match against \"{}\"", path, paths::REGEX_BUSINESSES_BUSINESSID_OFFER_MAPPINGS_DELETE.as_str())
                    );

                let param_business_id = match percent_encoding::percent_decode(path_params["businessId"].as_bytes()).decode_utf8() {
                    Ok(param_business_id) => match param_business_id.parse::<i64>() {
                        Ok(param_business_id) => param_business_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter businessId: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["businessId"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                // Handle body parameters (note that non-required body parameters will ignore garbage
                // values, rather than causing a 400 response). Produce warning header and logs for
                // any unused fields.
                let result = body.into_raw().await;
                match result {
                     Ok(body) => {
                                let mut unused_elements : Vec<String> = vec![];
                                let param_delete_offers_request: Option<models::DeleteOffersRequest> = if !body.is_empty() {
                                    let deserializer = &mut serde_json::Deserializer::from_slice(&*body);
                                    match serde_ignored::deserialize(deserializer, |path| {
                                            warn!("Ignoring unknown field in body: {}", path);
                                            unused_elements.push(path.to_string());
                                    }) {
                                        Ok(param_delete_offers_request) => param_delete_offers_request,
                                        Err(e) => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from(format!("Couldn't parse body parameter DeleteOffersRequest - doesn't match schema: {}", e)))
                                                        .expect("Unable to create Bad Request response for invalid body parameter DeleteOffersRequest due to schema")),
                                    }
                                } else {
                                    None
                                };
                                let param_delete_offers_request = match param_delete_offers_request {
                                    Some(param_delete_offers_request) => param_delete_offers_request,
                                    None => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from("Missing required body parameter DeleteOffersRequest"))
                                                        .expect("Unable to create Bad Request response for missing body parameter DeleteOffersRequest")),
                                };


                                let result = api_impl.delete_offers(
                                            param_business_id,
                                            param_delete_offers_request,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        if !unused_elements.is_empty() {
                                            response.headers_mut().insert(
                                                HeaderName::from_static("warning"),
                                                HeaderValue::from_str(format!("Ignoring unknown fields in body: {:?}", unused_elements).as_str())
                                                    .expect("Unable to create Warning header value"));
                                        }
                                        match result {
                                            Ok(rsp) => match rsp {
                                                DeleteOffersResponse::Status200
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                DeleteOffersResponse::Status400
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                DeleteOffersResponse::Status401
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                DeleteOffersResponse::Status403
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                DeleteOffersResponse::Status404
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                DeleteOffersResponse::Status420
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(420).expect("Unable to turn 420 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                DeleteOffersResponse::Status423
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(423).expect("Unable to turn 423 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                DeleteOffersResponse::Status500
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
                            },
                            Err(e) => Ok(Response::builder()
                                                .status(StatusCode::BAD_REQUEST)
                                                .body(Body::from(format!("Unable to read body: {}", e)))
                                                .expect("Unable to create Bad Request response due to unable to read body")),
                        }
            },

            // DeleteOffersFromArchive - POST /businesses/{businessId}/offer-mappings/unarchive
            hyper::Method::POST if path.matched(paths::ID_BUSINESSES_BUSINESSID_OFFER_MAPPINGS_UNARCHIVE) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "market:partner-api".to_string(), // API Яндекс.Маркета / Поиска по товарам для партнеров
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_BUSINESSES_BUSINESSID_OFFER_MAPPINGS_UNARCHIVE
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE BUSINESSES_BUSINESSID_OFFER_MAPPINGS_UNARCHIVE in set but failed match against \"{}\"", path, paths::REGEX_BUSINESSES_BUSINESSID_OFFER_MAPPINGS_UNARCHIVE.as_str())
                    );

                let param_business_id = match percent_encoding::percent_decode(path_params["businessId"].as_bytes()).decode_utf8() {
                    Ok(param_business_id) => match param_business_id.parse::<i64>() {
                        Ok(param_business_id) => param_business_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter businessId: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["businessId"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                // Handle body parameters (note that non-required body parameters will ignore garbage
                // values, rather than causing a 400 response). Produce warning header and logs for
                // any unused fields.
                let result = body.into_raw().await;
                match result {
                     Ok(body) => {
                                let mut unused_elements : Vec<String> = vec![];
                                let param_delete_offers_from_archive_request: Option<models::DeleteOffersFromArchiveRequest> = if !body.is_empty() {
                                    let deserializer = &mut serde_json::Deserializer::from_slice(&*body);
                                    match serde_ignored::deserialize(deserializer, |path| {
                                            warn!("Ignoring unknown field in body: {}", path);
                                            unused_elements.push(path.to_string());
                                    }) {
                                        Ok(param_delete_offers_from_archive_request) => param_delete_offers_from_archive_request,
                                        Err(e) => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from(format!("Couldn't parse body parameter DeleteOffersFromArchiveRequest - doesn't match schema: {}", e)))
                                                        .expect("Unable to create Bad Request response for invalid body parameter DeleteOffersFromArchiveRequest due to schema")),
                                    }
                                } else {
                                    None
                                };
                                let param_delete_offers_from_archive_request = match param_delete_offers_from_archive_request {
                                    Some(param_delete_offers_from_archive_request) => param_delete_offers_from_archive_request,
                                    None => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from("Missing required body parameter DeleteOffersFromArchiveRequest"))
                                                        .expect("Unable to create Bad Request response for missing body parameter DeleteOffersFromArchiveRequest")),
                                };


                                let result = api_impl.delete_offers_from_archive(
                                            param_business_id,
                                            param_delete_offers_from_archive_request,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        if !unused_elements.is_empty() {
                                            response.headers_mut().insert(
                                                HeaderName::from_static("warning"),
                                                HeaderValue::from_str(format!("Ignoring unknown fields in body: {:?}", unused_elements).as_str())
                                                    .expect("Unable to create Warning header value"));
                                        }
                                        match result {
                                            Ok(rsp) => match rsp {
                                                DeleteOffersFromArchiveResponse::Status200
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                DeleteOffersFromArchiveResponse::Status400
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                DeleteOffersFromArchiveResponse::Status401
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                DeleteOffersFromArchiveResponse::Status403
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                DeleteOffersFromArchiveResponse::Status404
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                DeleteOffersFromArchiveResponse::Status420
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(420).expect("Unable to turn 420 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                DeleteOffersFromArchiveResponse::Status423
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(423).expect("Unable to turn 423 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                DeleteOffersFromArchiveResponse::Status500
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
                            },
                            Err(e) => Ok(Response::builder()
                                                .status(StatusCode::BAD_REQUEST)
                                                .body(Body::from(format!("Unable to read body: {}", e)))
                                                .expect("Unable to create Bad Request response due to unable to read body")),
                        }
            },

            // GetOfferMappings - POST /businesses/{businessId}/offer-mappings
            hyper::Method::POST if path.matched(paths::ID_BUSINESSES_BUSINESSID_OFFER_MAPPINGS) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "market:partner-api".to_string(), // API Яндекс.Маркета / Поиска по товарам для партнеров
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_BUSINESSES_BUSINESSID_OFFER_MAPPINGS
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE BUSINESSES_BUSINESSID_OFFER_MAPPINGS in set but failed match against \"{}\"", path, paths::REGEX_BUSINESSES_BUSINESSID_OFFER_MAPPINGS.as_str())
                    );

                let param_business_id = match percent_encoding::percent_decode(path_params["businessId"].as_bytes()).decode_utf8() {
                    Ok(param_business_id) => match param_business_id.parse::<i64>() {
                        Ok(param_business_id) => param_business_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter businessId: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["businessId"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                // Query parameters (note that non-required or collection query parameters will ignore garbage values, rather than causing a 400 response)
                let query_params = form_urlencoded::parse(uri.query().unwrap_or_default().as_bytes()).collect::<Vec<_>>();
                let param_page_token = query_params.iter().filter(|e| e.0 == "page_token").map(|e| e.1.clone())
                    .next();
                let param_page_token = match param_page_token {
                    Some(param_page_token) => {
                        let param_page_token =
                            <String as std::str::FromStr>::from_str
                                (&param_page_token);
                        match param_page_token {
                            Ok(param_page_token) => Some(param_page_token),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter page_token - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter page_token")),
                        }
                    },
                    None => None,
                };
                let param_limit = query_params.iter().filter(|e| e.0 == "limit").map(|e| e.1.clone())
                    .next();
                let param_limit = match param_limit {
                    Some(param_limit) => {
                        let param_limit =
                            <i32 as std::str::FromStr>::from_str
                                (&param_limit);
                        match param_limit {
                            Ok(param_limit) => Some(param_limit),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter limit - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter limit")),
                        }
                    },
                    None => None,
                };

                // Handle body parameters (note that non-required body parameters will ignore garbage
                // values, rather than causing a 400 response). Produce warning header and logs for
                // any unused fields.
                let result = body.into_raw().await;
                match result {
                     Ok(body) => {
                                let mut unused_elements : Vec<String> = vec![];
                                let param_get_offer_mappings_request: Option<models::GetOfferMappingsRequest> = if !body.is_empty() {
                                    let deserializer = &mut serde_json::Deserializer::from_slice(&*body);
                                    match serde_ignored::deserialize(deserializer, |path| {
                                            warn!("Ignoring unknown field in body: {}", path);
                                            unused_elements.push(path.to_string());
                                    }) {
                                        Ok(param_get_offer_mappings_request) => param_get_offer_mappings_request,
                                        Err(_) => None,
                                    }
                                } else {
                                    None
                                };


                                let result = api_impl.get_offer_mappings(
                                            param_business_id,
                                            param_page_token,
                                            param_limit,
                                            param_get_offer_mappings_request,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        if !unused_elements.is_empty() {
                                            response.headers_mut().insert(
                                                HeaderName::from_static("warning"),
                                                HeaderValue::from_str(format!("Ignoring unknown fields in body: {:?}", unused_elements).as_str())
                                                    .expect("Unable to create Warning header value"));
                                        }
                                        match result {
                                            Ok(rsp) => match rsp {
                                                GetOfferMappingsResponse::Status200
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetOfferMappingsResponse::Status400
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetOfferMappingsResponse::Status401
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetOfferMappingsResponse::Status403
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetOfferMappingsResponse::Status404
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetOfferMappingsResponse::Status420
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(420).expect("Unable to turn 420 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetOfferMappingsResponse::Status500
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
                            },
                            Err(e) => Ok(Response::builder()
                                                .status(StatusCode::BAD_REQUEST)
                                                .body(Body::from(format!("Unable to read body: {}", e)))
                                                .expect("Unable to create Bad Request response due to unable to read body")),
                        }
            },

            // GetSuggestedOfferMappings - POST /businesses/{businessId}/offer-mappings/suggestions
            hyper::Method::POST if path.matched(paths::ID_BUSINESSES_BUSINESSID_OFFER_MAPPINGS_SUGGESTIONS) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "market:partner-api".to_string(), // API Яндекс.Маркета / Поиска по товарам для партнеров
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_BUSINESSES_BUSINESSID_OFFER_MAPPINGS_SUGGESTIONS
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE BUSINESSES_BUSINESSID_OFFER_MAPPINGS_SUGGESTIONS in set but failed match against \"{}\"", path, paths::REGEX_BUSINESSES_BUSINESSID_OFFER_MAPPINGS_SUGGESTIONS.as_str())
                    );

                let param_business_id = match percent_encoding::percent_decode(path_params["businessId"].as_bytes()).decode_utf8() {
                    Ok(param_business_id) => match param_business_id.parse::<i64>() {
                        Ok(param_business_id) => param_business_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter businessId: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["businessId"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                // Handle body parameters (note that non-required body parameters will ignore garbage
                // values, rather than causing a 400 response). Produce warning header and logs for
                // any unused fields.
                let result = body.into_raw().await;
                match result {
                     Ok(body) => {
                                let mut unused_elements : Vec<String> = vec![];
                                let param_get_suggested_offer_mappings_request: Option<models::GetSuggestedOfferMappingsRequest> = if !body.is_empty() {
                                    let deserializer = &mut serde_json::Deserializer::from_slice(&*body);
                                    match serde_ignored::deserialize(deserializer, |path| {
                                            warn!("Ignoring unknown field in body: {}", path);
                                            unused_elements.push(path.to_string());
                                    }) {
                                        Ok(param_get_suggested_offer_mappings_request) => param_get_suggested_offer_mappings_request,
                                        Err(_) => None,
                                    }
                                } else {
                                    None
                                };


                                let result = api_impl.get_suggested_offer_mappings(
                                            param_business_id,
                                            param_get_suggested_offer_mappings_request,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        if !unused_elements.is_empty() {
                                            response.headers_mut().insert(
                                                HeaderName::from_static("warning"),
                                                HeaderValue::from_str(format!("Ignoring unknown fields in body: {:?}", unused_elements).as_str())
                                                    .expect("Unable to create Warning header value"));
                                        }
                                        match result {
                                            Ok(rsp) => match rsp {
                                                GetSuggestedOfferMappingsResponse::Status200
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetSuggestedOfferMappingsResponse::Status400
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetSuggestedOfferMappingsResponse::Status401
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetSuggestedOfferMappingsResponse::Status403
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetSuggestedOfferMappingsResponse::Status404
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetSuggestedOfferMappingsResponse::Status420
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(420).expect("Unable to turn 420 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetSuggestedOfferMappingsResponse::Status500
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
                            },
                            Err(e) => Ok(Response::builder()
                                                .status(StatusCode::BAD_REQUEST)
                                                .body(Body::from(format!("Unable to read body: {}", e)))
                                                .expect("Unable to create Bad Request response due to unable to read body")),
                        }
            },

            // UpdateOfferMappings - POST /businesses/{businessId}/offer-mappings/update
            hyper::Method::POST if path.matched(paths::ID_BUSINESSES_BUSINESSID_OFFER_MAPPINGS_UPDATE) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "market:partner-api".to_string(), // API Яндекс.Маркета / Поиска по товарам для партнеров
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_BUSINESSES_BUSINESSID_OFFER_MAPPINGS_UPDATE
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE BUSINESSES_BUSINESSID_OFFER_MAPPINGS_UPDATE in set but failed match against \"{}\"", path, paths::REGEX_BUSINESSES_BUSINESSID_OFFER_MAPPINGS_UPDATE.as_str())
                    );

                let param_business_id = match percent_encoding::percent_decode(path_params["businessId"].as_bytes()).decode_utf8() {
                    Ok(param_business_id) => match param_business_id.parse::<i64>() {
                        Ok(param_business_id) => param_business_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter businessId: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["businessId"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                // Handle body parameters (note that non-required body parameters will ignore garbage
                // values, rather than causing a 400 response). Produce warning header and logs for
                // any unused fields.
                let result = body.into_raw().await;
                match result {
                     Ok(body) => {
                                let mut unused_elements : Vec<String> = vec![];
                                let param_update_offer_mappings_request: Option<models::UpdateOfferMappingsRequest> = if !body.is_empty() {
                                    let deserializer = &mut serde_json::Deserializer::from_slice(&*body);
                                    match serde_ignored::deserialize(deserializer, |path| {
                                            warn!("Ignoring unknown field in body: {}", path);
                                            unused_elements.push(path.to_string());
                                    }) {
                                        Ok(param_update_offer_mappings_request) => param_update_offer_mappings_request,
                                        Err(e) => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from(format!("Couldn't parse body parameter UpdateOfferMappingsRequest - doesn't match schema: {}", e)))
                                                        .expect("Unable to create Bad Request response for invalid body parameter UpdateOfferMappingsRequest due to schema")),
                                    }
                                } else {
                                    None
                                };
                                let param_update_offer_mappings_request = match param_update_offer_mappings_request {
                                    Some(param_update_offer_mappings_request) => param_update_offer_mappings_request,
                                    None => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from("Missing required body parameter UpdateOfferMappingsRequest"))
                                                        .expect("Unable to create Bad Request response for missing body parameter UpdateOfferMappingsRequest")),
                                };


                                let result = api_impl.update_offer_mappings(
                                            param_business_id,
                                            param_update_offer_mappings_request,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        if !unused_elements.is_empty() {
                                            response.headers_mut().insert(
                                                HeaderName::from_static("warning"),
                                                HeaderValue::from_str(format!("Ignoring unknown fields in body: {:?}", unused_elements).as_str())
                                                    .expect("Unable to create Warning header value"));
                                        }
                                        match result {
                                            Ok(rsp) => match rsp {
                                                UpdateOfferMappingsResponse::Status200
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                UpdateOfferMappingsResponse::Status400
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                UpdateOfferMappingsResponse::Status401
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                UpdateOfferMappingsResponse::Status403
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                UpdateOfferMappingsResponse::Status404
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                UpdateOfferMappingsResponse::Status420
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(420).expect("Unable to turn 420 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                UpdateOfferMappingsResponse::Status423
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(423).expect("Unable to turn 423 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                UpdateOfferMappingsResponse::Status500
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
                            },
                            Err(e) => Ok(Response::builder()
                                                .status(StatusCode::BAD_REQUEST)
                                                .body(Body::from(format!("Unable to read body: {}", e)))
                                                .expect("Unable to create Bad Request response due to unable to read body")),
                        }
            },

            // GetBusinessSettings - POST /businesses/{businessId}/settings
            hyper::Method::POST if path.matched(paths::ID_BUSINESSES_BUSINESSID_SETTINGS) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "market:partner-api".to_string(), // API Яндекс.Маркета / Поиска по товарам для партнеров
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_BUSINESSES_BUSINESSID_SETTINGS
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE BUSINESSES_BUSINESSID_SETTINGS in set but failed match against \"{}\"", path, paths::REGEX_BUSINESSES_BUSINESSID_SETTINGS.as_str())
                    );

                let param_business_id = match percent_encoding::percent_decode(path_params["businessId"].as_bytes()).decode_utf8() {
                    Ok(param_business_id) => match param_business_id.parse::<i64>() {
                        Ok(param_business_id) => param_business_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter businessId: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["businessId"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                                let result = api_impl.get_business_settings(
                                            param_business_id,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                GetBusinessSettingsResponse::Status200
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetBusinessSettingsResponse::Status400
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetBusinessSettingsResponse::Status401
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetBusinessSettingsResponse::Status403
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetBusinessSettingsResponse::Status404
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetBusinessSettingsResponse::Status420
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(420).expect("Unable to turn 420 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetBusinessSettingsResponse::Status500
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
            },

            // GetCampaigns - GET /campaigns
            hyper::Method::GET if path.matched(paths::ID_CAMPAIGNS) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "market:partner-api".to_string(), // API Яндекс.Маркета / Поиска по товарам для партнеров
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Query parameters (note that non-required or collection query parameters will ignore garbage values, rather than causing a 400 response)
                let query_params = form_urlencoded::parse(uri.query().unwrap_or_default().as_bytes()).collect::<Vec<_>>();
                let param_page = query_params.iter().filter(|e| e.0 == "page").map(|e| e.1.clone())
                    .next();
                let param_page = match param_page {
                    Some(param_page) => {
                        let param_page =
                            <i32 as std::str::FromStr>::from_str
                                (&param_page);
                        match param_page {
                            Ok(param_page) => Some(param_page),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter page - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter page")),
                        }
                    },
                    None => None,
                };
                let param_page_size = query_params.iter().filter(|e| e.0 == "pageSize").map(|e| e.1.clone())
                    .next();
                let param_page_size = match param_page_size {
                    Some(param_page_size) => {
                        let param_page_size =
                            <i32 as std::str::FromStr>::from_str
                                (&param_page_size);
                        match param_page_size {
                            Ok(param_page_size) => Some(param_page_size),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter pageSize - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter pageSize")),
                        }
                    },
                    None => None,
                };

                                let result = api_impl.get_campaigns(
                                            param_page,
                                            param_page_size,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                GetCampaignsResponse::Status200
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetCampaignsResponse::Status400
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetCampaignsResponse::Status401
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetCampaignsResponse::Status403
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetCampaignsResponse::Status404
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetCampaignsResponse::Status420
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(420).expect("Unable to turn 420 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetCampaignsResponse::Status500
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
            },

            // GetCampaign - GET /campaigns/{campaignId}
            hyper::Method::GET if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "market:partner-api".to_string(), // API Яндекс.Маркета / Поиска по товарам для партнеров
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_CAMPAIGNS_CAMPAIGNID
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE CAMPAIGNS_CAMPAIGNID in set but failed match against \"{}\"", path, paths::REGEX_CAMPAIGNS_CAMPAIGNID.as_str())
                    );

                let param_campaign_id = match percent_encoding::percent_decode(path_params["campaignId"].as_bytes()).decode_utf8() {
                    Ok(param_campaign_id) => match param_campaign_id.parse::<i64>() {
                        Ok(param_campaign_id) => param_campaign_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter campaignId: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["campaignId"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                                let result = api_impl.get_campaign(
                                            param_campaign_id,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                GetCampaignResponse::Status200
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetCampaignResponse::Status400
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetCampaignResponse::Status401
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetCampaignResponse::Status403
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetCampaignResponse::Status404
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetCampaignResponse::Status420
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(420).expect("Unable to turn 420 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetCampaignResponse::Status500
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
            },

            // GetCampaignLogins - GET /campaigns/{campaignId}/logins
            hyper::Method::GET if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_LOGINS) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "market:partner-api".to_string(), // API Яндекс.Маркета / Поиска по товарам для партнеров
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_CAMPAIGNS_CAMPAIGNID_LOGINS
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE CAMPAIGNS_CAMPAIGNID_LOGINS in set but failed match against \"{}\"", path, paths::REGEX_CAMPAIGNS_CAMPAIGNID_LOGINS.as_str())
                    );

                let param_campaign_id = match percent_encoding::percent_decode(path_params["campaignId"].as_bytes()).decode_utf8() {
                    Ok(param_campaign_id) => match param_campaign_id.parse::<i64>() {
                        Ok(param_campaign_id) => param_campaign_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter campaignId: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["campaignId"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                                let result = api_impl.get_campaign_logins(
                                            param_campaign_id,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                GetCampaignLoginsResponse::Status200
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetCampaignLoginsResponse::Status400
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetCampaignLoginsResponse::Status401
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetCampaignLoginsResponse::Status403
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetCampaignLoginsResponse::Status404
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetCampaignLoginsResponse::Status420
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(420).expect("Unable to turn 420 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetCampaignLoginsResponse::Status500
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
            },

            // GetCampaignRegion - GET /campaigns/{campaignId}/region
            hyper::Method::GET if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_REGION) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "market:partner-api".to_string(), // API Яндекс.Маркета / Поиска по товарам для партнеров
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_CAMPAIGNS_CAMPAIGNID_REGION
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE CAMPAIGNS_CAMPAIGNID_REGION in set but failed match against \"{}\"", path, paths::REGEX_CAMPAIGNS_CAMPAIGNID_REGION.as_str())
                    );

                let param_campaign_id = match percent_encoding::percent_decode(path_params["campaignId"].as_bytes()).decode_utf8() {
                    Ok(param_campaign_id) => match param_campaign_id.parse::<i64>() {
                        Ok(param_campaign_id) => param_campaign_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter campaignId: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["campaignId"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                                let result = api_impl.get_campaign_region(
                                            param_campaign_id,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                GetCampaignRegionResponse::Status200
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetCampaignRegionResponse::Status400
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetCampaignRegionResponse::Status401
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetCampaignRegionResponse::Status403
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetCampaignRegionResponse::Status404
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetCampaignRegionResponse::Status420
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(420).expect("Unable to turn 420 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetCampaignRegionResponse::Status500
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
            },

            // GetCampaignSettings - GET /campaigns/{campaignId}/settings
            hyper::Method::GET if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_SETTINGS) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "market:partner-api".to_string(), // API Яндекс.Маркета / Поиска по товарам для партнеров
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_CAMPAIGNS_CAMPAIGNID_SETTINGS
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE CAMPAIGNS_CAMPAIGNID_SETTINGS in set but failed match against \"{}\"", path, paths::REGEX_CAMPAIGNS_CAMPAIGNID_SETTINGS.as_str())
                    );

                let param_campaign_id = match percent_encoding::percent_decode(path_params["campaignId"].as_bytes()).decode_utf8() {
                    Ok(param_campaign_id) => match param_campaign_id.parse::<i64>() {
                        Ok(param_campaign_id) => param_campaign_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter campaignId: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["campaignId"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                                let result = api_impl.get_campaign_settings(
                                            param_campaign_id,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                GetCampaignSettingsResponse::Status200
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetCampaignSettingsResponse::Status400
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetCampaignSettingsResponse::Status401
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetCampaignSettingsResponse::Status403
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetCampaignSettingsResponse::Status404
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetCampaignSettingsResponse::Status420
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(420).expect("Unable to turn 420 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetCampaignSettingsResponse::Status500
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
            },

            // GetCampaignsByLogin - GET /campaigns/by_login/{login}
            hyper::Method::GET if path.matched(paths::ID_CAMPAIGNS_BY_LOGIN_LOGIN) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "market:partner-api".to_string(), // API Яндекс.Маркета / Поиска по товарам для партнеров
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_CAMPAIGNS_BY_LOGIN_LOGIN
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE CAMPAIGNS_BY_LOGIN_LOGIN in set but failed match against \"{}\"", path, paths::REGEX_CAMPAIGNS_BY_LOGIN_LOGIN.as_str())
                    );

                let param_login = match percent_encoding::percent_decode(path_params["login"].as_bytes()).decode_utf8() {
                    Ok(param_login) => match param_login.parse::<String>() {
                        Ok(param_login) => param_login,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter login: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["login"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                // Query parameters (note that non-required or collection query parameters will ignore garbage values, rather than causing a 400 response)
                let query_params = form_urlencoded::parse(uri.query().unwrap_or_default().as_bytes()).collect::<Vec<_>>();
                let param_page = query_params.iter().filter(|e| e.0 == "page").map(|e| e.1.clone())
                    .next();
                let param_page = match param_page {
                    Some(param_page) => {
                        let param_page =
                            <i32 as std::str::FromStr>::from_str
                                (&param_page);
                        match param_page {
                            Ok(param_page) => Some(param_page),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter page - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter page")),
                        }
                    },
                    None => None,
                };
                let param_page_size = query_params.iter().filter(|e| e.0 == "pageSize").map(|e| e.1.clone())
                    .next();
                let param_page_size = match param_page_size {
                    Some(param_page_size) => {
                        let param_page_size =
                            <i32 as std::str::FromStr>::from_str
                                (&param_page_size);
                        match param_page_size {
                            Ok(param_page_size) => Some(param_page_size),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter pageSize - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter pageSize")),
                        }
                    },
                    None => None,
                };

                                let result = api_impl.get_campaigns_by_login(
                                            param_login,
                                            param_page,
                                            param_page_size,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                GetCampaignsByLoginResponse::Status200
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetCampaignsByLoginResponse::Status400
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetCampaignsByLoginResponse::Status401
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetCampaignsByLoginResponse::Status403
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetCampaignsByLoginResponse::Status404
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetCampaignsByLoginResponse::Status420
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(420).expect("Unable to turn 420 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetCampaignsByLoginResponse::Status500
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
            },

            // GetCategoriesMaxSaleQuantum - POST /categories/max-sale-quantum
            hyper::Method::POST if path.matched(paths::ID_CATEGORIES_MAX_SALE_QUANTUM) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "market:partner-api".to_string(), // API Яндекс.Маркета / Поиска по товарам для партнеров
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Handle body parameters (note that non-required body parameters will ignore garbage
                // values, rather than causing a 400 response). Produce warning header and logs for
                // any unused fields.
                let result = body.into_raw().await;
                match result {
                     Ok(body) => {
                                let mut unused_elements : Vec<String> = vec![];
                                let param_get_categories_max_sale_quantum_request: Option<models::GetCategoriesMaxSaleQuantumRequest> = if !body.is_empty() {
                                    let deserializer = &mut serde_json::Deserializer::from_slice(&*body);
                                    match serde_ignored::deserialize(deserializer, |path| {
                                            warn!("Ignoring unknown field in body: {}", path);
                                            unused_elements.push(path.to_string());
                                    }) {
                                        Ok(param_get_categories_max_sale_quantum_request) => param_get_categories_max_sale_quantum_request,
                                        Err(e) => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from(format!("Couldn't parse body parameter GetCategoriesMaxSaleQuantumRequest - doesn't match schema: {}", e)))
                                                        .expect("Unable to create Bad Request response for invalid body parameter GetCategoriesMaxSaleQuantumRequest due to schema")),
                                    }
                                } else {
                                    None
                                };
                                let param_get_categories_max_sale_quantum_request = match param_get_categories_max_sale_quantum_request {
                                    Some(param_get_categories_max_sale_quantum_request) => param_get_categories_max_sale_quantum_request,
                                    None => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from("Missing required body parameter GetCategoriesMaxSaleQuantumRequest"))
                                                        .expect("Unable to create Bad Request response for missing body parameter GetCategoriesMaxSaleQuantumRequest")),
                                };


                                let result = api_impl.get_categories_max_sale_quantum(
                                            param_get_categories_max_sale_quantum_request,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        if !unused_elements.is_empty() {
                                            response.headers_mut().insert(
                                                HeaderName::from_static("warning"),
                                                HeaderValue::from_str(format!("Ignoring unknown fields in body: {:?}", unused_elements).as_str())
                                                    .expect("Unable to create Warning header value"));
                                        }
                                        match result {
                                            Ok(rsp) => match rsp {
                                                GetCategoriesMaxSaleQuantumResponse::Status200
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetCategoriesMaxSaleQuantumResponse::Status400
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetCategoriesMaxSaleQuantumResponse::Status401
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetCategoriesMaxSaleQuantumResponse::Status403
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetCategoriesMaxSaleQuantumResponse::Status404
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetCategoriesMaxSaleQuantumResponse::Status420
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(420).expect("Unable to turn 420 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetCategoriesMaxSaleQuantumResponse::Status500
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
                            },
                            Err(e) => Ok(Response::builder()
                                                .status(StatusCode::BAD_REQUEST)
                                                .body(Body::from(format!("Unable to read body: {}", e)))
                                                .expect("Unable to create Bad Request response due to unable to read body")),
                        }
            },

            // GetCategoriesTree - POST /categories/tree
            hyper::Method::POST if path.matched(paths::ID_CATEGORIES_TREE) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "market:partner-api".to_string(), // API Яндекс.Маркета / Поиска по товарам для партнеров
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Handle body parameters (note that non-required body parameters will ignore garbage
                // values, rather than causing a 400 response). Produce warning header and logs for
                // any unused fields.
                let result = body.into_raw().await;
                match result {
                     Ok(body) => {
                                let mut unused_elements : Vec<String> = vec![];
                                let param_get_categories_request: Option<models::GetCategoriesRequest> = if !body.is_empty() {
                                    let deserializer = &mut serde_json::Deserializer::from_slice(&*body);
                                    match serde_ignored::deserialize(deserializer, |path| {
                                            warn!("Ignoring unknown field in body: {}", path);
                                            unused_elements.push(path.to_string());
                                    }) {
                                        Ok(param_get_categories_request) => param_get_categories_request,
                                        Err(_) => None,
                                    }
                                } else {
                                    None
                                };


                                let result = api_impl.get_categories_tree(
                                            param_get_categories_request,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        if !unused_elements.is_empty() {
                                            response.headers_mut().insert(
                                                HeaderName::from_static("warning"),
                                                HeaderValue::from_str(format!("Ignoring unknown fields in body: {:?}", unused_elements).as_str())
                                                    .expect("Unable to create Warning header value"));
                                        }
                                        match result {
                                            Ok(rsp) => match rsp {
                                                GetCategoriesTreeResponse::Status200
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetCategoriesTreeResponse::Status400
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetCategoriesTreeResponse::Status401
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetCategoriesTreeResponse::Status403
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetCategoriesTreeResponse::Status404
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetCategoriesTreeResponse::Status420
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(420).expect("Unable to turn 420 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetCategoriesTreeResponse::Status500
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
                            },
                            Err(e) => Ok(Response::builder()
                                                .status(StatusCode::BAD_REQUEST)
                                                .body(Body::from(format!("Unable to read body: {}", e)))
                                                .expect("Unable to create Bad Request response due to unable to read body")),
                        }
            },

            // CreateChat - POST /businesses/{businessId}/chats/new
            hyper::Method::POST if path.matched(paths::ID_BUSINESSES_BUSINESSID_CHATS_NEW) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "market:partner-api".to_string(), // API Яндекс.Маркета / Поиска по товарам для партнеров
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_BUSINESSES_BUSINESSID_CHATS_NEW
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE BUSINESSES_BUSINESSID_CHATS_NEW in set but failed match against \"{}\"", path, paths::REGEX_BUSINESSES_BUSINESSID_CHATS_NEW.as_str())
                    );

                let param_business_id = match percent_encoding::percent_decode(path_params["businessId"].as_bytes()).decode_utf8() {
                    Ok(param_business_id) => match param_business_id.parse::<i64>() {
                        Ok(param_business_id) => param_business_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter businessId: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["businessId"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                // Handle body parameters (note that non-required body parameters will ignore garbage
                // values, rather than causing a 400 response). Produce warning header and logs for
                // any unused fields.
                let result = body.into_raw().await;
                match result {
                     Ok(body) => {
                                let mut unused_elements : Vec<String> = vec![];
                                let param_create_chat_request: Option<models::CreateChatRequest> = if !body.is_empty() {
                                    let deserializer = &mut serde_json::Deserializer::from_slice(&*body);
                                    match serde_ignored::deserialize(deserializer, |path| {
                                            warn!("Ignoring unknown field in body: {}", path);
                                            unused_elements.push(path.to_string());
                                    }) {
                                        Ok(param_create_chat_request) => param_create_chat_request,
                                        Err(e) => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from(format!("Couldn't parse body parameter CreateChatRequest - doesn't match schema: {}", e)))
                                                        .expect("Unable to create Bad Request response for invalid body parameter CreateChatRequest due to schema")),
                                    }
                                } else {
                                    None
                                };
                                let param_create_chat_request = match param_create_chat_request {
                                    Some(param_create_chat_request) => param_create_chat_request,
                                    None => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from("Missing required body parameter CreateChatRequest"))
                                                        .expect("Unable to create Bad Request response for missing body parameter CreateChatRequest")),
                                };


                                let result = api_impl.create_chat(
                                            param_business_id,
                                            param_create_chat_request,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        if !unused_elements.is_empty() {
                                            response.headers_mut().insert(
                                                HeaderName::from_static("warning"),
                                                HeaderValue::from_str(format!("Ignoring unknown fields in body: {:?}", unused_elements).as_str())
                                                    .expect("Unable to create Warning header value"));
                                        }
                                        match result {
                                            Ok(rsp) => match rsp {
                                                CreateChatResponse::Status200
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                CreateChatResponse::Status400
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                CreateChatResponse::Status401
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                CreateChatResponse::Status403
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                CreateChatResponse::Status404
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                CreateChatResponse::Status420
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(420).expect("Unable to turn 420 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                CreateChatResponse::Status500
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
                            },
                            Err(e) => Ok(Response::builder()
                                                .status(StatusCode::BAD_REQUEST)
                                                .body(Body::from(format!("Unable to read body: {}", e)))
                                                .expect("Unable to create Bad Request response due to unable to read body")),
                        }
            },

            // GetChatHistory - POST /businesses/{businessId}/chats/history
            hyper::Method::POST if path.matched(paths::ID_BUSINESSES_BUSINESSID_CHATS_HISTORY) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "market:partner-api".to_string(), // API Яндекс.Маркета / Поиска по товарам для партнеров
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_BUSINESSES_BUSINESSID_CHATS_HISTORY
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE BUSINESSES_BUSINESSID_CHATS_HISTORY in set but failed match against \"{}\"", path, paths::REGEX_BUSINESSES_BUSINESSID_CHATS_HISTORY.as_str())
                    );

                let param_business_id = match percent_encoding::percent_decode(path_params["businessId"].as_bytes()).decode_utf8() {
                    Ok(param_business_id) => match param_business_id.parse::<i64>() {
                        Ok(param_business_id) => param_business_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter businessId: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["businessId"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                // Query parameters (note that non-required or collection query parameters will ignore garbage values, rather than causing a 400 response)
                let query_params = form_urlencoded::parse(uri.query().unwrap_or_default().as_bytes()).collect::<Vec<_>>();
                let param_chat_id = query_params.iter().filter(|e| e.0 == "chatId").map(|e| e.1.clone())
                    .next();
                let param_chat_id = match param_chat_id {
                    Some(param_chat_id) => {
                        let param_chat_id =
                            <i64 as std::str::FromStr>::from_str
                                (&param_chat_id);
                        match param_chat_id {
                            Ok(param_chat_id) => Some(param_chat_id),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter chatId - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter chatId")),
                        }
                    },
                    None => None,
                };
                let param_chat_id = match param_chat_id {
                    Some(param_chat_id) => param_chat_id,
                    None => return Ok(Response::builder()
                        .status(StatusCode::BAD_REQUEST)
                        .body(Body::from("Missing required query parameter chatId"))
                        .expect("Unable to create Bad Request response for missing query parameter chatId")),
                };
                let param_page_token = query_params.iter().filter(|e| e.0 == "page_token").map(|e| e.1.clone())
                    .next();
                let param_page_token = match param_page_token {
                    Some(param_page_token) => {
                        let param_page_token =
                            <String as std::str::FromStr>::from_str
                                (&param_page_token);
                        match param_page_token {
                            Ok(param_page_token) => Some(param_page_token),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter page_token - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter page_token")),
                        }
                    },
                    None => None,
                };
                let param_limit = query_params.iter().filter(|e| e.0 == "limit").map(|e| e.1.clone())
                    .next();
                let param_limit = match param_limit {
                    Some(param_limit) => {
                        let param_limit =
                            <i32 as std::str::FromStr>::from_str
                                (&param_limit);
                        match param_limit {
                            Ok(param_limit) => Some(param_limit),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter limit - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter limit")),
                        }
                    },
                    None => None,
                };

                // Handle body parameters (note that non-required body parameters will ignore garbage
                // values, rather than causing a 400 response). Produce warning header and logs for
                // any unused fields.
                let result = body.into_raw().await;
                match result {
                     Ok(body) => {
                                let mut unused_elements : Vec<String> = vec![];
                                let param_get_chat_history_request: Option<models::GetChatHistoryRequest> = if !body.is_empty() {
                                    let deserializer = &mut serde_json::Deserializer::from_slice(&*body);
                                    match serde_ignored::deserialize(deserializer, |path| {
                                            warn!("Ignoring unknown field in body: {}", path);
                                            unused_elements.push(path.to_string());
                                    }) {
                                        Ok(param_get_chat_history_request) => param_get_chat_history_request,
                                        Err(e) => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from(format!("Couldn't parse body parameter GetChatHistoryRequest - doesn't match schema: {}", e)))
                                                        .expect("Unable to create Bad Request response for invalid body parameter GetChatHistoryRequest due to schema")),
                                    }
                                } else {
                                    None
                                };
                                let param_get_chat_history_request = match param_get_chat_history_request {
                                    Some(param_get_chat_history_request) => param_get_chat_history_request,
                                    None => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from("Missing required body parameter GetChatHistoryRequest"))
                                                        .expect("Unable to create Bad Request response for missing body parameter GetChatHistoryRequest")),
                                };


                                let result = api_impl.get_chat_history(
                                            param_business_id,
                                            param_chat_id,
                                            param_get_chat_history_request,
                                            param_page_token,
                                            param_limit,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        if !unused_elements.is_empty() {
                                            response.headers_mut().insert(
                                                HeaderName::from_static("warning"),
                                                HeaderValue::from_str(format!("Ignoring unknown fields in body: {:?}", unused_elements).as_str())
                                                    .expect("Unable to create Warning header value"));
                                        }
                                        match result {
                                            Ok(rsp) => match rsp {
                                                GetChatHistoryResponse::Status200
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetChatHistoryResponse::Status400
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetChatHistoryResponse::Status401
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetChatHistoryResponse::Status403
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetChatHistoryResponse::Status404
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetChatHistoryResponse::Status420
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(420).expect("Unable to turn 420 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetChatHistoryResponse::Status500
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
                            },
                            Err(e) => Ok(Response::builder()
                                                .status(StatusCode::BAD_REQUEST)
                                                .body(Body::from(format!("Unable to read body: {}", e)))
                                                .expect("Unable to create Bad Request response due to unable to read body")),
                        }
            },

            // GetChats - POST /businesses/{businessId}/chats
            hyper::Method::POST if path.matched(paths::ID_BUSINESSES_BUSINESSID_CHATS) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "market:partner-api".to_string(), // API Яндекс.Маркета / Поиска по товарам для партнеров
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_BUSINESSES_BUSINESSID_CHATS
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE BUSINESSES_BUSINESSID_CHATS in set but failed match against \"{}\"", path, paths::REGEX_BUSINESSES_BUSINESSID_CHATS.as_str())
                    );

                let param_business_id = match percent_encoding::percent_decode(path_params["businessId"].as_bytes()).decode_utf8() {
                    Ok(param_business_id) => match param_business_id.parse::<i64>() {
                        Ok(param_business_id) => param_business_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter businessId: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["businessId"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                // Query parameters (note that non-required or collection query parameters will ignore garbage values, rather than causing a 400 response)
                let query_params = form_urlencoded::parse(uri.query().unwrap_or_default().as_bytes()).collect::<Vec<_>>();
                let param_page_token = query_params.iter().filter(|e| e.0 == "page_token").map(|e| e.1.clone())
                    .next();
                let param_page_token = match param_page_token {
                    Some(param_page_token) => {
                        let param_page_token =
                            <String as std::str::FromStr>::from_str
                                (&param_page_token);
                        match param_page_token {
                            Ok(param_page_token) => Some(param_page_token),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter page_token - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter page_token")),
                        }
                    },
                    None => None,
                };
                let param_limit = query_params.iter().filter(|e| e.0 == "limit").map(|e| e.1.clone())
                    .next();
                let param_limit = match param_limit {
                    Some(param_limit) => {
                        let param_limit =
                            <i32 as std::str::FromStr>::from_str
                                (&param_limit);
                        match param_limit {
                            Ok(param_limit) => Some(param_limit),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter limit - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter limit")),
                        }
                    },
                    None => None,
                };

                // Handle body parameters (note that non-required body parameters will ignore garbage
                // values, rather than causing a 400 response). Produce warning header and logs for
                // any unused fields.
                let result = body.into_raw().await;
                match result {
                     Ok(body) => {
                                let mut unused_elements : Vec<String> = vec![];
                                let param_get_chats_request: Option<models::GetChatsRequest> = if !body.is_empty() {
                                    let deserializer = &mut serde_json::Deserializer::from_slice(&*body);
                                    match serde_ignored::deserialize(deserializer, |path| {
                                            warn!("Ignoring unknown field in body: {}", path);
                                            unused_elements.push(path.to_string());
                                    }) {
                                        Ok(param_get_chats_request) => param_get_chats_request,
                                        Err(e) => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from(format!("Couldn't parse body parameter GetChatsRequest - doesn't match schema: {}", e)))
                                                        .expect("Unable to create Bad Request response for invalid body parameter GetChatsRequest due to schema")),
                                    }
                                } else {
                                    None
                                };
                                let param_get_chats_request = match param_get_chats_request {
                                    Some(param_get_chats_request) => param_get_chats_request,
                                    None => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from("Missing required body parameter GetChatsRequest"))
                                                        .expect("Unable to create Bad Request response for missing body parameter GetChatsRequest")),
                                };


                                let result = api_impl.get_chats(
                                            param_business_id,
                                            param_get_chats_request,
                                            param_page_token,
                                            param_limit,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        if !unused_elements.is_empty() {
                                            response.headers_mut().insert(
                                                HeaderName::from_static("warning"),
                                                HeaderValue::from_str(format!("Ignoring unknown fields in body: {:?}", unused_elements).as_str())
                                                    .expect("Unable to create Warning header value"));
                                        }
                                        match result {
                                            Ok(rsp) => match rsp {
                                                GetChatsResponse::Status200
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetChatsResponse::Status400
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetChatsResponse::Status401
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetChatsResponse::Status403
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetChatsResponse::Status404
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetChatsResponse::Status420
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(420).expect("Unable to turn 420 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetChatsResponse::Status500
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
                            },
                            Err(e) => Ok(Response::builder()
                                                .status(StatusCode::BAD_REQUEST)
                                                .body(Body::from(format!("Unable to read body: {}", e)))
                                                .expect("Unable to create Bad Request response due to unable to read body")),
                        }
            },

            // SendFileToChat - POST /businesses/{businessId}/chats/file/send
            hyper::Method::POST if path.matched(paths::ID_BUSINESSES_BUSINESSID_CHATS_FILE_SEND) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "market:partner-api".to_string(), // API Яндекс.Маркета / Поиска по товарам для партнеров
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_BUSINESSES_BUSINESSID_CHATS_FILE_SEND
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE BUSINESSES_BUSINESSID_CHATS_FILE_SEND in set but failed match against \"{}\"", path, paths::REGEX_BUSINESSES_BUSINESSID_CHATS_FILE_SEND.as_str())
                    );

                let param_business_id = match percent_encoding::percent_decode(path_params["businessId"].as_bytes()).decode_utf8() {
                    Ok(param_business_id) => match param_business_id.parse::<i64>() {
                        Ok(param_business_id) => param_business_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter businessId: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["businessId"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                // Query parameters (note that non-required or collection query parameters will ignore garbage values, rather than causing a 400 response)
                let query_params = form_urlencoded::parse(uri.query().unwrap_or_default().as_bytes()).collect::<Vec<_>>();
                let param_chat_id = query_params.iter().filter(|e| e.0 == "chatId").map(|e| e.1.clone())
                    .next();
                let param_chat_id = match param_chat_id {
                    Some(param_chat_id) => {
                        let param_chat_id =
                            <i64 as std::str::FromStr>::from_str
                                (&param_chat_id);
                        match param_chat_id {
                            Ok(param_chat_id) => Some(param_chat_id),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter chatId - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter chatId")),
                        }
                    },
                    None => None,
                };
                let param_chat_id = match param_chat_id {
                    Some(param_chat_id) => param_chat_id,
                    None => return Ok(Response::builder()
                        .status(StatusCode::BAD_REQUEST)
                        .body(Body::from("Missing required query parameter chatId"))
                        .expect("Unable to create Bad Request response for missing query parameter chatId")),
                };

                // Handle body parameters (note that non-required body parameters will ignore garbage
                // values, rather than causing a 400 response). Produce warning header and logs for
                // any unused fields.
                let result = body.into_raw().await;
                match result {
                     Ok(body) => {
                                let boundary = match swagger::multipart::form::boundary(&headers) {
                                    Some(boundary) => boundary.to_string(),
                                    None => return Ok(Response::builder()
                                                .status(StatusCode::BAD_REQUEST)
                                                .body(Body::from("Couldn't find valid multipart body".to_string()))
                                                .expect("Unable to create Bad Request response for incorrect boundary")),
                                };

                                use std::io::Read;

                                // Read Form Parameters from body
                                let mut entries = match Multipart::with_body(&body.to_vec()[..], boundary)
                                    .save()
                                    .size_limit(multipart_form_size_limit)
                                    .temp()
                                {
                                    SaveResult::Full(entries) => {
                                        entries
                                    },
                                    SaveResult::Partial(_, PartialReason::CountLimit) => {
                                        return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from("Unable to process message part due to excessive parts".to_string()))
                                                        .expect("Unable to create Bad Request response due to excessive parts"))
                                    },
                                    SaveResult::Partial(_, PartialReason::SizeLimit) => {
                                        return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from("Unable to process message part due to excessive data".to_string()))
                                                        .expect("Unable to create Bad Request response due to excessive data"))
                                    },
                                    SaveResult::Partial(_, PartialReason::Utf8Error(_)) => {
                                        return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from("Unable to process message part due to invalid data".to_string()))
                                                        .expect("Unable to create Bad Request response due to invalid data"))
                                    },
                                    SaveResult::Partial(_, PartialReason::IoError(_)) => {
                                        return Ok(Response::builder()
                                                        .status(StatusCode::INTERNAL_SERVER_ERROR)
                                                        .body(Body::from("Failed to process message part due an internal error".to_string()))
                                                        .expect("Unable to create Internal Server Error response due to an internal errror"))
                                    },
                                    SaveResult::Error(e) => {
                                        return Ok(Response::builder()
                                                        .status(StatusCode::INTERNAL_SERVER_ERROR)
                                                        .body(Body::from("Failed to process all message parts due to an internal error".to_string()))
                                                        .expect("Unable to create Internal Server Error response due to an internal error"))
                                    },
                                };
                                let field_file = entries.fields.remove("file");
                                let param_file = match field_file {
                                    Some(field) => {
                                        let mut reader = field[0].data.readable().expect("Unable to read field for file");
                                        let mut data = String::new();
                                        reader.read_to_string(&mut data).expect("Reading saved String should never fail");
                                        let file_model: swagger::ByteArray = match serde_json::from_str(&data) {
                                            Ok(model) => model,
                                            Err(e) => {
                                                return Ok(
                                                    Response::builder()
                                                    .status(StatusCode::BAD_REQUEST)
                                                    .body(Body::from(format!("file data does not match API definition : {}", e)))
                                                    .expect("Unable to create Bad Request due to missing required form parameter file"))
                                            }
                                        };
                                        file_model
                                    },
                                    None => {
                                        return Ok(
                                            Response::builder()
                                            .status(StatusCode::BAD_REQUEST)
                                            .body(Body::from("Missing required form parameter file".to_string()))
                                            .expect("Unable to create Bad Request due to missing required form parameter file"))
                                    }
                                };


                                let result = api_impl.send_file_to_chat(
                                            param_business_id,
                                            param_chat_id,
                                            param_file,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                SendFileToChatResponse::Status200
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                SendFileToChatResponse::Status400
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                SendFileToChatResponse::Status401
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                SendFileToChatResponse::Status403
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                SendFileToChatResponse::Status404
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                SendFileToChatResponse::Status420
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(420).expect("Unable to turn 420 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                SendFileToChatResponse::Status500
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
                            },
                            Err(e) => Ok(Response::builder()
                                                .status(StatusCode::BAD_REQUEST)
                                                .body(Body::from(format!("Unable to read body: {}", e)))
                                                .expect("Unable to create Bad Request response due to unable to read body")),
                        }
            },

            // SendMessageToChat - POST /businesses/{businessId}/chats/message
            hyper::Method::POST if path.matched(paths::ID_BUSINESSES_BUSINESSID_CHATS_MESSAGE) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "market:partner-api".to_string(), // API Яндекс.Маркета / Поиска по товарам для партнеров
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_BUSINESSES_BUSINESSID_CHATS_MESSAGE
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE BUSINESSES_BUSINESSID_CHATS_MESSAGE in set but failed match against \"{}\"", path, paths::REGEX_BUSINESSES_BUSINESSID_CHATS_MESSAGE.as_str())
                    );

                let param_business_id = match percent_encoding::percent_decode(path_params["businessId"].as_bytes()).decode_utf8() {
                    Ok(param_business_id) => match param_business_id.parse::<i64>() {
                        Ok(param_business_id) => param_business_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter businessId: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["businessId"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                // Query parameters (note that non-required or collection query parameters will ignore garbage values, rather than causing a 400 response)
                let query_params = form_urlencoded::parse(uri.query().unwrap_or_default().as_bytes()).collect::<Vec<_>>();
                let param_chat_id = query_params.iter().filter(|e| e.0 == "chatId").map(|e| e.1.clone())
                    .next();
                let param_chat_id = match param_chat_id {
                    Some(param_chat_id) => {
                        let param_chat_id =
                            <i64 as std::str::FromStr>::from_str
                                (&param_chat_id);
                        match param_chat_id {
                            Ok(param_chat_id) => Some(param_chat_id),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter chatId - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter chatId")),
                        }
                    },
                    None => None,
                };
                let param_chat_id = match param_chat_id {
                    Some(param_chat_id) => param_chat_id,
                    None => return Ok(Response::builder()
                        .status(StatusCode::BAD_REQUEST)
                        .body(Body::from("Missing required query parameter chatId"))
                        .expect("Unable to create Bad Request response for missing query parameter chatId")),
                };

                // Handle body parameters (note that non-required body parameters will ignore garbage
                // values, rather than causing a 400 response). Produce warning header and logs for
                // any unused fields.
                let result = body.into_raw().await;
                match result {
                     Ok(body) => {
                                let mut unused_elements : Vec<String> = vec![];
                                let param_send_message_to_chat_request: Option<models::SendMessageToChatRequest> = if !body.is_empty() {
                                    let deserializer = &mut serde_json::Deserializer::from_slice(&*body);
                                    match serde_ignored::deserialize(deserializer, |path| {
                                            warn!("Ignoring unknown field in body: {}", path);
                                            unused_elements.push(path.to_string());
                                    }) {
                                        Ok(param_send_message_to_chat_request) => param_send_message_to_chat_request,
                                        Err(e) => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from(format!("Couldn't parse body parameter SendMessageToChatRequest - doesn't match schema: {}", e)))
                                                        .expect("Unable to create Bad Request response for invalid body parameter SendMessageToChatRequest due to schema")),
                                    }
                                } else {
                                    None
                                };
                                let param_send_message_to_chat_request = match param_send_message_to_chat_request {
                                    Some(param_send_message_to_chat_request) => param_send_message_to_chat_request,
                                    None => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from("Missing required body parameter SendMessageToChatRequest"))
                                                        .expect("Unable to create Bad Request response for missing body parameter SendMessageToChatRequest")),
                                };


                                let result = api_impl.send_message_to_chat(
                                            param_business_id,
                                            param_chat_id,
                                            param_send_message_to_chat_request,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        if !unused_elements.is_empty() {
                                            response.headers_mut().insert(
                                                HeaderName::from_static("warning"),
                                                HeaderValue::from_str(format!("Ignoring unknown fields in body: {:?}", unused_elements).as_str())
                                                    .expect("Unable to create Warning header value"));
                                        }
                                        match result {
                                            Ok(rsp) => match rsp {
                                                SendMessageToChatResponse::Status200
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                SendMessageToChatResponse::Status400
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                SendMessageToChatResponse::Status401
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                SendMessageToChatResponse::Status403
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                SendMessageToChatResponse::Status404
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                SendMessageToChatResponse::Status420
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(420).expect("Unable to turn 420 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                SendMessageToChatResponse::Status500
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
                            },
                            Err(e) => Ok(Response::builder()
                                                .status(StatusCode::BAD_REQUEST)
                                                .body(Body::from(format!("Unable to read body: {}", e)))
                                                .expect("Unable to create Bad Request response due to unable to read body")),
                        }
            },

            // GetCategoryContentParameters - POST /category/{categoryId}/parameters
            hyper::Method::POST if path.matched(paths::ID_CATEGORY_CATEGORYID_PARAMETERS) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "market:partner-api".to_string(), // API Яндекс.Маркета / Поиска по товарам для партнеров
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_CATEGORY_CATEGORYID_PARAMETERS
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE CATEGORY_CATEGORYID_PARAMETERS in set but failed match against \"{}\"", path, paths::REGEX_CATEGORY_CATEGORYID_PARAMETERS.as_str())
                    );

                let param_category_id = match percent_encoding::percent_decode(path_params["categoryId"].as_bytes()).decode_utf8() {
                    Ok(param_category_id) => match param_category_id.parse::<i64>() {
                        Ok(param_category_id) => param_category_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter categoryId: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["categoryId"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                                let result = api_impl.get_category_content_parameters(
                                            param_category_id,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                GetCategoryContentParametersResponse::Status200
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetCategoryContentParametersResponse::Status400
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetCategoryContentParametersResponse::Status401
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetCategoryContentParametersResponse::Status403
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetCategoryContentParametersResponse::Status404
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetCategoryContentParametersResponse::Status420
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(420).expect("Unable to turn 420 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetCategoryContentParametersResponse::Status500
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
            },

            // GetOfferCardsContentStatus - POST /businesses/{businessId}/offer-cards
            hyper::Method::POST if path.matched(paths::ID_BUSINESSES_BUSINESSID_OFFER_CARDS) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "market:partner-api".to_string(), // API Яндекс.Маркета / Поиска по товарам для партнеров
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_BUSINESSES_BUSINESSID_OFFER_CARDS
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE BUSINESSES_BUSINESSID_OFFER_CARDS in set but failed match against \"{}\"", path, paths::REGEX_BUSINESSES_BUSINESSID_OFFER_CARDS.as_str())
                    );

                let param_business_id = match percent_encoding::percent_decode(path_params["businessId"].as_bytes()).decode_utf8() {
                    Ok(param_business_id) => match param_business_id.parse::<i64>() {
                        Ok(param_business_id) => param_business_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter businessId: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["businessId"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                // Query parameters (note that non-required or collection query parameters will ignore garbage values, rather than causing a 400 response)
                let query_params = form_urlencoded::parse(uri.query().unwrap_or_default().as_bytes()).collect::<Vec<_>>();
                let param_page_token = query_params.iter().filter(|e| e.0 == "page_token").map(|e| e.1.clone())
                    .next();
                let param_page_token = match param_page_token {
                    Some(param_page_token) => {
                        let param_page_token =
                            <String as std::str::FromStr>::from_str
                                (&param_page_token);
                        match param_page_token {
                            Ok(param_page_token) => Some(param_page_token),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter page_token - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter page_token")),
                        }
                    },
                    None => None,
                };
                let param_limit = query_params.iter().filter(|e| e.0 == "limit").map(|e| e.1.clone())
                    .next();
                let param_limit = match param_limit {
                    Some(param_limit) => {
                        let param_limit =
                            <i32 as std::str::FromStr>::from_str
                                (&param_limit);
                        match param_limit {
                            Ok(param_limit) => Some(param_limit),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter limit - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter limit")),
                        }
                    },
                    None => None,
                };

                // Handle body parameters (note that non-required body parameters will ignore garbage
                // values, rather than causing a 400 response). Produce warning header and logs for
                // any unused fields.
                let result = body.into_raw().await;
                match result {
                     Ok(body) => {
                                let mut unused_elements : Vec<String> = vec![];
                                let param_get_offer_cards_content_status_request: Option<models::GetOfferCardsContentStatusRequest> = if !body.is_empty() {
                                    let deserializer = &mut serde_json::Deserializer::from_slice(&*body);
                                    match serde_ignored::deserialize(deserializer, |path| {
                                            warn!("Ignoring unknown field in body: {}", path);
                                            unused_elements.push(path.to_string());
                                    }) {
                                        Ok(param_get_offer_cards_content_status_request) => param_get_offer_cards_content_status_request,
                                        Err(_) => None,
                                    }
                                } else {
                                    None
                                };


                                let result = api_impl.get_offer_cards_content_status(
                                            param_business_id,
                                            param_page_token,
                                            param_limit,
                                            param_get_offer_cards_content_status_request,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        if !unused_elements.is_empty() {
                                            response.headers_mut().insert(
                                                HeaderName::from_static("warning"),
                                                HeaderValue::from_str(format!("Ignoring unknown fields in body: {:?}", unused_elements).as_str())
                                                    .expect("Unable to create Warning header value"));
                                        }
                                        match result {
                                            Ok(rsp) => match rsp {
                                                GetOfferCardsContentStatusResponse::Status200
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetOfferCardsContentStatusResponse::Status400
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetOfferCardsContentStatusResponse::Status401
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetOfferCardsContentStatusResponse::Status403
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetOfferCardsContentStatusResponse::Status404
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetOfferCardsContentStatusResponse::Status420
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(420).expect("Unable to turn 420 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetOfferCardsContentStatusResponse::Status500
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
                            },
                            Err(e) => Ok(Response::builder()
                                                .status(StatusCode::BAD_REQUEST)
                                                .body(Body::from(format!("Unable to read body: {}", e)))
                                                .expect("Unable to create Bad Request response due to unable to read body")),
                        }
            },

            // UpdateOfferContent - POST /businesses/{businessId}/offer-cards/update
            hyper::Method::POST if path.matched(paths::ID_BUSINESSES_BUSINESSID_OFFER_CARDS_UPDATE) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "market:partner-api".to_string(), // API Яндекс.Маркета / Поиска по товарам для партнеров
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_BUSINESSES_BUSINESSID_OFFER_CARDS_UPDATE
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE BUSINESSES_BUSINESSID_OFFER_CARDS_UPDATE in set but failed match against \"{}\"", path, paths::REGEX_BUSINESSES_BUSINESSID_OFFER_CARDS_UPDATE.as_str())
                    );

                let param_business_id = match percent_encoding::percent_decode(path_params["businessId"].as_bytes()).decode_utf8() {
                    Ok(param_business_id) => match param_business_id.parse::<i64>() {
                        Ok(param_business_id) => param_business_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter businessId: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["businessId"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                // Handle body parameters (note that non-required body parameters will ignore garbage
                // values, rather than causing a 400 response). Produce warning header and logs for
                // any unused fields.
                let result = body.into_raw().await;
                match result {
                     Ok(body) => {
                                let mut unused_elements : Vec<String> = vec![];
                                let param_update_offer_content_request: Option<models::UpdateOfferContentRequest> = if !body.is_empty() {
                                    let deserializer = &mut serde_json::Deserializer::from_slice(&*body);
                                    match serde_ignored::deserialize(deserializer, |path| {
                                            warn!("Ignoring unknown field in body: {}", path);
                                            unused_elements.push(path.to_string());
                                    }) {
                                        Ok(param_update_offer_content_request) => param_update_offer_content_request,
                                        Err(e) => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from(format!("Couldn't parse body parameter UpdateOfferContentRequest - doesn't match schema: {}", e)))
                                                        .expect("Unable to create Bad Request response for invalid body parameter UpdateOfferContentRequest due to schema")),
                                    }
                                } else {
                                    None
                                };
                                let param_update_offer_content_request = match param_update_offer_content_request {
                                    Some(param_update_offer_content_request) => param_update_offer_content_request,
                                    None => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from("Missing required body parameter UpdateOfferContentRequest"))
                                                        .expect("Unable to create Bad Request response for missing body parameter UpdateOfferContentRequest")),
                                };


                                let result = api_impl.update_offer_content(
                                            param_business_id,
                                            param_update_offer_content_request,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        if !unused_elements.is_empty() {
                                            response.headers_mut().insert(
                                                HeaderName::from_static("warning"),
                                                HeaderValue::from_str(format!("Ignoring unknown fields in body: {:?}", unused_elements).as_str())
                                                    .expect("Unable to create Warning header value"));
                                        }
                                        match result {
                                            Ok(rsp) => match rsp {
                                                UpdateOfferContentResponse::Status200
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                UpdateOfferContentResponse::Status400
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                UpdateOfferContentResponse::Status401
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                UpdateOfferContentResponse::Status403
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                UpdateOfferContentResponse::Status404
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                UpdateOfferContentResponse::Status420
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(420).expect("Unable to turn 420 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                UpdateOfferContentResponse::Status423
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(423).expect("Unable to turn 423 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                UpdateOfferContentResponse::Status500
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
                            },
                            Err(e) => Ok(Response::builder()
                                                .status(StatusCode::BAD_REQUEST)
                                                .body(Body::from(format!("Unable to read body: {}", e)))
                                                .expect("Unable to create Bad Request response due to unable to read body")),
                        }
            },

            // GetDeliveryServices - GET /delivery/services
            hyper::Method::GET if path.matched(paths::ID_DELIVERY_SERVICES) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "market:partner-api".to_string(), // API Яндекс.Маркета / Поиска по товарам для партнеров
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                                let result = api_impl.get_delivery_services(
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                GetDeliveryServicesResponse::Status200
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetDeliveryServicesResponse::Status400
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetDeliveryServicesResponse::Status401
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetDeliveryServicesResponse::Status403
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetDeliveryServicesResponse::Status404
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetDeliveryServicesResponse::Status420
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(420).expect("Unable to turn 420 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetDeliveryServicesResponse::Status500
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
            },

            // GetFeedbackAndCommentUpdates - GET /campaigns/{campaignId}/feedback/updates
            hyper::Method::GET if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_FEEDBACK_UPDATES) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "market:partner-api".to_string(), // API Яндекс.Маркета / Поиска по товарам для партнеров
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_CAMPAIGNS_CAMPAIGNID_FEEDBACK_UPDATES
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE CAMPAIGNS_CAMPAIGNID_FEEDBACK_UPDATES in set but failed match against \"{}\"", path, paths::REGEX_CAMPAIGNS_CAMPAIGNID_FEEDBACK_UPDATES.as_str())
                    );

                let param_campaign_id = match percent_encoding::percent_decode(path_params["campaignId"].as_bytes()).decode_utf8() {
                    Ok(param_campaign_id) => match param_campaign_id.parse::<i64>() {
                        Ok(param_campaign_id) => param_campaign_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter campaignId: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["campaignId"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                // Query parameters (note that non-required or collection query parameters will ignore garbage values, rather than causing a 400 response)
                let query_params = form_urlencoded::parse(uri.query().unwrap_or_default().as_bytes()).collect::<Vec<_>>();
                let param_page_token = query_params.iter().filter(|e| e.0 == "page_token").map(|e| e.1.clone())
                    .next();
                let param_page_token = match param_page_token {
                    Some(param_page_token) => {
                        let param_page_token =
                            <String as std::str::FromStr>::from_str
                                (&param_page_token);
                        match param_page_token {
                            Ok(param_page_token) => Some(param_page_token),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter page_token - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter page_token")),
                        }
                    },
                    None => None,
                };
                let param_limit = query_params.iter().filter(|e| e.0 == "limit").map(|e| e.1.clone())
                    .next();
                let param_limit = match param_limit {
                    Some(param_limit) => {
                        let param_limit =
                            <i32 as std::str::FromStr>::from_str
                                (&param_limit);
                        match param_limit {
                            Ok(param_limit) => Some(param_limit),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter limit - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter limit")),
                        }
                    },
                    None => None,
                };
                let param_from_date = query_params.iter().filter(|e| e.0 == "from_date").map(|e| e.1.clone())
                    .next();
                let param_from_date = match param_from_date {
                    Some(param_from_date) => {
                        let param_from_date =
                            <chrono::naive::NaiveDate as std::str::FromStr>::from_str
                                (&param_from_date);
                        match param_from_date {
                            Ok(param_from_date) => Some(param_from_date),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter from_date - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter from_date")),
                        }
                    },
                    None => None,
                };

                                let result = api_impl.get_feedback_and_comment_updates(
                                            param_campaign_id,
                                            param_page_token,
                                            param_limit,
                                            param_from_date,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                GetFeedbackAndCommentUpdatesResponse::Status200
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetFeedbackAndCommentUpdatesResponse::Status400
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetFeedbackAndCommentUpdatesResponse::Status401
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetFeedbackAndCommentUpdatesResponse::Status403
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetFeedbackAndCommentUpdatesResponse::Status404
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetFeedbackAndCommentUpdatesResponse::Status420
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(420).expect("Unable to turn 420 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetFeedbackAndCommentUpdatesResponse::Status500
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
            },

            // GetFeeds - GET /campaigns/{campaignId}/feeds
            hyper::Method::GET if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_FEEDS) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "market:partner-api".to_string(), // API Яндекс.Маркета / Поиска по товарам для партнеров
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_CAMPAIGNS_CAMPAIGNID_FEEDS
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE CAMPAIGNS_CAMPAIGNID_FEEDS in set but failed match against \"{}\"", path, paths::REGEX_CAMPAIGNS_CAMPAIGNID_FEEDS.as_str())
                    );

                let param_campaign_id = match percent_encoding::percent_decode(path_params["campaignId"].as_bytes()).decode_utf8() {
                    Ok(param_campaign_id) => match param_campaign_id.parse::<i64>() {
                        Ok(param_campaign_id) => param_campaign_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter campaignId: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["campaignId"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                                let result = api_impl.get_feeds(
                                            param_campaign_id,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                GetFeedsResponse::Status200
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetFeedsResponse::Status400
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetFeedsResponse::Status401
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetFeedsResponse::Status403
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetFeedsResponse::Status404
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetFeedsResponse::Status420
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(420).expect("Unable to turn 420 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetFeedsResponse::Status500
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
            },

            // GetFeed - GET /campaigns/{campaignId}/feeds/{feedId}
            hyper::Method::GET if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_FEEDS_FEEDID) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "market:partner-api".to_string(), // API Яндекс.Маркета / Поиска по товарам для партнеров
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_CAMPAIGNS_CAMPAIGNID_FEEDS_FEEDID
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE CAMPAIGNS_CAMPAIGNID_FEEDS_FEEDID in set but failed match against \"{}\"", path, paths::REGEX_CAMPAIGNS_CAMPAIGNID_FEEDS_FEEDID.as_str())
                    );

                let param_campaign_id = match percent_encoding::percent_decode(path_params["campaignId"].as_bytes()).decode_utf8() {
                    Ok(param_campaign_id) => match param_campaign_id.parse::<i64>() {
                        Ok(param_campaign_id) => param_campaign_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter campaignId: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["campaignId"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                let param_feed_id = match percent_encoding::percent_decode(path_params["feedId"].as_bytes()).decode_utf8() {
                    Ok(param_feed_id) => match param_feed_id.parse::<i64>() {
                        Ok(param_feed_id) => param_feed_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter feedId: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["feedId"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                                let result = api_impl.get_feed(
                                            param_campaign_id,
                                            param_feed_id,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                GetFeedResponse::Status200
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetFeedResponse::Status400
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetFeedResponse::Status401
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetFeedResponse::Status403
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetFeedResponse::Status404
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetFeedResponse::Status420
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(420).expect("Unable to turn 420 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetFeedResponse::Status500
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
            },

            // GetFeedIndexLogs - GET /campaigns/{campaignId}/feeds/{feedId}/index-logs
            hyper::Method::GET if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_FEEDS_FEEDID_INDEX_LOGS) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "market:partner-api".to_string(), // API Яндекс.Маркета / Поиска по товарам для партнеров
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_CAMPAIGNS_CAMPAIGNID_FEEDS_FEEDID_INDEX_LOGS
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE CAMPAIGNS_CAMPAIGNID_FEEDS_FEEDID_INDEX_LOGS in set but failed match against \"{}\"", path, paths::REGEX_CAMPAIGNS_CAMPAIGNID_FEEDS_FEEDID_INDEX_LOGS.as_str())
                    );

                let param_campaign_id = match percent_encoding::percent_decode(path_params["campaignId"].as_bytes()).decode_utf8() {
                    Ok(param_campaign_id) => match param_campaign_id.parse::<i64>() {
                        Ok(param_campaign_id) => param_campaign_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter campaignId: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["campaignId"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                let param_feed_id = match percent_encoding::percent_decode(path_params["feedId"].as_bytes()).decode_utf8() {
                    Ok(param_feed_id) => match param_feed_id.parse::<i64>() {
                        Ok(param_feed_id) => param_feed_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter feedId: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["feedId"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                // Query parameters (note that non-required or collection query parameters will ignore garbage values, rather than causing a 400 response)
                let query_params = form_urlencoded::parse(uri.query().unwrap_or_default().as_bytes()).collect::<Vec<_>>();
                let param_limit = query_params.iter().filter(|e| e.0 == "limit").map(|e| e.1.clone())
                    .next();
                let param_limit = match param_limit {
                    Some(param_limit) => {
                        let param_limit =
                            <i32 as std::str::FromStr>::from_str
                                (&param_limit);
                        match param_limit {
                            Ok(param_limit) => Some(param_limit),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter limit - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter limit")),
                        }
                    },
                    None => None,
                };
                let param_published_time_from = query_params.iter().filter(|e| e.0 == "published_time_from").map(|e| e.1.clone())
                    .next();
                let param_published_time_from = match param_published_time_from {
                    Some(param_published_time_from) => {
                        let param_published_time_from =
                            <chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str
                                (&param_published_time_from);
                        match param_published_time_from {
                            Ok(param_published_time_from) => Some(param_published_time_from),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter published_time_from - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter published_time_from")),
                        }
                    },
                    None => None,
                };
                let param_published_time_to = query_params.iter().filter(|e| e.0 == "published_time_to").map(|e| e.1.clone())
                    .next();
                let param_published_time_to = match param_published_time_to {
                    Some(param_published_time_to) => {
                        let param_published_time_to =
                            <chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str
                                (&param_published_time_to);
                        match param_published_time_to {
                            Ok(param_published_time_to) => Some(param_published_time_to),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter published_time_to - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter published_time_to")),
                        }
                    },
                    None => None,
                };
                let param_status = query_params.iter().filter(|e| e.0 == "status").map(|e| e.1.clone())
                    .next();
                let param_status = match param_status {
                    Some(param_status) => {
                        let param_status =
                            <models::FeedIndexLogsStatusType as std::str::FromStr>::from_str
                                (&param_status);
                        match param_status {
                            Ok(param_status) => Some(param_status),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter status - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter status")),
                        }
                    },
                    None => None,
                };

                                let result = api_impl.get_feed_index_logs(
                                            param_campaign_id,
                                            param_feed_id,
                                            param_limit,
                                            param_published_time_from,
                                            param_published_time_to,
                                            param_status,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                GetFeedIndexLogsResponse::Status200
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetFeedIndexLogsResponse::Status400
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetFeedIndexLogsResponse::Status401
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetFeedIndexLogsResponse::Status403
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetFeedIndexLogsResponse::Status404
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetFeedIndexLogsResponse::Status420
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(420).expect("Unable to turn 420 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetFeedIndexLogsResponse::Status500
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
            },

            // RefreshFeed - POST /campaigns/{campaignId}/feeds/{feedId}/refresh
            hyper::Method::POST if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_FEEDS_FEEDID_REFRESH) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "market:partner-api".to_string(), // API Яндекс.Маркета / Поиска по товарам для партнеров
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_CAMPAIGNS_CAMPAIGNID_FEEDS_FEEDID_REFRESH
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE CAMPAIGNS_CAMPAIGNID_FEEDS_FEEDID_REFRESH in set but failed match against \"{}\"", path, paths::REGEX_CAMPAIGNS_CAMPAIGNID_FEEDS_FEEDID_REFRESH.as_str())
                    );

                let param_campaign_id = match percent_encoding::percent_decode(path_params["campaignId"].as_bytes()).decode_utf8() {
                    Ok(param_campaign_id) => match param_campaign_id.parse::<i64>() {
                        Ok(param_campaign_id) => param_campaign_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter campaignId: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["campaignId"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                let param_feed_id = match percent_encoding::percent_decode(path_params["feedId"].as_bytes()).decode_utf8() {
                    Ok(param_feed_id) => match param_feed_id.parse::<i64>() {
                        Ok(param_feed_id) => param_feed_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter feedId: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["feedId"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                                let result = api_impl.refresh_feed(
                                            param_campaign_id,
                                            param_feed_id,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                RefreshFeedResponse::Status200
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                RefreshFeedResponse::Status400
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                RefreshFeedResponse::Status401
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                RefreshFeedResponse::Status403
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                RefreshFeedResponse::Status404
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                RefreshFeedResponse::Status420
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(420).expect("Unable to turn 420 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                RefreshFeedResponse::Status500
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
            },

            // SetFeedParams - POST /campaigns/{campaignId}/feeds/{feedId}/params
            hyper::Method::POST if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_FEEDS_FEEDID_PARAMS) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "market:partner-api".to_string(), // API Яндекс.Маркета / Поиска по товарам для партнеров
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_CAMPAIGNS_CAMPAIGNID_FEEDS_FEEDID_PARAMS
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE CAMPAIGNS_CAMPAIGNID_FEEDS_FEEDID_PARAMS in set but failed match against \"{}\"", path, paths::REGEX_CAMPAIGNS_CAMPAIGNID_FEEDS_FEEDID_PARAMS.as_str())
                    );

                let param_campaign_id = match percent_encoding::percent_decode(path_params["campaignId"].as_bytes()).decode_utf8() {
                    Ok(param_campaign_id) => match param_campaign_id.parse::<i64>() {
                        Ok(param_campaign_id) => param_campaign_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter campaignId: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["campaignId"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                let param_feed_id = match percent_encoding::percent_decode(path_params["feedId"].as_bytes()).decode_utf8() {
                    Ok(param_feed_id) => match param_feed_id.parse::<i64>() {
                        Ok(param_feed_id) => param_feed_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter feedId: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["feedId"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                // Handle body parameters (note that non-required body parameters will ignore garbage
                // values, rather than causing a 400 response). Produce warning header and logs for
                // any unused fields.
                let result = body.into_raw().await;
                match result {
                     Ok(body) => {
                                let mut unused_elements : Vec<String> = vec![];
                                let param_set_feed_params_request: Option<models::SetFeedParamsRequest> = if !body.is_empty() {
                                    let deserializer = &mut serde_json::Deserializer::from_slice(&*body);
                                    match serde_ignored::deserialize(deserializer, |path| {
                                            warn!("Ignoring unknown field in body: {}", path);
                                            unused_elements.push(path.to_string());
                                    }) {
                                        Ok(param_set_feed_params_request) => param_set_feed_params_request,
                                        Err(e) => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from(format!("Couldn't parse body parameter SetFeedParamsRequest - doesn't match schema: {}", e)))
                                                        .expect("Unable to create Bad Request response for invalid body parameter SetFeedParamsRequest due to schema")),
                                    }
                                } else {
                                    None
                                };
                                let param_set_feed_params_request = match param_set_feed_params_request {
                                    Some(param_set_feed_params_request) => param_set_feed_params_request,
                                    None => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from("Missing required body parameter SetFeedParamsRequest"))
                                                        .expect("Unable to create Bad Request response for missing body parameter SetFeedParamsRequest")),
                                };


                                let result = api_impl.set_feed_params(
                                            param_campaign_id,
                                            param_feed_id,
                                            param_set_feed_params_request,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        if !unused_elements.is_empty() {
                                            response.headers_mut().insert(
                                                HeaderName::from_static("warning"),
                                                HeaderValue::from_str(format!("Ignoring unknown fields in body: {:?}", unused_elements).as_str())
                                                    .expect("Unable to create Warning header value"));
                                        }
                                        match result {
                                            Ok(rsp) => match rsp {
                                                SetFeedParamsResponse::Status200
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                SetFeedParamsResponse::Status400
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                SetFeedParamsResponse::Status401
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                SetFeedParamsResponse::Status403
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                SetFeedParamsResponse::Status404
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                SetFeedParamsResponse::Status420
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(420).expect("Unable to turn 420 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                SetFeedParamsResponse::Status423
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(423).expect("Unable to turn 423 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                SetFeedParamsResponse::Status500
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
                            },
                            Err(e) => Ok(Response::builder()
                                                .status(StatusCode::BAD_REQUEST)
                                                .body(Body::from(format!("Unable to read body: {}", e)))
                                                .expect("Unable to create Bad Request response due to unable to read body")),
                        }
            },

            // DeleteGoodsFeedbackComment - POST /businesses/{businessId}/goods-feedback/comments/delete
            hyper::Method::POST if path.matched(paths::ID_BUSINESSES_BUSINESSID_GOODS_FEEDBACK_COMMENTS_DELETE) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "market:partner-api".to_string(), // API Яндекс.Маркета / Поиска по товарам для партнеров
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_BUSINESSES_BUSINESSID_GOODS_FEEDBACK_COMMENTS_DELETE
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE BUSINESSES_BUSINESSID_GOODS_FEEDBACK_COMMENTS_DELETE in set but failed match against \"{}\"", path, paths::REGEX_BUSINESSES_BUSINESSID_GOODS_FEEDBACK_COMMENTS_DELETE.as_str())
                    );

                let param_business_id = match percent_encoding::percent_decode(path_params["businessId"].as_bytes()).decode_utf8() {
                    Ok(param_business_id) => match param_business_id.parse::<i64>() {
                        Ok(param_business_id) => param_business_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter businessId: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["businessId"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                // Handle body parameters (note that non-required body parameters will ignore garbage
                // values, rather than causing a 400 response). Produce warning header and logs for
                // any unused fields.
                let result = body.into_raw().await;
                match result {
                     Ok(body) => {
                                let mut unused_elements : Vec<String> = vec![];
                                let param_delete_goods_feedback_comment_request: Option<models::DeleteGoodsFeedbackCommentRequest> = if !body.is_empty() {
                                    let deserializer = &mut serde_json::Deserializer::from_slice(&*body);
                                    match serde_ignored::deserialize(deserializer, |path| {
                                            warn!("Ignoring unknown field in body: {}", path);
                                            unused_elements.push(path.to_string());
                                    }) {
                                        Ok(param_delete_goods_feedback_comment_request) => param_delete_goods_feedback_comment_request,
                                        Err(e) => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from(format!("Couldn't parse body parameter DeleteGoodsFeedbackCommentRequest - doesn't match schema: {}", e)))
                                                        .expect("Unable to create Bad Request response for invalid body parameter DeleteGoodsFeedbackCommentRequest due to schema")),
                                    }
                                } else {
                                    None
                                };
                                let param_delete_goods_feedback_comment_request = match param_delete_goods_feedback_comment_request {
                                    Some(param_delete_goods_feedback_comment_request) => param_delete_goods_feedback_comment_request,
                                    None => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from("Missing required body parameter DeleteGoodsFeedbackCommentRequest"))
                                                        .expect("Unable to create Bad Request response for missing body parameter DeleteGoodsFeedbackCommentRequest")),
                                };


                                let result = api_impl.delete_goods_feedback_comment(
                                            param_business_id,
                                            param_delete_goods_feedback_comment_request,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        if !unused_elements.is_empty() {
                                            response.headers_mut().insert(
                                                HeaderName::from_static("warning"),
                                                HeaderValue::from_str(format!("Ignoring unknown fields in body: {:?}", unused_elements).as_str())
                                                    .expect("Unable to create Warning header value"));
                                        }
                                        match result {
                                            Ok(rsp) => match rsp {
                                                DeleteGoodsFeedbackCommentResponse::Status200
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                DeleteGoodsFeedbackCommentResponse::Status400
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                DeleteGoodsFeedbackCommentResponse::Status401
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                DeleteGoodsFeedbackCommentResponse::Status403
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                DeleteGoodsFeedbackCommentResponse::Status404
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                DeleteGoodsFeedbackCommentResponse::Status420
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(420).expect("Unable to turn 420 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                DeleteGoodsFeedbackCommentResponse::Status500
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
                            },
                            Err(e) => Ok(Response::builder()
                                                .status(StatusCode::BAD_REQUEST)
                                                .body(Body::from(format!("Unable to read body: {}", e)))
                                                .expect("Unable to create Bad Request response due to unable to read body")),
                        }
            },

            // GetGoodsFeedbackComments - POST /businesses/{businessId}/goods-feedback/comments
            hyper::Method::POST if path.matched(paths::ID_BUSINESSES_BUSINESSID_GOODS_FEEDBACK_COMMENTS) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "market:partner-api".to_string(), // API Яндекс.Маркета / Поиска по товарам для партнеров
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_BUSINESSES_BUSINESSID_GOODS_FEEDBACK_COMMENTS
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE BUSINESSES_BUSINESSID_GOODS_FEEDBACK_COMMENTS in set but failed match against \"{}\"", path, paths::REGEX_BUSINESSES_BUSINESSID_GOODS_FEEDBACK_COMMENTS.as_str())
                    );

                let param_business_id = match percent_encoding::percent_decode(path_params["businessId"].as_bytes()).decode_utf8() {
                    Ok(param_business_id) => match param_business_id.parse::<i64>() {
                        Ok(param_business_id) => param_business_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter businessId: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["businessId"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                // Query parameters (note that non-required or collection query parameters will ignore garbage values, rather than causing a 400 response)
                let query_params = form_urlencoded::parse(uri.query().unwrap_or_default().as_bytes()).collect::<Vec<_>>();
                let param_page_token = query_params.iter().filter(|e| e.0 == "page_token").map(|e| e.1.clone())
                    .next();
                let param_page_token = match param_page_token {
                    Some(param_page_token) => {
                        let param_page_token =
                            <String as std::str::FromStr>::from_str
                                (&param_page_token);
                        match param_page_token {
                            Ok(param_page_token) => Some(param_page_token),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter page_token - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter page_token")),
                        }
                    },
                    None => None,
                };
                let param_limit = query_params.iter().filter(|e| e.0 == "limit").map(|e| e.1.clone())
                    .next();
                let param_limit = match param_limit {
                    Some(param_limit) => {
                        let param_limit =
                            <i32 as std::str::FromStr>::from_str
                                (&param_limit);
                        match param_limit {
                            Ok(param_limit) => Some(param_limit),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter limit - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter limit")),
                        }
                    },
                    None => None,
                };

                // Handle body parameters (note that non-required body parameters will ignore garbage
                // values, rather than causing a 400 response). Produce warning header and logs for
                // any unused fields.
                let result = body.into_raw().await;
                match result {
                     Ok(body) => {
                                let mut unused_elements : Vec<String> = vec![];
                                let param_get_goods_feedback_comments_request: Option<models::GetGoodsFeedbackCommentsRequest> = if !body.is_empty() {
                                    let deserializer = &mut serde_json::Deserializer::from_slice(&*body);
                                    match serde_ignored::deserialize(deserializer, |path| {
                                            warn!("Ignoring unknown field in body: {}", path);
                                            unused_elements.push(path.to_string());
                                    }) {
                                        Ok(param_get_goods_feedback_comments_request) => param_get_goods_feedback_comments_request,
                                        Err(e) => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from(format!("Couldn't parse body parameter GetGoodsFeedbackCommentsRequest - doesn't match schema: {}", e)))
                                                        .expect("Unable to create Bad Request response for invalid body parameter GetGoodsFeedbackCommentsRequest due to schema")),
                                    }
                                } else {
                                    None
                                };
                                let param_get_goods_feedback_comments_request = match param_get_goods_feedback_comments_request {
                                    Some(param_get_goods_feedback_comments_request) => param_get_goods_feedback_comments_request,
                                    None => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from("Missing required body parameter GetGoodsFeedbackCommentsRequest"))
                                                        .expect("Unable to create Bad Request response for missing body parameter GetGoodsFeedbackCommentsRequest")),
                                };


                                let result = api_impl.get_goods_feedback_comments(
                                            param_business_id,
                                            param_get_goods_feedback_comments_request,
                                            param_page_token,
                                            param_limit,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        if !unused_elements.is_empty() {
                                            response.headers_mut().insert(
                                                HeaderName::from_static("warning"),
                                                HeaderValue::from_str(format!("Ignoring unknown fields in body: {:?}", unused_elements).as_str())
                                                    .expect("Unable to create Warning header value"));
                                        }
                                        match result {
                                            Ok(rsp) => match rsp {
                                                GetGoodsFeedbackCommentsResponse::Status200
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetGoodsFeedbackCommentsResponse::Status400
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetGoodsFeedbackCommentsResponse::Status401
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetGoodsFeedbackCommentsResponse::Status403
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetGoodsFeedbackCommentsResponse::Status404
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetGoodsFeedbackCommentsResponse::Status420
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(420).expect("Unable to turn 420 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetGoodsFeedbackCommentsResponse::Status500
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
                            },
                            Err(e) => Ok(Response::builder()
                                                .status(StatusCode::BAD_REQUEST)
                                                .body(Body::from(format!("Unable to read body: {}", e)))
                                                .expect("Unable to create Bad Request response due to unable to read body")),
                        }
            },

            // GetGoodsFeedbacks - POST /businesses/{businessId}/goods-feedback
            hyper::Method::POST if path.matched(paths::ID_BUSINESSES_BUSINESSID_GOODS_FEEDBACK) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "market:partner-api".to_string(), // API Яндекс.Маркета / Поиска по товарам для партнеров
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_BUSINESSES_BUSINESSID_GOODS_FEEDBACK
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE BUSINESSES_BUSINESSID_GOODS_FEEDBACK in set but failed match against \"{}\"", path, paths::REGEX_BUSINESSES_BUSINESSID_GOODS_FEEDBACK.as_str())
                    );

                let param_business_id = match percent_encoding::percent_decode(path_params["businessId"].as_bytes()).decode_utf8() {
                    Ok(param_business_id) => match param_business_id.parse::<i64>() {
                        Ok(param_business_id) => param_business_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter businessId: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["businessId"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                // Query parameters (note that non-required or collection query parameters will ignore garbage values, rather than causing a 400 response)
                let query_params = form_urlencoded::parse(uri.query().unwrap_or_default().as_bytes()).collect::<Vec<_>>();
                let param_page_token = query_params.iter().filter(|e| e.0 == "page_token").map(|e| e.1.clone())
                    .next();
                let param_page_token = match param_page_token {
                    Some(param_page_token) => {
                        let param_page_token =
                            <String as std::str::FromStr>::from_str
                                (&param_page_token);
                        match param_page_token {
                            Ok(param_page_token) => Some(param_page_token),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter page_token - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter page_token")),
                        }
                    },
                    None => None,
                };
                let param_limit = query_params.iter().filter(|e| e.0 == "limit").map(|e| e.1.clone())
                    .next();
                let param_limit = match param_limit {
                    Some(param_limit) => {
                        let param_limit =
                            <i32 as std::str::FromStr>::from_str
                                (&param_limit);
                        match param_limit {
                            Ok(param_limit) => Some(param_limit),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter limit - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter limit")),
                        }
                    },
                    None => None,
                };

                // Handle body parameters (note that non-required body parameters will ignore garbage
                // values, rather than causing a 400 response). Produce warning header and logs for
                // any unused fields.
                let result = body.into_raw().await;
                match result {
                     Ok(body) => {
                                let mut unused_elements : Vec<String> = vec![];
                                let param_get_goods_feedback_request: Option<models::GetGoodsFeedbackRequest> = if !body.is_empty() {
                                    let deserializer = &mut serde_json::Deserializer::from_slice(&*body);
                                    match serde_ignored::deserialize(deserializer, |path| {
                                            warn!("Ignoring unknown field in body: {}", path);
                                            unused_elements.push(path.to_string());
                                    }) {
                                        Ok(param_get_goods_feedback_request) => param_get_goods_feedback_request,
                                        Err(_) => None,
                                    }
                                } else {
                                    None
                                };


                                let result = api_impl.get_goods_feedbacks(
                                            param_business_id,
                                            param_page_token,
                                            param_limit,
                                            param_get_goods_feedback_request,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        if !unused_elements.is_empty() {
                                            response.headers_mut().insert(
                                                HeaderName::from_static("warning"),
                                                HeaderValue::from_str(format!("Ignoring unknown fields in body: {:?}", unused_elements).as_str())
                                                    .expect("Unable to create Warning header value"));
                                        }
                                        match result {
                                            Ok(rsp) => match rsp {
                                                GetGoodsFeedbacksResponse::Status200
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetGoodsFeedbacksResponse::Status400
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetGoodsFeedbacksResponse::Status401
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetGoodsFeedbacksResponse::Status403
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetGoodsFeedbacksResponse::Status404
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetGoodsFeedbacksResponse::Status420
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(420).expect("Unable to turn 420 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetGoodsFeedbacksResponse::Status500
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
                            },
                            Err(e) => Ok(Response::builder()
                                                .status(StatusCode::BAD_REQUEST)
                                                .body(Body::from(format!("Unable to read body: {}", e)))
                                                .expect("Unable to create Bad Request response due to unable to read body")),
                        }
            },

            // SkipGoodsFeedbacksReaction - POST /businesses/{businessId}/goods-feedback/skip-reaction
            hyper::Method::POST if path.matched(paths::ID_BUSINESSES_BUSINESSID_GOODS_FEEDBACK_SKIP_REACTION) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "market:partner-api".to_string(), // API Яндекс.Маркета / Поиска по товарам для партнеров
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_BUSINESSES_BUSINESSID_GOODS_FEEDBACK_SKIP_REACTION
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE BUSINESSES_BUSINESSID_GOODS_FEEDBACK_SKIP_REACTION in set but failed match against \"{}\"", path, paths::REGEX_BUSINESSES_BUSINESSID_GOODS_FEEDBACK_SKIP_REACTION.as_str())
                    );

                let param_business_id = match percent_encoding::percent_decode(path_params["businessId"].as_bytes()).decode_utf8() {
                    Ok(param_business_id) => match param_business_id.parse::<i64>() {
                        Ok(param_business_id) => param_business_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter businessId: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["businessId"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                // Handle body parameters (note that non-required body parameters will ignore garbage
                // values, rather than causing a 400 response). Produce warning header and logs for
                // any unused fields.
                let result = body.into_raw().await;
                match result {
                     Ok(body) => {
                                let mut unused_elements : Vec<String> = vec![];
                                let param_skip_goods_feedback_reaction_request: Option<models::SkipGoodsFeedbackReactionRequest> = if !body.is_empty() {
                                    let deserializer = &mut serde_json::Deserializer::from_slice(&*body);
                                    match serde_ignored::deserialize(deserializer, |path| {
                                            warn!("Ignoring unknown field in body: {}", path);
                                            unused_elements.push(path.to_string());
                                    }) {
                                        Ok(param_skip_goods_feedback_reaction_request) => param_skip_goods_feedback_reaction_request,
                                        Err(e) => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from(format!("Couldn't parse body parameter SkipGoodsFeedbackReactionRequest - doesn't match schema: {}", e)))
                                                        .expect("Unable to create Bad Request response for invalid body parameter SkipGoodsFeedbackReactionRequest due to schema")),
                                    }
                                } else {
                                    None
                                };
                                let param_skip_goods_feedback_reaction_request = match param_skip_goods_feedback_reaction_request {
                                    Some(param_skip_goods_feedback_reaction_request) => param_skip_goods_feedback_reaction_request,
                                    None => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from("Missing required body parameter SkipGoodsFeedbackReactionRequest"))
                                                        .expect("Unable to create Bad Request response for missing body parameter SkipGoodsFeedbackReactionRequest")),
                                };


                                let result = api_impl.skip_goods_feedbacks_reaction(
                                            param_business_id,
                                            param_skip_goods_feedback_reaction_request,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        if !unused_elements.is_empty() {
                                            response.headers_mut().insert(
                                                HeaderName::from_static("warning"),
                                                HeaderValue::from_str(format!("Ignoring unknown fields in body: {:?}", unused_elements).as_str())
                                                    .expect("Unable to create Warning header value"));
                                        }
                                        match result {
                                            Ok(rsp) => match rsp {
                                                SkipGoodsFeedbacksReactionResponse::Status200
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                SkipGoodsFeedbacksReactionResponse::Status400
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                SkipGoodsFeedbacksReactionResponse::Status401
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                SkipGoodsFeedbacksReactionResponse::Status403
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                SkipGoodsFeedbacksReactionResponse::Status404
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                SkipGoodsFeedbacksReactionResponse::Status420
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(420).expect("Unable to turn 420 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                SkipGoodsFeedbacksReactionResponse::Status500
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
                            },
                            Err(e) => Ok(Response::builder()
                                                .status(StatusCode::BAD_REQUEST)
                                                .body(Body::from(format!("Unable to read body: {}", e)))
                                                .expect("Unable to create Bad Request response due to unable to read body")),
                        }
            },

            // UpdateGoodsFeedbackComment - POST /businesses/{businessId}/goods-feedback/comments/update
            hyper::Method::POST if path.matched(paths::ID_BUSINESSES_BUSINESSID_GOODS_FEEDBACK_COMMENTS_UPDATE) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "market:partner-api".to_string(), // API Яндекс.Маркета / Поиска по товарам для партнеров
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_BUSINESSES_BUSINESSID_GOODS_FEEDBACK_COMMENTS_UPDATE
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE BUSINESSES_BUSINESSID_GOODS_FEEDBACK_COMMENTS_UPDATE in set but failed match against \"{}\"", path, paths::REGEX_BUSINESSES_BUSINESSID_GOODS_FEEDBACK_COMMENTS_UPDATE.as_str())
                    );

                let param_business_id = match percent_encoding::percent_decode(path_params["businessId"].as_bytes()).decode_utf8() {
                    Ok(param_business_id) => match param_business_id.parse::<i64>() {
                        Ok(param_business_id) => param_business_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter businessId: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["businessId"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                // Handle body parameters (note that non-required body parameters will ignore garbage
                // values, rather than causing a 400 response). Produce warning header and logs for
                // any unused fields.
                let result = body.into_raw().await;
                match result {
                     Ok(body) => {
                                let mut unused_elements : Vec<String> = vec![];
                                let param_update_goods_feedback_comment_request: Option<models::UpdateGoodsFeedbackCommentRequest> = if !body.is_empty() {
                                    let deserializer = &mut serde_json::Deserializer::from_slice(&*body);
                                    match serde_ignored::deserialize(deserializer, |path| {
                                            warn!("Ignoring unknown field in body: {}", path);
                                            unused_elements.push(path.to_string());
                                    }) {
                                        Ok(param_update_goods_feedback_comment_request) => param_update_goods_feedback_comment_request,
                                        Err(e) => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from(format!("Couldn't parse body parameter UpdateGoodsFeedbackCommentRequest - doesn't match schema: {}", e)))
                                                        .expect("Unable to create Bad Request response for invalid body parameter UpdateGoodsFeedbackCommentRequest due to schema")),
                                    }
                                } else {
                                    None
                                };
                                let param_update_goods_feedback_comment_request = match param_update_goods_feedback_comment_request {
                                    Some(param_update_goods_feedback_comment_request) => param_update_goods_feedback_comment_request,
                                    None => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from("Missing required body parameter UpdateGoodsFeedbackCommentRequest"))
                                                        .expect("Unable to create Bad Request response for missing body parameter UpdateGoodsFeedbackCommentRequest")),
                                };


                                let result = api_impl.update_goods_feedback_comment(
                                            param_business_id,
                                            param_update_goods_feedback_comment_request,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        if !unused_elements.is_empty() {
                                            response.headers_mut().insert(
                                                HeaderName::from_static("warning"),
                                                HeaderValue::from_str(format!("Ignoring unknown fields in body: {:?}", unused_elements).as_str())
                                                    .expect("Unable to create Warning header value"));
                                        }
                                        match result {
                                            Ok(rsp) => match rsp {
                                                UpdateGoodsFeedbackCommentResponse::Status200
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                UpdateGoodsFeedbackCommentResponse::Status400
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                UpdateGoodsFeedbackCommentResponse::Status401
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                UpdateGoodsFeedbackCommentResponse::Status403
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                UpdateGoodsFeedbackCommentResponse::Status404
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                UpdateGoodsFeedbackCommentResponse::Status420
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(420).expect("Unable to turn 420 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                UpdateGoodsFeedbackCommentResponse::Status500
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
                            },
                            Err(e) => Ok(Response::builder()
                                                .status(StatusCode::BAD_REQUEST)
                                                .body(Body::from(format!("Unable to read body: {}", e)))
                                                .expect("Unable to create Bad Request response due to unable to read body")),
                        }
            },

            // GetGoodsStats - POST /campaigns/{campaignId}/stats/skus
            hyper::Method::POST if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_STATS_SKUS) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "market:partner-api".to_string(), // API Яндекс.Маркета / Поиска по товарам для партнеров
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_CAMPAIGNS_CAMPAIGNID_STATS_SKUS
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE CAMPAIGNS_CAMPAIGNID_STATS_SKUS in set but failed match against \"{}\"", path, paths::REGEX_CAMPAIGNS_CAMPAIGNID_STATS_SKUS.as_str())
                    );

                let param_campaign_id = match percent_encoding::percent_decode(path_params["campaignId"].as_bytes()).decode_utf8() {
                    Ok(param_campaign_id) => match param_campaign_id.parse::<i64>() {
                        Ok(param_campaign_id) => param_campaign_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter campaignId: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["campaignId"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                // Handle body parameters (note that non-required body parameters will ignore garbage
                // values, rather than causing a 400 response). Produce warning header and logs for
                // any unused fields.
                let result = body.into_raw().await;
                match result {
                     Ok(body) => {
                                let mut unused_elements : Vec<String> = vec![];
                                let param_get_goods_stats_request: Option<models::GetGoodsStatsRequest> = if !body.is_empty() {
                                    let deserializer = &mut serde_json::Deserializer::from_slice(&*body);
                                    match serde_ignored::deserialize(deserializer, |path| {
                                            warn!("Ignoring unknown field in body: {}", path);
                                            unused_elements.push(path.to_string());
                                    }) {
                                        Ok(param_get_goods_stats_request) => param_get_goods_stats_request,
                                        Err(e) => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from(format!("Couldn't parse body parameter GetGoodsStatsRequest - doesn't match schema: {}", e)))
                                                        .expect("Unable to create Bad Request response for invalid body parameter GetGoodsStatsRequest due to schema")),
                                    }
                                } else {
                                    None
                                };
                                let param_get_goods_stats_request = match param_get_goods_stats_request {
                                    Some(param_get_goods_stats_request) => param_get_goods_stats_request,
                                    None => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from("Missing required body parameter GetGoodsStatsRequest"))
                                                        .expect("Unable to create Bad Request response for missing body parameter GetGoodsStatsRequest")),
                                };


                                let result = api_impl.get_goods_stats(
                                            param_campaign_id,
                                            param_get_goods_stats_request,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        if !unused_elements.is_empty() {
                                            response.headers_mut().insert(
                                                HeaderName::from_static("warning"),
                                                HeaderValue::from_str(format!("Ignoring unknown fields in body: {:?}", unused_elements).as_str())
                                                    .expect("Unable to create Warning header value"));
                                        }
                                        match result {
                                            Ok(rsp) => match rsp {
                                                GetGoodsStatsResponse::Status200
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetGoodsStatsResponse::Status400
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetGoodsStatsResponse::Status401
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetGoodsStatsResponse::Status403
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetGoodsStatsResponse::Status404
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetGoodsStatsResponse::Status420
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(420).expect("Unable to turn 420 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetGoodsStatsResponse::Status500
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
                            },
                            Err(e) => Ok(Response::builder()
                                                .status(StatusCode::BAD_REQUEST)
                                                .body(Body::from(format!("Unable to read body: {}", e)))
                                                .expect("Unable to create Bad Request response due to unable to read body")),
                        }
            },

            // AddHiddenOffers - POST /campaigns/{campaignId}/hidden-offers
            hyper::Method::POST if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_HIDDEN_OFFERS) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "market:partner-api".to_string(), // API Яндекс.Маркета / Поиска по товарам для партнеров
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_CAMPAIGNS_CAMPAIGNID_HIDDEN_OFFERS
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE CAMPAIGNS_CAMPAIGNID_HIDDEN_OFFERS in set but failed match against \"{}\"", path, paths::REGEX_CAMPAIGNS_CAMPAIGNID_HIDDEN_OFFERS.as_str())
                    );

                let param_campaign_id = match percent_encoding::percent_decode(path_params["campaignId"].as_bytes()).decode_utf8() {
                    Ok(param_campaign_id) => match param_campaign_id.parse::<i64>() {
                        Ok(param_campaign_id) => param_campaign_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter campaignId: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["campaignId"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                // Handle body parameters (note that non-required body parameters will ignore garbage
                // values, rather than causing a 400 response). Produce warning header and logs for
                // any unused fields.
                let result = body.into_raw().await;
                match result {
                     Ok(body) => {
                                let mut unused_elements : Vec<String> = vec![];
                                let param_add_hidden_offers_request: Option<models::AddHiddenOffersRequest> = if !body.is_empty() {
                                    let deserializer = &mut serde_json::Deserializer::from_slice(&*body);
                                    match serde_ignored::deserialize(deserializer, |path| {
                                            warn!("Ignoring unknown field in body: {}", path);
                                            unused_elements.push(path.to_string());
                                    }) {
                                        Ok(param_add_hidden_offers_request) => param_add_hidden_offers_request,
                                        Err(e) => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from(format!("Couldn't parse body parameter AddHiddenOffersRequest - doesn't match schema: {}", e)))
                                                        .expect("Unable to create Bad Request response for invalid body parameter AddHiddenOffersRequest due to schema")),
                                    }
                                } else {
                                    None
                                };
                                let param_add_hidden_offers_request = match param_add_hidden_offers_request {
                                    Some(param_add_hidden_offers_request) => param_add_hidden_offers_request,
                                    None => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from("Missing required body parameter AddHiddenOffersRequest"))
                                                        .expect("Unable to create Bad Request response for missing body parameter AddHiddenOffersRequest")),
                                };


                                let result = api_impl.add_hidden_offers(
                                            param_campaign_id,
                                            param_add_hidden_offers_request,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        if !unused_elements.is_empty() {
                                            response.headers_mut().insert(
                                                HeaderName::from_static("warning"),
                                                HeaderValue::from_str(format!("Ignoring unknown fields in body: {:?}", unused_elements).as_str())
                                                    .expect("Unable to create Warning header value"));
                                        }
                                        match result {
                                            Ok(rsp) => match rsp {
                                                AddHiddenOffersResponse::Status200
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                AddHiddenOffersResponse::Status400
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                AddHiddenOffersResponse::Status401
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                AddHiddenOffersResponse::Status403
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                AddHiddenOffersResponse::Status420
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(420).expect("Unable to turn 420 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                AddHiddenOffersResponse::Status423
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(423).expect("Unable to turn 423 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                AddHiddenOffersResponse::Status500
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
                            },
                            Err(e) => Ok(Response::builder()
                                                .status(StatusCode::BAD_REQUEST)
                                                .body(Body::from(format!("Unable to read body: {}", e)))
                                                .expect("Unable to create Bad Request response due to unable to read body")),
                        }
            },

            // DeleteHiddenOffers - POST /campaigns/{campaignId}/hidden-offers/delete
            hyper::Method::POST if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_HIDDEN_OFFERS_DELETE) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "market:partner-api".to_string(), // API Яндекс.Маркета / Поиска по товарам для партнеров
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_CAMPAIGNS_CAMPAIGNID_HIDDEN_OFFERS_DELETE
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE CAMPAIGNS_CAMPAIGNID_HIDDEN_OFFERS_DELETE in set but failed match against \"{}\"", path, paths::REGEX_CAMPAIGNS_CAMPAIGNID_HIDDEN_OFFERS_DELETE.as_str())
                    );

                let param_campaign_id = match percent_encoding::percent_decode(path_params["campaignId"].as_bytes()).decode_utf8() {
                    Ok(param_campaign_id) => match param_campaign_id.parse::<i64>() {
                        Ok(param_campaign_id) => param_campaign_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter campaignId: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["campaignId"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                // Handle body parameters (note that non-required body parameters will ignore garbage
                // values, rather than causing a 400 response). Produce warning header and logs for
                // any unused fields.
                let result = body.into_raw().await;
                match result {
                     Ok(body) => {
                                let mut unused_elements : Vec<String> = vec![];
                                let param_delete_hidden_offers_request: Option<models::DeleteHiddenOffersRequest> = if !body.is_empty() {
                                    let deserializer = &mut serde_json::Deserializer::from_slice(&*body);
                                    match serde_ignored::deserialize(deserializer, |path| {
                                            warn!("Ignoring unknown field in body: {}", path);
                                            unused_elements.push(path.to_string());
                                    }) {
                                        Ok(param_delete_hidden_offers_request) => param_delete_hidden_offers_request,
                                        Err(e) => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from(format!("Couldn't parse body parameter DeleteHiddenOffersRequest - doesn't match schema: {}", e)))
                                                        .expect("Unable to create Bad Request response for invalid body parameter DeleteHiddenOffersRequest due to schema")),
                                    }
                                } else {
                                    None
                                };
                                let param_delete_hidden_offers_request = match param_delete_hidden_offers_request {
                                    Some(param_delete_hidden_offers_request) => param_delete_hidden_offers_request,
                                    None => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from("Missing required body parameter DeleteHiddenOffersRequest"))
                                                        .expect("Unable to create Bad Request response for missing body parameter DeleteHiddenOffersRequest")),
                                };


                                let result = api_impl.delete_hidden_offers(
                                            param_campaign_id,
                                            param_delete_hidden_offers_request,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        if !unused_elements.is_empty() {
                                            response.headers_mut().insert(
                                                HeaderName::from_static("warning"),
                                                HeaderValue::from_str(format!("Ignoring unknown fields in body: {:?}", unused_elements).as_str())
                                                    .expect("Unable to create Warning header value"));
                                        }
                                        match result {
                                            Ok(rsp) => match rsp {
                                                DeleteHiddenOffersResponse::Status200
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                DeleteHiddenOffersResponse::Status400
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                DeleteHiddenOffersResponse::Status401
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                DeleteHiddenOffersResponse::Status403
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                DeleteHiddenOffersResponse::Status404
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                DeleteHiddenOffersResponse::Status420
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(420).expect("Unable to turn 420 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                DeleteHiddenOffersResponse::Status423
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(423).expect("Unable to turn 423 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                DeleteHiddenOffersResponse::Status500
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
                            },
                            Err(e) => Ok(Response::builder()
                                                .status(StatusCode::BAD_REQUEST)
                                                .body(Body::from(format!("Unable to read body: {}", e)))
                                                .expect("Unable to create Bad Request response due to unable to read body")),
                        }
            },

            // GetHiddenOffers - GET /campaigns/{campaignId}/hidden-offers
            hyper::Method::GET if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_HIDDEN_OFFERS) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "market:partner-api".to_string(), // API Яндекс.Маркета / Поиска по товарам для партнеров
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_CAMPAIGNS_CAMPAIGNID_HIDDEN_OFFERS
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE CAMPAIGNS_CAMPAIGNID_HIDDEN_OFFERS in set but failed match against \"{}\"", path, paths::REGEX_CAMPAIGNS_CAMPAIGNID_HIDDEN_OFFERS.as_str())
                    );

                let param_campaign_id = match percent_encoding::percent_decode(path_params["campaignId"].as_bytes()).decode_utf8() {
                    Ok(param_campaign_id) => match param_campaign_id.parse::<i64>() {
                        Ok(param_campaign_id) => param_campaign_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter campaignId: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["campaignId"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                // Query parameters (note that non-required or collection query parameters will ignore garbage values, rather than causing a 400 response)
                let query_params = form_urlencoded::parse(uri.query().unwrap_or_default().as_bytes()).collect::<Vec<_>>();
                let param_offer_id = query_params.iter().filter(|e| e.0 == "offer_id").map(|e| e.1.clone())
                    .filter_map(|param_offer_id| param_offer_id.parse().ok())
                    .collect::<Vec<_>>();
                let param_offer_id = if !param_offer_id.is_empty() {
                    Some(param_offer_id)
                } else {
                    None
                };
                let param_page_token = query_params.iter().filter(|e| e.0 == "page_token").map(|e| e.1.clone())
                    .next();
                let param_page_token = match param_page_token {
                    Some(param_page_token) => {
                        let param_page_token =
                            <String as std::str::FromStr>::from_str
                                (&param_page_token);
                        match param_page_token {
                            Ok(param_page_token) => Some(param_page_token),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter page_token - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter page_token")),
                        }
                    },
                    None => None,
                };
                let param_limit = query_params.iter().filter(|e| e.0 == "limit").map(|e| e.1.clone())
                    .next();
                let param_limit = match param_limit {
                    Some(param_limit) => {
                        let param_limit =
                            <i32 as std::str::FromStr>::from_str
                                (&param_limit);
                        match param_limit {
                            Ok(param_limit) => Some(param_limit),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter limit - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter limit")),
                        }
                    },
                    None => None,
                };
                let param_offset = query_params.iter().filter(|e| e.0 == "offset").map(|e| e.1.clone())
                    .next();
                let param_offset = match param_offset {
                    Some(param_offset) => {
                        let param_offset =
                            <i32 as std::str::FromStr>::from_str
                                (&param_offset);
                        match param_offset {
                            Ok(param_offset) => Some(param_offset),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter offset - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter offset")),
                        }
                    },
                    None => None,
                };
                let param_page = query_params.iter().filter(|e| e.0 == "page").map(|e| e.1.clone())
                    .next();
                let param_page = match param_page {
                    Some(param_page) => {
                        let param_page =
                            <i32 as std::str::FromStr>::from_str
                                (&param_page);
                        match param_page {
                            Ok(param_page) => Some(param_page),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter page - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter page")),
                        }
                    },
                    None => None,
                };
                let param_page_size = query_params.iter().filter(|e| e.0 == "pageSize").map(|e| e.1.clone())
                    .next();
                let param_page_size = match param_page_size {
                    Some(param_page_size) => {
                        let param_page_size =
                            <i32 as std::str::FromStr>::from_str
                                (&param_page_size);
                        match param_page_size {
                            Ok(param_page_size) => Some(param_page_size),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter pageSize - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter pageSize")),
                        }
                    },
                    None => None,
                };

                                let result = api_impl.get_hidden_offers(
                                            param_campaign_id,
                                            param_offer_id.as_ref(),
                                            param_page_token,
                                            param_limit,
                                            param_offset,
                                            param_page,
                                            param_page_size,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                GetHiddenOffersResponse::Status200
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetHiddenOffersResponse::Status400
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetHiddenOffersResponse::Status401
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetHiddenOffersResponse::Status403
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetHiddenOffersResponse::Status420
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(420).expect("Unable to turn 420 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetHiddenOffersResponse::Status500
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
            },

            // GetModels - POST /models
            hyper::Method::POST if path.matched(paths::ID_MODELS) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "market:partner-api".to_string(), // API Яндекс.Маркета / Поиска по товарам для партнеров
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Query parameters (note that non-required or collection query parameters will ignore garbage values, rather than causing a 400 response)
                let query_params = form_urlencoded::parse(uri.query().unwrap_or_default().as_bytes()).collect::<Vec<_>>();
                let param_region_id = query_params.iter().filter(|e| e.0 == "regionId").map(|e| e.1.clone())
                    .next();
                let param_region_id = match param_region_id {
                    Some(param_region_id) => {
                        let param_region_id =
                            <i64 as std::str::FromStr>::from_str
                                (&param_region_id);
                        match param_region_id {
                            Ok(param_region_id) => Some(param_region_id),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter regionId - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter regionId")),
                        }
                    },
                    None => None,
                };
                let param_region_id = match param_region_id {
                    Some(param_region_id) => param_region_id,
                    None => return Ok(Response::builder()
                        .status(StatusCode::BAD_REQUEST)
                        .body(Body::from("Missing required query parameter regionId"))
                        .expect("Unable to create Bad Request response for missing query parameter regionId")),
                };
                let param_currency = query_params.iter().filter(|e| e.0 == "currency").map(|e| e.1.clone())
                    .next();
                let param_currency = match param_currency {
                    Some(param_currency) => {
                        let param_currency =
                            <models::CurrencyType as std::str::FromStr>::from_str
                                (&param_currency);
                        match param_currency {
                            Ok(param_currency) => Some(param_currency),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter currency - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter currency")),
                        }
                    },
                    None => None,
                };

                // Handle body parameters (note that non-required body parameters will ignore garbage
                // values, rather than causing a 400 response). Produce warning header and logs for
                // any unused fields.
                let result = body.into_raw().await;
                match result {
                     Ok(body) => {
                                let mut unused_elements : Vec<String> = vec![];
                                let param_get_models_request: Option<models::GetModelsRequest> = if !body.is_empty() {
                                    let deserializer = &mut serde_json::Deserializer::from_slice(&*body);
                                    match serde_ignored::deserialize(deserializer, |path| {
                                            warn!("Ignoring unknown field in body: {}", path);
                                            unused_elements.push(path.to_string());
                                    }) {
                                        Ok(param_get_models_request) => param_get_models_request,
                                        Err(e) => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from(format!("Couldn't parse body parameter GetModelsRequest - doesn't match schema: {}", e)))
                                                        .expect("Unable to create Bad Request response for invalid body parameter GetModelsRequest due to schema")),
                                    }
                                } else {
                                    None
                                };
                                let param_get_models_request = match param_get_models_request {
                                    Some(param_get_models_request) => param_get_models_request,
                                    None => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from("Missing required body parameter GetModelsRequest"))
                                                        .expect("Unable to create Bad Request response for missing body parameter GetModelsRequest")),
                                };


                                let result = api_impl.get_models(
                                            param_region_id,
                                            param_get_models_request,
                                            param_currency,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        if !unused_elements.is_empty() {
                                            response.headers_mut().insert(
                                                HeaderName::from_static("warning"),
                                                HeaderValue::from_str(format!("Ignoring unknown fields in body: {:?}", unused_elements).as_str())
                                                    .expect("Unable to create Warning header value"));
                                        }
                                        match result {
                                            Ok(rsp) => match rsp {
                                                GetModelsResponse::Status200
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetModelsResponse::Status400
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetModelsResponse::Status401
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetModelsResponse::Status403
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetModelsResponse::Status404
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetModelsResponse::Status420
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(420).expect("Unable to turn 420 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetModelsResponse::Status500
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
                            },
                            Err(e) => Ok(Response::builder()
                                                .status(StatusCode::BAD_REQUEST)
                                                .body(Body::from(format!("Unable to read body: {}", e)))
                                                .expect("Unable to create Bad Request response due to unable to read body")),
                        }
            },

            // GetModelsOffers - POST /models/offers
            hyper::Method::POST if path.matched(paths::ID_MODELS_OFFERS) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "market:partner-api".to_string(), // API Яндекс.Маркета / Поиска по товарам для партнеров
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Query parameters (note that non-required or collection query parameters will ignore garbage values, rather than causing a 400 response)
                let query_params = form_urlencoded::parse(uri.query().unwrap_or_default().as_bytes()).collect::<Vec<_>>();
                let param_region_id = query_params.iter().filter(|e| e.0 == "regionId").map(|e| e.1.clone())
                    .next();
                let param_region_id = match param_region_id {
                    Some(param_region_id) => {
                        let param_region_id =
                            <i64 as std::str::FromStr>::from_str
                                (&param_region_id);
                        match param_region_id {
                            Ok(param_region_id) => Some(param_region_id),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter regionId - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter regionId")),
                        }
                    },
                    None => None,
                };
                let param_region_id = match param_region_id {
                    Some(param_region_id) => param_region_id,
                    None => return Ok(Response::builder()
                        .status(StatusCode::BAD_REQUEST)
                        .body(Body::from("Missing required query parameter regionId"))
                        .expect("Unable to create Bad Request response for missing query parameter regionId")),
                };
                let param_currency = query_params.iter().filter(|e| e.0 == "currency").map(|e| e.1.clone())
                    .next();
                let param_currency = match param_currency {
                    Some(param_currency) => {
                        let param_currency =
                            <models::CurrencyType as std::str::FromStr>::from_str
                                (&param_currency);
                        match param_currency {
                            Ok(param_currency) => Some(param_currency),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter currency - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter currency")),
                        }
                    },
                    None => None,
                };
                let param_order_by_price = query_params.iter().filter(|e| e.0 == "orderByPrice").map(|e| e.1.clone())
                    .next();
                let param_order_by_price = match param_order_by_price {
                    Some(param_order_by_price) => {
                        let param_order_by_price =
                            <models::SortOrderType as std::str::FromStr>::from_str
                                (&param_order_by_price);
                        match param_order_by_price {
                            Ok(param_order_by_price) => Some(param_order_by_price),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter orderByPrice - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter orderByPrice")),
                        }
                    },
                    None => None,
                };

                // Handle body parameters (note that non-required body parameters will ignore garbage
                // values, rather than causing a 400 response). Produce warning header and logs for
                // any unused fields.
                let result = body.into_raw().await;
                match result {
                     Ok(body) => {
                                let mut unused_elements : Vec<String> = vec![];
                                let param_get_models_request: Option<models::GetModelsRequest> = if !body.is_empty() {
                                    let deserializer = &mut serde_json::Deserializer::from_slice(&*body);
                                    match serde_ignored::deserialize(deserializer, |path| {
                                            warn!("Ignoring unknown field in body: {}", path);
                                            unused_elements.push(path.to_string());
                                    }) {
                                        Ok(param_get_models_request) => param_get_models_request,
                                        Err(e) => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from(format!("Couldn't parse body parameter GetModelsRequest - doesn't match schema: {}", e)))
                                                        .expect("Unable to create Bad Request response for invalid body parameter GetModelsRequest due to schema")),
                                    }
                                } else {
                                    None
                                };
                                let param_get_models_request = match param_get_models_request {
                                    Some(param_get_models_request) => param_get_models_request,
                                    None => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from("Missing required body parameter GetModelsRequest"))
                                                        .expect("Unable to create Bad Request response for missing body parameter GetModelsRequest")),
                                };


                                let result = api_impl.get_models_offers(
                                            param_region_id,
                                            param_get_models_request,
                                            param_currency,
                                            param_order_by_price,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        if !unused_elements.is_empty() {
                                            response.headers_mut().insert(
                                                HeaderName::from_static("warning"),
                                                HeaderValue::from_str(format!("Ignoring unknown fields in body: {:?}", unused_elements).as_str())
                                                    .expect("Unable to create Warning header value"));
                                        }
                                        match result {
                                            Ok(rsp) => match rsp {
                                                GetModelsOffersResponse::Status200
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetModelsOffersResponse::Status400
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetModelsOffersResponse::Status401
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetModelsOffersResponse::Status403
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetModelsOffersResponse::Status404
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetModelsOffersResponse::Status420
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(420).expect("Unable to turn 420 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetModelsOffersResponse::Status500
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
                            },
                            Err(e) => Ok(Response::builder()
                                                .status(StatusCode::BAD_REQUEST)
                                                .body(Body::from(format!("Unable to read body: {}", e)))
                                                .expect("Unable to create Bad Request response due to unable to read body")),
                        }
            },

            // SearchModels - GET /models
            hyper::Method::GET if path.matched(paths::ID_MODELS) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "market:partner-api".to_string(), // API Яндекс.Маркета / Поиска по товарам для партнеров
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Query parameters (note that non-required or collection query parameters will ignore garbage values, rather than causing a 400 response)
                let query_params = form_urlencoded::parse(uri.query().unwrap_or_default().as_bytes()).collect::<Vec<_>>();
                let param_query = query_params.iter().filter(|e| e.0 == "query").map(|e| e.1.clone())
                    .next();
                let param_query = match param_query {
                    Some(param_query) => {
                        let param_query =
                            <String as std::str::FromStr>::from_str
                                (&param_query);
                        match param_query {
                            Ok(param_query) => Some(param_query),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter query - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter query")),
                        }
                    },
                    None => None,
                };
                let param_query = match param_query {
                    Some(param_query) => param_query,
                    None => return Ok(Response::builder()
                        .status(StatusCode::BAD_REQUEST)
                        .body(Body::from("Missing required query parameter query"))
                        .expect("Unable to create Bad Request response for missing query parameter query")),
                };
                let param_region_id = query_params.iter().filter(|e| e.0 == "regionId").map(|e| e.1.clone())
                    .next();
                let param_region_id = match param_region_id {
                    Some(param_region_id) => {
                        let param_region_id =
                            <i64 as std::str::FromStr>::from_str
                                (&param_region_id);
                        match param_region_id {
                            Ok(param_region_id) => Some(param_region_id),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter regionId - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter regionId")),
                        }
                    },
                    None => None,
                };
                let param_region_id = match param_region_id {
                    Some(param_region_id) => param_region_id,
                    None => return Ok(Response::builder()
                        .status(StatusCode::BAD_REQUEST)
                        .body(Body::from("Missing required query parameter regionId"))
                        .expect("Unable to create Bad Request response for missing query parameter regionId")),
                };
                let param_currency = query_params.iter().filter(|e| e.0 == "currency").map(|e| e.1.clone())
                    .next();
                let param_currency = match param_currency {
                    Some(param_currency) => {
                        let param_currency =
                            <models::CurrencyType as std::str::FromStr>::from_str
                                (&param_currency);
                        match param_currency {
                            Ok(param_currency) => Some(param_currency),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter currency - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter currency")),
                        }
                    },
                    None => None,
                };
                let param_page = query_params.iter().filter(|e| e.0 == "page").map(|e| e.1.clone())
                    .next();
                let param_page = match param_page {
                    Some(param_page) => {
                        let param_page =
                            <i32 as std::str::FromStr>::from_str
                                (&param_page);
                        match param_page {
                            Ok(param_page) => Some(param_page),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter page - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter page")),
                        }
                    },
                    None => None,
                };
                let param_page_size = query_params.iter().filter(|e| e.0 == "pageSize").map(|e| e.1.clone())
                    .next();
                let param_page_size = match param_page_size {
                    Some(param_page_size) => {
                        let param_page_size =
                            <i32 as std::str::FromStr>::from_str
                                (&param_page_size);
                        match param_page_size {
                            Ok(param_page_size) => Some(param_page_size),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter pageSize - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter pageSize")),
                        }
                    },
                    None => None,
                };

                                let result = api_impl.search_models(
                                            param_query,
                                            param_region_id,
                                            param_currency,
                                            param_page,
                                            param_page_size,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                SearchModelsResponse::Status200
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                SearchModelsResponse::Status400
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                SearchModelsResponse::Status401
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                SearchModelsResponse::Status403
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                SearchModelsResponse::Status404
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                SearchModelsResponse::Status420
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(420).expect("Unable to turn 420 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                SearchModelsResponse::Status500
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
            },

            // GetModel - GET /models/{modelId}
            hyper::Method::GET if path.matched(paths::ID_MODELS_MODELID) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "market:partner-api".to_string(), // API Яндекс.Маркета / Поиска по товарам для партнеров
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_MODELS_MODELID
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE MODELS_MODELID in set but failed match against \"{}\"", path, paths::REGEX_MODELS_MODELID.as_str())
                    );

                let param_model_id = match percent_encoding::percent_decode(path_params["modelId"].as_bytes()).decode_utf8() {
                    Ok(param_model_id) => match param_model_id.parse::<i64>() {
                        Ok(param_model_id) => param_model_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter modelId: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["modelId"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                // Query parameters (note that non-required or collection query parameters will ignore garbage values, rather than causing a 400 response)
                let query_params = form_urlencoded::parse(uri.query().unwrap_or_default().as_bytes()).collect::<Vec<_>>();
                let param_region_id = query_params.iter().filter(|e| e.0 == "regionId").map(|e| e.1.clone())
                    .next();
                let param_region_id = match param_region_id {
                    Some(param_region_id) => {
                        let param_region_id =
                            <i64 as std::str::FromStr>::from_str
                                (&param_region_id);
                        match param_region_id {
                            Ok(param_region_id) => Some(param_region_id),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter regionId - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter regionId")),
                        }
                    },
                    None => None,
                };
                let param_region_id = match param_region_id {
                    Some(param_region_id) => param_region_id,
                    None => return Ok(Response::builder()
                        .status(StatusCode::BAD_REQUEST)
                        .body(Body::from("Missing required query parameter regionId"))
                        .expect("Unable to create Bad Request response for missing query parameter regionId")),
                };
                let param_currency = query_params.iter().filter(|e| e.0 == "currency").map(|e| e.1.clone())
                    .next();
                let param_currency = match param_currency {
                    Some(param_currency) => {
                        let param_currency =
                            <models::CurrencyType as std::str::FromStr>::from_str
                                (&param_currency);
                        match param_currency {
                            Ok(param_currency) => Some(param_currency),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter currency - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter currency")),
                        }
                    },
                    None => None,
                };

                                let result = api_impl.get_model(
                                            param_model_id,
                                            param_region_id,
                                            param_currency,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                GetModelResponse::Status200
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetModelResponse::Status400
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetModelResponse::Status401
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetModelResponse::Status403
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetModelResponse::Status404
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetModelResponse::Status420
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(420).expect("Unable to turn 420 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetModelResponse::Status500
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
            },

            // GetModelOffers - GET /models/{modelId}/offers
            hyper::Method::GET if path.matched(paths::ID_MODELS_MODELID_OFFERS) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "market:partner-api".to_string(), // API Яндекс.Маркета / Поиска по товарам для партнеров
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_MODELS_MODELID_OFFERS
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE MODELS_MODELID_OFFERS in set but failed match against \"{}\"", path, paths::REGEX_MODELS_MODELID_OFFERS.as_str())
                    );

                let param_model_id = match percent_encoding::percent_decode(path_params["modelId"].as_bytes()).decode_utf8() {
                    Ok(param_model_id) => match param_model_id.parse::<i64>() {
                        Ok(param_model_id) => param_model_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter modelId: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["modelId"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                // Query parameters (note that non-required or collection query parameters will ignore garbage values, rather than causing a 400 response)
                let query_params = form_urlencoded::parse(uri.query().unwrap_or_default().as_bytes()).collect::<Vec<_>>();
                let param_region_id = query_params.iter().filter(|e| e.0 == "regionId").map(|e| e.1.clone())
                    .next();
                let param_region_id = match param_region_id {
                    Some(param_region_id) => {
                        let param_region_id =
                            <i64 as std::str::FromStr>::from_str
                                (&param_region_id);
                        match param_region_id {
                            Ok(param_region_id) => Some(param_region_id),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter regionId - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter regionId")),
                        }
                    },
                    None => None,
                };
                let param_region_id = match param_region_id {
                    Some(param_region_id) => param_region_id,
                    None => return Ok(Response::builder()
                        .status(StatusCode::BAD_REQUEST)
                        .body(Body::from("Missing required query parameter regionId"))
                        .expect("Unable to create Bad Request response for missing query parameter regionId")),
                };
                let param_currency = query_params.iter().filter(|e| e.0 == "currency").map(|e| e.1.clone())
                    .next();
                let param_currency = match param_currency {
                    Some(param_currency) => {
                        let param_currency =
                            <models::CurrencyType as std::str::FromStr>::from_str
                                (&param_currency);
                        match param_currency {
                            Ok(param_currency) => Some(param_currency),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter currency - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter currency")),
                        }
                    },
                    None => None,
                };
                let param_order_by_price = query_params.iter().filter(|e| e.0 == "orderByPrice").map(|e| e.1.clone())
                    .next();
                let param_order_by_price = match param_order_by_price {
                    Some(param_order_by_price) => {
                        let param_order_by_price =
                            <models::SortOrderType as std::str::FromStr>::from_str
                                (&param_order_by_price);
                        match param_order_by_price {
                            Ok(param_order_by_price) => Some(param_order_by_price),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter orderByPrice - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter orderByPrice")),
                        }
                    },
                    None => None,
                };
                let param_count = query_params.iter().filter(|e| e.0 == "count").map(|e| e.1.clone())
                    .next();
                let param_count = match param_count {
                    Some(param_count) => {
                        let param_count =
                            <i32 as std::str::FromStr>::from_str
                                (&param_count);
                        match param_count {
                            Ok(param_count) => Some(param_count),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter count - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter count")),
                        }
                    },
                    None => None,
                };
                let param_page = query_params.iter().filter(|e| e.0 == "page").map(|e| e.1.clone())
                    .next();
                let param_page = match param_page {
                    Some(param_page) => {
                        let param_page =
                            <i32 as std::str::FromStr>::from_str
                                (&param_page);
                        match param_page {
                            Ok(param_page) => Some(param_page),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter page - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter page")),
                        }
                    },
                    None => None,
                };

                                let result = api_impl.get_model_offers(
                                            param_model_id,
                                            param_region_id,
                                            param_currency,
                                            param_order_by_price,
                                            param_count,
                                            param_page,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                GetModelOffersResponse::Status200
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetModelOffersResponse::Status400
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetModelOffersResponse::Status401
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetModelOffersResponse::Status403
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetModelOffersResponse::Status404
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetModelOffersResponse::Status420
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(420).expect("Unable to turn 420 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetModelOffersResponse::Status500
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
            },

            // GetOfferMappingEntries - GET /campaigns/{campaignId}/offer-mapping-entries
            hyper::Method::GET if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_OFFER_MAPPING_ENTRIES) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "market:partner-api".to_string(), // API Яндекс.Маркета / Поиска по товарам для партнеров
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_CAMPAIGNS_CAMPAIGNID_OFFER_MAPPING_ENTRIES
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE CAMPAIGNS_CAMPAIGNID_OFFER_MAPPING_ENTRIES in set but failed match against \"{}\"", path, paths::REGEX_CAMPAIGNS_CAMPAIGNID_OFFER_MAPPING_ENTRIES.as_str())
                    );

                let param_campaign_id = match percent_encoding::percent_decode(path_params["campaignId"].as_bytes()).decode_utf8() {
                    Ok(param_campaign_id) => match param_campaign_id.parse::<i64>() {
                        Ok(param_campaign_id) => param_campaign_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter campaignId: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["campaignId"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                // Query parameters (note that non-required or collection query parameters will ignore garbage values, rather than causing a 400 response)
                let query_params = form_urlencoded::parse(uri.query().unwrap_or_default().as_bytes()).collect::<Vec<_>>();
                let param_offer_id = query_params.iter().filter(|e| e.0 == "offer_id").map(|e| e.1.clone())
                    .filter_map(|param_offer_id| param_offer_id.parse().ok())
                    .collect::<Vec<_>>();
                let param_offer_id = if !param_offer_id.is_empty() {
                    Some(param_offer_id)
                } else {
                    None
                };
                let param_shop_sku = query_params.iter().filter(|e| e.0 == "shop_sku").map(|e| e.1.clone())
                    .filter_map(|param_shop_sku| param_shop_sku.parse().ok())
                    .collect::<Vec<_>>();
                let param_shop_sku = if !param_shop_sku.is_empty() {
                    Some(param_shop_sku)
                } else {
                    None
                };
                let param_mapping_kind = query_params.iter().filter(|e| e.0 == "mapping_kind").map(|e| e.1.clone())
                    .next();
                let param_mapping_kind = match param_mapping_kind {
                    Some(param_mapping_kind) => {
                        let param_mapping_kind =
                            <models::OfferMappingKindType as std::str::FromStr>::from_str
                                (&param_mapping_kind);
                        match param_mapping_kind {
                            Ok(param_mapping_kind) => Some(param_mapping_kind),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter mapping_kind - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter mapping_kind")),
                        }
                    },
                    None => None,
                };
                let param_status = query_params.iter().filter(|e| e.0 == "status").map(|e| e.1.clone())
                    .filter_map(|param_status| param_status.parse().ok())
                    .collect::<Vec<_>>();
                let param_status = if !param_status.is_empty() {
                    Some(param_status)
                } else {
                    None
                };
                let param_availability = query_params.iter().filter(|e| e.0 == "availability").map(|e| e.1.clone())
                    .filter_map(|param_availability| param_availability.parse().ok())
                    .collect::<Vec<_>>();
                let param_availability = if !param_availability.is_empty() {
                    Some(param_availability)
                } else {
                    None
                };
                let param_category_id = query_params.iter().filter(|e| e.0 == "category_id").map(|e| e.1.clone())
                    .filter_map(|param_category_id| param_category_id.parse().ok())
                    .collect::<Vec<_>>();
                let param_category_id = if !param_category_id.is_empty() {
                    Some(param_category_id)
                } else {
                    None
                };
                let param_vendor = query_params.iter().filter(|e| e.0 == "vendor").map(|e| e.1.clone())
                    .filter_map(|param_vendor| param_vendor.parse().ok())
                    .collect::<Vec<_>>();
                let param_vendor = if !param_vendor.is_empty() {
                    Some(param_vendor)
                } else {
                    None
                };
                let param_page_token = query_params.iter().filter(|e| e.0 == "page_token").map(|e| e.1.clone())
                    .next();
                let param_page_token = match param_page_token {
                    Some(param_page_token) => {
                        let param_page_token =
                            <String as std::str::FromStr>::from_str
                                (&param_page_token);
                        match param_page_token {
                            Ok(param_page_token) => Some(param_page_token),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter page_token - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter page_token")),
                        }
                    },
                    None => None,
                };
                let param_limit = query_params.iter().filter(|e| e.0 == "limit").map(|e| e.1.clone())
                    .next();
                let param_limit = match param_limit {
                    Some(param_limit) => {
                        let param_limit =
                            <i32 as std::str::FromStr>::from_str
                                (&param_limit);
                        match param_limit {
                            Ok(param_limit) => Some(param_limit),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter limit - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter limit")),
                        }
                    },
                    None => None,
                };

                                let result = api_impl.get_offer_mapping_entries(
                                            param_campaign_id,
                                            param_offer_id.as_ref(),
                                            param_shop_sku.as_ref(),
                                            param_mapping_kind,
                                            param_status.as_ref(),
                                            param_availability.as_ref(),
                                            param_category_id.as_ref(),
                                            param_vendor.as_ref(),
                                            param_page_token,
                                            param_limit,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                GetOfferMappingEntriesResponse::Status200
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetOfferMappingEntriesResponse::Status400
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetOfferMappingEntriesResponse::Status401
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetOfferMappingEntriesResponse::Status403
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetOfferMappingEntriesResponse::Status404
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetOfferMappingEntriesResponse::Status420
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(420).expect("Unable to turn 420 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetOfferMappingEntriesResponse::Status500
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
            },

            // GetSuggestedOfferMappingEntries - POST /campaigns/{campaignId}/offer-mapping-entries/suggestions
            hyper::Method::POST if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_OFFER_MAPPING_ENTRIES_SUGGESTIONS) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "market:partner-api".to_string(), // API Яндекс.Маркета / Поиска по товарам для партнеров
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_CAMPAIGNS_CAMPAIGNID_OFFER_MAPPING_ENTRIES_SUGGESTIONS
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE CAMPAIGNS_CAMPAIGNID_OFFER_MAPPING_ENTRIES_SUGGESTIONS in set but failed match against \"{}\"", path, paths::REGEX_CAMPAIGNS_CAMPAIGNID_OFFER_MAPPING_ENTRIES_SUGGESTIONS.as_str())
                    );

                let param_campaign_id = match percent_encoding::percent_decode(path_params["campaignId"].as_bytes()).decode_utf8() {
                    Ok(param_campaign_id) => match param_campaign_id.parse::<i64>() {
                        Ok(param_campaign_id) => param_campaign_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter campaignId: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["campaignId"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                // Handle body parameters (note that non-required body parameters will ignore garbage
                // values, rather than causing a 400 response). Produce warning header and logs for
                // any unused fields.
                let result = body.into_raw().await;
                match result {
                     Ok(body) => {
                                let mut unused_elements : Vec<String> = vec![];
                                let param_get_suggested_offer_mapping_entries_request: Option<models::GetSuggestedOfferMappingEntriesRequest> = if !body.is_empty() {
                                    let deserializer = &mut serde_json::Deserializer::from_slice(&*body);
                                    match serde_ignored::deserialize(deserializer, |path| {
                                            warn!("Ignoring unknown field in body: {}", path);
                                            unused_elements.push(path.to_string());
                                    }) {
                                        Ok(param_get_suggested_offer_mapping_entries_request) => param_get_suggested_offer_mapping_entries_request,
                                        Err(e) => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from(format!("Couldn't parse body parameter GetSuggestedOfferMappingEntriesRequest - doesn't match schema: {}", e)))
                                                        .expect("Unable to create Bad Request response for invalid body parameter GetSuggestedOfferMappingEntriesRequest due to schema")),
                                    }
                                } else {
                                    None
                                };
                                let param_get_suggested_offer_mapping_entries_request = match param_get_suggested_offer_mapping_entries_request {
                                    Some(param_get_suggested_offer_mapping_entries_request) => param_get_suggested_offer_mapping_entries_request,
                                    None => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from("Missing required body parameter GetSuggestedOfferMappingEntriesRequest"))
                                                        .expect("Unable to create Bad Request response for missing body parameter GetSuggestedOfferMappingEntriesRequest")),
                                };


                                let result = api_impl.get_suggested_offer_mapping_entries(
                                            param_campaign_id,
                                            param_get_suggested_offer_mapping_entries_request,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        if !unused_elements.is_empty() {
                                            response.headers_mut().insert(
                                                HeaderName::from_static("warning"),
                                                HeaderValue::from_str(format!("Ignoring unknown fields in body: {:?}", unused_elements).as_str())
                                                    .expect("Unable to create Warning header value"));
                                        }
                                        match result {
                                            Ok(rsp) => match rsp {
                                                GetSuggestedOfferMappingEntriesResponse::Status200
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetSuggestedOfferMappingEntriesResponse::Status400
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetSuggestedOfferMappingEntriesResponse::Status401
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetSuggestedOfferMappingEntriesResponse::Status403
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetSuggestedOfferMappingEntriesResponse::Status404
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetSuggestedOfferMappingEntriesResponse::Status420
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(420).expect("Unable to turn 420 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetSuggestedOfferMappingEntriesResponse::Status500
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
                            },
                            Err(e) => Ok(Response::builder()
                                                .status(StatusCode::BAD_REQUEST)
                                                .body(Body::from(format!("Unable to read body: {}", e)))
                                                .expect("Unable to create Bad Request response due to unable to read body")),
                        }
            },

            // UpdateOfferMappingEntries - POST /campaigns/{campaignId}/offer-mapping-entries/updates
            hyper::Method::POST if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_OFFER_MAPPING_ENTRIES_UPDATES) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "market:partner-api".to_string(), // API Яндекс.Маркета / Поиска по товарам для партнеров
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_CAMPAIGNS_CAMPAIGNID_OFFER_MAPPING_ENTRIES_UPDATES
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE CAMPAIGNS_CAMPAIGNID_OFFER_MAPPING_ENTRIES_UPDATES in set but failed match against \"{}\"", path, paths::REGEX_CAMPAIGNS_CAMPAIGNID_OFFER_MAPPING_ENTRIES_UPDATES.as_str())
                    );

                let param_campaign_id = match percent_encoding::percent_decode(path_params["campaignId"].as_bytes()).decode_utf8() {
                    Ok(param_campaign_id) => match param_campaign_id.parse::<i64>() {
                        Ok(param_campaign_id) => param_campaign_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter campaignId: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["campaignId"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                // Handle body parameters (note that non-required body parameters will ignore garbage
                // values, rather than causing a 400 response). Produce warning header and logs for
                // any unused fields.
                let result = body.into_raw().await;
                match result {
                     Ok(body) => {
                                let mut unused_elements : Vec<String> = vec![];
                                let param_update_offer_mapping_entry_request: Option<models::UpdateOfferMappingEntryRequest> = if !body.is_empty() {
                                    let deserializer = &mut serde_json::Deserializer::from_slice(&*body);
                                    match serde_ignored::deserialize(deserializer, |path| {
                                            warn!("Ignoring unknown field in body: {}", path);
                                            unused_elements.push(path.to_string());
                                    }) {
                                        Ok(param_update_offer_mapping_entry_request) => param_update_offer_mapping_entry_request,
                                        Err(e) => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from(format!("Couldn't parse body parameter UpdateOfferMappingEntryRequest - doesn't match schema: {}", e)))
                                                        .expect("Unable to create Bad Request response for invalid body parameter UpdateOfferMappingEntryRequest due to schema")),
                                    }
                                } else {
                                    None
                                };
                                let param_update_offer_mapping_entry_request = match param_update_offer_mapping_entry_request {
                                    Some(param_update_offer_mapping_entry_request) => param_update_offer_mapping_entry_request,
                                    None => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from("Missing required body parameter UpdateOfferMappingEntryRequest"))
                                                        .expect("Unable to create Bad Request response for missing body parameter UpdateOfferMappingEntryRequest")),
                                };


                                let result = api_impl.update_offer_mapping_entries(
                                            param_campaign_id,
                                            param_update_offer_mapping_entry_request,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        if !unused_elements.is_empty() {
                                            response.headers_mut().insert(
                                                HeaderName::from_static("warning"),
                                                HeaderValue::from_str(format!("Ignoring unknown fields in body: {:?}", unused_elements).as_str())
                                                    .expect("Unable to create Warning header value"));
                                        }
                                        match result {
                                            Ok(rsp) => match rsp {
                                                UpdateOfferMappingEntriesResponse::Status200
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                UpdateOfferMappingEntriesResponse::Status400
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                UpdateOfferMappingEntriesResponse::Status401
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                UpdateOfferMappingEntriesResponse::Status403
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                UpdateOfferMappingEntriesResponse::Status404
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                UpdateOfferMappingEntriesResponse::Status420
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(420).expect("Unable to turn 420 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                UpdateOfferMappingEntriesResponse::Status423
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(423).expect("Unable to turn 423 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                UpdateOfferMappingEntriesResponse::Status500
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
                            },
                            Err(e) => Ok(Response::builder()
                                                .status(StatusCode::BAD_REQUEST)
                                                .body(Body::from(format!("Unable to read body: {}", e)))
                                                .expect("Unable to create Bad Request response due to unable to read body")),
                        }
            },

            // DeleteCampaignOffers - POST /campaigns/{campaignId}/offers/delete
            hyper::Method::POST if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_OFFERS_DELETE) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "market:partner-api".to_string(), // API Яндекс.Маркета / Поиска по товарам для партнеров
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_CAMPAIGNS_CAMPAIGNID_OFFERS_DELETE
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE CAMPAIGNS_CAMPAIGNID_OFFERS_DELETE in set but failed match against \"{}\"", path, paths::REGEX_CAMPAIGNS_CAMPAIGNID_OFFERS_DELETE.as_str())
                    );

                let param_campaign_id = match percent_encoding::percent_decode(path_params["campaignId"].as_bytes()).decode_utf8() {
                    Ok(param_campaign_id) => match param_campaign_id.parse::<i64>() {
                        Ok(param_campaign_id) => param_campaign_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter campaignId: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["campaignId"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                // Handle body parameters (note that non-required body parameters will ignore garbage
                // values, rather than causing a 400 response). Produce warning header and logs for
                // any unused fields.
                let result = body.into_raw().await;
                match result {
                     Ok(body) => {
                                let mut unused_elements : Vec<String> = vec![];
                                let param_delete_campaign_offers_request: Option<models::DeleteCampaignOffersRequest> = if !body.is_empty() {
                                    let deserializer = &mut serde_json::Deserializer::from_slice(&*body);
                                    match serde_ignored::deserialize(deserializer, |path| {
                                            warn!("Ignoring unknown field in body: {}", path);
                                            unused_elements.push(path.to_string());
                                    }) {
                                        Ok(param_delete_campaign_offers_request) => param_delete_campaign_offers_request,
                                        Err(e) => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from(format!("Couldn't parse body parameter DeleteCampaignOffersRequest - doesn't match schema: {}", e)))
                                                        .expect("Unable to create Bad Request response for invalid body parameter DeleteCampaignOffersRequest due to schema")),
                                    }
                                } else {
                                    None
                                };
                                let param_delete_campaign_offers_request = match param_delete_campaign_offers_request {
                                    Some(param_delete_campaign_offers_request) => param_delete_campaign_offers_request,
                                    None => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from("Missing required body parameter DeleteCampaignOffersRequest"))
                                                        .expect("Unable to create Bad Request response for missing body parameter DeleteCampaignOffersRequest")),
                                };


                                let result = api_impl.delete_campaign_offers(
                                            param_campaign_id,
                                            param_delete_campaign_offers_request,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        if !unused_elements.is_empty() {
                                            response.headers_mut().insert(
                                                HeaderName::from_static("warning"),
                                                HeaderValue::from_str(format!("Ignoring unknown fields in body: {:?}", unused_elements).as_str())
                                                    .expect("Unable to create Warning header value"));
                                        }
                                        match result {
                                            Ok(rsp) => match rsp {
                                                DeleteCampaignOffersResponse::Status200
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                DeleteCampaignOffersResponse::Status400
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                DeleteCampaignOffersResponse::Status401
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                DeleteCampaignOffersResponse::Status403
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                DeleteCampaignOffersResponse::Status404
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                DeleteCampaignOffersResponse::Status420
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(420).expect("Unable to turn 420 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                DeleteCampaignOffersResponse::Status423
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(423).expect("Unable to turn 423 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                DeleteCampaignOffersResponse::Status500
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
                            },
                            Err(e) => Ok(Response::builder()
                                                .status(StatusCode::BAD_REQUEST)
                                                .body(Body::from(format!("Unable to read body: {}", e)))
                                                .expect("Unable to create Bad Request response due to unable to read body")),
                        }
            },

            // GetAllOffers - GET /campaigns/{campaignId}/offers/all
            hyper::Method::GET if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_OFFERS_ALL) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "market:partner-api".to_string(), // API Яндекс.Маркета / Поиска по товарам для партнеров
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_CAMPAIGNS_CAMPAIGNID_OFFERS_ALL
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE CAMPAIGNS_CAMPAIGNID_OFFERS_ALL in set but failed match against \"{}\"", path, paths::REGEX_CAMPAIGNS_CAMPAIGNID_OFFERS_ALL.as_str())
                    );

                let param_campaign_id = match percent_encoding::percent_decode(path_params["campaignId"].as_bytes()).decode_utf8() {
                    Ok(param_campaign_id) => match param_campaign_id.parse::<i64>() {
                        Ok(param_campaign_id) => param_campaign_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter campaignId: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["campaignId"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                // Query parameters (note that non-required or collection query parameters will ignore garbage values, rather than causing a 400 response)
                let query_params = form_urlencoded::parse(uri.query().unwrap_or_default().as_bytes()).collect::<Vec<_>>();
                let param_feed_id = query_params.iter().filter(|e| e.0 == "feedId").map(|e| e.1.clone())
                    .next();
                let param_feed_id = match param_feed_id {
                    Some(param_feed_id) => {
                        let param_feed_id =
                            <i64 as std::str::FromStr>::from_str
                                (&param_feed_id);
                        match param_feed_id {
                            Ok(param_feed_id) => Some(param_feed_id),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter feedId - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter feedId")),
                        }
                    },
                    None => None,
                };
                let param_chunk = query_params.iter().filter(|e| e.0 == "chunk").map(|e| e.1.clone())
                    .next();
                let param_chunk = match param_chunk {
                    Some(param_chunk) => {
                        let param_chunk =
                            <i32 as std::str::FromStr>::from_str
                                (&param_chunk);
                        match param_chunk {
                            Ok(param_chunk) => Some(param_chunk),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter chunk - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter chunk")),
                        }
                    },
                    None => None,
                };

                                let result = api_impl.get_all_offers(
                                            param_campaign_id,
                                            param_feed_id,
                                            param_chunk,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                GetAllOffersResponse::Status200
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetAllOffersResponse::Status400
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetAllOffersResponse::Status401
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetAllOffersResponse::Status403
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetAllOffersResponse::Status404
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetAllOffersResponse::Status420
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(420).expect("Unable to turn 420 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetAllOffersResponse::Status500
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
            },

            // GetCampaignOffers - POST /campaigns/{campaignId}/offers
            hyper::Method::POST if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_OFFERS) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "market:partner-api".to_string(), // API Яндекс.Маркета / Поиска по товарам для партнеров
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_CAMPAIGNS_CAMPAIGNID_OFFERS
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE CAMPAIGNS_CAMPAIGNID_OFFERS in set but failed match against \"{}\"", path, paths::REGEX_CAMPAIGNS_CAMPAIGNID_OFFERS.as_str())
                    );

                let param_campaign_id = match percent_encoding::percent_decode(path_params["campaignId"].as_bytes()).decode_utf8() {
                    Ok(param_campaign_id) => match param_campaign_id.parse::<i64>() {
                        Ok(param_campaign_id) => param_campaign_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter campaignId: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["campaignId"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                // Query parameters (note that non-required or collection query parameters will ignore garbage values, rather than causing a 400 response)
                let query_params = form_urlencoded::parse(uri.query().unwrap_or_default().as_bytes()).collect::<Vec<_>>();
                let param_page_token = query_params.iter().filter(|e| e.0 == "page_token").map(|e| e.1.clone())
                    .next();
                let param_page_token = match param_page_token {
                    Some(param_page_token) => {
                        let param_page_token =
                            <String as std::str::FromStr>::from_str
                                (&param_page_token);
                        match param_page_token {
                            Ok(param_page_token) => Some(param_page_token),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter page_token - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter page_token")),
                        }
                    },
                    None => None,
                };
                let param_limit = query_params.iter().filter(|e| e.0 == "limit").map(|e| e.1.clone())
                    .next();
                let param_limit = match param_limit {
                    Some(param_limit) => {
                        let param_limit =
                            <i32 as std::str::FromStr>::from_str
                                (&param_limit);
                        match param_limit {
                            Ok(param_limit) => Some(param_limit),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter limit - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter limit")),
                        }
                    },
                    None => None,
                };

                // Handle body parameters (note that non-required body parameters will ignore garbage
                // values, rather than causing a 400 response). Produce warning header and logs for
                // any unused fields.
                let result = body.into_raw().await;
                match result {
                     Ok(body) => {
                                let mut unused_elements : Vec<String> = vec![];
                                let param_get_campaign_offers_request: Option<models::GetCampaignOffersRequest> = if !body.is_empty() {
                                    let deserializer = &mut serde_json::Deserializer::from_slice(&*body);
                                    match serde_ignored::deserialize(deserializer, |path| {
                                            warn!("Ignoring unknown field in body: {}", path);
                                            unused_elements.push(path.to_string());
                                    }) {
                                        Ok(param_get_campaign_offers_request) => param_get_campaign_offers_request,
                                        Err(e) => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from(format!("Couldn't parse body parameter GetCampaignOffersRequest - doesn't match schema: {}", e)))
                                                        .expect("Unable to create Bad Request response for invalid body parameter GetCampaignOffersRequest due to schema")),
                                    }
                                } else {
                                    None
                                };
                                let param_get_campaign_offers_request = match param_get_campaign_offers_request {
                                    Some(param_get_campaign_offers_request) => param_get_campaign_offers_request,
                                    None => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from("Missing required body parameter GetCampaignOffersRequest"))
                                                        .expect("Unable to create Bad Request response for missing body parameter GetCampaignOffersRequest")),
                                };


                                let result = api_impl.get_campaign_offers(
                                            param_campaign_id,
                                            param_get_campaign_offers_request,
                                            param_page_token,
                                            param_limit,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        if !unused_elements.is_empty() {
                                            response.headers_mut().insert(
                                                HeaderName::from_static("warning"),
                                                HeaderValue::from_str(format!("Ignoring unknown fields in body: {:?}", unused_elements).as_str())
                                                    .expect("Unable to create Warning header value"));
                                        }
                                        match result {
                                            Ok(rsp) => match rsp {
                                                GetCampaignOffersResponse::Status200
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetCampaignOffersResponse::Status400
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetCampaignOffersResponse::Status401
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetCampaignOffersResponse::Status403
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetCampaignOffersResponse::Status404
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetCampaignOffersResponse::Status420
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(420).expect("Unable to turn 420 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetCampaignOffersResponse::Status500
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
                            },
                            Err(e) => Ok(Response::builder()
                                                .status(StatusCode::BAD_REQUEST)
                                                .body(Body::from(format!("Unable to read body: {}", e)))
                                                .expect("Unable to create Bad Request response due to unable to read body")),
                        }
            },

            // GetOfferRecommendations - POST /businesses/{businessId}/offers/recommendations
            hyper::Method::POST if path.matched(paths::ID_BUSINESSES_BUSINESSID_OFFERS_RECOMMENDATIONS) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "market:partner-api".to_string(), // API Яндекс.Маркета / Поиска по товарам для партнеров
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_BUSINESSES_BUSINESSID_OFFERS_RECOMMENDATIONS
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE BUSINESSES_BUSINESSID_OFFERS_RECOMMENDATIONS in set but failed match against \"{}\"", path, paths::REGEX_BUSINESSES_BUSINESSID_OFFERS_RECOMMENDATIONS.as_str())
                    );

                let param_business_id = match percent_encoding::percent_decode(path_params["businessId"].as_bytes()).decode_utf8() {
                    Ok(param_business_id) => match param_business_id.parse::<i64>() {
                        Ok(param_business_id) => param_business_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter businessId: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["businessId"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                // Query parameters (note that non-required or collection query parameters will ignore garbage values, rather than causing a 400 response)
                let query_params = form_urlencoded::parse(uri.query().unwrap_or_default().as_bytes()).collect::<Vec<_>>();
                let param_page_token = query_params.iter().filter(|e| e.0 == "page_token").map(|e| e.1.clone())
                    .next();
                let param_page_token = match param_page_token {
                    Some(param_page_token) => {
                        let param_page_token =
                            <String as std::str::FromStr>::from_str
                                (&param_page_token);
                        match param_page_token {
                            Ok(param_page_token) => Some(param_page_token),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter page_token - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter page_token")),
                        }
                    },
                    None => None,
                };
                let param_limit = query_params.iter().filter(|e| e.0 == "limit").map(|e| e.1.clone())
                    .next();
                let param_limit = match param_limit {
                    Some(param_limit) => {
                        let param_limit =
                            <i32 as std::str::FromStr>::from_str
                                (&param_limit);
                        match param_limit {
                            Ok(param_limit) => Some(param_limit),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter limit - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter limit")),
                        }
                    },
                    None => None,
                };

                // Handle body parameters (note that non-required body parameters will ignore garbage
                // values, rather than causing a 400 response). Produce warning header and logs for
                // any unused fields.
                let result = body.into_raw().await;
                match result {
                     Ok(body) => {
                                let mut unused_elements : Vec<String> = vec![];
                                let param_get_offer_recommendations_request: Option<models::GetOfferRecommendationsRequest> = if !body.is_empty() {
                                    let deserializer = &mut serde_json::Deserializer::from_slice(&*body);
                                    match serde_ignored::deserialize(deserializer, |path| {
                                            warn!("Ignoring unknown field in body: {}", path);
                                            unused_elements.push(path.to_string());
                                    }) {
                                        Ok(param_get_offer_recommendations_request) => param_get_offer_recommendations_request,
                                        Err(e) => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from(format!("Couldn't parse body parameter GetOfferRecommendationsRequest - doesn't match schema: {}", e)))
                                                        .expect("Unable to create Bad Request response for invalid body parameter GetOfferRecommendationsRequest due to schema")),
                                    }
                                } else {
                                    None
                                };
                                let param_get_offer_recommendations_request = match param_get_offer_recommendations_request {
                                    Some(param_get_offer_recommendations_request) => param_get_offer_recommendations_request,
                                    None => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from("Missing required body parameter GetOfferRecommendationsRequest"))
                                                        .expect("Unable to create Bad Request response for missing body parameter GetOfferRecommendationsRequest")),
                                };


                                let result = api_impl.get_offer_recommendations(
                                            param_business_id,
                                            param_get_offer_recommendations_request,
                                            param_page_token,
                                            param_limit,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        if !unused_elements.is_empty() {
                                            response.headers_mut().insert(
                                                HeaderName::from_static("warning"),
                                                HeaderValue::from_str(format!("Ignoring unknown fields in body: {:?}", unused_elements).as_str())
                                                    .expect("Unable to create Warning header value"));
                                        }
                                        match result {
                                            Ok(rsp) => match rsp {
                                                GetOfferRecommendationsResponse::Status200
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetOfferRecommendationsResponse::Status400
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetOfferRecommendationsResponse::Status401
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetOfferRecommendationsResponse::Status403
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetOfferRecommendationsResponse::Status404
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetOfferRecommendationsResponse::Status420
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(420).expect("Unable to turn 420 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetOfferRecommendationsResponse::Status500
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
                            },
                            Err(e) => Ok(Response::builder()
                                                .status(StatusCode::BAD_REQUEST)
                                                .body(Body::from(format!("Unable to read body: {}", e)))
                                                .expect("Unable to create Bad Request response due to unable to read body")),
                        }
            },

            // GetOffers - GET /campaigns/{campaignId}/offers
            hyper::Method::GET if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_OFFERS) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "market:partner-api".to_string(), // API Яндекс.Маркета / Поиска по товарам для партнеров
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_CAMPAIGNS_CAMPAIGNID_OFFERS
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE CAMPAIGNS_CAMPAIGNID_OFFERS in set but failed match against \"{}\"", path, paths::REGEX_CAMPAIGNS_CAMPAIGNID_OFFERS.as_str())
                    );

                let param_campaign_id = match percent_encoding::percent_decode(path_params["campaignId"].as_bytes()).decode_utf8() {
                    Ok(param_campaign_id) => match param_campaign_id.parse::<i64>() {
                        Ok(param_campaign_id) => param_campaign_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter campaignId: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["campaignId"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                // Query parameters (note that non-required or collection query parameters will ignore garbage values, rather than causing a 400 response)
                let query_params = form_urlencoded::parse(uri.query().unwrap_or_default().as_bytes()).collect::<Vec<_>>();
                let param_query = query_params.iter().filter(|e| e.0 == "query").map(|e| e.1.clone())
                    .next();
                let param_query = match param_query {
                    Some(param_query) => {
                        let param_query =
                            <String as std::str::FromStr>::from_str
                                (&param_query);
                        match param_query {
                            Ok(param_query) => Some(param_query),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter query - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter query")),
                        }
                    },
                    None => None,
                };
                let param_feed_id = query_params.iter().filter(|e| e.0 == "feedId").map(|e| e.1.clone())
                    .next();
                let param_feed_id = match param_feed_id {
                    Some(param_feed_id) => {
                        let param_feed_id =
                            <i64 as std::str::FromStr>::from_str
                                (&param_feed_id);
                        match param_feed_id {
                            Ok(param_feed_id) => Some(param_feed_id),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter feedId - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter feedId")),
                        }
                    },
                    None => None,
                };
                let param_shop_category_id = query_params.iter().filter(|e| e.0 == "shopCategoryId").map(|e| e.1.clone())
                    .next();
                let param_shop_category_id = match param_shop_category_id {
                    Some(param_shop_category_id) => {
                        let param_shop_category_id =
                            <String as std::str::FromStr>::from_str
                                (&param_shop_category_id);
                        match param_shop_category_id {
                            Ok(param_shop_category_id) => Some(param_shop_category_id),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter shopCategoryId - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter shopCategoryId")),
                        }
                    },
                    None => None,
                };
                let param_currency = query_params.iter().filter(|e| e.0 == "currency").map(|e| e.1.clone())
                    .next();
                let param_currency = match param_currency {
                    Some(param_currency) => {
                        let param_currency =
                            <models::CurrencyType as std::str::FromStr>::from_str
                                (&param_currency);
                        match param_currency {
                            Ok(param_currency) => Some(param_currency),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter currency - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter currency")),
                        }
                    },
                    None => None,
                };
                let param_matched = query_params.iter().filter(|e| e.0 == "matched").map(|e| e.1.clone())
                    .next();
                let param_matched = match param_matched {
                    Some(param_matched) => {
                        let param_matched =
                            <bool as std::str::FromStr>::from_str
                                (&param_matched);
                        match param_matched {
                            Ok(param_matched) => Some(param_matched),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter matched - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter matched")),
                        }
                    },
                    None => None,
                };
                let param_page = query_params.iter().filter(|e| e.0 == "page").map(|e| e.1.clone())
                    .next();
                let param_page = match param_page {
                    Some(param_page) => {
                        let param_page =
                            <i32 as std::str::FromStr>::from_str
                                (&param_page);
                        match param_page {
                            Ok(param_page) => Some(param_page),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter page - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter page")),
                        }
                    },
                    None => None,
                };
                let param_page_size = query_params.iter().filter(|e| e.0 == "pageSize").map(|e| e.1.clone())
                    .next();
                let param_page_size = match param_page_size {
                    Some(param_page_size) => {
                        let param_page_size =
                            <i32 as std::str::FromStr>::from_str
                                (&param_page_size);
                        match param_page_size {
                            Ok(param_page_size) => Some(param_page_size),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter pageSize - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter pageSize")),
                        }
                    },
                    None => None,
                };

                                let result = api_impl.get_offers(
                                            param_campaign_id,
                                            param_query,
                                            param_feed_id,
                                            param_shop_category_id,
                                            param_currency,
                                            param_matched,
                                            param_page,
                                            param_page_size,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                GetOffersResponse::Status200
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetOffersResponse::Status400
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetOffersResponse::Status401
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetOffersResponse::Status403
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetOffersResponse::Status404
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetOffersResponse::Status420
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(420).expect("Unable to turn 420 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetOffersResponse::Status500
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
            },

            // UpdateCampaignOffers - POST /campaigns/{campaignId}/offers/update
            hyper::Method::POST if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_OFFERS_UPDATE) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "market:partner-api".to_string(), // API Яндекс.Маркета / Поиска по товарам для партнеров
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_CAMPAIGNS_CAMPAIGNID_OFFERS_UPDATE
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE CAMPAIGNS_CAMPAIGNID_OFFERS_UPDATE in set but failed match against \"{}\"", path, paths::REGEX_CAMPAIGNS_CAMPAIGNID_OFFERS_UPDATE.as_str())
                    );

                let param_campaign_id = match percent_encoding::percent_decode(path_params["campaignId"].as_bytes()).decode_utf8() {
                    Ok(param_campaign_id) => match param_campaign_id.parse::<i64>() {
                        Ok(param_campaign_id) => param_campaign_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter campaignId: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["campaignId"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                // Handle body parameters (note that non-required body parameters will ignore garbage
                // values, rather than causing a 400 response). Produce warning header and logs for
                // any unused fields.
                let result = body.into_raw().await;
                match result {
                     Ok(body) => {
                                let mut unused_elements : Vec<String> = vec![];
                                let param_update_campaign_offers_request: Option<models::UpdateCampaignOffersRequest> = if !body.is_empty() {
                                    let deserializer = &mut serde_json::Deserializer::from_slice(&*body);
                                    match serde_ignored::deserialize(deserializer, |path| {
                                            warn!("Ignoring unknown field in body: {}", path);
                                            unused_elements.push(path.to_string());
                                    }) {
                                        Ok(param_update_campaign_offers_request) => param_update_campaign_offers_request,
                                        Err(e) => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from(format!("Couldn't parse body parameter UpdateCampaignOffersRequest - doesn't match schema: {}", e)))
                                                        .expect("Unable to create Bad Request response for invalid body parameter UpdateCampaignOffersRequest due to schema")),
                                    }
                                } else {
                                    None
                                };
                                let param_update_campaign_offers_request = match param_update_campaign_offers_request {
                                    Some(param_update_campaign_offers_request) => param_update_campaign_offers_request,
                                    None => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from("Missing required body parameter UpdateCampaignOffersRequest"))
                                                        .expect("Unable to create Bad Request response for missing body parameter UpdateCampaignOffersRequest")),
                                };


                                let result = api_impl.update_campaign_offers(
                                            param_campaign_id,
                                            param_update_campaign_offers_request,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        if !unused_elements.is_empty() {
                                            response.headers_mut().insert(
                                                HeaderName::from_static("warning"),
                                                HeaderValue::from_str(format!("Ignoring unknown fields in body: {:?}", unused_elements).as_str())
                                                    .expect("Unable to create Warning header value"));
                                        }
                                        match result {
                                            Ok(rsp) => match rsp {
                                                UpdateCampaignOffersResponse::Status200
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                UpdateCampaignOffersResponse::Status400
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                UpdateCampaignOffersResponse::Status401
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                UpdateCampaignOffersResponse::Status403
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                UpdateCampaignOffersResponse::Status404
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                UpdateCampaignOffersResponse::Status420
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(420).expect("Unable to turn 420 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                UpdateCampaignOffersResponse::Status423
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(423).expect("Unable to turn 423 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                UpdateCampaignOffersResponse::Status500
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
                            },
                            Err(e) => Ok(Response::builder()
                                                .status(StatusCode::BAD_REQUEST)
                                                .body(Body::from(format!("Unable to read body: {}", e)))
                                                .expect("Unable to create Bad Request response due to unable to read body")),
                        }
            },

            // GetOrderBusinessBuyerInfo - POST /campaigns/{campaignId}/orders/{orderId}/business-buyer
            hyper::Method::POST if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_BUSINESS_BUYER) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "market:partner-api".to_string(), // API Яндекс.Маркета / Поиска по товарам для партнеров
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_BUSINESS_BUYER
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_BUSINESS_BUYER in set but failed match against \"{}\"", path, paths::REGEX_CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_BUSINESS_BUYER.as_str())
                    );

                let param_campaign_id = match percent_encoding::percent_decode(path_params["campaignId"].as_bytes()).decode_utf8() {
                    Ok(param_campaign_id) => match param_campaign_id.parse::<i64>() {
                        Ok(param_campaign_id) => param_campaign_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter campaignId: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["campaignId"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                let param_order_id = match percent_encoding::percent_decode(path_params["orderId"].as_bytes()).decode_utf8() {
                    Ok(param_order_id) => match param_order_id.parse::<i64>() {
                        Ok(param_order_id) => param_order_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter orderId: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["orderId"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                                let result = api_impl.get_order_business_buyer_info(
                                            param_campaign_id,
                                            param_order_id,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                GetOrderBusinessBuyerInfoResponse::Status200
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetOrderBusinessBuyerInfoResponse::Status400
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetOrderBusinessBuyerInfoResponse::Status401
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetOrderBusinessBuyerInfoResponse::Status403
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetOrderBusinessBuyerInfoResponse::Status404
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetOrderBusinessBuyerInfoResponse::Status420
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(420).expect("Unable to turn 420 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetOrderBusinessBuyerInfoResponse::Status500
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
            },

            // GetOrderBusinessDocumentsInfo - POST /campaigns/{campaignId}/orders/{orderId}/documents
            hyper::Method::POST if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_DOCUMENTS) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "market:partner-api".to_string(), // API Яндекс.Маркета / Поиска по товарам для партнеров
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_DOCUMENTS
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_DOCUMENTS in set but failed match against \"{}\"", path, paths::REGEX_CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_DOCUMENTS.as_str())
                    );

                let param_campaign_id = match percent_encoding::percent_decode(path_params["campaignId"].as_bytes()).decode_utf8() {
                    Ok(param_campaign_id) => match param_campaign_id.parse::<i64>() {
                        Ok(param_campaign_id) => param_campaign_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter campaignId: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["campaignId"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                let param_order_id = match percent_encoding::percent_decode(path_params["orderId"].as_bytes()).decode_utf8() {
                    Ok(param_order_id) => match param_order_id.parse::<i64>() {
                        Ok(param_order_id) => param_order_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter orderId: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["orderId"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                                let result = api_impl.get_order_business_documents_info(
                                            param_campaign_id,
                                            param_order_id,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                GetOrderBusinessDocumentsInfoResponse::Status200
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetOrderBusinessDocumentsInfoResponse::Status400
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetOrderBusinessDocumentsInfoResponse::Status401
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetOrderBusinessDocumentsInfoResponse::Status403
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetOrderBusinessDocumentsInfoResponse::Status404
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetOrderBusinessDocumentsInfoResponse::Status420
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(420).expect("Unable to turn 420 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetOrderBusinessDocumentsInfoResponse::Status500
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
            },

            // GetOrderBuyerInfo - GET /campaigns/{campaignId}/orders/{orderId}/buyer
            hyper::Method::GET if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_BUYER) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "market:partner-api".to_string(), // API Яндекс.Маркета / Поиска по товарам для партнеров
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_BUYER
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_BUYER in set but failed match against \"{}\"", path, paths::REGEX_CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_BUYER.as_str())
                    );

                let param_campaign_id = match percent_encoding::percent_decode(path_params["campaignId"].as_bytes()).decode_utf8() {
                    Ok(param_campaign_id) => match param_campaign_id.parse::<i64>() {
                        Ok(param_campaign_id) => param_campaign_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter campaignId: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["campaignId"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                let param_order_id = match percent_encoding::percent_decode(path_params["orderId"].as_bytes()).decode_utf8() {
                    Ok(param_order_id) => match param_order_id.parse::<i64>() {
                        Ok(param_order_id) => param_order_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter orderId: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["orderId"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                                let result = api_impl.get_order_buyer_info(
                                            param_campaign_id,
                                            param_order_id,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                GetOrderBuyerInfoResponse::Status200
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetOrderBuyerInfoResponse::Status400
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetOrderBuyerInfoResponse::Status401
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetOrderBuyerInfoResponse::Status403
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetOrderBuyerInfoResponse::Status404
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetOrderBuyerInfoResponse::Status420
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(420).expect("Unable to turn 420 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetOrderBuyerInfoResponse::Status500
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
            },

            // SetOrderDeliveryDate - PUT /campaigns/{campaignId}/orders/{orderId}/delivery/date
            hyper::Method::PUT if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_DELIVERY_DATE) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "market:partner-api".to_string(), // API Яндекс.Маркета / Поиска по товарам для партнеров
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_DELIVERY_DATE
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_DELIVERY_DATE in set but failed match against \"{}\"", path, paths::REGEX_CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_DELIVERY_DATE.as_str())
                    );

                let param_campaign_id = match percent_encoding::percent_decode(path_params["campaignId"].as_bytes()).decode_utf8() {
                    Ok(param_campaign_id) => match param_campaign_id.parse::<i64>() {
                        Ok(param_campaign_id) => param_campaign_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter campaignId: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["campaignId"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                let param_order_id = match percent_encoding::percent_decode(path_params["orderId"].as_bytes()).decode_utf8() {
                    Ok(param_order_id) => match param_order_id.parse::<i64>() {
                        Ok(param_order_id) => param_order_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter orderId: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["orderId"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                // Handle body parameters (note that non-required body parameters will ignore garbage
                // values, rather than causing a 400 response). Produce warning header and logs for
                // any unused fields.
                let result = body.into_raw().await;
                match result {
                     Ok(body) => {
                                let mut unused_elements : Vec<String> = vec![];
                                let param_set_order_delivery_date_request: Option<models::SetOrderDeliveryDateRequest> = if !body.is_empty() {
                                    let deserializer = &mut serde_json::Deserializer::from_slice(&*body);
                                    match serde_ignored::deserialize(deserializer, |path| {
                                            warn!("Ignoring unknown field in body: {}", path);
                                            unused_elements.push(path.to_string());
                                    }) {
                                        Ok(param_set_order_delivery_date_request) => param_set_order_delivery_date_request,
                                        Err(e) => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from(format!("Couldn't parse body parameter SetOrderDeliveryDateRequest - doesn't match schema: {}", e)))
                                                        .expect("Unable to create Bad Request response for invalid body parameter SetOrderDeliveryDateRequest due to schema")),
                                    }
                                } else {
                                    None
                                };
                                let param_set_order_delivery_date_request = match param_set_order_delivery_date_request {
                                    Some(param_set_order_delivery_date_request) => param_set_order_delivery_date_request,
                                    None => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from("Missing required body parameter SetOrderDeliveryDateRequest"))
                                                        .expect("Unable to create Bad Request response for missing body parameter SetOrderDeliveryDateRequest")),
                                };


                                let result = api_impl.set_order_delivery_date(
                                            param_campaign_id,
                                            param_order_id,
                                            param_set_order_delivery_date_request,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        if !unused_elements.is_empty() {
                                            response.headers_mut().insert(
                                                HeaderName::from_static("warning"),
                                                HeaderValue::from_str(format!("Ignoring unknown fields in body: {:?}", unused_elements).as_str())
                                                    .expect("Unable to create Warning header value"));
                                        }
                                        match result {
                                            Ok(rsp) => match rsp {
                                                SetOrderDeliveryDateResponse::Status200
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                SetOrderDeliveryDateResponse::Status400
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                SetOrderDeliveryDateResponse::Status401
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                SetOrderDeliveryDateResponse::Status403
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                SetOrderDeliveryDateResponse::Status404
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                SetOrderDeliveryDateResponse::Status420
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(420).expect("Unable to turn 420 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                SetOrderDeliveryDateResponse::Status500
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
                            },
                            Err(e) => Ok(Response::builder()
                                                .status(StatusCode::BAD_REQUEST)
                                                .body(Body::from(format!("Unable to read body: {}", e)))
                                                .expect("Unable to create Bad Request response due to unable to read body")),
                        }
            },

            // SetOrderDeliveryTrackCode - POST /campaigns/{campaignId}/orders/{orderId}/delivery/track
            hyper::Method::POST if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_DELIVERY_TRACK) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "market:partner-api".to_string(), // API Яндекс.Маркета / Поиска по товарам для партнеров
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_DELIVERY_TRACK
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_DELIVERY_TRACK in set but failed match against \"{}\"", path, paths::REGEX_CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_DELIVERY_TRACK.as_str())
                    );

                let param_campaign_id = match percent_encoding::percent_decode(path_params["campaignId"].as_bytes()).decode_utf8() {
                    Ok(param_campaign_id) => match param_campaign_id.parse::<i64>() {
                        Ok(param_campaign_id) => param_campaign_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter campaignId: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["campaignId"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                let param_order_id = match percent_encoding::percent_decode(path_params["orderId"].as_bytes()).decode_utf8() {
                    Ok(param_order_id) => match param_order_id.parse::<i64>() {
                        Ok(param_order_id) => param_order_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter orderId: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["orderId"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                // Handle body parameters (note that non-required body parameters will ignore garbage
                // values, rather than causing a 400 response). Produce warning header and logs for
                // any unused fields.
                let result = body.into_raw().await;
                match result {
                     Ok(body) => {
                                let mut unused_elements : Vec<String> = vec![];
                                let param_set_order_delivery_track_code_request: Option<models::SetOrderDeliveryTrackCodeRequest> = if !body.is_empty() {
                                    let deserializer = &mut serde_json::Deserializer::from_slice(&*body);
                                    match serde_ignored::deserialize(deserializer, |path| {
                                            warn!("Ignoring unknown field in body: {}", path);
                                            unused_elements.push(path.to_string());
                                    }) {
                                        Ok(param_set_order_delivery_track_code_request) => param_set_order_delivery_track_code_request,
                                        Err(e) => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from(format!("Couldn't parse body parameter SetOrderDeliveryTrackCodeRequest - doesn't match schema: {}", e)))
                                                        .expect("Unable to create Bad Request response for invalid body parameter SetOrderDeliveryTrackCodeRequest due to schema")),
                                    }
                                } else {
                                    None
                                };
                                let param_set_order_delivery_track_code_request = match param_set_order_delivery_track_code_request {
                                    Some(param_set_order_delivery_track_code_request) => param_set_order_delivery_track_code_request,
                                    None => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from("Missing required body parameter SetOrderDeliveryTrackCodeRequest"))
                                                        .expect("Unable to create Bad Request response for missing body parameter SetOrderDeliveryTrackCodeRequest")),
                                };


                                let result = api_impl.set_order_delivery_track_code(
                                            param_campaign_id,
                                            param_order_id,
                                            param_set_order_delivery_track_code_request,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        if !unused_elements.is_empty() {
                                            response.headers_mut().insert(
                                                HeaderName::from_static("warning"),
                                                HeaderValue::from_str(format!("Ignoring unknown fields in body: {:?}", unused_elements).as_str())
                                                    .expect("Unable to create Warning header value"));
                                        }
                                        match result {
                                            Ok(rsp) => match rsp {
                                                SetOrderDeliveryTrackCodeResponse::Status200
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                SetOrderDeliveryTrackCodeResponse::Status400
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                SetOrderDeliveryTrackCodeResponse::Status401
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                SetOrderDeliveryTrackCodeResponse::Status403
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                SetOrderDeliveryTrackCodeResponse::Status404
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                SetOrderDeliveryTrackCodeResponse::Status420
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(420).expect("Unable to turn 420 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                SetOrderDeliveryTrackCodeResponse::Status500
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
                            },
                            Err(e) => Ok(Response::builder()
                                                .status(StatusCode::BAD_REQUEST)
                                                .body(Body::from(format!("Unable to read body: {}", e)))
                                                .expect("Unable to create Bad Request response due to unable to read body")),
                        }
            },

            // UpdateOrderStorageLimit - PUT /campaigns/{campaignId}/orders/{orderId}/delivery/storage-limit
            hyper::Method::PUT if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_DELIVERY_STORAGE_LIMIT) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "market:partner-api".to_string(), // API Яндекс.Маркета / Поиска по товарам для партнеров
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_DELIVERY_STORAGE_LIMIT
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_DELIVERY_STORAGE_LIMIT in set but failed match against \"{}\"", path, paths::REGEX_CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_DELIVERY_STORAGE_LIMIT.as_str())
                    );

                let param_campaign_id = match percent_encoding::percent_decode(path_params["campaignId"].as_bytes()).decode_utf8() {
                    Ok(param_campaign_id) => match param_campaign_id.parse::<i64>() {
                        Ok(param_campaign_id) => param_campaign_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter campaignId: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["campaignId"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                let param_order_id = match percent_encoding::percent_decode(path_params["orderId"].as_bytes()).decode_utf8() {
                    Ok(param_order_id) => match param_order_id.parse::<i64>() {
                        Ok(param_order_id) => param_order_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter orderId: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["orderId"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                // Handle body parameters (note that non-required body parameters will ignore garbage
                // values, rather than causing a 400 response). Produce warning header and logs for
                // any unused fields.
                let result = body.into_raw().await;
                match result {
                     Ok(body) => {
                                let mut unused_elements : Vec<String> = vec![];
                                let param_update_order_storage_limit_request: Option<models::UpdateOrderStorageLimitRequest> = if !body.is_empty() {
                                    let deserializer = &mut serde_json::Deserializer::from_slice(&*body);
                                    match serde_ignored::deserialize(deserializer, |path| {
                                            warn!("Ignoring unknown field in body: {}", path);
                                            unused_elements.push(path.to_string());
                                    }) {
                                        Ok(param_update_order_storage_limit_request) => param_update_order_storage_limit_request,
                                        Err(e) => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from(format!("Couldn't parse body parameter UpdateOrderStorageLimitRequest - doesn't match schema: {}", e)))
                                                        .expect("Unable to create Bad Request response for invalid body parameter UpdateOrderStorageLimitRequest due to schema")),
                                    }
                                } else {
                                    None
                                };
                                let param_update_order_storage_limit_request = match param_update_order_storage_limit_request {
                                    Some(param_update_order_storage_limit_request) => param_update_order_storage_limit_request,
                                    None => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from("Missing required body parameter UpdateOrderStorageLimitRequest"))
                                                        .expect("Unable to create Bad Request response for missing body parameter UpdateOrderStorageLimitRequest")),
                                };


                                let result = api_impl.update_order_storage_limit(
                                            param_campaign_id,
                                            param_order_id,
                                            param_update_order_storage_limit_request,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        if !unused_elements.is_empty() {
                                            response.headers_mut().insert(
                                                HeaderName::from_static("warning"),
                                                HeaderValue::from_str(format!("Ignoring unknown fields in body: {:?}", unused_elements).as_str())
                                                    .expect("Unable to create Warning header value"));
                                        }
                                        match result {
                                            Ok(rsp) => match rsp {
                                                UpdateOrderStorageLimitResponse::Status200
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                UpdateOrderStorageLimitResponse::Status400
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                UpdateOrderStorageLimitResponse::Status401
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                UpdateOrderStorageLimitResponse::Status403
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                UpdateOrderStorageLimitResponse::Status404
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                UpdateOrderStorageLimitResponse::Status420
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(420).expect("Unable to turn 420 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                UpdateOrderStorageLimitResponse::Status500
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
                            },
                            Err(e) => Ok(Response::builder()
                                                .status(StatusCode::BAD_REQUEST)
                                                .body(Body::from(format!("Unable to read body: {}", e)))
                                                .expect("Unable to create Bad Request response due to unable to read body")),
                        }
            },

            // VerifyOrderEac - PUT /campaigns/{campaignId}/orders/{orderId}/verifyEac
            hyper::Method::PUT if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_VERIFYEAC) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "market:partner-api".to_string(), // API Яндекс.Маркета / Поиска по товарам для партнеров
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_VERIFYEAC
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_VERIFYEAC in set but failed match against \"{}\"", path, paths::REGEX_CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_VERIFYEAC.as_str())
                    );

                let param_campaign_id = match percent_encoding::percent_decode(path_params["campaignId"].as_bytes()).decode_utf8() {
                    Ok(param_campaign_id) => match param_campaign_id.parse::<i64>() {
                        Ok(param_campaign_id) => param_campaign_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter campaignId: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["campaignId"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                let param_order_id = match percent_encoding::percent_decode(path_params["orderId"].as_bytes()).decode_utf8() {
                    Ok(param_order_id) => match param_order_id.parse::<i64>() {
                        Ok(param_order_id) => param_order_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter orderId: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["orderId"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                // Handle body parameters (note that non-required body parameters will ignore garbage
                // values, rather than causing a 400 response). Produce warning header and logs for
                // any unused fields.
                let result = body.into_raw().await;
                match result {
                     Ok(body) => {
                                let mut unused_elements : Vec<String> = vec![];
                                let param_verify_order_eac_request: Option<models::VerifyOrderEacRequest> = if !body.is_empty() {
                                    let deserializer = &mut serde_json::Deserializer::from_slice(&*body);
                                    match serde_ignored::deserialize(deserializer, |path| {
                                            warn!("Ignoring unknown field in body: {}", path);
                                            unused_elements.push(path.to_string());
                                    }) {
                                        Ok(param_verify_order_eac_request) => param_verify_order_eac_request,
                                        Err(e) => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from(format!("Couldn't parse body parameter VerifyOrderEacRequest - doesn't match schema: {}", e)))
                                                        .expect("Unable to create Bad Request response for invalid body parameter VerifyOrderEacRequest due to schema")),
                                    }
                                } else {
                                    None
                                };
                                let param_verify_order_eac_request = match param_verify_order_eac_request {
                                    Some(param_verify_order_eac_request) => param_verify_order_eac_request,
                                    None => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from("Missing required body parameter VerifyOrderEacRequest"))
                                                        .expect("Unable to create Bad Request response for missing body parameter VerifyOrderEacRequest")),
                                };


                                let result = api_impl.verify_order_eac(
                                            param_campaign_id,
                                            param_order_id,
                                            param_verify_order_eac_request,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        if !unused_elements.is_empty() {
                                            response.headers_mut().insert(
                                                HeaderName::from_static("warning"),
                                                HeaderValue::from_str(format!("Ignoring unknown fields in body: {:?}", unused_elements).as_str())
                                                    .expect("Unable to create Warning header value"));
                                        }
                                        match result {
                                            Ok(rsp) => match rsp {
                                                VerifyOrderEacResponse::Status200
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                VerifyOrderEacResponse::Status400
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                VerifyOrderEacResponse::Status401
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                VerifyOrderEacResponse::Status403
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                VerifyOrderEacResponse::Status404
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                VerifyOrderEacResponse::Status420
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(420).expect("Unable to turn 420 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                VerifyOrderEacResponse::Status500
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
                            },
                            Err(e) => Ok(Response::builder()
                                                .status(StatusCode::BAD_REQUEST)
                                                .body(Body::from(format!("Unable to read body: {}", e)))
                                                .expect("Unable to create Bad Request response due to unable to read body")),
                        }
            },

            // GenerateOrderLabels - GET /campaigns/{campaignId}/orders/{orderId}/delivery/labels
            hyper::Method::GET if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_DELIVERY_LABELS) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "market:partner-api".to_string(), // API Яндекс.Маркета / Поиска по товарам для партнеров
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_DELIVERY_LABELS
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_DELIVERY_LABELS in set but failed match against \"{}\"", path, paths::REGEX_CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_DELIVERY_LABELS.as_str())
                    );

                let param_campaign_id = match percent_encoding::percent_decode(path_params["campaignId"].as_bytes()).decode_utf8() {
                    Ok(param_campaign_id) => match param_campaign_id.parse::<i64>() {
                        Ok(param_campaign_id) => param_campaign_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter campaignId: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["campaignId"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                let param_order_id = match percent_encoding::percent_decode(path_params["orderId"].as_bytes()).decode_utf8() {
                    Ok(param_order_id) => match param_order_id.parse::<i64>() {
                        Ok(param_order_id) => param_order_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter orderId: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["orderId"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                // Query parameters (note that non-required or collection query parameters will ignore garbage values, rather than causing a 400 response)
                let query_params = form_urlencoded::parse(uri.query().unwrap_or_default().as_bytes()).collect::<Vec<_>>();
                let param_format = query_params.iter().filter(|e| e.0 == "format").map(|e| e.1.clone())
                    .next();
                let param_format = match param_format {
                    Some(param_format) => {
                        let param_format =
                            <models::PageFormatType as std::str::FromStr>::from_str
                                (&param_format);
                        match param_format {
                            Ok(param_format) => Some(param_format),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter format - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter format")),
                        }
                    },
                    None => None,
                };

                                let result = api_impl.generate_order_labels(
                                            param_campaign_id,
                                            param_order_id,
                                            param_format,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                GenerateOrderLabelsResponse::PDF
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/pdf")
                                                            .expect("Unable to create Content-Type header for application/pdf"));
                                                    // Binary Body
                                                    let body = body.0;
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GenerateOrderLabelsResponse::Status400
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GenerateOrderLabelsResponse::Status401
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GenerateOrderLabelsResponse::Status403
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GenerateOrderLabelsResponse::Status404
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GenerateOrderLabelsResponse::Status420
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(420).expect("Unable to turn 420 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GenerateOrderLabelsResponse::Status500
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
            },

            // GetOrderLabelsData - GET /campaigns/{campaignId}/orders/{orderId}/delivery/labels/data
            hyper::Method::GET if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_DELIVERY_LABELS_DATA) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "market:partner-api".to_string(), // API Яндекс.Маркета / Поиска по товарам для партнеров
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_DELIVERY_LABELS_DATA
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_DELIVERY_LABELS_DATA in set but failed match against \"{}\"", path, paths::REGEX_CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_DELIVERY_LABELS_DATA.as_str())
                    );

                let param_campaign_id = match percent_encoding::percent_decode(path_params["campaignId"].as_bytes()).decode_utf8() {
                    Ok(param_campaign_id) => match param_campaign_id.parse::<i64>() {
                        Ok(param_campaign_id) => param_campaign_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter campaignId: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["campaignId"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                let param_order_id = match percent_encoding::percent_decode(path_params["orderId"].as_bytes()).decode_utf8() {
                    Ok(param_order_id) => match param_order_id.parse::<i64>() {
                        Ok(param_order_id) => param_order_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter orderId: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["orderId"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                                let result = api_impl.get_order_labels_data(
                                            param_campaign_id,
                                            param_order_id,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                GetOrderLabelsDataResponse::Status200
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetOrderLabelsDataResponse::Status400
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetOrderLabelsDataResponse::Status401
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetOrderLabelsDataResponse::Status403
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetOrderLabelsDataResponse::Status404
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetOrderLabelsDataResponse::Status420
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(420).expect("Unable to turn 420 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetOrderLabelsDataResponse::Status500
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
            },

            // GenerateOrderLabel - GET /campaigns/{campaignId}/orders/{orderId}/delivery/shipments/{shipmentId}/boxes/{boxId}/label
            hyper::Method::GET if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_DELIVERY_SHIPMENTS_SHIPMENTID_BOXES_BOXID_LABEL) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "market:partner-api".to_string(), // API Яндекс.Маркета / Поиска по товарам для партнеров
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_DELIVERY_SHIPMENTS_SHIPMENTID_BOXES_BOXID_LABEL
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_DELIVERY_SHIPMENTS_SHIPMENTID_BOXES_BOXID_LABEL in set but failed match against \"{}\"", path, paths::REGEX_CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_DELIVERY_SHIPMENTS_SHIPMENTID_BOXES_BOXID_LABEL.as_str())
                    );

                let param_campaign_id = match percent_encoding::percent_decode(path_params["campaignId"].as_bytes()).decode_utf8() {
                    Ok(param_campaign_id) => match param_campaign_id.parse::<i64>() {
                        Ok(param_campaign_id) => param_campaign_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter campaignId: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["campaignId"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                let param_order_id = match percent_encoding::percent_decode(path_params["orderId"].as_bytes()).decode_utf8() {
                    Ok(param_order_id) => match param_order_id.parse::<i64>() {
                        Ok(param_order_id) => param_order_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter orderId: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["orderId"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                let param_shipment_id = match percent_encoding::percent_decode(path_params["shipmentId"].as_bytes()).decode_utf8() {
                    Ok(param_shipment_id) => match param_shipment_id.parse::<i64>() {
                        Ok(param_shipment_id) => param_shipment_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter shipmentId: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["shipmentId"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                let param_box_id = match percent_encoding::percent_decode(path_params["boxId"].as_bytes()).decode_utf8() {
                    Ok(param_box_id) => match param_box_id.parse::<i64>() {
                        Ok(param_box_id) => param_box_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter boxId: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["boxId"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                // Query parameters (note that non-required or collection query parameters will ignore garbage values, rather than causing a 400 response)
                let query_params = form_urlencoded::parse(uri.query().unwrap_or_default().as_bytes()).collect::<Vec<_>>();
                let param_format = query_params.iter().filter(|e| e.0 == "format").map(|e| e.1.clone())
                    .next();
                let param_format = match param_format {
                    Some(param_format) => {
                        let param_format =
                            <models::PageFormatType as std::str::FromStr>::from_str
                                (&param_format);
                        match param_format {
                            Ok(param_format) => Some(param_format),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter format - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter format")),
                        }
                    },
                    None => None,
                };

                                let result = api_impl.generate_order_label(
                                            param_campaign_id,
                                            param_order_id,
                                            param_shipment_id,
                                            param_box_id,
                                            param_format,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                GenerateOrderLabelResponse::PDF
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/pdf")
                                                            .expect("Unable to create Content-Type header for application/pdf"));
                                                    // Binary Body
                                                    let body = body.0;
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GenerateOrderLabelResponse::Status400
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GenerateOrderLabelResponse::Status401
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GenerateOrderLabelResponse::Status403
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GenerateOrderLabelResponse::Status404
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GenerateOrderLabelResponse::Status420
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(420).expect("Unable to turn 420 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GenerateOrderLabelResponse::Status500
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
            },

            // GetOrders - GET /campaigns/{campaignId}/orders
            hyper::Method::GET if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_ORDERS) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "market:partner-api".to_string(), // API Яндекс.Маркета / Поиска по товарам для партнеров
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_CAMPAIGNS_CAMPAIGNID_ORDERS
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE CAMPAIGNS_CAMPAIGNID_ORDERS in set but failed match against \"{}\"", path, paths::REGEX_CAMPAIGNS_CAMPAIGNID_ORDERS.as_str())
                    );

                let param_campaign_id = match percent_encoding::percent_decode(path_params["campaignId"].as_bytes()).decode_utf8() {
                    Ok(param_campaign_id) => match param_campaign_id.parse::<i64>() {
                        Ok(param_campaign_id) => param_campaign_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter campaignId: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["campaignId"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                // Query parameters (note that non-required or collection query parameters will ignore garbage values, rather than causing a 400 response)
                let query_params = form_urlencoded::parse(uri.query().unwrap_or_default().as_bytes()).collect::<Vec<_>>();
                let param_order_ids = query_params.iter().filter(|e| e.0 == "orderIds").map(|e| e.1.clone())
                    .filter_map(|param_order_ids| param_order_ids.parse().ok())
                    .collect::<Vec<_>>();
                let param_order_ids = if !param_order_ids.is_empty() {
                    Some(param_order_ids)
                } else {
                    None
                };
                let param_status = query_params.iter().filter(|e| e.0 == "status").map(|e| e.1.clone())
                    .filter_map(|param_status| param_status.parse().ok())
                    .collect::<Vec<_>>();
                let param_status = if !param_status.is_empty() {
                    Some(param_status)
                } else {
                    None
                };
                let param_substatus = query_params.iter().filter(|e| e.0 == "substatus").map(|e| e.1.clone())
                    .filter_map(|param_substatus| param_substatus.parse().ok())
                    .collect::<Vec<_>>();
                let param_substatus = if !param_substatus.is_empty() {
                    Some(param_substatus)
                } else {
                    None
                };
                let param_from_date = query_params.iter().filter(|e| e.0 == "fromDate").map(|e| e.1.clone())
                    .next();
                let param_from_date = match param_from_date {
                    Some(param_from_date) => {
                        let param_from_date =
                            <chrono::naive::NaiveDate as std::str::FromStr>::from_str
                                (&param_from_date);
                        match param_from_date {
                            Ok(param_from_date) => Some(param_from_date),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter fromDate - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter fromDate")),
                        }
                    },
                    None => None,
                };
                let param_to_date = query_params.iter().filter(|e| e.0 == "toDate").map(|e| e.1.clone())
                    .next();
                let param_to_date = match param_to_date {
                    Some(param_to_date) => {
                        let param_to_date =
                            <chrono::naive::NaiveDate as std::str::FromStr>::from_str
                                (&param_to_date);
                        match param_to_date {
                            Ok(param_to_date) => Some(param_to_date),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter toDate - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter toDate")),
                        }
                    },
                    None => None,
                };
                let param_supplier_shipment_date_from = query_params.iter().filter(|e| e.0 == "supplierShipmentDateFrom").map(|e| e.1.clone())
                    .next();
                let param_supplier_shipment_date_from = match param_supplier_shipment_date_from {
                    Some(param_supplier_shipment_date_from) => {
                        let param_supplier_shipment_date_from =
                            <chrono::naive::NaiveDate as std::str::FromStr>::from_str
                                (&param_supplier_shipment_date_from);
                        match param_supplier_shipment_date_from {
                            Ok(param_supplier_shipment_date_from) => Some(param_supplier_shipment_date_from),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter supplierShipmentDateFrom - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter supplierShipmentDateFrom")),
                        }
                    },
                    None => None,
                };
                let param_supplier_shipment_date_to = query_params.iter().filter(|e| e.0 == "supplierShipmentDateTo").map(|e| e.1.clone())
                    .next();
                let param_supplier_shipment_date_to = match param_supplier_shipment_date_to {
                    Some(param_supplier_shipment_date_to) => {
                        let param_supplier_shipment_date_to =
                            <chrono::naive::NaiveDate as std::str::FromStr>::from_str
                                (&param_supplier_shipment_date_to);
                        match param_supplier_shipment_date_to {
                            Ok(param_supplier_shipment_date_to) => Some(param_supplier_shipment_date_to),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter supplierShipmentDateTo - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter supplierShipmentDateTo")),
                        }
                    },
                    None => None,
                };
                let param_updated_at_from = query_params.iter().filter(|e| e.0 == "updatedAtFrom").map(|e| e.1.clone())
                    .next();
                let param_updated_at_from = match param_updated_at_from {
                    Some(param_updated_at_from) => {
                        let param_updated_at_from =
                            <chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str
                                (&param_updated_at_from);
                        match param_updated_at_from {
                            Ok(param_updated_at_from) => Some(param_updated_at_from),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter updatedAtFrom - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter updatedAtFrom")),
                        }
                    },
                    None => None,
                };
                let param_updated_at_to = query_params.iter().filter(|e| e.0 == "updatedAtTo").map(|e| e.1.clone())
                    .next();
                let param_updated_at_to = match param_updated_at_to {
                    Some(param_updated_at_to) => {
                        let param_updated_at_to =
                            <chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str
                                (&param_updated_at_to);
                        match param_updated_at_to {
                            Ok(param_updated_at_to) => Some(param_updated_at_to),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter updatedAtTo - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter updatedAtTo")),
                        }
                    },
                    None => None,
                };
                let param_dispatch_type = query_params.iter().filter(|e| e.0 == "dispatchType").map(|e| e.1.clone())
                    .next();
                let param_dispatch_type = match param_dispatch_type {
                    Some(param_dispatch_type) => {
                        let param_dispatch_type =
                            <models::OrderDeliveryDispatchType as std::str::FromStr>::from_str
                                (&param_dispatch_type);
                        match param_dispatch_type {
                            Ok(param_dispatch_type) => Some(param_dispatch_type),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter dispatchType - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter dispatchType")),
                        }
                    },
                    None => None,
                };
                let param_fake = query_params.iter().filter(|e| e.0 == "fake").map(|e| e.1.clone())
                    .next();
                let param_fake = match param_fake {
                    Some(param_fake) => {
                        let param_fake =
                            <bool as std::str::FromStr>::from_str
                                (&param_fake);
                        match param_fake {
                            Ok(param_fake) => Some(param_fake),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter fake - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter fake")),
                        }
                    },
                    None => None,
                };
                let param_has_cis = query_params.iter().filter(|e| e.0 == "hasCis").map(|e| e.1.clone())
                    .next();
                let param_has_cis = match param_has_cis {
                    Some(param_has_cis) => {
                        let param_has_cis =
                            <bool as std::str::FromStr>::from_str
                                (&param_has_cis);
                        match param_has_cis {
                            Ok(param_has_cis) => Some(param_has_cis),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter hasCis - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter hasCis")),
                        }
                    },
                    None => None,
                };
                let param_only_waiting_for_cancellation_approve = query_params.iter().filter(|e| e.0 == "onlyWaitingForCancellationApprove").map(|e| e.1.clone())
                    .next();
                let param_only_waiting_for_cancellation_approve = match param_only_waiting_for_cancellation_approve {
                    Some(param_only_waiting_for_cancellation_approve) => {
                        let param_only_waiting_for_cancellation_approve =
                            <bool as std::str::FromStr>::from_str
                                (&param_only_waiting_for_cancellation_approve);
                        match param_only_waiting_for_cancellation_approve {
                            Ok(param_only_waiting_for_cancellation_approve) => Some(param_only_waiting_for_cancellation_approve),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter onlyWaitingForCancellationApprove - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter onlyWaitingForCancellationApprove")),
                        }
                    },
                    None => None,
                };
                let param_only_estimated_delivery = query_params.iter().filter(|e| e.0 == "onlyEstimatedDelivery").map(|e| e.1.clone())
                    .next();
                let param_only_estimated_delivery = match param_only_estimated_delivery {
                    Some(param_only_estimated_delivery) => {
                        let param_only_estimated_delivery =
                            <bool as std::str::FromStr>::from_str
                                (&param_only_estimated_delivery);
                        match param_only_estimated_delivery {
                            Ok(param_only_estimated_delivery) => Some(param_only_estimated_delivery),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter onlyEstimatedDelivery - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter onlyEstimatedDelivery")),
                        }
                    },
                    None => None,
                };
                let param_buyer_type = query_params.iter().filter(|e| e.0 == "buyerType").map(|e| e.1.clone())
                    .next();
                let param_buyer_type = match param_buyer_type {
                    Some(param_buyer_type) => {
                        let param_buyer_type =
                            <models::OrderBuyerType as std::str::FromStr>::from_str
                                (&param_buyer_type);
                        match param_buyer_type {
                            Ok(param_buyer_type) => Some(param_buyer_type),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter buyerType - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter buyerType")),
                        }
                    },
                    None => None,
                };
                let param_page = query_params.iter().filter(|e| e.0 == "page").map(|e| e.1.clone())
                    .next();
                let param_page = match param_page {
                    Some(param_page) => {
                        let param_page =
                            <i32 as std::str::FromStr>::from_str
                                (&param_page);
                        match param_page {
                            Ok(param_page) => Some(param_page),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter page - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter page")),
                        }
                    },
                    None => None,
                };
                let param_page_size = query_params.iter().filter(|e| e.0 == "pageSize").map(|e| e.1.clone())
                    .next();
                let param_page_size = match param_page_size {
                    Some(param_page_size) => {
                        let param_page_size =
                            <i32 as std::str::FromStr>::from_str
                                (&param_page_size);
                        match param_page_size {
                            Ok(param_page_size) => Some(param_page_size),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter pageSize - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter pageSize")),
                        }
                    },
                    None => None,
                };
                let param_page_token = query_params.iter().filter(|e| e.0 == "page_token").map(|e| e.1.clone())
                    .next();
                let param_page_token = match param_page_token {
                    Some(param_page_token) => {
                        let param_page_token =
                            <String as std::str::FromStr>::from_str
                                (&param_page_token);
                        match param_page_token {
                            Ok(param_page_token) => Some(param_page_token),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter page_token - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter page_token")),
                        }
                    },
                    None => None,
                };
                let param_limit = query_params.iter().filter(|e| e.0 == "limit").map(|e| e.1.clone())
                    .next();
                let param_limit = match param_limit {
                    Some(param_limit) => {
                        let param_limit =
                            <i32 as std::str::FromStr>::from_str
                                (&param_limit);
                        match param_limit {
                            Ok(param_limit) => Some(param_limit),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter limit - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter limit")),
                        }
                    },
                    None => None,
                };

                                let result = api_impl.get_orders(
                                            param_campaign_id,
                                            param_order_ids.as_ref(),
                                            param_status.as_ref(),
                                            param_substatus.as_ref(),
                                            param_from_date,
                                            param_to_date,
                                            param_supplier_shipment_date_from,
                                            param_supplier_shipment_date_to,
                                            param_updated_at_from,
                                            param_updated_at_to,
                                            param_dispatch_type,
                                            param_fake,
                                            param_has_cis,
                                            param_only_waiting_for_cancellation_approve,
                                            param_only_estimated_delivery,
                                            param_buyer_type,
                                            param_page,
                                            param_page_size,
                                            param_page_token,
                                            param_limit,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                GetOrdersResponse::Status200
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetOrdersResponse::Status400
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetOrdersResponse::Status401
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetOrdersResponse::Status403
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetOrdersResponse::Status404
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetOrdersResponse::Status420
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(420).expect("Unable to turn 420 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetOrdersResponse::Status500
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
            },

            // UpdateOrderStatuses - POST /campaigns/{campaignId}/orders/status-update
            hyper::Method::POST if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_ORDERS_STATUS_UPDATE) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "market:partner-api".to_string(), // API Яндекс.Маркета / Поиска по товарам для партнеров
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_CAMPAIGNS_CAMPAIGNID_ORDERS_STATUS_UPDATE
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE CAMPAIGNS_CAMPAIGNID_ORDERS_STATUS_UPDATE in set but failed match against \"{}\"", path, paths::REGEX_CAMPAIGNS_CAMPAIGNID_ORDERS_STATUS_UPDATE.as_str())
                    );

                let param_campaign_id = match percent_encoding::percent_decode(path_params["campaignId"].as_bytes()).decode_utf8() {
                    Ok(param_campaign_id) => match param_campaign_id.parse::<i64>() {
                        Ok(param_campaign_id) => param_campaign_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter campaignId: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["campaignId"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                // Handle body parameters (note that non-required body parameters will ignore garbage
                // values, rather than causing a 400 response). Produce warning header and logs for
                // any unused fields.
                let result = body.into_raw().await;
                match result {
                     Ok(body) => {
                                let mut unused_elements : Vec<String> = vec![];
                                let param_update_order_statuses_request: Option<models::UpdateOrderStatusesRequest> = if !body.is_empty() {
                                    let deserializer = &mut serde_json::Deserializer::from_slice(&*body);
                                    match serde_ignored::deserialize(deserializer, |path| {
                                            warn!("Ignoring unknown field in body: {}", path);
                                            unused_elements.push(path.to_string());
                                    }) {
                                        Ok(param_update_order_statuses_request) => param_update_order_statuses_request,
                                        Err(e) => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from(format!("Couldn't parse body parameter UpdateOrderStatusesRequest - doesn't match schema: {}", e)))
                                                        .expect("Unable to create Bad Request response for invalid body parameter UpdateOrderStatusesRequest due to schema")),
                                    }
                                } else {
                                    None
                                };
                                let param_update_order_statuses_request = match param_update_order_statuses_request {
                                    Some(param_update_order_statuses_request) => param_update_order_statuses_request,
                                    None => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from("Missing required body parameter UpdateOrderStatusesRequest"))
                                                        .expect("Unable to create Bad Request response for missing body parameter UpdateOrderStatusesRequest")),
                                };


                                let result = api_impl.update_order_statuses(
                                            param_campaign_id,
                                            param_update_order_statuses_request,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        if !unused_elements.is_empty() {
                                            response.headers_mut().insert(
                                                HeaderName::from_static("warning"),
                                                HeaderValue::from_str(format!("Ignoring unknown fields in body: {:?}", unused_elements).as_str())
                                                    .expect("Unable to create Warning header value"));
                                        }
                                        match result {
                                            Ok(rsp) => match rsp {
                                                UpdateOrderStatusesResponse::Status200
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                UpdateOrderStatusesResponse::Status400
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                UpdateOrderStatusesResponse::Status401
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                UpdateOrderStatusesResponse::Status403
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                UpdateOrderStatusesResponse::Status404
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                UpdateOrderStatusesResponse::Status420
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(420).expect("Unable to turn 420 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                UpdateOrderStatusesResponse::Status500
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
                            },
                            Err(e) => Ok(Response::builder()
                                                .status(StatusCode::BAD_REQUEST)
                                                .body(Body::from(format!("Unable to read body: {}", e)))
                                                .expect("Unable to create Bad Request response due to unable to read body")),
                        }
            },

            // AcceptOrderCancellation - PUT /campaigns/{campaignId}/orders/{orderId}/cancellation/accept
            hyper::Method::PUT if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_CANCELLATION_ACCEPT) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "market:partner-api".to_string(), // API Яндекс.Маркета / Поиска по товарам для партнеров
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_CANCELLATION_ACCEPT
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_CANCELLATION_ACCEPT in set but failed match against \"{}\"", path, paths::REGEX_CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_CANCELLATION_ACCEPT.as_str())
                    );

                let param_campaign_id = match percent_encoding::percent_decode(path_params["campaignId"].as_bytes()).decode_utf8() {
                    Ok(param_campaign_id) => match param_campaign_id.parse::<i64>() {
                        Ok(param_campaign_id) => param_campaign_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter campaignId: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["campaignId"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                let param_order_id = match percent_encoding::percent_decode(path_params["orderId"].as_bytes()).decode_utf8() {
                    Ok(param_order_id) => match param_order_id.parse::<i64>() {
                        Ok(param_order_id) => param_order_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter orderId: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["orderId"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                // Handle body parameters (note that non-required body parameters will ignore garbage
                // values, rather than causing a 400 response). Produce warning header and logs for
                // any unused fields.
                let result = body.into_raw().await;
                match result {
                     Ok(body) => {
                                let mut unused_elements : Vec<String> = vec![];
                                let param_accept_order_cancellation_request: Option<models::AcceptOrderCancellationRequest> = if !body.is_empty() {
                                    let deserializer = &mut serde_json::Deserializer::from_slice(&*body);
                                    match serde_ignored::deserialize(deserializer, |path| {
                                            warn!("Ignoring unknown field in body: {}", path);
                                            unused_elements.push(path.to_string());
                                    }) {
                                        Ok(param_accept_order_cancellation_request) => param_accept_order_cancellation_request,
                                        Err(e) => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from(format!("Couldn't parse body parameter AcceptOrderCancellationRequest - doesn't match schema: {}", e)))
                                                        .expect("Unable to create Bad Request response for invalid body parameter AcceptOrderCancellationRequest due to schema")),
                                    }
                                } else {
                                    None
                                };
                                let param_accept_order_cancellation_request = match param_accept_order_cancellation_request {
                                    Some(param_accept_order_cancellation_request) => param_accept_order_cancellation_request,
                                    None => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from("Missing required body parameter AcceptOrderCancellationRequest"))
                                                        .expect("Unable to create Bad Request response for missing body parameter AcceptOrderCancellationRequest")),
                                };


                                let result = api_impl.accept_order_cancellation(
                                            param_campaign_id,
                                            param_order_id,
                                            param_accept_order_cancellation_request,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        if !unused_elements.is_empty() {
                                            response.headers_mut().insert(
                                                HeaderName::from_static("warning"),
                                                HeaderValue::from_str(format!("Ignoring unknown fields in body: {:?}", unused_elements).as_str())
                                                    .expect("Unable to create Warning header value"));
                                        }
                                        match result {
                                            Ok(rsp) => match rsp {
                                                AcceptOrderCancellationResponse::Status200
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                AcceptOrderCancellationResponse::Status400
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                AcceptOrderCancellationResponse::Status401
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                AcceptOrderCancellationResponse::Status403
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                AcceptOrderCancellationResponse::Status404
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                AcceptOrderCancellationResponse::Status420
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(420).expect("Unable to turn 420 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                AcceptOrderCancellationResponse::Status500
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
                            },
                            Err(e) => Ok(Response::builder()
                                                .status(StatusCode::BAD_REQUEST)
                                                .body(Body::from(format!("Unable to read body: {}", e)))
                                                .expect("Unable to create Bad Request response due to unable to read body")),
                        }
            },

            // GetOrder - GET /campaigns/{campaignId}/orders/{orderId}
            hyper::Method::GET if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "market:partner-api".to_string(), // API Яндекс.Маркета / Поиска по товарам для партнеров
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID in set but failed match against \"{}\"", path, paths::REGEX_CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID.as_str())
                    );

                let param_campaign_id = match percent_encoding::percent_decode(path_params["campaignId"].as_bytes()).decode_utf8() {
                    Ok(param_campaign_id) => match param_campaign_id.parse::<i64>() {
                        Ok(param_campaign_id) => param_campaign_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter campaignId: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["campaignId"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                let param_order_id = match percent_encoding::percent_decode(path_params["orderId"].as_bytes()).decode_utf8() {
                    Ok(param_order_id) => match param_order_id.parse::<i64>() {
                        Ok(param_order_id) => param_order_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter orderId: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["orderId"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                                let result = api_impl.get_order(
                                            param_campaign_id,
                                            param_order_id,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                GetOrderResponse::Status200
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetOrderResponse::Status400
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetOrderResponse::Status401
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetOrderResponse::Status403
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetOrderResponse::Status404
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetOrderResponse::Status420
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(420).expect("Unable to turn 420 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetOrderResponse::Status500
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
            },

            // ProvideOrderDigitalCodes - POST /campaigns/{campaignId}/orders/{orderId}/deliverDigitalGoods
            hyper::Method::POST if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_DELIVERDIGITALGOODS) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "market:partner-api".to_string(), // API Яндекс.Маркета / Поиска по товарам для партнеров
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_DELIVERDIGITALGOODS
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_DELIVERDIGITALGOODS in set but failed match against \"{}\"", path, paths::REGEX_CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_DELIVERDIGITALGOODS.as_str())
                    );

                let param_campaign_id = match percent_encoding::percent_decode(path_params["campaignId"].as_bytes()).decode_utf8() {
                    Ok(param_campaign_id) => match param_campaign_id.parse::<i64>() {
                        Ok(param_campaign_id) => param_campaign_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter campaignId: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["campaignId"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                let param_order_id = match percent_encoding::percent_decode(path_params["orderId"].as_bytes()).decode_utf8() {
                    Ok(param_order_id) => match param_order_id.parse::<i64>() {
                        Ok(param_order_id) => param_order_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter orderId: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["orderId"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                // Handle body parameters (note that non-required body parameters will ignore garbage
                // values, rather than causing a 400 response). Produce warning header and logs for
                // any unused fields.
                let result = body.into_raw().await;
                match result {
                     Ok(body) => {
                                let mut unused_elements : Vec<String> = vec![];
                                let param_provide_order_digital_codes_request: Option<models::ProvideOrderDigitalCodesRequest> = if !body.is_empty() {
                                    let deserializer = &mut serde_json::Deserializer::from_slice(&*body);
                                    match serde_ignored::deserialize(deserializer, |path| {
                                            warn!("Ignoring unknown field in body: {}", path);
                                            unused_elements.push(path.to_string());
                                    }) {
                                        Ok(param_provide_order_digital_codes_request) => param_provide_order_digital_codes_request,
                                        Err(e) => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from(format!("Couldn't parse body parameter ProvideOrderDigitalCodesRequest - doesn't match schema: {}", e)))
                                                        .expect("Unable to create Bad Request response for invalid body parameter ProvideOrderDigitalCodesRequest due to schema")),
                                    }
                                } else {
                                    None
                                };
                                let param_provide_order_digital_codes_request = match param_provide_order_digital_codes_request {
                                    Some(param_provide_order_digital_codes_request) => param_provide_order_digital_codes_request,
                                    None => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from("Missing required body parameter ProvideOrderDigitalCodesRequest"))
                                                        .expect("Unable to create Bad Request response for missing body parameter ProvideOrderDigitalCodesRequest")),
                                };


                                let result = api_impl.provide_order_digital_codes(
                                            param_campaign_id,
                                            param_order_id,
                                            param_provide_order_digital_codes_request,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        if !unused_elements.is_empty() {
                                            response.headers_mut().insert(
                                                HeaderName::from_static("warning"),
                                                HeaderValue::from_str(format!("Ignoring unknown fields in body: {:?}", unused_elements).as_str())
                                                    .expect("Unable to create Warning header value"));
                                        }
                                        match result {
                                            Ok(rsp) => match rsp {
                                                ProvideOrderDigitalCodesResponse::Status200
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                ProvideOrderDigitalCodesResponse::Status400
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                ProvideOrderDigitalCodesResponse::Status401
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                ProvideOrderDigitalCodesResponse::Status403
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                ProvideOrderDigitalCodesResponse::Status404
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                ProvideOrderDigitalCodesResponse::Status420
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(420).expect("Unable to turn 420 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                ProvideOrderDigitalCodesResponse::Status500
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
                            },
                            Err(e) => Ok(Response::builder()
                                                .status(StatusCode::BAD_REQUEST)
                                                .body(Body::from(format!("Unable to read body: {}", e)))
                                                .expect("Unable to create Bad Request response due to unable to read body")),
                        }
            },

            // ProvideOrderItemIdentifiers - PUT /campaigns/{campaignId}/orders/{orderId}/identifiers
            hyper::Method::PUT if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_IDENTIFIERS) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "market:partner-api".to_string(), // API Яндекс.Маркета / Поиска по товарам для партнеров
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_IDENTIFIERS
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_IDENTIFIERS in set but failed match against \"{}\"", path, paths::REGEX_CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_IDENTIFIERS.as_str())
                    );

                let param_campaign_id = match percent_encoding::percent_decode(path_params["campaignId"].as_bytes()).decode_utf8() {
                    Ok(param_campaign_id) => match param_campaign_id.parse::<i64>() {
                        Ok(param_campaign_id) => param_campaign_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter campaignId: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["campaignId"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                let param_order_id = match percent_encoding::percent_decode(path_params["orderId"].as_bytes()).decode_utf8() {
                    Ok(param_order_id) => match param_order_id.parse::<i64>() {
                        Ok(param_order_id) => param_order_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter orderId: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["orderId"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                // Handle body parameters (note that non-required body parameters will ignore garbage
                // values, rather than causing a 400 response). Produce warning header and logs for
                // any unused fields.
                let result = body.into_raw().await;
                match result {
                     Ok(body) => {
                                let mut unused_elements : Vec<String> = vec![];
                                let param_provide_order_item_identifiers_request: Option<models::ProvideOrderItemIdentifiersRequest> = if !body.is_empty() {
                                    let deserializer = &mut serde_json::Deserializer::from_slice(&*body);
                                    match serde_ignored::deserialize(deserializer, |path| {
                                            warn!("Ignoring unknown field in body: {}", path);
                                            unused_elements.push(path.to_string());
                                    }) {
                                        Ok(param_provide_order_item_identifiers_request) => param_provide_order_item_identifiers_request,
                                        Err(e) => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from(format!("Couldn't parse body parameter ProvideOrderItemIdentifiersRequest - doesn't match schema: {}", e)))
                                                        .expect("Unable to create Bad Request response for invalid body parameter ProvideOrderItemIdentifiersRequest due to schema")),
                                    }
                                } else {
                                    None
                                };
                                let param_provide_order_item_identifiers_request = match param_provide_order_item_identifiers_request {
                                    Some(param_provide_order_item_identifiers_request) => param_provide_order_item_identifiers_request,
                                    None => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from("Missing required body parameter ProvideOrderItemIdentifiersRequest"))
                                                        .expect("Unable to create Bad Request response for missing body parameter ProvideOrderItemIdentifiersRequest")),
                                };


                                let result = api_impl.provide_order_item_identifiers(
                                            param_campaign_id,
                                            param_order_id,
                                            param_provide_order_item_identifiers_request,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        if !unused_elements.is_empty() {
                                            response.headers_mut().insert(
                                                HeaderName::from_static("warning"),
                                                HeaderValue::from_str(format!("Ignoring unknown fields in body: {:?}", unused_elements).as_str())
                                                    .expect("Unable to create Warning header value"));
                                        }
                                        match result {
                                            Ok(rsp) => match rsp {
                                                ProvideOrderItemIdentifiersResponse::Status200
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                ProvideOrderItemIdentifiersResponse::Status400
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                ProvideOrderItemIdentifiersResponse::Status401
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                ProvideOrderItemIdentifiersResponse::Status403
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                ProvideOrderItemIdentifiersResponse::Status404
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                ProvideOrderItemIdentifiersResponse::Status420
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(420).expect("Unable to turn 420 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                ProvideOrderItemIdentifiersResponse::Status500
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
                            },
                            Err(e) => Ok(Response::builder()
                                                .status(StatusCode::BAD_REQUEST)
                                                .body(Body::from(format!("Unable to read body: {}", e)))
                                                .expect("Unable to create Bad Request response due to unable to read body")),
                        }
            },

            // SetOrderBoxLayout - PUT /campaigns/{campaignId}/orders/{orderId}/boxes
            hyper::Method::PUT if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_BOXES) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "market:partner-api".to_string(), // API Яндекс.Маркета / Поиска по товарам для партнеров
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_BOXES
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_BOXES in set but failed match against \"{}\"", path, paths::REGEX_CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_BOXES.as_str())
                    );

                let param_campaign_id = match percent_encoding::percent_decode(path_params["campaignId"].as_bytes()).decode_utf8() {
                    Ok(param_campaign_id) => match param_campaign_id.parse::<i64>() {
                        Ok(param_campaign_id) => param_campaign_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter campaignId: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["campaignId"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                let param_order_id = match percent_encoding::percent_decode(path_params["orderId"].as_bytes()).decode_utf8() {
                    Ok(param_order_id) => match param_order_id.parse::<i64>() {
                        Ok(param_order_id) => param_order_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter orderId: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["orderId"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                // Handle body parameters (note that non-required body parameters will ignore garbage
                // values, rather than causing a 400 response). Produce warning header and logs for
                // any unused fields.
                let result = body.into_raw().await;
                match result {
                     Ok(body) => {
                                let mut unused_elements : Vec<String> = vec![];
                                let param_set_order_box_layout_request: Option<models::SetOrderBoxLayoutRequest> = if !body.is_empty() {
                                    let deserializer = &mut serde_json::Deserializer::from_slice(&*body);
                                    match serde_ignored::deserialize(deserializer, |path| {
                                            warn!("Ignoring unknown field in body: {}", path);
                                            unused_elements.push(path.to_string());
                                    }) {
                                        Ok(param_set_order_box_layout_request) => param_set_order_box_layout_request,
                                        Err(e) => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from(format!("Couldn't parse body parameter SetOrderBoxLayoutRequest - doesn't match schema: {}", e)))
                                                        .expect("Unable to create Bad Request response for invalid body parameter SetOrderBoxLayoutRequest due to schema")),
                                    }
                                } else {
                                    None
                                };
                                let param_set_order_box_layout_request = match param_set_order_box_layout_request {
                                    Some(param_set_order_box_layout_request) => param_set_order_box_layout_request,
                                    None => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from("Missing required body parameter SetOrderBoxLayoutRequest"))
                                                        .expect("Unable to create Bad Request response for missing body parameter SetOrderBoxLayoutRequest")),
                                };


                                let result = api_impl.set_order_box_layout(
                                            param_campaign_id,
                                            param_order_id,
                                            param_set_order_box_layout_request,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        if !unused_elements.is_empty() {
                                            response.headers_mut().insert(
                                                HeaderName::from_static("warning"),
                                                HeaderValue::from_str(format!("Ignoring unknown fields in body: {:?}", unused_elements).as_str())
                                                    .expect("Unable to create Warning header value"));
                                        }
                                        match result {
                                            Ok(rsp) => match rsp {
                                                SetOrderBoxLayoutResponse::Status200
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                SetOrderBoxLayoutResponse::Status400
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                SetOrderBoxLayoutResponse::Status401
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                SetOrderBoxLayoutResponse::Status403
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                SetOrderBoxLayoutResponse::Status404
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                SetOrderBoxLayoutResponse::Status420
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(420).expect("Unable to turn 420 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                SetOrderBoxLayoutResponse::Status500
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
                            },
                            Err(e) => Ok(Response::builder()
                                                .status(StatusCode::BAD_REQUEST)
                                                .body(Body::from(format!("Unable to read body: {}", e)))
                                                .expect("Unable to create Bad Request response due to unable to read body")),
                        }
            },

            // UpdateOrderItems - PUT /campaigns/{campaignId}/orders/{orderId}/items
            hyper::Method::PUT if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_ITEMS) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "market:partner-api".to_string(), // API Яндекс.Маркета / Поиска по товарам для партнеров
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_ITEMS
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_ITEMS in set but failed match against \"{}\"", path, paths::REGEX_CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_ITEMS.as_str())
                    );

                let param_campaign_id = match percent_encoding::percent_decode(path_params["campaignId"].as_bytes()).decode_utf8() {
                    Ok(param_campaign_id) => match param_campaign_id.parse::<i64>() {
                        Ok(param_campaign_id) => param_campaign_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter campaignId: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["campaignId"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                let param_order_id = match percent_encoding::percent_decode(path_params["orderId"].as_bytes()).decode_utf8() {
                    Ok(param_order_id) => match param_order_id.parse::<i64>() {
                        Ok(param_order_id) => param_order_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter orderId: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["orderId"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                // Handle body parameters (note that non-required body parameters will ignore garbage
                // values, rather than causing a 400 response). Produce warning header and logs for
                // any unused fields.
                let result = body.into_raw().await;
                match result {
                     Ok(body) => {
                                let mut unused_elements : Vec<String> = vec![];
                                let param_update_order_item_request: Option<models::UpdateOrderItemRequest> = if !body.is_empty() {
                                    let deserializer = &mut serde_json::Deserializer::from_slice(&*body);
                                    match serde_ignored::deserialize(deserializer, |path| {
                                            warn!("Ignoring unknown field in body: {}", path);
                                            unused_elements.push(path.to_string());
                                    }) {
                                        Ok(param_update_order_item_request) => param_update_order_item_request,
                                        Err(e) => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from(format!("Couldn't parse body parameter UpdateOrderItemRequest - doesn't match schema: {}", e)))
                                                        .expect("Unable to create Bad Request response for invalid body parameter UpdateOrderItemRequest due to schema")),
                                    }
                                } else {
                                    None
                                };
                                let param_update_order_item_request = match param_update_order_item_request {
                                    Some(param_update_order_item_request) => param_update_order_item_request,
                                    None => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from("Missing required body parameter UpdateOrderItemRequest"))
                                                        .expect("Unable to create Bad Request response for missing body parameter UpdateOrderItemRequest")),
                                };


                                let result = api_impl.update_order_items(
                                            param_campaign_id,
                                            param_order_id,
                                            param_update_order_item_request,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        if !unused_elements.is_empty() {
                                            response.headers_mut().insert(
                                                HeaderName::from_static("warning"),
                                                HeaderValue::from_str(format!("Ignoring unknown fields in body: {:?}", unused_elements).as_str())
                                                    .expect("Unable to create Warning header value"));
                                        }
                                        match result {
                                            Ok(rsp) => match rsp {
                                                UpdateOrderItemsResponse::Status200
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");

                                                },
                                                UpdateOrderItemsResponse::Status400
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                UpdateOrderItemsResponse::Status401
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                UpdateOrderItemsResponse::Status403
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                UpdateOrderItemsResponse::Status404
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                UpdateOrderItemsResponse::Status420
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(420).expect("Unable to turn 420 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                UpdateOrderItemsResponse::Status500
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
                            },
                            Err(e) => Ok(Response::builder()
                                                .status(StatusCode::BAD_REQUEST)
                                                .body(Body::from(format!("Unable to read body: {}", e)))
                                                .expect("Unable to create Bad Request response due to unable to read body")),
                        }
            },

            // UpdateOrderStatus - PUT /campaigns/{campaignId}/orders/{orderId}/status
            hyper::Method::PUT if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_STATUS) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "market:partner-api".to_string(), // API Яндекс.Маркета / Поиска по товарам для партнеров
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_STATUS
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_STATUS in set but failed match against \"{}\"", path, paths::REGEX_CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_STATUS.as_str())
                    );

                let param_campaign_id = match percent_encoding::percent_decode(path_params["campaignId"].as_bytes()).decode_utf8() {
                    Ok(param_campaign_id) => match param_campaign_id.parse::<i64>() {
                        Ok(param_campaign_id) => param_campaign_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter campaignId: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["campaignId"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                let param_order_id = match percent_encoding::percent_decode(path_params["orderId"].as_bytes()).decode_utf8() {
                    Ok(param_order_id) => match param_order_id.parse::<i64>() {
                        Ok(param_order_id) => param_order_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter orderId: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["orderId"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                // Handle body parameters (note that non-required body parameters will ignore garbage
                // values, rather than causing a 400 response). Produce warning header and logs for
                // any unused fields.
                let result = body.into_raw().await;
                match result {
                     Ok(body) => {
                                let mut unused_elements : Vec<String> = vec![];
                                let param_update_order_status_request: Option<models::UpdateOrderStatusRequest> = if !body.is_empty() {
                                    let deserializer = &mut serde_json::Deserializer::from_slice(&*body);
                                    match serde_ignored::deserialize(deserializer, |path| {
                                            warn!("Ignoring unknown field in body: {}", path);
                                            unused_elements.push(path.to_string());
                                    }) {
                                        Ok(param_update_order_status_request) => param_update_order_status_request,
                                        Err(e) => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from(format!("Couldn't parse body parameter UpdateOrderStatusRequest - doesn't match schema: {}", e)))
                                                        .expect("Unable to create Bad Request response for invalid body parameter UpdateOrderStatusRequest due to schema")),
                                    }
                                } else {
                                    None
                                };
                                let param_update_order_status_request = match param_update_order_status_request {
                                    Some(param_update_order_status_request) => param_update_order_status_request,
                                    None => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from("Missing required body parameter UpdateOrderStatusRequest"))
                                                        .expect("Unable to create Bad Request response for missing body parameter UpdateOrderStatusRequest")),
                                };


                                let result = api_impl.update_order_status(
                                            param_campaign_id,
                                            param_order_id,
                                            param_update_order_status_request,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        if !unused_elements.is_empty() {
                                            response.headers_mut().insert(
                                                HeaderName::from_static("warning"),
                                                HeaderValue::from_str(format!("Ignoring unknown fields in body: {:?}", unused_elements).as_str())
                                                    .expect("Unable to create Warning header value"));
                                        }
                                        match result {
                                            Ok(rsp) => match rsp {
                                                UpdateOrderStatusResponse::Status200
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                UpdateOrderStatusResponse::Status400
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                UpdateOrderStatusResponse::Status401
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                UpdateOrderStatusResponse::Status403
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                UpdateOrderStatusResponse::Status404
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                UpdateOrderStatusResponse::Status420
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(420).expect("Unable to turn 420 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                UpdateOrderStatusResponse::Status500
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
                            },
                            Err(e) => Ok(Response::builder()
                                                .status(StatusCode::BAD_REQUEST)
                                                .body(Body::from(format!("Unable to read body: {}", e)))
                                                .expect("Unable to create Bad Request response due to unable to read body")),
                        }
            },

            // SetOrderShipmentBoxes - PUT /campaigns/{campaignId}/orders/{orderId}/delivery/shipments/{shipmentId}/boxes
            hyper::Method::PUT if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_DELIVERY_SHIPMENTS_SHIPMENTID_BOXES) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "market:partner-api".to_string(), // API Яндекс.Маркета / Поиска по товарам для партнеров
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_DELIVERY_SHIPMENTS_SHIPMENTID_BOXES
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_DELIVERY_SHIPMENTS_SHIPMENTID_BOXES in set but failed match against \"{}\"", path, paths::REGEX_CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_DELIVERY_SHIPMENTS_SHIPMENTID_BOXES.as_str())
                    );

                let param_campaign_id = match percent_encoding::percent_decode(path_params["campaignId"].as_bytes()).decode_utf8() {
                    Ok(param_campaign_id) => match param_campaign_id.parse::<i64>() {
                        Ok(param_campaign_id) => param_campaign_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter campaignId: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["campaignId"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                let param_order_id = match percent_encoding::percent_decode(path_params["orderId"].as_bytes()).decode_utf8() {
                    Ok(param_order_id) => match param_order_id.parse::<i64>() {
                        Ok(param_order_id) => param_order_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter orderId: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["orderId"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                let param_shipment_id = match percent_encoding::percent_decode(path_params["shipmentId"].as_bytes()).decode_utf8() {
                    Ok(param_shipment_id) => match param_shipment_id.parse::<i64>() {
                        Ok(param_shipment_id) => param_shipment_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter shipmentId: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["shipmentId"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                // Handle body parameters (note that non-required body parameters will ignore garbage
                // values, rather than causing a 400 response). Produce warning header and logs for
                // any unused fields.
                let result = body.into_raw().await;
                match result {
                     Ok(body) => {
                                let mut unused_elements : Vec<String> = vec![];
                                let param_set_order_shipment_boxes_request: Option<models::SetOrderShipmentBoxesRequest> = if !body.is_empty() {
                                    let deserializer = &mut serde_json::Deserializer::from_slice(&*body);
                                    match serde_ignored::deserialize(deserializer, |path| {
                                            warn!("Ignoring unknown field in body: {}", path);
                                            unused_elements.push(path.to_string());
                                    }) {
                                        Ok(param_set_order_shipment_boxes_request) => param_set_order_shipment_boxes_request,
                                        Err(e) => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from(format!("Couldn't parse body parameter SetOrderShipmentBoxesRequest - doesn't match schema: {}", e)))
                                                        .expect("Unable to create Bad Request response for invalid body parameter SetOrderShipmentBoxesRequest due to schema")),
                                    }
                                } else {
                                    None
                                };
                                let param_set_order_shipment_boxes_request = match param_set_order_shipment_boxes_request {
                                    Some(param_set_order_shipment_boxes_request) => param_set_order_shipment_boxes_request,
                                    None => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from("Missing required body parameter SetOrderShipmentBoxesRequest"))
                                                        .expect("Unable to create Bad Request response for missing body parameter SetOrderShipmentBoxesRequest")),
                                };


                                let result = api_impl.set_order_shipment_boxes(
                                            param_campaign_id,
                                            param_order_id,
                                            param_shipment_id,
                                            param_set_order_shipment_boxes_request,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        if !unused_elements.is_empty() {
                                            response.headers_mut().insert(
                                                HeaderName::from_static("warning"),
                                                HeaderValue::from_str(format!("Ignoring unknown fields in body: {:?}", unused_elements).as_str())
                                                    .expect("Unable to create Warning header value"));
                                        }
                                        match result {
                                            Ok(rsp) => match rsp {
                                                SetOrderShipmentBoxesResponse::Status200
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                SetOrderShipmentBoxesResponse::Status400
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                SetOrderShipmentBoxesResponse::Status401
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                SetOrderShipmentBoxesResponse::Status403
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                SetOrderShipmentBoxesResponse::Status404
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                SetOrderShipmentBoxesResponse::Status420
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(420).expect("Unable to turn 420 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                SetOrderShipmentBoxesResponse::Status500
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
                            },
                            Err(e) => Ok(Response::builder()
                                                .status(StatusCode::BAD_REQUEST)
                                                .body(Body::from(format!("Unable to read body: {}", e)))
                                                .expect("Unable to create Bad Request response due to unable to read body")),
                        }
            },

            // GetOrdersStats - POST /campaigns/{campaignId}/stats/orders
            hyper::Method::POST if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_STATS_ORDERS) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "market:partner-api".to_string(), // API Яндекс.Маркета / Поиска по товарам для партнеров
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_CAMPAIGNS_CAMPAIGNID_STATS_ORDERS
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE CAMPAIGNS_CAMPAIGNID_STATS_ORDERS in set but failed match against \"{}\"", path, paths::REGEX_CAMPAIGNS_CAMPAIGNID_STATS_ORDERS.as_str())
                    );

                let param_campaign_id = match percent_encoding::percent_decode(path_params["campaignId"].as_bytes()).decode_utf8() {
                    Ok(param_campaign_id) => match param_campaign_id.parse::<i64>() {
                        Ok(param_campaign_id) => param_campaign_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter campaignId: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["campaignId"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                // Query parameters (note that non-required or collection query parameters will ignore garbage values, rather than causing a 400 response)
                let query_params = form_urlencoded::parse(uri.query().unwrap_or_default().as_bytes()).collect::<Vec<_>>();
                let param_page_token = query_params.iter().filter(|e| e.0 == "page_token").map(|e| e.1.clone())
                    .next();
                let param_page_token = match param_page_token {
                    Some(param_page_token) => {
                        let param_page_token =
                            <String as std::str::FromStr>::from_str
                                (&param_page_token);
                        match param_page_token {
                            Ok(param_page_token) => Some(param_page_token),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter page_token - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter page_token")),
                        }
                    },
                    None => None,
                };
                let param_limit = query_params.iter().filter(|e| e.0 == "limit").map(|e| e.1.clone())
                    .next();
                let param_limit = match param_limit {
                    Some(param_limit) => {
                        let param_limit =
                            <i32 as std::str::FromStr>::from_str
                                (&param_limit);
                        match param_limit {
                            Ok(param_limit) => Some(param_limit),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter limit - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter limit")),
                        }
                    },
                    None => None,
                };

                // Handle body parameters (note that non-required body parameters will ignore garbage
                // values, rather than causing a 400 response). Produce warning header and logs for
                // any unused fields.
                let result = body.into_raw().await;
                match result {
                     Ok(body) => {
                                let mut unused_elements : Vec<String> = vec![];
                                let param_get_orders_stats_request: Option<models::GetOrdersStatsRequest> = if !body.is_empty() {
                                    let deserializer = &mut serde_json::Deserializer::from_slice(&*body);
                                    match serde_ignored::deserialize(deserializer, |path| {
                                            warn!("Ignoring unknown field in body: {}", path);
                                            unused_elements.push(path.to_string());
                                    }) {
                                        Ok(param_get_orders_stats_request) => param_get_orders_stats_request,
                                        Err(_) => None,
                                    }
                                } else {
                                    None
                                };


                                let result = api_impl.get_orders_stats(
                                            param_campaign_id,
                                            param_page_token,
                                            param_limit,
                                            param_get_orders_stats_request,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        if !unused_elements.is_empty() {
                                            response.headers_mut().insert(
                                                HeaderName::from_static("warning"),
                                                HeaderValue::from_str(format!("Ignoring unknown fields in body: {:?}", unused_elements).as_str())
                                                    .expect("Unable to create Warning header value"));
                                        }
                                        match result {
                                            Ok(rsp) => match rsp {
                                                GetOrdersStatsResponse::Status200
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetOrdersStatsResponse::Status400
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetOrdersStatsResponse::Status401
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetOrdersStatsResponse::Status403
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetOrdersStatsResponse::Status404
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetOrdersStatsResponse::Status420
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(420).expect("Unable to turn 420 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetOrdersStatsResponse::Status500
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
                            },
                            Err(e) => Ok(Response::builder()
                                                .status(StatusCode::BAD_REQUEST)
                                                .body(Body::from(format!("Unable to read body: {}", e)))
                                                .expect("Unable to create Bad Request response due to unable to read body")),
                        }
            },

            // DeleteOutletLicenses - DELETE /campaigns/{campaignId}/outlets/licenses
            hyper::Method::DELETE if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_OUTLETS_LICENSES) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "market:partner-api".to_string(), // API Яндекс.Маркета / Поиска по товарам для партнеров
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_CAMPAIGNS_CAMPAIGNID_OUTLETS_LICENSES
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE CAMPAIGNS_CAMPAIGNID_OUTLETS_LICENSES in set but failed match against \"{}\"", path, paths::REGEX_CAMPAIGNS_CAMPAIGNID_OUTLETS_LICENSES.as_str())
                    );

                let param_campaign_id = match percent_encoding::percent_decode(path_params["campaignId"].as_bytes()).decode_utf8() {
                    Ok(param_campaign_id) => match param_campaign_id.parse::<i64>() {
                        Ok(param_campaign_id) => param_campaign_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter campaignId: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["campaignId"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                // Query parameters (note that non-required or collection query parameters will ignore garbage values, rather than causing a 400 response)
                let query_params = form_urlencoded::parse(uri.query().unwrap_or_default().as_bytes()).collect::<Vec<_>>();
                let param_ids = query_params.iter().filter(|e| e.0 == "ids").map(|e| e.1.clone())
                    .filter_map(|param_ids| param_ids.parse().ok())
                    .collect::<Vec<_>>();
                let param_ids = if !param_ids.is_empty() {
                    Some(param_ids)
                } else {
                    None
                };

                                let result = api_impl.delete_outlet_licenses(
                                            param_campaign_id,
                                            param_ids.as_ref(),
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                DeleteOutletLicensesResponse::Status200
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                DeleteOutletLicensesResponse::Status400
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                DeleteOutletLicensesResponse::Status401
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                DeleteOutletLicensesResponse::Status403
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                DeleteOutletLicensesResponse::Status404
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                DeleteOutletLicensesResponse::Status420
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(420).expect("Unable to turn 420 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                DeleteOutletLicensesResponse::Status500
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
            },

            // GetOutletLicenses - GET /campaigns/{campaignId}/outlets/licenses
            hyper::Method::GET if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_OUTLETS_LICENSES) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "market:partner-api".to_string(), // API Яндекс.Маркета / Поиска по товарам для партнеров
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_CAMPAIGNS_CAMPAIGNID_OUTLETS_LICENSES
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE CAMPAIGNS_CAMPAIGNID_OUTLETS_LICENSES in set but failed match against \"{}\"", path, paths::REGEX_CAMPAIGNS_CAMPAIGNID_OUTLETS_LICENSES.as_str())
                    );

                let param_campaign_id = match percent_encoding::percent_decode(path_params["campaignId"].as_bytes()).decode_utf8() {
                    Ok(param_campaign_id) => match param_campaign_id.parse::<i64>() {
                        Ok(param_campaign_id) => param_campaign_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter campaignId: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["campaignId"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                // Query parameters (note that non-required or collection query parameters will ignore garbage values, rather than causing a 400 response)
                let query_params = form_urlencoded::parse(uri.query().unwrap_or_default().as_bytes()).collect::<Vec<_>>();
                let param_outlet_ids = query_params.iter().filter(|e| e.0 == "outletIds").map(|e| e.1.clone())
                    .filter_map(|param_outlet_ids| param_outlet_ids.parse().ok())
                    .collect::<Vec<_>>();
                let param_outlet_ids = if !param_outlet_ids.is_empty() {
                    Some(param_outlet_ids)
                } else {
                    None
                };
                let param_ids = query_params.iter().filter(|e| e.0 == "ids").map(|e| e.1.clone())
                    .filter_map(|param_ids| param_ids.parse().ok())
                    .collect::<Vec<_>>();
                let param_ids = if !param_ids.is_empty() {
                    Some(param_ids)
                } else {
                    None
                };

                                let result = api_impl.get_outlet_licenses(
                                            param_campaign_id,
                                            param_outlet_ids.as_ref(),
                                            param_ids.as_ref(),
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                GetOutletLicensesResponse::Status200
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetOutletLicensesResponse::Status400
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetOutletLicensesResponse::Status401
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetOutletLicensesResponse::Status403
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetOutletLicensesResponse::Status404
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetOutletLicensesResponse::Status420
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(420).expect("Unable to turn 420 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetOutletLicensesResponse::Status500
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
            },

            // UpdateOutletLicenses - POST /campaigns/{campaignId}/outlets/licenses
            hyper::Method::POST if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_OUTLETS_LICENSES) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "market:partner-api".to_string(), // API Яндекс.Маркета / Поиска по товарам для партнеров
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_CAMPAIGNS_CAMPAIGNID_OUTLETS_LICENSES
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE CAMPAIGNS_CAMPAIGNID_OUTLETS_LICENSES in set but failed match against \"{}\"", path, paths::REGEX_CAMPAIGNS_CAMPAIGNID_OUTLETS_LICENSES.as_str())
                    );

                let param_campaign_id = match percent_encoding::percent_decode(path_params["campaignId"].as_bytes()).decode_utf8() {
                    Ok(param_campaign_id) => match param_campaign_id.parse::<i64>() {
                        Ok(param_campaign_id) => param_campaign_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter campaignId: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["campaignId"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                // Handle body parameters (note that non-required body parameters will ignore garbage
                // values, rather than causing a 400 response). Produce warning header and logs for
                // any unused fields.
                let result = body.into_raw().await;
                match result {
                     Ok(body) => {
                                let mut unused_elements : Vec<String> = vec![];
                                let param_update_outlet_license_request: Option<models::UpdateOutletLicenseRequest> = if !body.is_empty() {
                                    let deserializer = &mut serde_json::Deserializer::from_slice(&*body);
                                    match serde_ignored::deserialize(deserializer, |path| {
                                            warn!("Ignoring unknown field in body: {}", path);
                                            unused_elements.push(path.to_string());
                                    }) {
                                        Ok(param_update_outlet_license_request) => param_update_outlet_license_request,
                                        Err(e) => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from(format!("Couldn't parse body parameter UpdateOutletLicenseRequest - doesn't match schema: {}", e)))
                                                        .expect("Unable to create Bad Request response for invalid body parameter UpdateOutletLicenseRequest due to schema")),
                                    }
                                } else {
                                    None
                                };
                                let param_update_outlet_license_request = match param_update_outlet_license_request {
                                    Some(param_update_outlet_license_request) => param_update_outlet_license_request,
                                    None => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from("Missing required body parameter UpdateOutletLicenseRequest"))
                                                        .expect("Unable to create Bad Request response for missing body parameter UpdateOutletLicenseRequest")),
                                };


                                let result = api_impl.update_outlet_licenses(
                                            param_campaign_id,
                                            param_update_outlet_license_request,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        if !unused_elements.is_empty() {
                                            response.headers_mut().insert(
                                                HeaderName::from_static("warning"),
                                                HeaderValue::from_str(format!("Ignoring unknown fields in body: {:?}", unused_elements).as_str())
                                                    .expect("Unable to create Warning header value"));
                                        }
                                        match result {
                                            Ok(rsp) => match rsp {
                                                UpdateOutletLicensesResponse::Status200
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                UpdateOutletLicensesResponse::Status400
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                UpdateOutletLicensesResponse::Status401
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                UpdateOutletLicensesResponse::Status403
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                UpdateOutletLicensesResponse::Status404
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                UpdateOutletLicensesResponse::Status420
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(420).expect("Unable to turn 420 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                UpdateOutletLicensesResponse::Status500
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
                            },
                            Err(e) => Ok(Response::builder()
                                                .status(StatusCode::BAD_REQUEST)
                                                .body(Body::from(format!("Unable to read body: {}", e)))
                                                .expect("Unable to create Bad Request response due to unable to read body")),
                        }
            },

            // CreateOutlet - POST /campaigns/{campaignId}/outlets
            hyper::Method::POST if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_OUTLETS) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "market:partner-api".to_string(), // API Яндекс.Маркета / Поиска по товарам для партнеров
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_CAMPAIGNS_CAMPAIGNID_OUTLETS
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE CAMPAIGNS_CAMPAIGNID_OUTLETS in set but failed match against \"{}\"", path, paths::REGEX_CAMPAIGNS_CAMPAIGNID_OUTLETS.as_str())
                    );

                let param_campaign_id = match percent_encoding::percent_decode(path_params["campaignId"].as_bytes()).decode_utf8() {
                    Ok(param_campaign_id) => match param_campaign_id.parse::<i64>() {
                        Ok(param_campaign_id) => param_campaign_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter campaignId: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["campaignId"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                // Handle body parameters (note that non-required body parameters will ignore garbage
                // values, rather than causing a 400 response). Produce warning header and logs for
                // any unused fields.
                let result = body.into_raw().await;
                match result {
                     Ok(body) => {
                                let mut unused_elements : Vec<String> = vec![];
                                let param_change_outlet_request: Option<models::ChangeOutletRequest> = if !body.is_empty() {
                                    let deserializer = &mut serde_json::Deserializer::from_slice(&*body);
                                    match serde_ignored::deserialize(deserializer, |path| {
                                            warn!("Ignoring unknown field in body: {}", path);
                                            unused_elements.push(path.to_string());
                                    }) {
                                        Ok(param_change_outlet_request) => param_change_outlet_request,
                                        Err(e) => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from(format!("Couldn't parse body parameter ChangeOutletRequest - doesn't match schema: {}", e)))
                                                        .expect("Unable to create Bad Request response for invalid body parameter ChangeOutletRequest due to schema")),
                                    }
                                } else {
                                    None
                                };
                                let param_change_outlet_request = match param_change_outlet_request {
                                    Some(param_change_outlet_request) => param_change_outlet_request,
                                    None => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from("Missing required body parameter ChangeOutletRequest"))
                                                        .expect("Unable to create Bad Request response for missing body parameter ChangeOutletRequest")),
                                };


                                let result = api_impl.create_outlet(
                                            param_campaign_id,
                                            param_change_outlet_request,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        if !unused_elements.is_empty() {
                                            response.headers_mut().insert(
                                                HeaderName::from_static("warning"),
                                                HeaderValue::from_str(format!("Ignoring unknown fields in body: {:?}", unused_elements).as_str())
                                                    .expect("Unable to create Warning header value"));
                                        }
                                        match result {
                                            Ok(rsp) => match rsp {
                                                CreateOutletResponse::Status200
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                CreateOutletResponse::Status400
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                CreateOutletResponse::Status401
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                CreateOutletResponse::Status403
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                CreateOutletResponse::Status404
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                CreateOutletResponse::Status420
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(420).expect("Unable to turn 420 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                CreateOutletResponse::Status500
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
                            },
                            Err(e) => Ok(Response::builder()
                                                .status(StatusCode::BAD_REQUEST)
                                                .body(Body::from(format!("Unable to read body: {}", e)))
                                                .expect("Unable to create Bad Request response due to unable to read body")),
                        }
            },

            // GetOutlets - GET /campaigns/{campaignId}/outlets
            hyper::Method::GET if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_OUTLETS) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "market:partner-api".to_string(), // API Яндекс.Маркета / Поиска по товарам для партнеров
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_CAMPAIGNS_CAMPAIGNID_OUTLETS
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE CAMPAIGNS_CAMPAIGNID_OUTLETS in set but failed match against \"{}\"", path, paths::REGEX_CAMPAIGNS_CAMPAIGNID_OUTLETS.as_str())
                    );

                let param_campaign_id = match percent_encoding::percent_decode(path_params["campaignId"].as_bytes()).decode_utf8() {
                    Ok(param_campaign_id) => match param_campaign_id.parse::<i64>() {
                        Ok(param_campaign_id) => param_campaign_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter campaignId: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["campaignId"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                // Query parameters (note that non-required or collection query parameters will ignore garbage values, rather than causing a 400 response)
                let query_params = form_urlencoded::parse(uri.query().unwrap_or_default().as_bytes()).collect::<Vec<_>>();
                let param_page_token = query_params.iter().filter(|e| e.0 == "page_token").map(|e| e.1.clone())
                    .next();
                let param_page_token = match param_page_token {
                    Some(param_page_token) => {
                        let param_page_token =
                            <String as std::str::FromStr>::from_str
                                (&param_page_token);
                        match param_page_token {
                            Ok(param_page_token) => Some(param_page_token),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter page_token - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter page_token")),
                        }
                    },
                    None => None,
                };
                let param_region_id = query_params.iter().filter(|e| e.0 == "region_id").map(|e| e.1.clone())
                    .next();
                let param_region_id = match param_region_id {
                    Some(param_region_id) => {
                        let param_region_id =
                            <i64 as std::str::FromStr>::from_str
                                (&param_region_id);
                        match param_region_id {
                            Ok(param_region_id) => Some(param_region_id),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter region_id - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter region_id")),
                        }
                    },
                    None => None,
                };
                let param_shop_outlet_code = query_params.iter().filter(|e| e.0 == "shop_outlet_code").map(|e| e.1.clone())
                    .next();
                let param_shop_outlet_code = match param_shop_outlet_code {
                    Some(param_shop_outlet_code) => {
                        let param_shop_outlet_code =
                            <String as std::str::FromStr>::from_str
                                (&param_shop_outlet_code);
                        match param_shop_outlet_code {
                            Ok(param_shop_outlet_code) => Some(param_shop_outlet_code),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter shop_outlet_code - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter shop_outlet_code")),
                        }
                    },
                    None => None,
                };
                let param_region_id2 = query_params.iter().filter(|e| e.0 == "regionId").map(|e| e.1.clone())
                    .next();
                let param_region_id2 = match param_region_id2 {
                    Some(param_region_id2) => {
                        let param_region_id2 =
                            <i64 as std::str::FromStr>::from_str
                                (&param_region_id2);
                        match param_region_id2 {
                            Ok(param_region_id2) => Some(param_region_id2),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter regionId - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter regionId")),
                        }
                    },
                    None => None,
                };

                                let result = api_impl.get_outlets(
                                            param_campaign_id,
                                            param_page_token,
                                            param_region_id,
                                            param_shop_outlet_code,
                                            param_region_id2,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                GetOutletsResponse::Status200
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetOutletsResponse::Status400
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetOutletsResponse::Status401
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetOutletsResponse::Status403
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetOutletsResponse::Status404
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetOutletsResponse::Status420
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(420).expect("Unable to turn 420 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetOutletsResponse::Status500
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
            },

            // DeleteOutlet - DELETE /campaigns/{campaignId}/outlets/{outletId}
            hyper::Method::DELETE if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_OUTLETS_OUTLETID) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "market:partner-api".to_string(), // API Яндекс.Маркета / Поиска по товарам для партнеров
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_CAMPAIGNS_CAMPAIGNID_OUTLETS_OUTLETID
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE CAMPAIGNS_CAMPAIGNID_OUTLETS_OUTLETID in set but failed match against \"{}\"", path, paths::REGEX_CAMPAIGNS_CAMPAIGNID_OUTLETS_OUTLETID.as_str())
                    );

                let param_campaign_id = match percent_encoding::percent_decode(path_params["campaignId"].as_bytes()).decode_utf8() {
                    Ok(param_campaign_id) => match param_campaign_id.parse::<i64>() {
                        Ok(param_campaign_id) => param_campaign_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter campaignId: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["campaignId"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                let param_outlet_id = match percent_encoding::percent_decode(path_params["outletId"].as_bytes()).decode_utf8() {
                    Ok(param_outlet_id) => match param_outlet_id.parse::<i64>() {
                        Ok(param_outlet_id) => param_outlet_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter outletId: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["outletId"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                                let result = api_impl.delete_outlet(
                                            param_campaign_id,
                                            param_outlet_id,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                DeleteOutletResponse::Status200
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                DeleteOutletResponse::Status400
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                DeleteOutletResponse::Status401
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                DeleteOutletResponse::Status403
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                DeleteOutletResponse::Status404
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                DeleteOutletResponse::Status420
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(420).expect("Unable to turn 420 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                DeleteOutletResponse::Status500
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
            },

            // GetOutlet - GET /campaigns/{campaignId}/outlets/{outletId}
            hyper::Method::GET if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_OUTLETS_OUTLETID) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "market:partner-api".to_string(), // API Яндекс.Маркета / Поиска по товарам для партнеров
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_CAMPAIGNS_CAMPAIGNID_OUTLETS_OUTLETID
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE CAMPAIGNS_CAMPAIGNID_OUTLETS_OUTLETID in set but failed match against \"{}\"", path, paths::REGEX_CAMPAIGNS_CAMPAIGNID_OUTLETS_OUTLETID.as_str())
                    );

                let param_campaign_id = match percent_encoding::percent_decode(path_params["campaignId"].as_bytes()).decode_utf8() {
                    Ok(param_campaign_id) => match param_campaign_id.parse::<i64>() {
                        Ok(param_campaign_id) => param_campaign_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter campaignId: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["campaignId"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                let param_outlet_id = match percent_encoding::percent_decode(path_params["outletId"].as_bytes()).decode_utf8() {
                    Ok(param_outlet_id) => match param_outlet_id.parse::<i64>() {
                        Ok(param_outlet_id) => param_outlet_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter outletId: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["outletId"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                                let result = api_impl.get_outlet(
                                            param_campaign_id,
                                            param_outlet_id,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                GetOutletResponse::Status200
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetOutletResponse::Status400
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetOutletResponse::Status401
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetOutletResponse::Status403
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetOutletResponse::Status404
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetOutletResponse::Status420
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(420).expect("Unable to turn 420 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetOutletResponse::Status500
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
            },

            // UpdateOutlet - PUT /campaigns/{campaignId}/outlets/{outletId}
            hyper::Method::PUT if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_OUTLETS_OUTLETID) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "market:partner-api".to_string(), // API Яндекс.Маркета / Поиска по товарам для партнеров
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_CAMPAIGNS_CAMPAIGNID_OUTLETS_OUTLETID
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE CAMPAIGNS_CAMPAIGNID_OUTLETS_OUTLETID in set but failed match against \"{}\"", path, paths::REGEX_CAMPAIGNS_CAMPAIGNID_OUTLETS_OUTLETID.as_str())
                    );

                let param_campaign_id = match percent_encoding::percent_decode(path_params["campaignId"].as_bytes()).decode_utf8() {
                    Ok(param_campaign_id) => match param_campaign_id.parse::<i64>() {
                        Ok(param_campaign_id) => param_campaign_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter campaignId: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["campaignId"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                let param_outlet_id = match percent_encoding::percent_decode(path_params["outletId"].as_bytes()).decode_utf8() {
                    Ok(param_outlet_id) => match param_outlet_id.parse::<i64>() {
                        Ok(param_outlet_id) => param_outlet_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter outletId: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["outletId"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                // Handle body parameters (note that non-required body parameters will ignore garbage
                // values, rather than causing a 400 response). Produce warning header and logs for
                // any unused fields.
                let result = body.into_raw().await;
                match result {
                     Ok(body) => {
                                let mut unused_elements : Vec<String> = vec![];
                                let param_change_outlet_request: Option<models::ChangeOutletRequest> = if !body.is_empty() {
                                    let deserializer = &mut serde_json::Deserializer::from_slice(&*body);
                                    match serde_ignored::deserialize(deserializer, |path| {
                                            warn!("Ignoring unknown field in body: {}", path);
                                            unused_elements.push(path.to_string());
                                    }) {
                                        Ok(param_change_outlet_request) => param_change_outlet_request,
                                        Err(e) => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from(format!("Couldn't parse body parameter ChangeOutletRequest - doesn't match schema: {}", e)))
                                                        .expect("Unable to create Bad Request response for invalid body parameter ChangeOutletRequest due to schema")),
                                    }
                                } else {
                                    None
                                };
                                let param_change_outlet_request = match param_change_outlet_request {
                                    Some(param_change_outlet_request) => param_change_outlet_request,
                                    None => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from("Missing required body parameter ChangeOutletRequest"))
                                                        .expect("Unable to create Bad Request response for missing body parameter ChangeOutletRequest")),
                                };


                                let result = api_impl.update_outlet(
                                            param_campaign_id,
                                            param_outlet_id,
                                            param_change_outlet_request,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        if !unused_elements.is_empty() {
                                            response.headers_mut().insert(
                                                HeaderName::from_static("warning"),
                                                HeaderValue::from_str(format!("Ignoring unknown fields in body: {:?}", unused_elements).as_str())
                                                    .expect("Unable to create Warning header value"));
                                        }
                                        match result {
                                            Ok(rsp) => match rsp {
                                                UpdateOutletResponse::Status200
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                UpdateOutletResponse::Status400
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                UpdateOutletResponse::Status401
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                UpdateOutletResponse::Status403
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                UpdateOutletResponse::Status404
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                UpdateOutletResponse::Status420
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(420).expect("Unable to turn 420 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                UpdateOutletResponse::Status500
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
                            },
                            Err(e) => Ok(Response::builder()
                                                .status(StatusCode::BAD_REQUEST)
                                                .body(Body::from(format!("Unable to read body: {}", e)))
                                                .expect("Unable to create Bad Request response due to unable to read body")),
                        }
            },

            // ConfirmBusinessPrices - POST /businesses/{businessId}/price-quarantine/confirm
            hyper::Method::POST if path.matched(paths::ID_BUSINESSES_BUSINESSID_PRICE_QUARANTINE_CONFIRM) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "market:partner-api".to_string(), // API Яндекс.Маркета / Поиска по товарам для партнеров
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_BUSINESSES_BUSINESSID_PRICE_QUARANTINE_CONFIRM
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE BUSINESSES_BUSINESSID_PRICE_QUARANTINE_CONFIRM in set but failed match against \"{}\"", path, paths::REGEX_BUSINESSES_BUSINESSID_PRICE_QUARANTINE_CONFIRM.as_str())
                    );

                let param_business_id = match percent_encoding::percent_decode(path_params["businessId"].as_bytes()).decode_utf8() {
                    Ok(param_business_id) => match param_business_id.parse::<i64>() {
                        Ok(param_business_id) => param_business_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter businessId: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["businessId"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                // Handle body parameters (note that non-required body parameters will ignore garbage
                // values, rather than causing a 400 response). Produce warning header and logs for
                // any unused fields.
                let result = body.into_raw().await;
                match result {
                     Ok(body) => {
                                let mut unused_elements : Vec<String> = vec![];
                                let param_confirm_prices_request: Option<models::ConfirmPricesRequest> = if !body.is_empty() {
                                    let deserializer = &mut serde_json::Deserializer::from_slice(&*body);
                                    match serde_ignored::deserialize(deserializer, |path| {
                                            warn!("Ignoring unknown field in body: {}", path);
                                            unused_elements.push(path.to_string());
                                    }) {
                                        Ok(param_confirm_prices_request) => param_confirm_prices_request,
                                        Err(e) => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from(format!("Couldn't parse body parameter ConfirmPricesRequest - doesn't match schema: {}", e)))
                                                        .expect("Unable to create Bad Request response for invalid body parameter ConfirmPricesRequest due to schema")),
                                    }
                                } else {
                                    None
                                };
                                let param_confirm_prices_request = match param_confirm_prices_request {
                                    Some(param_confirm_prices_request) => param_confirm_prices_request,
                                    None => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from("Missing required body parameter ConfirmPricesRequest"))
                                                        .expect("Unable to create Bad Request response for missing body parameter ConfirmPricesRequest")),
                                };


                                let result = api_impl.confirm_business_prices(
                                            param_business_id,
                                            param_confirm_prices_request,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        if !unused_elements.is_empty() {
                                            response.headers_mut().insert(
                                                HeaderName::from_static("warning"),
                                                HeaderValue::from_str(format!("Ignoring unknown fields in body: {:?}", unused_elements).as_str())
                                                    .expect("Unable to create Warning header value"));
                                        }
                                        match result {
                                            Ok(rsp) => match rsp {
                                                ConfirmBusinessPricesResponse::Status200
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                ConfirmBusinessPricesResponse::Status400
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                ConfirmBusinessPricesResponse::Status401
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                ConfirmBusinessPricesResponse::Status403
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                ConfirmBusinessPricesResponse::Status404
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                ConfirmBusinessPricesResponse::Status420
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(420).expect("Unable to turn 420 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                ConfirmBusinessPricesResponse::Status423
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(423).expect("Unable to turn 423 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                ConfirmBusinessPricesResponse::Status500
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
                            },
                            Err(e) => Ok(Response::builder()
                                                .status(StatusCode::BAD_REQUEST)
                                                .body(Body::from(format!("Unable to read body: {}", e)))
                                                .expect("Unable to create Bad Request response due to unable to read body")),
                        }
            },

            // ConfirmCampaignPrices - POST /campaigns/{campaignId}/price-quarantine/confirm
            hyper::Method::POST if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_PRICE_QUARANTINE_CONFIRM) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "market:partner-api".to_string(), // API Яндекс.Маркета / Поиска по товарам для партнеров
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_CAMPAIGNS_CAMPAIGNID_PRICE_QUARANTINE_CONFIRM
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE CAMPAIGNS_CAMPAIGNID_PRICE_QUARANTINE_CONFIRM in set but failed match against \"{}\"", path, paths::REGEX_CAMPAIGNS_CAMPAIGNID_PRICE_QUARANTINE_CONFIRM.as_str())
                    );

                let param_campaign_id = match percent_encoding::percent_decode(path_params["campaignId"].as_bytes()).decode_utf8() {
                    Ok(param_campaign_id) => match param_campaign_id.parse::<i64>() {
                        Ok(param_campaign_id) => param_campaign_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter campaignId: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["campaignId"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                // Handle body parameters (note that non-required body parameters will ignore garbage
                // values, rather than causing a 400 response). Produce warning header and logs for
                // any unused fields.
                let result = body.into_raw().await;
                match result {
                     Ok(body) => {
                                let mut unused_elements : Vec<String> = vec![];
                                let param_confirm_prices_request: Option<models::ConfirmPricesRequest> = if !body.is_empty() {
                                    let deserializer = &mut serde_json::Deserializer::from_slice(&*body);
                                    match serde_ignored::deserialize(deserializer, |path| {
                                            warn!("Ignoring unknown field in body: {}", path);
                                            unused_elements.push(path.to_string());
                                    }) {
                                        Ok(param_confirm_prices_request) => param_confirm_prices_request,
                                        Err(e) => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from(format!("Couldn't parse body parameter ConfirmPricesRequest - doesn't match schema: {}", e)))
                                                        .expect("Unable to create Bad Request response for invalid body parameter ConfirmPricesRequest due to schema")),
                                    }
                                } else {
                                    None
                                };
                                let param_confirm_prices_request = match param_confirm_prices_request {
                                    Some(param_confirm_prices_request) => param_confirm_prices_request,
                                    None => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from("Missing required body parameter ConfirmPricesRequest"))
                                                        .expect("Unable to create Bad Request response for missing body parameter ConfirmPricesRequest")),
                                };


                                let result = api_impl.confirm_campaign_prices(
                                            param_campaign_id,
                                            param_confirm_prices_request,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        if !unused_elements.is_empty() {
                                            response.headers_mut().insert(
                                                HeaderName::from_static("warning"),
                                                HeaderValue::from_str(format!("Ignoring unknown fields in body: {:?}", unused_elements).as_str())
                                                    .expect("Unable to create Warning header value"));
                                        }
                                        match result {
                                            Ok(rsp) => match rsp {
                                                ConfirmCampaignPricesResponse::Status200
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                ConfirmCampaignPricesResponse::Status400
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                ConfirmCampaignPricesResponse::Status401
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                ConfirmCampaignPricesResponse::Status403
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                ConfirmCampaignPricesResponse::Status404
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                ConfirmCampaignPricesResponse::Status420
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(420).expect("Unable to turn 420 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                ConfirmCampaignPricesResponse::Status423
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(423).expect("Unable to turn 423 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                ConfirmCampaignPricesResponse::Status500
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
                            },
                            Err(e) => Ok(Response::builder()
                                                .status(StatusCode::BAD_REQUEST)
                                                .body(Body::from(format!("Unable to read body: {}", e)))
                                                .expect("Unable to create Bad Request response due to unable to read body")),
                        }
            },

            // GetBusinessQuarantineOffers - POST /businesses/{businessId}/price-quarantine
            hyper::Method::POST if path.matched(paths::ID_BUSINESSES_BUSINESSID_PRICE_QUARANTINE) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "market:partner-api".to_string(), // API Яндекс.Маркета / Поиска по товарам для партнеров
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_BUSINESSES_BUSINESSID_PRICE_QUARANTINE
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE BUSINESSES_BUSINESSID_PRICE_QUARANTINE in set but failed match against \"{}\"", path, paths::REGEX_BUSINESSES_BUSINESSID_PRICE_QUARANTINE.as_str())
                    );

                let param_business_id = match percent_encoding::percent_decode(path_params["businessId"].as_bytes()).decode_utf8() {
                    Ok(param_business_id) => match param_business_id.parse::<i64>() {
                        Ok(param_business_id) => param_business_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter businessId: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["businessId"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                // Query parameters (note that non-required or collection query parameters will ignore garbage values, rather than causing a 400 response)
                let query_params = form_urlencoded::parse(uri.query().unwrap_or_default().as_bytes()).collect::<Vec<_>>();
                let param_page_token = query_params.iter().filter(|e| e.0 == "page_token").map(|e| e.1.clone())
                    .next();
                let param_page_token = match param_page_token {
                    Some(param_page_token) => {
                        let param_page_token =
                            <String as std::str::FromStr>::from_str
                                (&param_page_token);
                        match param_page_token {
                            Ok(param_page_token) => Some(param_page_token),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter page_token - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter page_token")),
                        }
                    },
                    None => None,
                };
                let param_limit = query_params.iter().filter(|e| e.0 == "limit").map(|e| e.1.clone())
                    .next();
                let param_limit = match param_limit {
                    Some(param_limit) => {
                        let param_limit =
                            <i32 as std::str::FromStr>::from_str
                                (&param_limit);
                        match param_limit {
                            Ok(param_limit) => Some(param_limit),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter limit - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter limit")),
                        }
                    },
                    None => None,
                };

                // Handle body parameters (note that non-required body parameters will ignore garbage
                // values, rather than causing a 400 response). Produce warning header and logs for
                // any unused fields.
                let result = body.into_raw().await;
                match result {
                     Ok(body) => {
                                let mut unused_elements : Vec<String> = vec![];
                                let param_get_quarantine_offers_request: Option<models::GetQuarantineOffersRequest> = if !body.is_empty() {
                                    let deserializer = &mut serde_json::Deserializer::from_slice(&*body);
                                    match serde_ignored::deserialize(deserializer, |path| {
                                            warn!("Ignoring unknown field in body: {}", path);
                                            unused_elements.push(path.to_string());
                                    }) {
                                        Ok(param_get_quarantine_offers_request) => param_get_quarantine_offers_request,
                                        Err(e) => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from(format!("Couldn't parse body parameter GetQuarantineOffersRequest - doesn't match schema: {}", e)))
                                                        .expect("Unable to create Bad Request response for invalid body parameter GetQuarantineOffersRequest due to schema")),
                                    }
                                } else {
                                    None
                                };
                                let param_get_quarantine_offers_request = match param_get_quarantine_offers_request {
                                    Some(param_get_quarantine_offers_request) => param_get_quarantine_offers_request,
                                    None => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from("Missing required body parameter GetQuarantineOffersRequest"))
                                                        .expect("Unable to create Bad Request response for missing body parameter GetQuarantineOffersRequest")),
                                };


                                let result = api_impl.get_business_quarantine_offers(
                                            param_business_id,
                                            param_get_quarantine_offers_request,
                                            param_page_token,
                                            param_limit,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        if !unused_elements.is_empty() {
                                            response.headers_mut().insert(
                                                HeaderName::from_static("warning"),
                                                HeaderValue::from_str(format!("Ignoring unknown fields in body: {:?}", unused_elements).as_str())
                                                    .expect("Unable to create Warning header value"));
                                        }
                                        match result {
                                            Ok(rsp) => match rsp {
                                                GetBusinessQuarantineOffersResponse::Status200
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetBusinessQuarantineOffersResponse::Status400
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetBusinessQuarantineOffersResponse::Status401
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetBusinessQuarantineOffersResponse::Status403
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetBusinessQuarantineOffersResponse::Status404
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetBusinessQuarantineOffersResponse::Status420
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(420).expect("Unable to turn 420 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetBusinessQuarantineOffersResponse::Status500
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
                            },
                            Err(e) => Ok(Response::builder()
                                                .status(StatusCode::BAD_REQUEST)
                                                .body(Body::from(format!("Unable to read body: {}", e)))
                                                .expect("Unable to create Bad Request response due to unable to read body")),
                        }
            },

            // GetCampaignQuarantineOffers - POST /campaigns/{campaignId}/price-quarantine
            hyper::Method::POST if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_PRICE_QUARANTINE) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "market:partner-api".to_string(), // API Яндекс.Маркета / Поиска по товарам для партнеров
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_CAMPAIGNS_CAMPAIGNID_PRICE_QUARANTINE
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE CAMPAIGNS_CAMPAIGNID_PRICE_QUARANTINE in set but failed match against \"{}\"", path, paths::REGEX_CAMPAIGNS_CAMPAIGNID_PRICE_QUARANTINE.as_str())
                    );

                let param_campaign_id = match percent_encoding::percent_decode(path_params["campaignId"].as_bytes()).decode_utf8() {
                    Ok(param_campaign_id) => match param_campaign_id.parse::<i64>() {
                        Ok(param_campaign_id) => param_campaign_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter campaignId: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["campaignId"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                // Query parameters (note that non-required or collection query parameters will ignore garbage values, rather than causing a 400 response)
                let query_params = form_urlencoded::parse(uri.query().unwrap_or_default().as_bytes()).collect::<Vec<_>>();
                let param_page_token = query_params.iter().filter(|e| e.0 == "page_token").map(|e| e.1.clone())
                    .next();
                let param_page_token = match param_page_token {
                    Some(param_page_token) => {
                        let param_page_token =
                            <String as std::str::FromStr>::from_str
                                (&param_page_token);
                        match param_page_token {
                            Ok(param_page_token) => Some(param_page_token),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter page_token - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter page_token")),
                        }
                    },
                    None => None,
                };
                let param_limit = query_params.iter().filter(|e| e.0 == "limit").map(|e| e.1.clone())
                    .next();
                let param_limit = match param_limit {
                    Some(param_limit) => {
                        let param_limit =
                            <i32 as std::str::FromStr>::from_str
                                (&param_limit);
                        match param_limit {
                            Ok(param_limit) => Some(param_limit),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter limit - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter limit")),
                        }
                    },
                    None => None,
                };

                // Handle body parameters (note that non-required body parameters will ignore garbage
                // values, rather than causing a 400 response). Produce warning header and logs for
                // any unused fields.
                let result = body.into_raw().await;
                match result {
                     Ok(body) => {
                                let mut unused_elements : Vec<String> = vec![];
                                let param_get_quarantine_offers_request: Option<models::GetQuarantineOffersRequest> = if !body.is_empty() {
                                    let deserializer = &mut serde_json::Deserializer::from_slice(&*body);
                                    match serde_ignored::deserialize(deserializer, |path| {
                                            warn!("Ignoring unknown field in body: {}", path);
                                            unused_elements.push(path.to_string());
                                    }) {
                                        Ok(param_get_quarantine_offers_request) => param_get_quarantine_offers_request,
                                        Err(e) => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from(format!("Couldn't parse body parameter GetQuarantineOffersRequest - doesn't match schema: {}", e)))
                                                        .expect("Unable to create Bad Request response for invalid body parameter GetQuarantineOffersRequest due to schema")),
                                    }
                                } else {
                                    None
                                };
                                let param_get_quarantine_offers_request = match param_get_quarantine_offers_request {
                                    Some(param_get_quarantine_offers_request) => param_get_quarantine_offers_request,
                                    None => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from("Missing required body parameter GetQuarantineOffersRequest"))
                                                        .expect("Unable to create Bad Request response for missing body parameter GetQuarantineOffersRequest")),
                                };


                                let result = api_impl.get_campaign_quarantine_offers(
                                            param_campaign_id,
                                            param_get_quarantine_offers_request,
                                            param_page_token,
                                            param_limit,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        if !unused_elements.is_empty() {
                                            response.headers_mut().insert(
                                                HeaderName::from_static("warning"),
                                                HeaderValue::from_str(format!("Ignoring unknown fields in body: {:?}", unused_elements).as_str())
                                                    .expect("Unable to create Warning header value"));
                                        }
                                        match result {
                                            Ok(rsp) => match rsp {
                                                GetCampaignQuarantineOffersResponse::Status200
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetCampaignQuarantineOffersResponse::Status400
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetCampaignQuarantineOffersResponse::Status401
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetCampaignQuarantineOffersResponse::Status403
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetCampaignQuarantineOffersResponse::Status404
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetCampaignQuarantineOffersResponse::Status420
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(420).expect("Unable to turn 420 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetCampaignQuarantineOffersResponse::Status500
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
                            },
                            Err(e) => Ok(Response::builder()
                                                .status(StatusCode::BAD_REQUEST)
                                                .body(Body::from(format!("Unable to read body: {}", e)))
                                                .expect("Unable to create Bad Request response due to unable to read body")),
                        }
            },

            // GetPrices - GET /campaigns/{campaignId}/offer-prices
            hyper::Method::GET if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_OFFER_PRICES) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "market:partner-api".to_string(), // API Яндекс.Маркета / Поиска по товарам для партнеров
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_CAMPAIGNS_CAMPAIGNID_OFFER_PRICES
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE CAMPAIGNS_CAMPAIGNID_OFFER_PRICES in set but failed match against \"{}\"", path, paths::REGEX_CAMPAIGNS_CAMPAIGNID_OFFER_PRICES.as_str())
                    );

                let param_campaign_id = match percent_encoding::percent_decode(path_params["campaignId"].as_bytes()).decode_utf8() {
                    Ok(param_campaign_id) => match param_campaign_id.parse::<i64>() {
                        Ok(param_campaign_id) => param_campaign_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter campaignId: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["campaignId"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                // Query parameters (note that non-required or collection query parameters will ignore garbage values, rather than causing a 400 response)
                let query_params = form_urlencoded::parse(uri.query().unwrap_or_default().as_bytes()).collect::<Vec<_>>();
                let param_page_token = query_params.iter().filter(|e| e.0 == "page_token").map(|e| e.1.clone())
                    .next();
                let param_page_token = match param_page_token {
                    Some(param_page_token) => {
                        let param_page_token =
                            <String as std::str::FromStr>::from_str
                                (&param_page_token);
                        match param_page_token {
                            Ok(param_page_token) => Some(param_page_token),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter page_token - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter page_token")),
                        }
                    },
                    None => None,
                };
                let param_limit = query_params.iter().filter(|e| e.0 == "limit").map(|e| e.1.clone())
                    .next();
                let param_limit = match param_limit {
                    Some(param_limit) => {
                        let param_limit =
                            <i32 as std::str::FromStr>::from_str
                                (&param_limit);
                        match param_limit {
                            Ok(param_limit) => Some(param_limit),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter limit - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter limit")),
                        }
                    },
                    None => None,
                };
                let param_archived = query_params.iter().filter(|e| e.0 == "archived").map(|e| e.1.clone())
                    .next();
                let param_archived = match param_archived {
                    Some(param_archived) => {
                        let param_archived =
                            <bool as std::str::FromStr>::from_str
                                (&param_archived);
                        match param_archived {
                            Ok(param_archived) => Some(param_archived),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter archived - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter archived")),
                        }
                    },
                    None => None,
                };

                                let result = api_impl.get_prices(
                                            param_campaign_id,
                                            param_page_token,
                                            param_limit,
                                            param_archived,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                GetPricesResponse::Status200
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetPricesResponse::Status400
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetPricesResponse::Status401
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetPricesResponse::Status403
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetPricesResponse::Status404
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetPricesResponse::Status420
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(420).expect("Unable to turn 420 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetPricesResponse::Status500
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
            },

            // GetPricesByOfferIds - POST /campaigns/{campaignId}/offer-prices
            hyper::Method::POST if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_OFFER_PRICES) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "market:partner-api".to_string(), // API Яндекс.Маркета / Поиска по товарам для партнеров
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_CAMPAIGNS_CAMPAIGNID_OFFER_PRICES
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE CAMPAIGNS_CAMPAIGNID_OFFER_PRICES in set but failed match against \"{}\"", path, paths::REGEX_CAMPAIGNS_CAMPAIGNID_OFFER_PRICES.as_str())
                    );

                let param_campaign_id = match percent_encoding::percent_decode(path_params["campaignId"].as_bytes()).decode_utf8() {
                    Ok(param_campaign_id) => match param_campaign_id.parse::<i64>() {
                        Ok(param_campaign_id) => param_campaign_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter campaignId: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["campaignId"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                // Query parameters (note that non-required or collection query parameters will ignore garbage values, rather than causing a 400 response)
                let query_params = form_urlencoded::parse(uri.query().unwrap_or_default().as_bytes()).collect::<Vec<_>>();
                let param_page_token = query_params.iter().filter(|e| e.0 == "page_token").map(|e| e.1.clone())
                    .next();
                let param_page_token = match param_page_token {
                    Some(param_page_token) => {
                        let param_page_token =
                            <String as std::str::FromStr>::from_str
                                (&param_page_token);
                        match param_page_token {
                            Ok(param_page_token) => Some(param_page_token),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter page_token - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter page_token")),
                        }
                    },
                    None => None,
                };
                let param_limit = query_params.iter().filter(|e| e.0 == "limit").map(|e| e.1.clone())
                    .next();
                let param_limit = match param_limit {
                    Some(param_limit) => {
                        let param_limit =
                            <i32 as std::str::FromStr>::from_str
                                (&param_limit);
                        match param_limit {
                            Ok(param_limit) => Some(param_limit),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter limit - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter limit")),
                        }
                    },
                    None => None,
                };

                // Handle body parameters (note that non-required body parameters will ignore garbage
                // values, rather than causing a 400 response). Produce warning header and logs for
                // any unused fields.
                let result = body.into_raw().await;
                match result {
                     Ok(body) => {
                                let mut unused_elements : Vec<String> = vec![];
                                let param_get_prices_by_offer_ids_request: Option<models::GetPricesByOfferIdsRequest> = if !body.is_empty() {
                                    let deserializer = &mut serde_json::Deserializer::from_slice(&*body);
                                    match serde_ignored::deserialize(deserializer, |path| {
                                            warn!("Ignoring unknown field in body: {}", path);
                                            unused_elements.push(path.to_string());
                                    }) {
                                        Ok(param_get_prices_by_offer_ids_request) => param_get_prices_by_offer_ids_request,
                                        Err(_) => None,
                                    }
                                } else {
                                    None
                                };


                                let result = api_impl.get_prices_by_offer_ids(
                                            param_campaign_id,
                                            param_page_token,
                                            param_limit,
                                            param_get_prices_by_offer_ids_request,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        if !unused_elements.is_empty() {
                                            response.headers_mut().insert(
                                                HeaderName::from_static("warning"),
                                                HeaderValue::from_str(format!("Ignoring unknown fields in body: {:?}", unused_elements).as_str())
                                                    .expect("Unable to create Warning header value"));
                                        }
                                        match result {
                                            Ok(rsp) => match rsp {
                                                GetPricesByOfferIdsResponse::Status200
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetPricesByOfferIdsResponse::Status400
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetPricesByOfferIdsResponse::Status401
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetPricesByOfferIdsResponse::Status403
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetPricesByOfferIdsResponse::Status404
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetPricesByOfferIdsResponse::Status420
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(420).expect("Unable to turn 420 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetPricesByOfferIdsResponse::Status500
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
                            },
                            Err(e) => Ok(Response::builder()
                                                .status(StatusCode::BAD_REQUEST)
                                                .body(Body::from(format!("Unable to read body: {}", e)))
                                                .expect("Unable to create Bad Request response due to unable to read body")),
                        }
            },

            // GetSuggestedPrices - POST /campaigns/{campaignId}/offer-prices/suggestions
            hyper::Method::POST if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_OFFER_PRICES_SUGGESTIONS) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "market:partner-api".to_string(), // API Яндекс.Маркета / Поиска по товарам для партнеров
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_CAMPAIGNS_CAMPAIGNID_OFFER_PRICES_SUGGESTIONS
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE CAMPAIGNS_CAMPAIGNID_OFFER_PRICES_SUGGESTIONS in set but failed match against \"{}\"", path, paths::REGEX_CAMPAIGNS_CAMPAIGNID_OFFER_PRICES_SUGGESTIONS.as_str())
                    );

                let param_campaign_id = match percent_encoding::percent_decode(path_params["campaignId"].as_bytes()).decode_utf8() {
                    Ok(param_campaign_id) => match param_campaign_id.parse::<i64>() {
                        Ok(param_campaign_id) => param_campaign_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter campaignId: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["campaignId"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                // Handle body parameters (note that non-required body parameters will ignore garbage
                // values, rather than causing a 400 response). Produce warning header and logs for
                // any unused fields.
                let result = body.into_raw().await;
                match result {
                     Ok(body) => {
                                let mut unused_elements : Vec<String> = vec![];
                                let param_suggest_prices_request: Option<models::SuggestPricesRequest> = if !body.is_empty() {
                                    let deserializer = &mut serde_json::Deserializer::from_slice(&*body);
                                    match serde_ignored::deserialize(deserializer, |path| {
                                            warn!("Ignoring unknown field in body: {}", path);
                                            unused_elements.push(path.to_string());
                                    }) {
                                        Ok(param_suggest_prices_request) => param_suggest_prices_request,
                                        Err(e) => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from(format!("Couldn't parse body parameter SuggestPricesRequest - doesn't match schema: {}", e)))
                                                        .expect("Unable to create Bad Request response for invalid body parameter SuggestPricesRequest due to schema")),
                                    }
                                } else {
                                    None
                                };
                                let param_suggest_prices_request = match param_suggest_prices_request {
                                    Some(param_suggest_prices_request) => param_suggest_prices_request,
                                    None => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from("Missing required body parameter SuggestPricesRequest"))
                                                        .expect("Unable to create Bad Request response for missing body parameter SuggestPricesRequest")),
                                };


                                let result = api_impl.get_suggested_prices(
                                            param_campaign_id,
                                            param_suggest_prices_request,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        if !unused_elements.is_empty() {
                                            response.headers_mut().insert(
                                                HeaderName::from_static("warning"),
                                                HeaderValue::from_str(format!("Ignoring unknown fields in body: {:?}", unused_elements).as_str())
                                                    .expect("Unable to create Warning header value"));
                                        }
                                        match result {
                                            Ok(rsp) => match rsp {
                                                GetSuggestedPricesResponse::Status200
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetSuggestedPricesResponse::Status400
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetSuggestedPricesResponse::Status401
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetSuggestedPricesResponse::Status403
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetSuggestedPricesResponse::Status404
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetSuggestedPricesResponse::Status420
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(420).expect("Unable to turn 420 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetSuggestedPricesResponse::Status500
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
                            },
                            Err(e) => Ok(Response::builder()
                                                .status(StatusCode::BAD_REQUEST)
                                                .body(Body::from(format!("Unable to read body: {}", e)))
                                                .expect("Unable to create Bad Request response due to unable to read body")),
                        }
            },

            // UpdateBusinessPrices - POST /businesses/{businessId}/offer-prices/updates
            hyper::Method::POST if path.matched(paths::ID_BUSINESSES_BUSINESSID_OFFER_PRICES_UPDATES) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "market:partner-api".to_string(), // API Яндекс.Маркета / Поиска по товарам для партнеров
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_BUSINESSES_BUSINESSID_OFFER_PRICES_UPDATES
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE BUSINESSES_BUSINESSID_OFFER_PRICES_UPDATES in set but failed match against \"{}\"", path, paths::REGEX_BUSINESSES_BUSINESSID_OFFER_PRICES_UPDATES.as_str())
                    );

                let param_business_id = match percent_encoding::percent_decode(path_params["businessId"].as_bytes()).decode_utf8() {
                    Ok(param_business_id) => match param_business_id.parse::<i64>() {
                        Ok(param_business_id) => param_business_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter businessId: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["businessId"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                // Handle body parameters (note that non-required body parameters will ignore garbage
                // values, rather than causing a 400 response). Produce warning header and logs for
                // any unused fields.
                let result = body.into_raw().await;
                match result {
                     Ok(body) => {
                                let mut unused_elements : Vec<String> = vec![];
                                let param_update_business_prices_request: Option<models::UpdateBusinessPricesRequest> = if !body.is_empty() {
                                    let deserializer = &mut serde_json::Deserializer::from_slice(&*body);
                                    match serde_ignored::deserialize(deserializer, |path| {
                                            warn!("Ignoring unknown field in body: {}", path);
                                            unused_elements.push(path.to_string());
                                    }) {
                                        Ok(param_update_business_prices_request) => param_update_business_prices_request,
                                        Err(e) => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from(format!("Couldn't parse body parameter UpdateBusinessPricesRequest - doesn't match schema: {}", e)))
                                                        .expect("Unable to create Bad Request response for invalid body parameter UpdateBusinessPricesRequest due to schema")),
                                    }
                                } else {
                                    None
                                };
                                let param_update_business_prices_request = match param_update_business_prices_request {
                                    Some(param_update_business_prices_request) => param_update_business_prices_request,
                                    None => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from("Missing required body parameter UpdateBusinessPricesRequest"))
                                                        .expect("Unable to create Bad Request response for missing body parameter UpdateBusinessPricesRequest")),
                                };


                                let result = api_impl.update_business_prices(
                                            param_business_id,
                                            param_update_business_prices_request,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        if !unused_elements.is_empty() {
                                            response.headers_mut().insert(
                                                HeaderName::from_static("warning"),
                                                HeaderValue::from_str(format!("Ignoring unknown fields in body: {:?}", unused_elements).as_str())
                                                    .expect("Unable to create Warning header value"));
                                        }
                                        match result {
                                            Ok(rsp) => match rsp {
                                                UpdateBusinessPricesResponse::Status200
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                UpdateBusinessPricesResponse::Status400
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                UpdateBusinessPricesResponse::Status401
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                UpdateBusinessPricesResponse::Status403
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                UpdateBusinessPricesResponse::Status404
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                UpdateBusinessPricesResponse::Status420
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(420).expect("Unable to turn 420 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                UpdateBusinessPricesResponse::Status423
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(423).expect("Unable to turn 423 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                UpdateBusinessPricesResponse::Status500
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
                            },
                            Err(e) => Ok(Response::builder()
                                                .status(StatusCode::BAD_REQUEST)
                                                .body(Body::from(format!("Unable to read body: {}", e)))
                                                .expect("Unable to create Bad Request response due to unable to read body")),
                        }
            },

            // UpdatePrices - POST /campaigns/{campaignId}/offer-prices/updates
            hyper::Method::POST if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_OFFER_PRICES_UPDATES) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "market:partner-api".to_string(), // API Яндекс.Маркета / Поиска по товарам для партнеров
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_CAMPAIGNS_CAMPAIGNID_OFFER_PRICES_UPDATES
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE CAMPAIGNS_CAMPAIGNID_OFFER_PRICES_UPDATES in set but failed match against \"{}\"", path, paths::REGEX_CAMPAIGNS_CAMPAIGNID_OFFER_PRICES_UPDATES.as_str())
                    );

                let param_campaign_id = match percent_encoding::percent_decode(path_params["campaignId"].as_bytes()).decode_utf8() {
                    Ok(param_campaign_id) => match param_campaign_id.parse::<i64>() {
                        Ok(param_campaign_id) => param_campaign_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter campaignId: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["campaignId"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                // Handle body parameters (note that non-required body parameters will ignore garbage
                // values, rather than causing a 400 response). Produce warning header and logs for
                // any unused fields.
                let result = body.into_raw().await;
                match result {
                     Ok(body) => {
                                let mut unused_elements : Vec<String> = vec![];
                                let param_update_prices_request: Option<models::UpdatePricesRequest> = if !body.is_empty() {
                                    let deserializer = &mut serde_json::Deserializer::from_slice(&*body);
                                    match serde_ignored::deserialize(deserializer, |path| {
                                            warn!("Ignoring unknown field in body: {}", path);
                                            unused_elements.push(path.to_string());
                                    }) {
                                        Ok(param_update_prices_request) => param_update_prices_request,
                                        Err(e) => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from(format!("Couldn't parse body parameter UpdatePricesRequest - doesn't match schema: {}", e)))
                                                        .expect("Unable to create Bad Request response for invalid body parameter UpdatePricesRequest due to schema")),
                                    }
                                } else {
                                    None
                                };
                                let param_update_prices_request = match param_update_prices_request {
                                    Some(param_update_prices_request) => param_update_prices_request,
                                    None => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from("Missing required body parameter UpdatePricesRequest"))
                                                        .expect("Unable to create Bad Request response for missing body parameter UpdatePricesRequest")),
                                };


                                let result = api_impl.update_prices(
                                            param_campaign_id,
                                            param_update_prices_request,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        if !unused_elements.is_empty() {
                                            response.headers_mut().insert(
                                                HeaderName::from_static("warning"),
                                                HeaderValue::from_str(format!("Ignoring unknown fields in body: {:?}", unused_elements).as_str())
                                                    .expect("Unable to create Warning header value"));
                                        }
                                        match result {
                                            Ok(rsp) => match rsp {
                                                UpdatePricesResponse::Status200
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                UpdatePricesResponse::Status400
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                UpdatePricesResponse::Status401
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                UpdatePricesResponse::Status403
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                UpdatePricesResponse::Status404
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                UpdatePricesResponse::Status420
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(420).expect("Unable to turn 420 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                UpdatePricesResponse::Status423
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(423).expect("Unable to turn 423 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                UpdatePricesResponse::Status500
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
                            },
                            Err(e) => Ok(Response::builder()
                                                .status(StatusCode::BAD_REQUEST)
                                                .body(Body::from(format!("Unable to read body: {}", e)))
                                                .expect("Unable to create Bad Request response due to unable to read body")),
                        }
            },

            // DeletePromoOffers - POST /businesses/{businessId}/promos/offers/delete
            hyper::Method::POST if path.matched(paths::ID_BUSINESSES_BUSINESSID_PROMOS_OFFERS_DELETE) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "market:partner-api".to_string(), // API Яндекс.Маркета / Поиска по товарам для партнеров
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_BUSINESSES_BUSINESSID_PROMOS_OFFERS_DELETE
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE BUSINESSES_BUSINESSID_PROMOS_OFFERS_DELETE in set but failed match against \"{}\"", path, paths::REGEX_BUSINESSES_BUSINESSID_PROMOS_OFFERS_DELETE.as_str())
                    );

                let param_business_id = match percent_encoding::percent_decode(path_params["businessId"].as_bytes()).decode_utf8() {
                    Ok(param_business_id) => match param_business_id.parse::<i64>() {
                        Ok(param_business_id) => param_business_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter businessId: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["businessId"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                // Handle body parameters (note that non-required body parameters will ignore garbage
                // values, rather than causing a 400 response). Produce warning header and logs for
                // any unused fields.
                let result = body.into_raw().await;
                match result {
                     Ok(body) => {
                                let mut unused_elements : Vec<String> = vec![];
                                let param_delete_promo_offers_request: Option<models::DeletePromoOffersRequest> = if !body.is_empty() {
                                    let deserializer = &mut serde_json::Deserializer::from_slice(&*body);
                                    match serde_ignored::deserialize(deserializer, |path| {
                                            warn!("Ignoring unknown field in body: {}", path);
                                            unused_elements.push(path.to_string());
                                    }) {
                                        Ok(param_delete_promo_offers_request) => param_delete_promo_offers_request,
                                        Err(e) => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from(format!("Couldn't parse body parameter DeletePromoOffersRequest - doesn't match schema: {}", e)))
                                                        .expect("Unable to create Bad Request response for invalid body parameter DeletePromoOffersRequest due to schema")),
                                    }
                                } else {
                                    None
                                };
                                let param_delete_promo_offers_request = match param_delete_promo_offers_request {
                                    Some(param_delete_promo_offers_request) => param_delete_promo_offers_request,
                                    None => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from("Missing required body parameter DeletePromoOffersRequest"))
                                                        .expect("Unable to create Bad Request response for missing body parameter DeletePromoOffersRequest")),
                                };


                                let result = api_impl.delete_promo_offers(
                                            param_business_id,
                                            param_delete_promo_offers_request,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        if !unused_elements.is_empty() {
                                            response.headers_mut().insert(
                                                HeaderName::from_static("warning"),
                                                HeaderValue::from_str(format!("Ignoring unknown fields in body: {:?}", unused_elements).as_str())
                                                    .expect("Unable to create Warning header value"));
                                        }
                                        match result {
                                            Ok(rsp) => match rsp {
                                                DeletePromoOffersResponse::Status200
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                DeletePromoOffersResponse::Status400
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                DeletePromoOffersResponse::Status401
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                DeletePromoOffersResponse::Status403
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                DeletePromoOffersResponse::Status404
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                DeletePromoOffersResponse::Status420
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(420).expect("Unable to turn 420 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                DeletePromoOffersResponse::Status500
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
                            },
                            Err(e) => Ok(Response::builder()
                                                .status(StatusCode::BAD_REQUEST)
                                                .body(Body::from(format!("Unable to read body: {}", e)))
                                                .expect("Unable to create Bad Request response due to unable to read body")),
                        }
            },

            // GetPromoOffers - POST /businesses/{businessId}/promos/offers
            hyper::Method::POST if path.matched(paths::ID_BUSINESSES_BUSINESSID_PROMOS_OFFERS) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "market:partner-api".to_string(), // API Яндекс.Маркета / Поиска по товарам для партнеров
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_BUSINESSES_BUSINESSID_PROMOS_OFFERS
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE BUSINESSES_BUSINESSID_PROMOS_OFFERS in set but failed match against \"{}\"", path, paths::REGEX_BUSINESSES_BUSINESSID_PROMOS_OFFERS.as_str())
                    );

                let param_business_id = match percent_encoding::percent_decode(path_params["businessId"].as_bytes()).decode_utf8() {
                    Ok(param_business_id) => match param_business_id.parse::<i64>() {
                        Ok(param_business_id) => param_business_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter businessId: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["businessId"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                // Query parameters (note that non-required or collection query parameters will ignore garbage values, rather than causing a 400 response)
                let query_params = form_urlencoded::parse(uri.query().unwrap_or_default().as_bytes()).collect::<Vec<_>>();
                let param_page_token = query_params.iter().filter(|e| e.0 == "page_token").map(|e| e.1.clone())
                    .next();
                let param_page_token = match param_page_token {
                    Some(param_page_token) => {
                        let param_page_token =
                            <String as std::str::FromStr>::from_str
                                (&param_page_token);
                        match param_page_token {
                            Ok(param_page_token) => Some(param_page_token),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter page_token - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter page_token")),
                        }
                    },
                    None => None,
                };
                let param_limit = query_params.iter().filter(|e| e.0 == "limit").map(|e| e.1.clone())
                    .next();
                let param_limit = match param_limit {
                    Some(param_limit) => {
                        let param_limit =
                            <i32 as std::str::FromStr>::from_str
                                (&param_limit);
                        match param_limit {
                            Ok(param_limit) => Some(param_limit),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter limit - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter limit")),
                        }
                    },
                    None => None,
                };

                // Handle body parameters (note that non-required body parameters will ignore garbage
                // values, rather than causing a 400 response). Produce warning header and logs for
                // any unused fields.
                let result = body.into_raw().await;
                match result {
                     Ok(body) => {
                                let mut unused_elements : Vec<String> = vec![];
                                let param_get_promo_offers_request: Option<models::GetPromoOffersRequest> = if !body.is_empty() {
                                    let deserializer = &mut serde_json::Deserializer::from_slice(&*body);
                                    match serde_ignored::deserialize(deserializer, |path| {
                                            warn!("Ignoring unknown field in body: {}", path);
                                            unused_elements.push(path.to_string());
                                    }) {
                                        Ok(param_get_promo_offers_request) => param_get_promo_offers_request,
                                        Err(e) => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from(format!("Couldn't parse body parameter GetPromoOffersRequest - doesn't match schema: {}", e)))
                                                        .expect("Unable to create Bad Request response for invalid body parameter GetPromoOffersRequest due to schema")),
                                    }
                                } else {
                                    None
                                };
                                let param_get_promo_offers_request = match param_get_promo_offers_request {
                                    Some(param_get_promo_offers_request) => param_get_promo_offers_request,
                                    None => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from("Missing required body parameter GetPromoOffersRequest"))
                                                        .expect("Unable to create Bad Request response for missing body parameter GetPromoOffersRequest")),
                                };


                                let result = api_impl.get_promo_offers(
                                            param_business_id,
                                            param_get_promo_offers_request,
                                            param_page_token,
                                            param_limit,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        if !unused_elements.is_empty() {
                                            response.headers_mut().insert(
                                                HeaderName::from_static("warning"),
                                                HeaderValue::from_str(format!("Ignoring unknown fields in body: {:?}", unused_elements).as_str())
                                                    .expect("Unable to create Warning header value"));
                                        }
                                        match result {
                                            Ok(rsp) => match rsp {
                                                GetPromoOffersResponse::Status200
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetPromoOffersResponse::Status400
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetPromoOffersResponse::Status401
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetPromoOffersResponse::Status403
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetPromoOffersResponse::Status404
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetPromoOffersResponse::Status420
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(420).expect("Unable to turn 420 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetPromoOffersResponse::Status500
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
                            },
                            Err(e) => Ok(Response::builder()
                                                .status(StatusCode::BAD_REQUEST)
                                                .body(Body::from(format!("Unable to read body: {}", e)))
                                                .expect("Unable to create Bad Request response due to unable to read body")),
                        }
            },

            // GetPromos - POST /businesses/{businessId}/promos
            hyper::Method::POST if path.matched(paths::ID_BUSINESSES_BUSINESSID_PROMOS) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "market:partner-api".to_string(), // API Яндекс.Маркета / Поиска по товарам для партнеров
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_BUSINESSES_BUSINESSID_PROMOS
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE BUSINESSES_BUSINESSID_PROMOS in set but failed match against \"{}\"", path, paths::REGEX_BUSINESSES_BUSINESSID_PROMOS.as_str())
                    );

                let param_business_id = match percent_encoding::percent_decode(path_params["businessId"].as_bytes()).decode_utf8() {
                    Ok(param_business_id) => match param_business_id.parse::<i64>() {
                        Ok(param_business_id) => param_business_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter businessId: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["businessId"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                // Handle body parameters (note that non-required body parameters will ignore garbage
                // values, rather than causing a 400 response). Produce warning header and logs for
                // any unused fields.
                let result = body.into_raw().await;
                match result {
                     Ok(body) => {
                                let mut unused_elements : Vec<String> = vec![];
                                let param_get_promos_request: Option<models::GetPromosRequest> = if !body.is_empty() {
                                    let deserializer = &mut serde_json::Deserializer::from_slice(&*body);
                                    match serde_ignored::deserialize(deserializer, |path| {
                                            warn!("Ignoring unknown field in body: {}", path);
                                            unused_elements.push(path.to_string());
                                    }) {
                                        Ok(param_get_promos_request) => param_get_promos_request,
                                        Err(_) => None,
                                    }
                                } else {
                                    None
                                };


                                let result = api_impl.get_promos(
                                            param_business_id,
                                            param_get_promos_request,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        if !unused_elements.is_empty() {
                                            response.headers_mut().insert(
                                                HeaderName::from_static("warning"),
                                                HeaderValue::from_str(format!("Ignoring unknown fields in body: {:?}", unused_elements).as_str())
                                                    .expect("Unable to create Warning header value"));
                                        }
                                        match result {
                                            Ok(rsp) => match rsp {
                                                GetPromosResponse::Status200
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetPromosResponse::Status400
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetPromosResponse::Status401
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetPromosResponse::Status403
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetPromosResponse::Status404
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetPromosResponse::Status420
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(420).expect("Unable to turn 420 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetPromosResponse::Status500
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
                            },
                            Err(e) => Ok(Response::builder()
                                                .status(StatusCode::BAD_REQUEST)
                                                .body(Body::from(format!("Unable to read body: {}", e)))
                                                .expect("Unable to create Bad Request response due to unable to read body")),
                        }
            },

            // UpdatePromoOffers - POST /businesses/{businessId}/promos/offers/update
            hyper::Method::POST if path.matched(paths::ID_BUSINESSES_BUSINESSID_PROMOS_OFFERS_UPDATE) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "market:partner-api".to_string(), // API Яндекс.Маркета / Поиска по товарам для партнеров
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_BUSINESSES_BUSINESSID_PROMOS_OFFERS_UPDATE
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE BUSINESSES_BUSINESSID_PROMOS_OFFERS_UPDATE in set but failed match against \"{}\"", path, paths::REGEX_BUSINESSES_BUSINESSID_PROMOS_OFFERS_UPDATE.as_str())
                    );

                let param_business_id = match percent_encoding::percent_decode(path_params["businessId"].as_bytes()).decode_utf8() {
                    Ok(param_business_id) => match param_business_id.parse::<i64>() {
                        Ok(param_business_id) => param_business_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter businessId: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["businessId"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                // Handle body parameters (note that non-required body parameters will ignore garbage
                // values, rather than causing a 400 response). Produce warning header and logs for
                // any unused fields.
                let result = body.into_raw().await;
                match result {
                     Ok(body) => {
                                let mut unused_elements : Vec<String> = vec![];
                                let param_update_promo_offers_request: Option<models::UpdatePromoOffersRequest> = if !body.is_empty() {
                                    let deserializer = &mut serde_json::Deserializer::from_slice(&*body);
                                    match serde_ignored::deserialize(deserializer, |path| {
                                            warn!("Ignoring unknown field in body: {}", path);
                                            unused_elements.push(path.to_string());
                                    }) {
                                        Ok(param_update_promo_offers_request) => param_update_promo_offers_request,
                                        Err(e) => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from(format!("Couldn't parse body parameter UpdatePromoOffersRequest - doesn't match schema: {}", e)))
                                                        .expect("Unable to create Bad Request response for invalid body parameter UpdatePromoOffersRequest due to schema")),
                                    }
                                } else {
                                    None
                                };
                                let param_update_promo_offers_request = match param_update_promo_offers_request {
                                    Some(param_update_promo_offers_request) => param_update_promo_offers_request,
                                    None => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from("Missing required body parameter UpdatePromoOffersRequest"))
                                                        .expect("Unable to create Bad Request response for missing body parameter UpdatePromoOffersRequest")),
                                };


                                let result = api_impl.update_promo_offers(
                                            param_business_id,
                                            param_update_promo_offers_request,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        if !unused_elements.is_empty() {
                                            response.headers_mut().insert(
                                                HeaderName::from_static("warning"),
                                                HeaderValue::from_str(format!("Ignoring unknown fields in body: {:?}", unused_elements).as_str())
                                                    .expect("Unable to create Warning header value"));
                                        }
                                        match result {
                                            Ok(rsp) => match rsp {
                                                UpdatePromoOffersResponse::Status200
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                UpdatePromoOffersResponse::Status400
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                UpdatePromoOffersResponse::Status401
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                UpdatePromoOffersResponse::Status403
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                UpdatePromoOffersResponse::Status404
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                UpdatePromoOffersResponse::Status420
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(420).expect("Unable to turn 420 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                UpdatePromoOffersResponse::Status500
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
                            },
                            Err(e) => Ok(Response::builder()
                                                .status(StatusCode::BAD_REQUEST)
                                                .body(Body::from(format!("Unable to read body: {}", e)))
                                                .expect("Unable to create Bad Request response due to unable to read body")),
                        }
            },

            // GetQualityRatingDetails - POST /campaigns/{campaignId}/ratings/quality/details
            hyper::Method::POST if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_RATINGS_QUALITY_DETAILS) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "market:partner-api".to_string(), // API Яндекс.Маркета / Поиска по товарам для партнеров
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_CAMPAIGNS_CAMPAIGNID_RATINGS_QUALITY_DETAILS
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE CAMPAIGNS_CAMPAIGNID_RATINGS_QUALITY_DETAILS in set but failed match against \"{}\"", path, paths::REGEX_CAMPAIGNS_CAMPAIGNID_RATINGS_QUALITY_DETAILS.as_str())
                    );

                let param_campaign_id = match percent_encoding::percent_decode(path_params["campaignId"].as_bytes()).decode_utf8() {
                    Ok(param_campaign_id) => match param_campaign_id.parse::<i64>() {
                        Ok(param_campaign_id) => param_campaign_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter campaignId: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["campaignId"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                                let result = api_impl.get_quality_rating_details(
                                            param_campaign_id,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                GetQualityRatingDetailsResponse::Status200
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetQualityRatingDetailsResponse::Status400
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetQualityRatingDetailsResponse::Status401
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetQualityRatingDetailsResponse::Status403
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetQualityRatingDetailsResponse::Status404
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetQualityRatingDetailsResponse::Status420
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(420).expect("Unable to turn 420 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetQualityRatingDetailsResponse::Status500
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
            },

            // GetQualityRatings - POST /businesses/{businessId}/ratings/quality
            hyper::Method::POST if path.matched(paths::ID_BUSINESSES_BUSINESSID_RATINGS_QUALITY) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "market:partner-api".to_string(), // API Яндекс.Маркета / Поиска по товарам для партнеров
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_BUSINESSES_BUSINESSID_RATINGS_QUALITY
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE BUSINESSES_BUSINESSID_RATINGS_QUALITY in set but failed match against \"{}\"", path, paths::REGEX_BUSINESSES_BUSINESSID_RATINGS_QUALITY.as_str())
                    );

                let param_business_id = match percent_encoding::percent_decode(path_params["businessId"].as_bytes()).decode_utf8() {
                    Ok(param_business_id) => match param_business_id.parse::<i64>() {
                        Ok(param_business_id) => param_business_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter businessId: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["businessId"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                // Handle body parameters (note that non-required body parameters will ignore garbage
                // values, rather than causing a 400 response). Produce warning header and logs for
                // any unused fields.
                let result = body.into_raw().await;
                match result {
                     Ok(body) => {
                                let mut unused_elements : Vec<String> = vec![];
                                let param_get_quality_rating_request: Option<models::GetQualityRatingRequest> = if !body.is_empty() {
                                    let deserializer = &mut serde_json::Deserializer::from_slice(&*body);
                                    match serde_ignored::deserialize(deserializer, |path| {
                                            warn!("Ignoring unknown field in body: {}", path);
                                            unused_elements.push(path.to_string());
                                    }) {
                                        Ok(param_get_quality_rating_request) => param_get_quality_rating_request,
                                        Err(e) => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from(format!("Couldn't parse body parameter GetQualityRatingRequest - doesn't match schema: {}", e)))
                                                        .expect("Unable to create Bad Request response for invalid body parameter GetQualityRatingRequest due to schema")),
                                    }
                                } else {
                                    None
                                };
                                let param_get_quality_rating_request = match param_get_quality_rating_request {
                                    Some(param_get_quality_rating_request) => param_get_quality_rating_request,
                                    None => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from("Missing required body parameter GetQualityRatingRequest"))
                                                        .expect("Unable to create Bad Request response for missing body parameter GetQualityRatingRequest")),
                                };


                                let result = api_impl.get_quality_ratings(
                                            param_business_id,
                                            param_get_quality_rating_request,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        if !unused_elements.is_empty() {
                                            response.headers_mut().insert(
                                                HeaderName::from_static("warning"),
                                                HeaderValue::from_str(format!("Ignoring unknown fields in body: {:?}", unused_elements).as_str())
                                                    .expect("Unable to create Warning header value"));
                                        }
                                        match result {
                                            Ok(rsp) => match rsp {
                                                GetQualityRatingsResponse::Status200
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetQualityRatingsResponse::Status400
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetQualityRatingsResponse::Status401
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetQualityRatingsResponse::Status403
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetQualityRatingsResponse::Status404
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetQualityRatingsResponse::Status420
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(420).expect("Unable to turn 420 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetQualityRatingsResponse::Status500
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
                            },
                            Err(e) => Ok(Response::builder()
                                                .status(StatusCode::BAD_REQUEST)
                                                .body(Body::from(format!("Unable to read body: {}", e)))
                                                .expect("Unable to create Bad Request response due to unable to read body")),
                        }
            },

            // SearchRegionsByName - GET /regions
            hyper::Method::GET if path.matched(paths::ID_REGIONS) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "market:partner-api".to_string(), // API Яндекс.Маркета / Поиска по товарам для партнеров
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Query parameters (note that non-required or collection query parameters will ignore garbage values, rather than causing a 400 response)
                let query_params = form_urlencoded::parse(uri.query().unwrap_or_default().as_bytes()).collect::<Vec<_>>();
                let param_name = query_params.iter().filter(|e| e.0 == "name").map(|e| e.1.clone())
                    .next();
                let param_name = match param_name {
                    Some(param_name) => {
                        let param_name =
                            <String as std::str::FromStr>::from_str
                                (&param_name);
                        match param_name {
                            Ok(param_name) => Some(param_name),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter name - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter name")),
                        }
                    },
                    None => None,
                };
                let param_name = match param_name {
                    Some(param_name) => param_name,
                    None => return Ok(Response::builder()
                        .status(StatusCode::BAD_REQUEST)
                        .body(Body::from("Missing required query parameter name"))
                        .expect("Unable to create Bad Request response for missing query parameter name")),
                };
                let param_page_token = query_params.iter().filter(|e| e.0 == "page_token").map(|e| e.1.clone())
                    .next();
                let param_page_token = match param_page_token {
                    Some(param_page_token) => {
                        let param_page_token =
                            <String as std::str::FromStr>::from_str
                                (&param_page_token);
                        match param_page_token {
                            Ok(param_page_token) => Some(param_page_token),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter page_token - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter page_token")),
                        }
                    },
                    None => None,
                };
                let param_limit = query_params.iter().filter(|e| e.0 == "limit").map(|e| e.1.clone())
                    .next();
                let param_limit = match param_limit {
                    Some(param_limit) => {
                        let param_limit =
                            <i32 as std::str::FromStr>::from_str
                                (&param_limit);
                        match param_limit {
                            Ok(param_limit) => Some(param_limit),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter limit - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter limit")),
                        }
                    },
                    None => None,
                };

                                let result = api_impl.search_regions_by_name(
                                            param_name,
                                            param_page_token,
                                            param_limit,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                SearchRegionsByNameResponse::Status200
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                SearchRegionsByNameResponse::Status401
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                SearchRegionsByNameResponse::Status403
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                SearchRegionsByNameResponse::Status420
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(420).expect("Unable to turn 420 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                SearchRegionsByNameResponse::Status500
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
            },

            // SearchRegionChildren - GET /regions/{regionId}/children
            hyper::Method::GET if path.matched(paths::ID_REGIONS_REGIONID_CHILDREN) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "market:partner-api".to_string(), // API Яндекс.Маркета / Поиска по товарам для партнеров
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_REGIONS_REGIONID_CHILDREN
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE REGIONS_REGIONID_CHILDREN in set but failed match against \"{}\"", path, paths::REGEX_REGIONS_REGIONID_CHILDREN.as_str())
                    );

                let param_region_id = match percent_encoding::percent_decode(path_params["regionId"].as_bytes()).decode_utf8() {
                    Ok(param_region_id) => match param_region_id.parse::<i64>() {
                        Ok(param_region_id) => param_region_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter regionId: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["regionId"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                // Query parameters (note that non-required or collection query parameters will ignore garbage values, rather than causing a 400 response)
                let query_params = form_urlencoded::parse(uri.query().unwrap_or_default().as_bytes()).collect::<Vec<_>>();
                let param_page = query_params.iter().filter(|e| e.0 == "page").map(|e| e.1.clone())
                    .next();
                let param_page = match param_page {
                    Some(param_page) => {
                        let param_page =
                            <i32 as std::str::FromStr>::from_str
                                (&param_page);
                        match param_page {
                            Ok(param_page) => Some(param_page),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter page - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter page")),
                        }
                    },
                    None => None,
                };
                let param_page_size = query_params.iter().filter(|e| e.0 == "pageSize").map(|e| e.1.clone())
                    .next();
                let param_page_size = match param_page_size {
                    Some(param_page_size) => {
                        let param_page_size =
                            <i32 as std::str::FromStr>::from_str
                                (&param_page_size);
                        match param_page_size {
                            Ok(param_page_size) => Some(param_page_size),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter pageSize - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter pageSize")),
                        }
                    },
                    None => None,
                };

                                let result = api_impl.search_region_children(
                                            param_region_id,
                                            param_page,
                                            param_page_size,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                SearchRegionChildrenResponse::Status200
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                SearchRegionChildrenResponse::Status400
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                SearchRegionChildrenResponse::Status401
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                SearchRegionChildrenResponse::Status403
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                SearchRegionChildrenResponse::Status404
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                SearchRegionChildrenResponse::Status420
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(420).expect("Unable to turn 420 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                SearchRegionChildrenResponse::Status500
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
            },

            // SearchRegionsById - GET /regions/{regionId}
            hyper::Method::GET if path.matched(paths::ID_REGIONS_REGIONID) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "market:partner-api".to_string(), // API Яндекс.Маркета / Поиска по товарам для партнеров
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_REGIONS_REGIONID
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE REGIONS_REGIONID in set but failed match against \"{}\"", path, paths::REGEX_REGIONS_REGIONID.as_str())
                    );

                let param_region_id = match percent_encoding::percent_decode(path_params["regionId"].as_bytes()).decode_utf8() {
                    Ok(param_region_id) => match param_region_id.parse::<i64>() {
                        Ok(param_region_id) => param_region_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter regionId: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["regionId"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                                let result = api_impl.search_regions_by_id(
                                            param_region_id,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                SearchRegionsByIdResponse::Status200
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                SearchRegionsByIdResponse::Status401
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                SearchRegionsByIdResponse::Status403
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                SearchRegionsByIdResponse::Status404
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                SearchRegionsByIdResponse::Status420
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(420).expect("Unable to turn 420 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                SearchRegionsByIdResponse::Status500
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
            },

            // GenerateBoostConsolidatedReport - POST /reports/boost-consolidated/generate
            hyper::Method::POST if path.matched(paths::ID_REPORTS_BOOST_CONSOLIDATED_GENERATE) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "market:partner-api".to_string(), // API Яндекс.Маркета / Поиска по товарам для партнеров
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Query parameters (note that non-required or collection query parameters will ignore garbage values, rather than causing a 400 response)
                let query_params = form_urlencoded::parse(uri.query().unwrap_or_default().as_bytes()).collect::<Vec<_>>();
                let param_format = query_params.iter().filter(|e| e.0 == "format").map(|e| e.1.clone())
                    .next();
                let param_format = match param_format {
                    Some(param_format) => {
                        let param_format =
                            <models::ReportFormatType as std::str::FromStr>::from_str
                                (&param_format);
                        match param_format {
                            Ok(param_format) => Some(param_format),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter format - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter format")),
                        }
                    },
                    None => None,
                };

                // Handle body parameters (note that non-required body parameters will ignore garbage
                // values, rather than causing a 400 response). Produce warning header and logs for
                // any unused fields.
                let result = body.into_raw().await;
                match result {
                     Ok(body) => {
                                let mut unused_elements : Vec<String> = vec![];
                                let param_generate_boost_consolidated_request: Option<models::GenerateBoostConsolidatedRequest> = if !body.is_empty() {
                                    let deserializer = &mut serde_json::Deserializer::from_slice(&*body);
                                    match serde_ignored::deserialize(deserializer, |path| {
                                            warn!("Ignoring unknown field in body: {}", path);
                                            unused_elements.push(path.to_string());
                                    }) {
                                        Ok(param_generate_boost_consolidated_request) => param_generate_boost_consolidated_request,
                                        Err(e) => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from(format!("Couldn't parse body parameter GenerateBoostConsolidatedRequest - doesn't match schema: {}", e)))
                                                        .expect("Unable to create Bad Request response for invalid body parameter GenerateBoostConsolidatedRequest due to schema")),
                                    }
                                } else {
                                    None
                                };
                                let param_generate_boost_consolidated_request = match param_generate_boost_consolidated_request {
                                    Some(param_generate_boost_consolidated_request) => param_generate_boost_consolidated_request,
                                    None => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from("Missing required body parameter GenerateBoostConsolidatedRequest"))
                                                        .expect("Unable to create Bad Request response for missing body parameter GenerateBoostConsolidatedRequest")),
                                };


                                let result = api_impl.generate_boost_consolidated_report(
                                            param_generate_boost_consolidated_request,
                                            param_format,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        if !unused_elements.is_empty() {
                                            response.headers_mut().insert(
                                                HeaderName::from_static("warning"),
                                                HeaderValue::from_str(format!("Ignoring unknown fields in body: {:?}", unused_elements).as_str())
                                                    .expect("Unable to create Warning header value"));
                                        }
                                        match result {
                                            Ok(rsp) => match rsp {
                                                GenerateBoostConsolidatedReportResponse::Status200
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GenerateBoostConsolidatedReportResponse::Status400
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GenerateBoostConsolidatedReportResponse::Status401
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GenerateBoostConsolidatedReportResponse::Status403
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GenerateBoostConsolidatedReportResponse::Status420
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(420).expect("Unable to turn 420 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GenerateBoostConsolidatedReportResponse::Status500
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
                            },
                            Err(e) => Ok(Response::builder()
                                                .status(StatusCode::BAD_REQUEST)
                                                .body(Body::from(format!("Unable to read body: {}", e)))
                                                .expect("Unable to create Bad Request response due to unable to read body")),
                        }
            },

            // GenerateCompetitorsPositionReport - POST /reports/competitors-position/generate
            hyper::Method::POST if path.matched(paths::ID_REPORTS_COMPETITORS_POSITION_GENERATE) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "market:partner-api".to_string(), // API Яндекс.Маркета / Поиска по товарам для партнеров
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Query parameters (note that non-required or collection query parameters will ignore garbage values, rather than causing a 400 response)
                let query_params = form_urlencoded::parse(uri.query().unwrap_or_default().as_bytes()).collect::<Vec<_>>();
                let param_format = query_params.iter().filter(|e| e.0 == "format").map(|e| e.1.clone())
                    .next();
                let param_format = match param_format {
                    Some(param_format) => {
                        let param_format =
                            <models::ReportFormatType as std::str::FromStr>::from_str
                                (&param_format);
                        match param_format {
                            Ok(param_format) => Some(param_format),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter format - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter format")),
                        }
                    },
                    None => None,
                };

                // Handle body parameters (note that non-required body parameters will ignore garbage
                // values, rather than causing a 400 response). Produce warning header and logs for
                // any unused fields.
                let result = body.into_raw().await;
                match result {
                     Ok(body) => {
                                let mut unused_elements : Vec<String> = vec![];
                                let param_generate_competitors_position_report_request: Option<models::GenerateCompetitorsPositionReportRequest> = if !body.is_empty() {
                                    let deserializer = &mut serde_json::Deserializer::from_slice(&*body);
                                    match serde_ignored::deserialize(deserializer, |path| {
                                            warn!("Ignoring unknown field in body: {}", path);
                                            unused_elements.push(path.to_string());
                                    }) {
                                        Ok(param_generate_competitors_position_report_request) => param_generate_competitors_position_report_request,
                                        Err(e) => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from(format!("Couldn't parse body parameter GenerateCompetitorsPositionReportRequest - doesn't match schema: {}", e)))
                                                        .expect("Unable to create Bad Request response for invalid body parameter GenerateCompetitorsPositionReportRequest due to schema")),
                                    }
                                } else {
                                    None
                                };
                                let param_generate_competitors_position_report_request = match param_generate_competitors_position_report_request {
                                    Some(param_generate_competitors_position_report_request) => param_generate_competitors_position_report_request,
                                    None => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from("Missing required body parameter GenerateCompetitorsPositionReportRequest"))
                                                        .expect("Unable to create Bad Request response for missing body parameter GenerateCompetitorsPositionReportRequest")),
                                };


                                let result = api_impl.generate_competitors_position_report(
                                            param_generate_competitors_position_report_request,
                                            param_format,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        if !unused_elements.is_empty() {
                                            response.headers_mut().insert(
                                                HeaderName::from_static("warning"),
                                                HeaderValue::from_str(format!("Ignoring unknown fields in body: {:?}", unused_elements).as_str())
                                                    .expect("Unable to create Warning header value"));
                                        }
                                        match result {
                                            Ok(rsp) => match rsp {
                                                GenerateCompetitorsPositionReportResponse::Status200
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GenerateCompetitorsPositionReportResponse::Status400
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GenerateCompetitorsPositionReportResponse::Status401
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GenerateCompetitorsPositionReportResponse::Status403
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GenerateCompetitorsPositionReportResponse::Status420
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(420).expect("Unable to turn 420 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GenerateCompetitorsPositionReportResponse::Status500
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
                            },
                            Err(e) => Ok(Response::builder()
                                                .status(StatusCode::BAD_REQUEST)
                                                .body(Body::from(format!("Unable to read body: {}", e)))
                                                .expect("Unable to create Bad Request response due to unable to read body")),
                        }
            },

            // GenerateGoodsFeedbackReport - POST /reports/goods-feedback/generate
            hyper::Method::POST if path.matched(paths::ID_REPORTS_GOODS_FEEDBACK_GENERATE) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "market:partner-api".to_string(), // API Яндекс.Маркета / Поиска по товарам для партнеров
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Query parameters (note that non-required or collection query parameters will ignore garbage values, rather than causing a 400 response)
                let query_params = form_urlencoded::parse(uri.query().unwrap_or_default().as_bytes()).collect::<Vec<_>>();
                let param_format = query_params.iter().filter(|e| e.0 == "format").map(|e| e.1.clone())
                    .next();
                let param_format = match param_format {
                    Some(param_format) => {
                        let param_format =
                            <models::ReportFormatType as std::str::FromStr>::from_str
                                (&param_format);
                        match param_format {
                            Ok(param_format) => Some(param_format),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter format - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter format")),
                        }
                    },
                    None => None,
                };

                // Handle body parameters (note that non-required body parameters will ignore garbage
                // values, rather than causing a 400 response). Produce warning header and logs for
                // any unused fields.
                let result = body.into_raw().await;
                match result {
                     Ok(body) => {
                                let mut unused_elements : Vec<String> = vec![];
                                let param_generate_goods_feedback_request: Option<models::GenerateGoodsFeedbackRequest> = if !body.is_empty() {
                                    let deserializer = &mut serde_json::Deserializer::from_slice(&*body);
                                    match serde_ignored::deserialize(deserializer, |path| {
                                            warn!("Ignoring unknown field in body: {}", path);
                                            unused_elements.push(path.to_string());
                                    }) {
                                        Ok(param_generate_goods_feedback_request) => param_generate_goods_feedback_request,
                                        Err(e) => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from(format!("Couldn't parse body parameter GenerateGoodsFeedbackRequest - doesn't match schema: {}", e)))
                                                        .expect("Unable to create Bad Request response for invalid body parameter GenerateGoodsFeedbackRequest due to schema")),
                                    }
                                } else {
                                    None
                                };
                                let param_generate_goods_feedback_request = match param_generate_goods_feedback_request {
                                    Some(param_generate_goods_feedback_request) => param_generate_goods_feedback_request,
                                    None => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from("Missing required body parameter GenerateGoodsFeedbackRequest"))
                                                        .expect("Unable to create Bad Request response for missing body parameter GenerateGoodsFeedbackRequest")),
                                };


                                let result = api_impl.generate_goods_feedback_report(
                                            param_generate_goods_feedback_request,
                                            param_format,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        if !unused_elements.is_empty() {
                                            response.headers_mut().insert(
                                                HeaderName::from_static("warning"),
                                                HeaderValue::from_str(format!("Ignoring unknown fields in body: {:?}", unused_elements).as_str())
                                                    .expect("Unable to create Warning header value"));
                                        }
                                        match result {
                                            Ok(rsp) => match rsp {
                                                GenerateGoodsFeedbackReportResponse::Status200
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GenerateGoodsFeedbackReportResponse::Status400
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GenerateGoodsFeedbackReportResponse::Status401
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GenerateGoodsFeedbackReportResponse::Status403
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GenerateGoodsFeedbackReportResponse::Status420
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(420).expect("Unable to turn 420 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GenerateGoodsFeedbackReportResponse::Status500
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
                            },
                            Err(e) => Ok(Response::builder()
                                                .status(StatusCode::BAD_REQUEST)
                                                .body(Body::from(format!("Unable to read body: {}", e)))
                                                .expect("Unable to create Bad Request response due to unable to read body")),
                        }
            },

            // GenerateGoodsMovementReport - POST /reports/goods-movement/generate
            hyper::Method::POST if path.matched(paths::ID_REPORTS_GOODS_MOVEMENT_GENERATE) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "market:partner-api".to_string(), // API Яндекс.Маркета / Поиска по товарам для партнеров
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Query parameters (note that non-required or collection query parameters will ignore garbage values, rather than causing a 400 response)
                let query_params = form_urlencoded::parse(uri.query().unwrap_or_default().as_bytes()).collect::<Vec<_>>();
                let param_format = query_params.iter().filter(|e| e.0 == "format").map(|e| e.1.clone())
                    .next();
                let param_format = match param_format {
                    Some(param_format) => {
                        let param_format =
                            <models::ReportFormatType as std::str::FromStr>::from_str
                                (&param_format);
                        match param_format {
                            Ok(param_format) => Some(param_format),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter format - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter format")),
                        }
                    },
                    None => None,
                };

                // Handle body parameters (note that non-required body parameters will ignore garbage
                // values, rather than causing a 400 response). Produce warning header and logs for
                // any unused fields.
                let result = body.into_raw().await;
                match result {
                     Ok(body) => {
                                let mut unused_elements : Vec<String> = vec![];
                                let param_generate_goods_movement_report_request: Option<models::GenerateGoodsMovementReportRequest> = if !body.is_empty() {
                                    let deserializer = &mut serde_json::Deserializer::from_slice(&*body);
                                    match serde_ignored::deserialize(deserializer, |path| {
                                            warn!("Ignoring unknown field in body: {}", path);
                                            unused_elements.push(path.to_string());
                                    }) {
                                        Ok(param_generate_goods_movement_report_request) => param_generate_goods_movement_report_request,
                                        Err(e) => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from(format!("Couldn't parse body parameter GenerateGoodsMovementReportRequest - doesn't match schema: {}", e)))
                                                        .expect("Unable to create Bad Request response for invalid body parameter GenerateGoodsMovementReportRequest due to schema")),
                                    }
                                } else {
                                    None
                                };
                                let param_generate_goods_movement_report_request = match param_generate_goods_movement_report_request {
                                    Some(param_generate_goods_movement_report_request) => param_generate_goods_movement_report_request,
                                    None => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from("Missing required body parameter GenerateGoodsMovementReportRequest"))
                                                        .expect("Unable to create Bad Request response for missing body parameter GenerateGoodsMovementReportRequest")),
                                };


                                let result = api_impl.generate_goods_movement_report(
                                            param_generate_goods_movement_report_request,
                                            param_format,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        if !unused_elements.is_empty() {
                                            response.headers_mut().insert(
                                                HeaderName::from_static("warning"),
                                                HeaderValue::from_str(format!("Ignoring unknown fields in body: {:?}", unused_elements).as_str())
                                                    .expect("Unable to create Warning header value"));
                                        }
                                        match result {
                                            Ok(rsp) => match rsp {
                                                GenerateGoodsMovementReportResponse::Status200
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GenerateGoodsMovementReportResponse::Status400
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GenerateGoodsMovementReportResponse::Status401
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GenerateGoodsMovementReportResponse::Status403
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GenerateGoodsMovementReportResponse::Status420
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(420).expect("Unable to turn 420 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GenerateGoodsMovementReportResponse::Status500
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
                            },
                            Err(e) => Ok(Response::builder()
                                                .status(StatusCode::BAD_REQUEST)
                                                .body(Body::from(format!("Unable to read body: {}", e)))
                                                .expect("Unable to create Bad Request response due to unable to read body")),
                        }
            },

            // GenerateGoodsRealizationReport - POST /reports/goods-realization/generate
            hyper::Method::POST if path.matched(paths::ID_REPORTS_GOODS_REALIZATION_GENERATE) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "market:partner-api".to_string(), // API Яндекс.Маркета / Поиска по товарам для партнеров
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Query parameters (note that non-required or collection query parameters will ignore garbage values, rather than causing a 400 response)
                let query_params = form_urlencoded::parse(uri.query().unwrap_or_default().as_bytes()).collect::<Vec<_>>();
                let param_format = query_params.iter().filter(|e| e.0 == "format").map(|e| e.1.clone())
                    .next();
                let param_format = match param_format {
                    Some(param_format) => {
                        let param_format =
                            <models::ReportFormatType as std::str::FromStr>::from_str
                                (&param_format);
                        match param_format {
                            Ok(param_format) => Some(param_format),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter format - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter format")),
                        }
                    },
                    None => None,
                };

                // Handle body parameters (note that non-required body parameters will ignore garbage
                // values, rather than causing a 400 response). Produce warning header and logs for
                // any unused fields.
                let result = body.into_raw().await;
                match result {
                     Ok(body) => {
                                let mut unused_elements : Vec<String> = vec![];
                                let param_generate_goods_realization_report_request: Option<models::GenerateGoodsRealizationReportRequest> = if !body.is_empty() {
                                    let deserializer = &mut serde_json::Deserializer::from_slice(&*body);
                                    match serde_ignored::deserialize(deserializer, |path| {
                                            warn!("Ignoring unknown field in body: {}", path);
                                            unused_elements.push(path.to_string());
                                    }) {
                                        Ok(param_generate_goods_realization_report_request) => param_generate_goods_realization_report_request,
                                        Err(e) => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from(format!("Couldn't parse body parameter GenerateGoodsRealizationReportRequest - doesn't match schema: {}", e)))
                                                        .expect("Unable to create Bad Request response for invalid body parameter GenerateGoodsRealizationReportRequest due to schema")),
                                    }
                                } else {
                                    None
                                };
                                let param_generate_goods_realization_report_request = match param_generate_goods_realization_report_request {
                                    Some(param_generate_goods_realization_report_request) => param_generate_goods_realization_report_request,
                                    None => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from("Missing required body parameter GenerateGoodsRealizationReportRequest"))
                                                        .expect("Unable to create Bad Request response for missing body parameter GenerateGoodsRealizationReportRequest")),
                                };


                                let result = api_impl.generate_goods_realization_report(
                                            param_generate_goods_realization_report_request,
                                            param_format,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        if !unused_elements.is_empty() {
                                            response.headers_mut().insert(
                                                HeaderName::from_static("warning"),
                                                HeaderValue::from_str(format!("Ignoring unknown fields in body: {:?}", unused_elements).as_str())
                                                    .expect("Unable to create Warning header value"));
                                        }
                                        match result {
                                            Ok(rsp) => match rsp {
                                                GenerateGoodsRealizationReportResponse::Status200
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GenerateGoodsRealizationReportResponse::Status400
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GenerateGoodsRealizationReportResponse::Status401
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GenerateGoodsRealizationReportResponse::Status403
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GenerateGoodsRealizationReportResponse::Status420
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(420).expect("Unable to turn 420 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GenerateGoodsRealizationReportResponse::Status500
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
                            },
                            Err(e) => Ok(Response::builder()
                                                .status(StatusCode::BAD_REQUEST)
                                                .body(Body::from(format!("Unable to read body: {}", e)))
                                                .expect("Unable to create Bad Request response due to unable to read body")),
                        }
            },

            // GenerateGoodsTurnoverReport - POST /reports/goods-turnover/generate
            hyper::Method::POST if path.matched(paths::ID_REPORTS_GOODS_TURNOVER_GENERATE) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "market:partner-api".to_string(), // API Яндекс.Маркета / Поиска по товарам для партнеров
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Query parameters (note that non-required or collection query parameters will ignore garbage values, rather than causing a 400 response)
                let query_params = form_urlencoded::parse(uri.query().unwrap_or_default().as_bytes()).collect::<Vec<_>>();
                let param_format = query_params.iter().filter(|e| e.0 == "format").map(|e| e.1.clone())
                    .next();
                let param_format = match param_format {
                    Some(param_format) => {
                        let param_format =
                            <models::ReportFormatType as std::str::FromStr>::from_str
                                (&param_format);
                        match param_format {
                            Ok(param_format) => Some(param_format),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter format - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter format")),
                        }
                    },
                    None => None,
                };

                // Handle body parameters (note that non-required body parameters will ignore garbage
                // values, rather than causing a 400 response). Produce warning header and logs for
                // any unused fields.
                let result = body.into_raw().await;
                match result {
                     Ok(body) => {
                                let mut unused_elements : Vec<String> = vec![];
                                let param_generate_goods_turnover_request: Option<models::GenerateGoodsTurnoverRequest> = if !body.is_empty() {
                                    let deserializer = &mut serde_json::Deserializer::from_slice(&*body);
                                    match serde_ignored::deserialize(deserializer, |path| {
                                            warn!("Ignoring unknown field in body: {}", path);
                                            unused_elements.push(path.to_string());
                                    }) {
                                        Ok(param_generate_goods_turnover_request) => param_generate_goods_turnover_request,
                                        Err(e) => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from(format!("Couldn't parse body parameter GenerateGoodsTurnoverRequest - doesn't match schema: {}", e)))
                                                        .expect("Unable to create Bad Request response for invalid body parameter GenerateGoodsTurnoverRequest due to schema")),
                                    }
                                } else {
                                    None
                                };
                                let param_generate_goods_turnover_request = match param_generate_goods_turnover_request {
                                    Some(param_generate_goods_turnover_request) => param_generate_goods_turnover_request,
                                    None => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from("Missing required body parameter GenerateGoodsTurnoverRequest"))
                                                        .expect("Unable to create Bad Request response for missing body parameter GenerateGoodsTurnoverRequest")),
                                };


                                let result = api_impl.generate_goods_turnover_report(
                                            param_generate_goods_turnover_request,
                                            param_format,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        if !unused_elements.is_empty() {
                                            response.headers_mut().insert(
                                                HeaderName::from_static("warning"),
                                                HeaderValue::from_str(format!("Ignoring unknown fields in body: {:?}", unused_elements).as_str())
                                                    .expect("Unable to create Warning header value"));
                                        }
                                        match result {
                                            Ok(rsp) => match rsp {
                                                GenerateGoodsTurnoverReportResponse::Status200
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GenerateGoodsTurnoverReportResponse::Status400
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GenerateGoodsTurnoverReportResponse::Status401
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GenerateGoodsTurnoverReportResponse::Status403
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GenerateGoodsTurnoverReportResponse::Status420
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(420).expect("Unable to turn 420 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GenerateGoodsTurnoverReportResponse::Status500
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
                            },
                            Err(e) => Ok(Response::builder()
                                                .status(StatusCode::BAD_REQUEST)
                                                .body(Body::from(format!("Unable to read body: {}", e)))
                                                .expect("Unable to create Bad Request response due to unable to read body")),
                        }
            },

            // GenerateMassOrderLabelsReport - POST /reports/documents/labels/generate
            hyper::Method::POST if path.matched(paths::ID_REPORTS_DOCUMENTS_LABELS_GENERATE) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "market:partner-api".to_string(), // API Яндекс.Маркета / Поиска по товарам для партнеров
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Query parameters (note that non-required or collection query parameters will ignore garbage values, rather than causing a 400 response)
                let query_params = form_urlencoded::parse(uri.query().unwrap_or_default().as_bytes()).collect::<Vec<_>>();
                let param_format = query_params.iter().filter(|e| e.0 == "format").map(|e| e.1.clone())
                    .next();
                let param_format = match param_format {
                    Some(param_format) => {
                        let param_format =
                            <models::PageFormatType as std::str::FromStr>::from_str
                                (&param_format);
                        match param_format {
                            Ok(param_format) => Some(param_format),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter format - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter format")),
                        }
                    },
                    None => None,
                };

                // Handle body parameters (note that non-required body parameters will ignore garbage
                // values, rather than causing a 400 response). Produce warning header and logs for
                // any unused fields.
                let result = body.into_raw().await;
                match result {
                     Ok(body) => {
                                let mut unused_elements : Vec<String> = vec![];
                                let param_generate_mass_order_labels_request: Option<models::GenerateMassOrderLabelsRequest> = if !body.is_empty() {
                                    let deserializer = &mut serde_json::Deserializer::from_slice(&*body);
                                    match serde_ignored::deserialize(deserializer, |path| {
                                            warn!("Ignoring unknown field in body: {}", path);
                                            unused_elements.push(path.to_string());
                                    }) {
                                        Ok(param_generate_mass_order_labels_request) => param_generate_mass_order_labels_request,
                                        Err(e) => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from(format!("Couldn't parse body parameter GenerateMassOrderLabelsRequest - doesn't match schema: {}", e)))
                                                        .expect("Unable to create Bad Request response for invalid body parameter GenerateMassOrderLabelsRequest due to schema")),
                                    }
                                } else {
                                    None
                                };
                                let param_generate_mass_order_labels_request = match param_generate_mass_order_labels_request {
                                    Some(param_generate_mass_order_labels_request) => param_generate_mass_order_labels_request,
                                    None => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from("Missing required body parameter GenerateMassOrderLabelsRequest"))
                                                        .expect("Unable to create Bad Request response for missing body parameter GenerateMassOrderLabelsRequest")),
                                };


                                let result = api_impl.generate_mass_order_labels_report(
                                            param_generate_mass_order_labels_request,
                                            param_format,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        if !unused_elements.is_empty() {
                                            response.headers_mut().insert(
                                                HeaderName::from_static("warning"),
                                                HeaderValue::from_str(format!("Ignoring unknown fields in body: {:?}", unused_elements).as_str())
                                                    .expect("Unable to create Warning header value"));
                                        }
                                        match result {
                                            Ok(rsp) => match rsp {
                                                GenerateMassOrderLabelsReportResponse::Status200
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GenerateMassOrderLabelsReportResponse::Status400
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GenerateMassOrderLabelsReportResponse::Status401
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GenerateMassOrderLabelsReportResponse::Status403
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GenerateMassOrderLabelsReportResponse::Status420
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(420).expect("Unable to turn 420 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GenerateMassOrderLabelsReportResponse::Status500
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
                            },
                            Err(e) => Ok(Response::builder()
                                                .status(StatusCode::BAD_REQUEST)
                                                .body(Body::from(format!("Unable to read body: {}", e)))
                                                .expect("Unable to create Bad Request response due to unable to read body")),
                        }
            },

            // GeneratePricesReport - POST /reports/prices/generate
            hyper::Method::POST if path.matched(paths::ID_REPORTS_PRICES_GENERATE) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "market:partner-api".to_string(), // API Яндекс.Маркета / Поиска по товарам для партнеров
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Query parameters (note that non-required or collection query parameters will ignore garbage values, rather than causing a 400 response)
                let query_params = form_urlencoded::parse(uri.query().unwrap_or_default().as_bytes()).collect::<Vec<_>>();
                let param_format = query_params.iter().filter(|e| e.0 == "format").map(|e| e.1.clone())
                    .next();
                let param_format = match param_format {
                    Some(param_format) => {
                        let param_format =
                            <models::ReportFormatType as std::str::FromStr>::from_str
                                (&param_format);
                        match param_format {
                            Ok(param_format) => Some(param_format),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter format - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter format")),
                        }
                    },
                    None => None,
                };

                // Handle body parameters (note that non-required body parameters will ignore garbage
                // values, rather than causing a 400 response). Produce warning header and logs for
                // any unused fields.
                let result = body.into_raw().await;
                match result {
                     Ok(body) => {
                                let mut unused_elements : Vec<String> = vec![];
                                let param_generate_prices_report_request: Option<models::GeneratePricesReportRequest> = if !body.is_empty() {
                                    let deserializer = &mut serde_json::Deserializer::from_slice(&*body);
                                    match serde_ignored::deserialize(deserializer, |path| {
                                            warn!("Ignoring unknown field in body: {}", path);
                                            unused_elements.push(path.to_string());
                                    }) {
                                        Ok(param_generate_prices_report_request) => param_generate_prices_report_request,
                                        Err(e) => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from(format!("Couldn't parse body parameter GeneratePricesReportRequest - doesn't match schema: {}", e)))
                                                        .expect("Unable to create Bad Request response for invalid body parameter GeneratePricesReportRequest due to schema")),
                                    }
                                } else {
                                    None
                                };
                                let param_generate_prices_report_request = match param_generate_prices_report_request {
                                    Some(param_generate_prices_report_request) => param_generate_prices_report_request,
                                    None => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from("Missing required body parameter GeneratePricesReportRequest"))
                                                        .expect("Unable to create Bad Request response for missing body parameter GeneratePricesReportRequest")),
                                };


                                let result = api_impl.generate_prices_report(
                                            param_generate_prices_report_request,
                                            param_format,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        if !unused_elements.is_empty() {
                                            response.headers_mut().insert(
                                                HeaderName::from_static("warning"),
                                                HeaderValue::from_str(format!("Ignoring unknown fields in body: {:?}", unused_elements).as_str())
                                                    .expect("Unable to create Warning header value"));
                                        }
                                        match result {
                                            Ok(rsp) => match rsp {
                                                GeneratePricesReportResponse::Status200
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GeneratePricesReportResponse::Status400
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GeneratePricesReportResponse::Status401
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GeneratePricesReportResponse::Status403
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GeneratePricesReportResponse::Status420
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(420).expect("Unable to turn 420 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GeneratePricesReportResponse::Status500
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
                            },
                            Err(e) => Ok(Response::builder()
                                                .status(StatusCode::BAD_REQUEST)
                                                .body(Body::from(format!("Unable to read body: {}", e)))
                                                .expect("Unable to create Bad Request response due to unable to read body")),
                        }
            },

            // GenerateShelfsStatisticsReport - POST /reports/shelf-statistics/generate
            hyper::Method::POST if path.matched(paths::ID_REPORTS_SHELF_STATISTICS_GENERATE) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "market:partner-api".to_string(), // API Яндекс.Маркета / Поиска по товарам для партнеров
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Query parameters (note that non-required or collection query parameters will ignore garbage values, rather than causing a 400 response)
                let query_params = form_urlencoded::parse(uri.query().unwrap_or_default().as_bytes()).collect::<Vec<_>>();
                let param_format = query_params.iter().filter(|e| e.0 == "format").map(|e| e.1.clone())
                    .next();
                let param_format = match param_format {
                    Some(param_format) => {
                        let param_format =
                            <models::ReportFormatType as std::str::FromStr>::from_str
                                (&param_format);
                        match param_format {
                            Ok(param_format) => Some(param_format),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter format - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter format")),
                        }
                    },
                    None => None,
                };

                // Handle body parameters (note that non-required body parameters will ignore garbage
                // values, rather than causing a 400 response). Produce warning header and logs for
                // any unused fields.
                let result = body.into_raw().await;
                match result {
                     Ok(body) => {
                                let mut unused_elements : Vec<String> = vec![];
                                let param_generate_shelfs_statistics_request: Option<models::GenerateShelfsStatisticsRequest> = if !body.is_empty() {
                                    let deserializer = &mut serde_json::Deserializer::from_slice(&*body);
                                    match serde_ignored::deserialize(deserializer, |path| {
                                            warn!("Ignoring unknown field in body: {}", path);
                                            unused_elements.push(path.to_string());
                                    }) {
                                        Ok(param_generate_shelfs_statistics_request) => param_generate_shelfs_statistics_request,
                                        Err(e) => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from(format!("Couldn't parse body parameter GenerateShelfsStatisticsRequest - doesn't match schema: {}", e)))
                                                        .expect("Unable to create Bad Request response for invalid body parameter GenerateShelfsStatisticsRequest due to schema")),
                                    }
                                } else {
                                    None
                                };
                                let param_generate_shelfs_statistics_request = match param_generate_shelfs_statistics_request {
                                    Some(param_generate_shelfs_statistics_request) => param_generate_shelfs_statistics_request,
                                    None => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from("Missing required body parameter GenerateShelfsStatisticsRequest"))
                                                        .expect("Unable to create Bad Request response for missing body parameter GenerateShelfsStatisticsRequest")),
                                };


                                let result = api_impl.generate_shelfs_statistics_report(
                                            param_generate_shelfs_statistics_request,
                                            param_format,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        if !unused_elements.is_empty() {
                                            response.headers_mut().insert(
                                                HeaderName::from_static("warning"),
                                                HeaderValue::from_str(format!("Ignoring unknown fields in body: {:?}", unused_elements).as_str())
                                                    .expect("Unable to create Warning header value"));
                                        }
                                        match result {
                                            Ok(rsp) => match rsp {
                                                GenerateShelfsStatisticsReportResponse::Status200
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GenerateShelfsStatisticsReportResponse::Status400
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GenerateShelfsStatisticsReportResponse::Status401
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GenerateShelfsStatisticsReportResponse::Status403
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GenerateShelfsStatisticsReportResponse::Status420
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(420).expect("Unable to turn 420 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GenerateShelfsStatisticsReportResponse::Status500
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
                            },
                            Err(e) => Ok(Response::builder()
                                                .status(StatusCode::BAD_REQUEST)
                                                .body(Body::from(format!("Unable to read body: {}", e)))
                                                .expect("Unable to create Bad Request response due to unable to read body")),
                        }
            },

            // GenerateShipmentListDocumentReport - POST /reports/documents/shipment-list/generate
            hyper::Method::POST if path.matched(paths::ID_REPORTS_DOCUMENTS_SHIPMENT_LIST_GENERATE) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "market:partner-api".to_string(), // API Яндекс.Маркета / Поиска по товарам для партнеров
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Handle body parameters (note that non-required body parameters will ignore garbage
                // values, rather than causing a 400 response). Produce warning header and logs for
                // any unused fields.
                let result = body.into_raw().await;
                match result {
                     Ok(body) => {
                                let mut unused_elements : Vec<String> = vec![];
                                let param_generate_shipment_list_document_report_request: Option<models::GenerateShipmentListDocumentReportRequest> = if !body.is_empty() {
                                    let deserializer = &mut serde_json::Deserializer::from_slice(&*body);
                                    match serde_ignored::deserialize(deserializer, |path| {
                                            warn!("Ignoring unknown field in body: {}", path);
                                            unused_elements.push(path.to_string());
                                    }) {
                                        Ok(param_generate_shipment_list_document_report_request) => param_generate_shipment_list_document_report_request,
                                        Err(e) => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from(format!("Couldn't parse body parameter GenerateShipmentListDocumentReportRequest - doesn't match schema: {}", e)))
                                                        .expect("Unable to create Bad Request response for invalid body parameter GenerateShipmentListDocumentReportRequest due to schema")),
                                    }
                                } else {
                                    None
                                };
                                let param_generate_shipment_list_document_report_request = match param_generate_shipment_list_document_report_request {
                                    Some(param_generate_shipment_list_document_report_request) => param_generate_shipment_list_document_report_request,
                                    None => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from("Missing required body parameter GenerateShipmentListDocumentReportRequest"))
                                                        .expect("Unable to create Bad Request response for missing body parameter GenerateShipmentListDocumentReportRequest")),
                                };


                                let result = api_impl.generate_shipment_list_document_report(
                                            param_generate_shipment_list_document_report_request,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        if !unused_elements.is_empty() {
                                            response.headers_mut().insert(
                                                HeaderName::from_static("warning"),
                                                HeaderValue::from_str(format!("Ignoring unknown fields in body: {:?}", unused_elements).as_str())
                                                    .expect("Unable to create Warning header value"));
                                        }
                                        match result {
                                            Ok(rsp) => match rsp {
                                                GenerateShipmentListDocumentReportResponse::Status200
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GenerateShipmentListDocumentReportResponse::Status400
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GenerateShipmentListDocumentReportResponse::Status401
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GenerateShipmentListDocumentReportResponse::Status403
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GenerateShipmentListDocumentReportResponse::Status420
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(420).expect("Unable to turn 420 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GenerateShipmentListDocumentReportResponse::Status500
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
                            },
                            Err(e) => Ok(Response::builder()
                                                .status(StatusCode::BAD_REQUEST)
                                                .body(Body::from(format!("Unable to read body: {}", e)))
                                                .expect("Unable to create Bad Request response due to unable to read body")),
                        }
            },

            // GenerateShowsSalesReport - POST /reports/shows-sales/generate
            hyper::Method::POST if path.matched(paths::ID_REPORTS_SHOWS_SALES_GENERATE) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "market:partner-api".to_string(), // API Яндекс.Маркета / Поиска по товарам для партнеров
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Query parameters (note that non-required or collection query parameters will ignore garbage values, rather than causing a 400 response)
                let query_params = form_urlencoded::parse(uri.query().unwrap_or_default().as_bytes()).collect::<Vec<_>>();
                let param_format = query_params.iter().filter(|e| e.0 == "format").map(|e| e.1.clone())
                    .next();
                let param_format = match param_format {
                    Some(param_format) => {
                        let param_format =
                            <models::ReportFormatType as std::str::FromStr>::from_str
                                (&param_format);
                        match param_format {
                            Ok(param_format) => Some(param_format),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter format - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter format")),
                        }
                    },
                    None => None,
                };

                // Handle body parameters (note that non-required body parameters will ignore garbage
                // values, rather than causing a 400 response). Produce warning header and logs for
                // any unused fields.
                let result = body.into_raw().await;
                match result {
                     Ok(body) => {
                                let mut unused_elements : Vec<String> = vec![];
                                let param_generate_shows_sales_report_request: Option<models::GenerateShowsSalesReportRequest> = if !body.is_empty() {
                                    let deserializer = &mut serde_json::Deserializer::from_slice(&*body);
                                    match serde_ignored::deserialize(deserializer, |path| {
                                            warn!("Ignoring unknown field in body: {}", path);
                                            unused_elements.push(path.to_string());
                                    }) {
                                        Ok(param_generate_shows_sales_report_request) => param_generate_shows_sales_report_request,
                                        Err(e) => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from(format!("Couldn't parse body parameter GenerateShowsSalesReportRequest - doesn't match schema: {}", e)))
                                                        .expect("Unable to create Bad Request response for invalid body parameter GenerateShowsSalesReportRequest due to schema")),
                                    }
                                } else {
                                    None
                                };
                                let param_generate_shows_sales_report_request = match param_generate_shows_sales_report_request {
                                    Some(param_generate_shows_sales_report_request) => param_generate_shows_sales_report_request,
                                    None => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from("Missing required body parameter GenerateShowsSalesReportRequest"))
                                                        .expect("Unable to create Bad Request response for missing body parameter GenerateShowsSalesReportRequest")),
                                };


                                let result = api_impl.generate_shows_sales_report(
                                            param_generate_shows_sales_report_request,
                                            param_format,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        if !unused_elements.is_empty() {
                                            response.headers_mut().insert(
                                                HeaderName::from_static("warning"),
                                                HeaderValue::from_str(format!("Ignoring unknown fields in body: {:?}", unused_elements).as_str())
                                                    .expect("Unable to create Warning header value"));
                                        }
                                        match result {
                                            Ok(rsp) => match rsp {
                                                GenerateShowsSalesReportResponse::Status200
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GenerateShowsSalesReportResponse::Status400
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GenerateShowsSalesReportResponse::Status401
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GenerateShowsSalesReportResponse::Status403
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GenerateShowsSalesReportResponse::Status420
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(420).expect("Unable to turn 420 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GenerateShowsSalesReportResponse::Status500
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
                            },
                            Err(e) => Ok(Response::builder()
                                                .status(StatusCode::BAD_REQUEST)
                                                .body(Body::from(format!("Unable to read body: {}", e)))
                                                .expect("Unable to create Bad Request response due to unable to read body")),
                        }
            },

            // GenerateStocksOnWarehousesReport - POST /reports/stocks-on-warehouses/generate
            hyper::Method::POST if path.matched(paths::ID_REPORTS_STOCKS_ON_WAREHOUSES_GENERATE) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "market:partner-api".to_string(), // API Яндекс.Маркета / Поиска по товарам для партнеров
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Query parameters (note that non-required or collection query parameters will ignore garbage values, rather than causing a 400 response)
                let query_params = form_urlencoded::parse(uri.query().unwrap_or_default().as_bytes()).collect::<Vec<_>>();
                let param_format = query_params.iter().filter(|e| e.0 == "format").map(|e| e.1.clone())
                    .next();
                let param_format = match param_format {
                    Some(param_format) => {
                        let param_format =
                            <models::ReportFormatType as std::str::FromStr>::from_str
                                (&param_format);
                        match param_format {
                            Ok(param_format) => Some(param_format),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter format - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter format")),
                        }
                    },
                    None => None,
                };

                // Handle body parameters (note that non-required body parameters will ignore garbage
                // values, rather than causing a 400 response). Produce warning header and logs for
                // any unused fields.
                let result = body.into_raw().await;
                match result {
                     Ok(body) => {
                                let mut unused_elements : Vec<String> = vec![];
                                let param_generate_stocks_on_warehouses_report_request: Option<models::GenerateStocksOnWarehousesReportRequest> = if !body.is_empty() {
                                    let deserializer = &mut serde_json::Deserializer::from_slice(&*body);
                                    match serde_ignored::deserialize(deserializer, |path| {
                                            warn!("Ignoring unknown field in body: {}", path);
                                            unused_elements.push(path.to_string());
                                    }) {
                                        Ok(param_generate_stocks_on_warehouses_report_request) => param_generate_stocks_on_warehouses_report_request,
                                        Err(e) => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from(format!("Couldn't parse body parameter GenerateStocksOnWarehousesReportRequest - doesn't match schema: {}", e)))
                                                        .expect("Unable to create Bad Request response for invalid body parameter GenerateStocksOnWarehousesReportRequest due to schema")),
                                    }
                                } else {
                                    None
                                };
                                let param_generate_stocks_on_warehouses_report_request = match param_generate_stocks_on_warehouses_report_request {
                                    Some(param_generate_stocks_on_warehouses_report_request) => param_generate_stocks_on_warehouses_report_request,
                                    None => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from("Missing required body parameter GenerateStocksOnWarehousesReportRequest"))
                                                        .expect("Unable to create Bad Request response for missing body parameter GenerateStocksOnWarehousesReportRequest")),
                                };


                                let result = api_impl.generate_stocks_on_warehouses_report(
                                            param_generate_stocks_on_warehouses_report_request,
                                            param_format,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        if !unused_elements.is_empty() {
                                            response.headers_mut().insert(
                                                HeaderName::from_static("warning"),
                                                HeaderValue::from_str(format!("Ignoring unknown fields in body: {:?}", unused_elements).as_str())
                                                    .expect("Unable to create Warning header value"));
                                        }
                                        match result {
                                            Ok(rsp) => match rsp {
                                                GenerateStocksOnWarehousesReportResponse::Status200
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GenerateStocksOnWarehousesReportResponse::Status400
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GenerateStocksOnWarehousesReportResponse::Status401
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GenerateStocksOnWarehousesReportResponse::Status403
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GenerateStocksOnWarehousesReportResponse::Status420
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(420).expect("Unable to turn 420 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GenerateStocksOnWarehousesReportResponse::Status500
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
                            },
                            Err(e) => Ok(Response::builder()
                                                .status(StatusCode::BAD_REQUEST)
                                                .body(Body::from(format!("Unable to read body: {}", e)))
                                                .expect("Unable to create Bad Request response due to unable to read body")),
                        }
            },

            // GenerateUnitedMarketplaceServicesReport - POST /reports/united-marketplace-services/generate
            hyper::Method::POST if path.matched(paths::ID_REPORTS_UNITED_MARKETPLACE_SERVICES_GENERATE) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "market:partner-api".to_string(), // API Яндекс.Маркета / Поиска по товарам для партнеров
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Query parameters (note that non-required or collection query parameters will ignore garbage values, rather than causing a 400 response)
                let query_params = form_urlencoded::parse(uri.query().unwrap_or_default().as_bytes()).collect::<Vec<_>>();
                let param_format = query_params.iter().filter(|e| e.0 == "format").map(|e| e.1.clone())
                    .next();
                let param_format = match param_format {
                    Some(param_format) => {
                        let param_format =
                            <models::ReportFormatType as std::str::FromStr>::from_str
                                (&param_format);
                        match param_format {
                            Ok(param_format) => Some(param_format),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter format - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter format")),
                        }
                    },
                    None => None,
                };

                // Handle body parameters (note that non-required body parameters will ignore garbage
                // values, rather than causing a 400 response). Produce warning header and logs for
                // any unused fields.
                let result = body.into_raw().await;
                match result {
                     Ok(body) => {
                                let mut unused_elements : Vec<String> = vec![];
                                let param_generate_united_marketplace_services_report_request: Option<models::GenerateUnitedMarketplaceServicesReportRequest> = if !body.is_empty() {
                                    let deserializer = &mut serde_json::Deserializer::from_slice(&*body);
                                    match serde_ignored::deserialize(deserializer, |path| {
                                            warn!("Ignoring unknown field in body: {}", path);
                                            unused_elements.push(path.to_string());
                                    }) {
                                        Ok(param_generate_united_marketplace_services_report_request) => param_generate_united_marketplace_services_report_request,
                                        Err(e) => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from(format!("Couldn't parse body parameter GenerateUnitedMarketplaceServicesReportRequest - doesn't match schema: {}", e)))
                                                        .expect("Unable to create Bad Request response for invalid body parameter GenerateUnitedMarketplaceServicesReportRequest due to schema")),
                                    }
                                } else {
                                    None
                                };
                                let param_generate_united_marketplace_services_report_request = match param_generate_united_marketplace_services_report_request {
                                    Some(param_generate_united_marketplace_services_report_request) => param_generate_united_marketplace_services_report_request,
                                    None => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from("Missing required body parameter GenerateUnitedMarketplaceServicesReportRequest"))
                                                        .expect("Unable to create Bad Request response for missing body parameter GenerateUnitedMarketplaceServicesReportRequest")),
                                };


                                let result = api_impl.generate_united_marketplace_services_report(
                                            param_generate_united_marketplace_services_report_request,
                                            param_format,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        if !unused_elements.is_empty() {
                                            response.headers_mut().insert(
                                                HeaderName::from_static("warning"),
                                                HeaderValue::from_str(format!("Ignoring unknown fields in body: {:?}", unused_elements).as_str())
                                                    .expect("Unable to create Warning header value"));
                                        }
                                        match result {
                                            Ok(rsp) => match rsp {
                                                GenerateUnitedMarketplaceServicesReportResponse::Status200
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GenerateUnitedMarketplaceServicesReportResponse::Status400
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GenerateUnitedMarketplaceServicesReportResponse::Status401
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GenerateUnitedMarketplaceServicesReportResponse::Status403
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GenerateUnitedMarketplaceServicesReportResponse::Status420
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(420).expect("Unable to turn 420 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GenerateUnitedMarketplaceServicesReportResponse::Status500
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
                            },
                            Err(e) => Ok(Response::builder()
                                                .status(StatusCode::BAD_REQUEST)
                                                .body(Body::from(format!("Unable to read body: {}", e)))
                                                .expect("Unable to create Bad Request response due to unable to read body")),
                        }
            },

            // GenerateUnitedNettingReport - POST /reports/united-netting/generate
            hyper::Method::POST if path.matched(paths::ID_REPORTS_UNITED_NETTING_GENERATE) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "market:partner-api".to_string(), // API Яндекс.Маркета / Поиска по товарам для партнеров
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Query parameters (note that non-required or collection query parameters will ignore garbage values, rather than causing a 400 response)
                let query_params = form_urlencoded::parse(uri.query().unwrap_or_default().as_bytes()).collect::<Vec<_>>();
                let param_format = query_params.iter().filter(|e| e.0 == "format").map(|e| e.1.clone())
                    .next();
                let param_format = match param_format {
                    Some(param_format) => {
                        let param_format =
                            <models::ReportFormatType as std::str::FromStr>::from_str
                                (&param_format);
                        match param_format {
                            Ok(param_format) => Some(param_format),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter format - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter format")),
                        }
                    },
                    None => None,
                };

                // Handle body parameters (note that non-required body parameters will ignore garbage
                // values, rather than causing a 400 response). Produce warning header and logs for
                // any unused fields.
                let result = body.into_raw().await;
                match result {
                     Ok(body) => {
                                let mut unused_elements : Vec<String> = vec![];
                                let param_generate_united_netting_report_request: Option<models::GenerateUnitedNettingReportRequest> = if !body.is_empty() {
                                    let deserializer = &mut serde_json::Deserializer::from_slice(&*body);
                                    match serde_ignored::deserialize(deserializer, |path| {
                                            warn!("Ignoring unknown field in body: {}", path);
                                            unused_elements.push(path.to_string());
                                    }) {
                                        Ok(param_generate_united_netting_report_request) => param_generate_united_netting_report_request,
                                        Err(e) => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from(format!("Couldn't parse body parameter GenerateUnitedNettingReportRequest - doesn't match schema: {}", e)))
                                                        .expect("Unable to create Bad Request response for invalid body parameter GenerateUnitedNettingReportRequest due to schema")),
                                    }
                                } else {
                                    None
                                };
                                let param_generate_united_netting_report_request = match param_generate_united_netting_report_request {
                                    Some(param_generate_united_netting_report_request) => param_generate_united_netting_report_request,
                                    None => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from("Missing required body parameter GenerateUnitedNettingReportRequest"))
                                                        .expect("Unable to create Bad Request response for missing body parameter GenerateUnitedNettingReportRequest")),
                                };


                                let result = api_impl.generate_united_netting_report(
                                            param_generate_united_netting_report_request,
                                            param_format,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        if !unused_elements.is_empty() {
                                            response.headers_mut().insert(
                                                HeaderName::from_static("warning"),
                                                HeaderValue::from_str(format!("Ignoring unknown fields in body: {:?}", unused_elements).as_str())
                                                    .expect("Unable to create Warning header value"));
                                        }
                                        match result {
                                            Ok(rsp) => match rsp {
                                                GenerateUnitedNettingReportResponse::Status200
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GenerateUnitedNettingReportResponse::Status400
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GenerateUnitedNettingReportResponse::Status401
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GenerateUnitedNettingReportResponse::Status403
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GenerateUnitedNettingReportResponse::Status420
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(420).expect("Unable to turn 420 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GenerateUnitedNettingReportResponse::Status500
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
                            },
                            Err(e) => Ok(Response::builder()
                                                .status(StatusCode::BAD_REQUEST)
                                                .body(Body::from(format!("Unable to read body: {}", e)))
                                                .expect("Unable to create Bad Request response due to unable to read body")),
                        }
            },

            // GenerateUnitedOrdersReport - POST /reports/united-orders/generate
            hyper::Method::POST if path.matched(paths::ID_REPORTS_UNITED_ORDERS_GENERATE) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "market:partner-api".to_string(), // API Яндекс.Маркета / Поиска по товарам для партнеров
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Query parameters (note that non-required or collection query parameters will ignore garbage values, rather than causing a 400 response)
                let query_params = form_urlencoded::parse(uri.query().unwrap_or_default().as_bytes()).collect::<Vec<_>>();
                let param_format = query_params.iter().filter(|e| e.0 == "format").map(|e| e.1.clone())
                    .next();
                let param_format = match param_format {
                    Some(param_format) => {
                        let param_format =
                            <models::ReportFormatType as std::str::FromStr>::from_str
                                (&param_format);
                        match param_format {
                            Ok(param_format) => Some(param_format),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter format - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter format")),
                        }
                    },
                    None => None,
                };

                // Handle body parameters (note that non-required body parameters will ignore garbage
                // values, rather than causing a 400 response). Produce warning header and logs for
                // any unused fields.
                let result = body.into_raw().await;
                match result {
                     Ok(body) => {
                                let mut unused_elements : Vec<String> = vec![];
                                let param_generate_united_orders_request: Option<models::GenerateUnitedOrdersRequest> = if !body.is_empty() {
                                    let deserializer = &mut serde_json::Deserializer::from_slice(&*body);
                                    match serde_ignored::deserialize(deserializer, |path| {
                                            warn!("Ignoring unknown field in body: {}", path);
                                            unused_elements.push(path.to_string());
                                    }) {
                                        Ok(param_generate_united_orders_request) => param_generate_united_orders_request,
                                        Err(e) => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from(format!("Couldn't parse body parameter GenerateUnitedOrdersRequest - doesn't match schema: {}", e)))
                                                        .expect("Unable to create Bad Request response for invalid body parameter GenerateUnitedOrdersRequest due to schema")),
                                    }
                                } else {
                                    None
                                };
                                let param_generate_united_orders_request = match param_generate_united_orders_request {
                                    Some(param_generate_united_orders_request) => param_generate_united_orders_request,
                                    None => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from("Missing required body parameter GenerateUnitedOrdersRequest"))
                                                        .expect("Unable to create Bad Request response for missing body parameter GenerateUnitedOrdersRequest")),
                                };


                                let result = api_impl.generate_united_orders_report(
                                            param_generate_united_orders_request,
                                            param_format,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        if !unused_elements.is_empty() {
                                            response.headers_mut().insert(
                                                HeaderName::from_static("warning"),
                                                HeaderValue::from_str(format!("Ignoring unknown fields in body: {:?}", unused_elements).as_str())
                                                    .expect("Unable to create Warning header value"));
                                        }
                                        match result {
                                            Ok(rsp) => match rsp {
                                                GenerateUnitedOrdersReportResponse::Status200
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GenerateUnitedOrdersReportResponse::Status400
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GenerateUnitedOrdersReportResponse::Status401
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GenerateUnitedOrdersReportResponse::Status403
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GenerateUnitedOrdersReportResponse::Status420
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(420).expect("Unable to turn 420 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GenerateUnitedOrdersReportResponse::Status500
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
                            },
                            Err(e) => Ok(Response::builder()
                                                .status(StatusCode::BAD_REQUEST)
                                                .body(Body::from(format!("Unable to read body: {}", e)))
                                                .expect("Unable to create Bad Request response due to unable to read body")),
                        }
            },

            // GetReportInfo - GET /reports/info/{reportId}
            hyper::Method::GET if path.matched(paths::ID_REPORTS_INFO_REPORTID) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "market:partner-api".to_string(), // API Яндекс.Маркета / Поиска по товарам для партнеров
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_REPORTS_INFO_REPORTID
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE REPORTS_INFO_REPORTID in set but failed match against \"{}\"", path, paths::REGEX_REPORTS_INFO_REPORTID.as_str())
                    );

                let param_report_id = match percent_encoding::percent_decode(path_params["reportId"].as_bytes()).decode_utf8() {
                    Ok(param_report_id) => match param_report_id.parse::<String>() {
                        Ok(param_report_id) => param_report_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter reportId: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["reportId"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                                let result = api_impl.get_report_info(
                                            param_report_id,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                GetReportInfoResponse::Status200
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetReportInfoResponse::Status400
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetReportInfoResponse::Status401
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetReportInfoResponse::Status403
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetReportInfoResponse::Status404
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetReportInfoResponse::Status420
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(420).expect("Unable to turn 420 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetReportInfoResponse::Status500
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
            },

            // GetReturns - GET /campaigns/{campaignId}/returns
            hyper::Method::GET if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_RETURNS) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "market:partner-api".to_string(), // API Яндекс.Маркета / Поиска по товарам для партнеров
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_CAMPAIGNS_CAMPAIGNID_RETURNS
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE CAMPAIGNS_CAMPAIGNID_RETURNS in set but failed match against \"{}\"", path, paths::REGEX_CAMPAIGNS_CAMPAIGNID_RETURNS.as_str())
                    );

                let param_campaign_id = match percent_encoding::percent_decode(path_params["campaignId"].as_bytes()).decode_utf8() {
                    Ok(param_campaign_id) => match param_campaign_id.parse::<i64>() {
                        Ok(param_campaign_id) => param_campaign_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter campaignId: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["campaignId"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                // Query parameters (note that non-required or collection query parameters will ignore garbage values, rather than causing a 400 response)
                let query_params = form_urlencoded::parse(uri.query().unwrap_or_default().as_bytes()).collect::<Vec<_>>();
                let param_page_token = query_params.iter().filter(|e| e.0 == "page_token").map(|e| e.1.clone())
                    .next();
                let param_page_token = match param_page_token {
                    Some(param_page_token) => {
                        let param_page_token =
                            <String as std::str::FromStr>::from_str
                                (&param_page_token);
                        match param_page_token {
                            Ok(param_page_token) => Some(param_page_token),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter page_token - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter page_token")),
                        }
                    },
                    None => None,
                };
                let param_limit = query_params.iter().filter(|e| e.0 == "limit").map(|e| e.1.clone())
                    .next();
                let param_limit = match param_limit {
                    Some(param_limit) => {
                        let param_limit =
                            <i32 as std::str::FromStr>::from_str
                                (&param_limit);
                        match param_limit {
                            Ok(param_limit) => Some(param_limit),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter limit - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter limit")),
                        }
                    },
                    None => None,
                };
                let param_order_ids = query_params.iter().filter(|e| e.0 == "orderIds").map(|e| e.1.clone())
                    .filter_map(|param_order_ids| param_order_ids.parse().ok())
                    .collect::<Vec<_>>();
                let param_order_ids = if !param_order_ids.is_empty() {
                    Some(param_order_ids)
                } else {
                    None
                };
                let param_statuses = query_params.iter().filter(|e| e.0 == "statuses").map(|e| e.1.clone())
                    .filter_map(|param_statuses| param_statuses.parse().ok())
                    .collect::<Vec<_>>();
                let param_statuses = if !param_statuses.is_empty() {
                    Some(param_statuses)
                } else {
                    None
                };
                let param_r#type = query_params.iter().filter(|e| e.0 == "type").map(|e| e.1.clone())
                    .next();
                let param_r#type = match param_r#type {
                    Some(param_r#type) => {
                        let param_r#type =
                            <models::ReturnType as std::str::FromStr>::from_str
                                (&param_r#type);
                        match param_r#type {
                            Ok(param_r#type) => Some(param_r#type),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter type - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter type")),
                        }
                    },
                    None => None,
                };
                let param_from_date = query_params.iter().filter(|e| e.0 == "fromDate").map(|e| e.1.clone())
                    .next();
                let param_from_date = match param_from_date {
                    Some(param_from_date) => {
                        let param_from_date =
                            <chrono::naive::NaiveDate as std::str::FromStr>::from_str
                                (&param_from_date);
                        match param_from_date {
                            Ok(param_from_date) => Some(param_from_date),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter fromDate - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter fromDate")),
                        }
                    },
                    None => None,
                };
                let param_to_date = query_params.iter().filter(|e| e.0 == "toDate").map(|e| e.1.clone())
                    .next();
                let param_to_date = match param_to_date {
                    Some(param_to_date) => {
                        let param_to_date =
                            <chrono::naive::NaiveDate as std::str::FromStr>::from_str
                                (&param_to_date);
                        match param_to_date {
                            Ok(param_to_date) => Some(param_to_date),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter toDate - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter toDate")),
                        }
                    },
                    None => None,
                };
                let param_from_date2 = query_params.iter().filter(|e| e.0 == "from_date").map(|e| e.1.clone())
                    .next();
                let param_from_date2 = match param_from_date2 {
                    Some(param_from_date2) => {
                        let param_from_date2 =
                            <chrono::naive::NaiveDate as std::str::FromStr>::from_str
                                (&param_from_date2);
                        match param_from_date2 {
                            Ok(param_from_date2) => Some(param_from_date2),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter from_date - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter from_date")),
                        }
                    },
                    None => None,
                };
                let param_to_date2 = query_params.iter().filter(|e| e.0 == "to_date").map(|e| e.1.clone())
                    .next();
                let param_to_date2 = match param_to_date2 {
                    Some(param_to_date2) => {
                        let param_to_date2 =
                            <chrono::naive::NaiveDate as std::str::FromStr>::from_str
                                (&param_to_date2);
                        match param_to_date2 {
                            Ok(param_to_date2) => Some(param_to_date2),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter to_date - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter to_date")),
                        }
                    },
                    None => None,
                };

                                let result = api_impl.get_returns(
                                            param_campaign_id,
                                            param_page_token,
                                            param_limit,
                                            param_order_ids.as_ref(),
                                            param_statuses.as_ref(),
                                            param_r#type,
                                            param_from_date,
                                            param_to_date,
                                            param_from_date2,
                                            param_to_date2,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                GetReturnsResponse::Status200
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetReturnsResponse::Status400
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetReturnsResponse::Status401
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetReturnsResponse::Status403
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetReturnsResponse::Status404
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetReturnsResponse::Status420
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(420).expect("Unable to turn 420 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetReturnsResponse::Status500
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
            },

            // GetReturn - GET /campaigns/{campaignId}/orders/{orderId}/returns/{returnId}
            hyper::Method::GET if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_RETURNS_RETURNID) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "market:partner-api".to_string(), // API Яндекс.Маркета / Поиска по товарам для партнеров
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_RETURNS_RETURNID
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_RETURNS_RETURNID in set but failed match against \"{}\"", path, paths::REGEX_CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_RETURNS_RETURNID.as_str())
                    );

                let param_campaign_id = match percent_encoding::percent_decode(path_params["campaignId"].as_bytes()).decode_utf8() {
                    Ok(param_campaign_id) => match param_campaign_id.parse::<i64>() {
                        Ok(param_campaign_id) => param_campaign_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter campaignId: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["campaignId"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                let param_order_id = match percent_encoding::percent_decode(path_params["orderId"].as_bytes()).decode_utf8() {
                    Ok(param_order_id) => match param_order_id.parse::<i64>() {
                        Ok(param_order_id) => param_order_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter orderId: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["orderId"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                let param_return_id = match percent_encoding::percent_decode(path_params["returnId"].as_bytes()).decode_utf8() {
                    Ok(param_return_id) => match param_return_id.parse::<i64>() {
                        Ok(param_return_id) => param_return_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter returnId: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["returnId"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                                let result = api_impl.get_return(
                                            param_campaign_id,
                                            param_order_id,
                                            param_return_id,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                GetReturnResponse::Status200
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetReturnResponse::Status400
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetReturnResponse::Status401
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetReturnResponse::Status403
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetReturnResponse::Status404
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetReturnResponse::Status420
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(420).expect("Unable to turn 420 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetReturnResponse::Status500
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
            },

            // GetReturnApplication - GET /campaigns/{campaignId}/orders/{orderId}/returns/{returnId}/application
            hyper::Method::GET if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_RETURNS_RETURNID_APPLICATION) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "market:partner-api".to_string(), // API Яндекс.Маркета / Поиска по товарам для партнеров
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_RETURNS_RETURNID_APPLICATION
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_RETURNS_RETURNID_APPLICATION in set but failed match against \"{}\"", path, paths::REGEX_CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_RETURNS_RETURNID_APPLICATION.as_str())
                    );

                let param_campaign_id = match percent_encoding::percent_decode(path_params["campaignId"].as_bytes()).decode_utf8() {
                    Ok(param_campaign_id) => match param_campaign_id.parse::<i64>() {
                        Ok(param_campaign_id) => param_campaign_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter campaignId: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["campaignId"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                let param_order_id = match percent_encoding::percent_decode(path_params["orderId"].as_bytes()).decode_utf8() {
                    Ok(param_order_id) => match param_order_id.parse::<i64>() {
                        Ok(param_order_id) => param_order_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter orderId: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["orderId"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                let param_return_id = match percent_encoding::percent_decode(path_params["returnId"].as_bytes()).decode_utf8() {
                    Ok(param_return_id) => match param_return_id.parse::<i64>() {
                        Ok(param_return_id) => param_return_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter returnId: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["returnId"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                                let result = api_impl.get_return_application(
                                            param_campaign_id,
                                            param_order_id,
                                            param_return_id,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                GetReturnApplicationResponse::Status200
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/octet-stream")
                                                            .expect("Unable to create Content-Type header for application/octet-stream"));
                                                    // Binary Body
                                                    let body = body.0;
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetReturnApplicationResponse::Status400
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetReturnApplicationResponse::Status401
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetReturnApplicationResponse::Status403
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetReturnApplicationResponse::Status404
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetReturnApplicationResponse::Status420
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(420).expect("Unable to turn 420 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetReturnApplicationResponse::Status500
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
            },

            // SetReturnDecision - POST /campaigns/{campaignId}/orders/{orderId}/returns/{returnId}/decision
            hyper::Method::POST if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_RETURNS_RETURNID_DECISION) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "market:partner-api".to_string(), // API Яндекс.Маркета / Поиска по товарам для партнеров
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_RETURNS_RETURNID_DECISION
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_RETURNS_RETURNID_DECISION in set but failed match against \"{}\"", path, paths::REGEX_CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_RETURNS_RETURNID_DECISION.as_str())
                    );

                let param_campaign_id = match percent_encoding::percent_decode(path_params["campaignId"].as_bytes()).decode_utf8() {
                    Ok(param_campaign_id) => match param_campaign_id.parse::<i64>() {
                        Ok(param_campaign_id) => param_campaign_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter campaignId: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["campaignId"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                let param_order_id = match percent_encoding::percent_decode(path_params["orderId"].as_bytes()).decode_utf8() {
                    Ok(param_order_id) => match param_order_id.parse::<i64>() {
                        Ok(param_order_id) => param_order_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter orderId: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["orderId"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                let param_return_id = match percent_encoding::percent_decode(path_params["returnId"].as_bytes()).decode_utf8() {
                    Ok(param_return_id) => match param_return_id.parse::<i64>() {
                        Ok(param_return_id) => param_return_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter returnId: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["returnId"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                // Handle body parameters (note that non-required body parameters will ignore garbage
                // values, rather than causing a 400 response). Produce warning header and logs for
                // any unused fields.
                let result = body.into_raw().await;
                match result {
                     Ok(body) => {
                                let mut unused_elements : Vec<String> = vec![];
                                let param_set_return_decision_request: Option<models::SetReturnDecisionRequest> = if !body.is_empty() {
                                    let deserializer = &mut serde_json::Deserializer::from_slice(&*body);
                                    match serde_ignored::deserialize(deserializer, |path| {
                                            warn!("Ignoring unknown field in body: {}", path);
                                            unused_elements.push(path.to_string());
                                    }) {
                                        Ok(param_set_return_decision_request) => param_set_return_decision_request,
                                        Err(e) => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from(format!("Couldn't parse body parameter SetReturnDecisionRequest - doesn't match schema: {}", e)))
                                                        .expect("Unable to create Bad Request response for invalid body parameter SetReturnDecisionRequest due to schema")),
                                    }
                                } else {
                                    None
                                };
                                let param_set_return_decision_request = match param_set_return_decision_request {
                                    Some(param_set_return_decision_request) => param_set_return_decision_request,
                                    None => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from("Missing required body parameter SetReturnDecisionRequest"))
                                                        .expect("Unable to create Bad Request response for missing body parameter SetReturnDecisionRequest")),
                                };


                                let result = api_impl.set_return_decision(
                                            param_campaign_id,
                                            param_order_id,
                                            param_return_id,
                                            param_set_return_decision_request,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        if !unused_elements.is_empty() {
                                            response.headers_mut().insert(
                                                HeaderName::from_static("warning"),
                                                HeaderValue::from_str(format!("Ignoring unknown fields in body: {:?}", unused_elements).as_str())
                                                    .expect("Unable to create Warning header value"));
                                        }
                                        match result {
                                            Ok(rsp) => match rsp {
                                                SetReturnDecisionResponse::Status200
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                SetReturnDecisionResponse::Status400
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                SetReturnDecisionResponse::Status401
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                SetReturnDecisionResponse::Status403
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                SetReturnDecisionResponse::Status404
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                SetReturnDecisionResponse::Status420
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(420).expect("Unable to turn 420 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                SetReturnDecisionResponse::Status500
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
                            },
                            Err(e) => Ok(Response::builder()
                                                .status(StatusCode::BAD_REQUEST)
                                                .body(Body::from(format!("Unable to read body: {}", e)))
                                                .expect("Unable to create Bad Request response due to unable to read body")),
                        }
            },

            // SubmitReturnDecision - POST /campaigns/{campaignId}/orders/{orderId}/returns/{returnId}/decision/submit
            hyper::Method::POST if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_RETURNS_RETURNID_DECISION_SUBMIT) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "market:partner-api".to_string(), // API Яндекс.Маркета / Поиска по товарам для партнеров
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_RETURNS_RETURNID_DECISION_SUBMIT
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_RETURNS_RETURNID_DECISION_SUBMIT in set but failed match against \"{}\"", path, paths::REGEX_CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_RETURNS_RETURNID_DECISION_SUBMIT.as_str())
                    );

                let param_campaign_id = match percent_encoding::percent_decode(path_params["campaignId"].as_bytes()).decode_utf8() {
                    Ok(param_campaign_id) => match param_campaign_id.parse::<i64>() {
                        Ok(param_campaign_id) => param_campaign_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter campaignId: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["campaignId"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                let param_order_id = match percent_encoding::percent_decode(path_params["orderId"].as_bytes()).decode_utf8() {
                    Ok(param_order_id) => match param_order_id.parse::<i64>() {
                        Ok(param_order_id) => param_order_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter orderId: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["orderId"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                let param_return_id = match percent_encoding::percent_decode(path_params["returnId"].as_bytes()).decode_utf8() {
                    Ok(param_return_id) => match param_return_id.parse::<i64>() {
                        Ok(param_return_id) => param_return_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter returnId: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["returnId"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                                let result = api_impl.submit_return_decision(
                                            param_campaign_id,
                                            param_order_id,
                                            param_return_id,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                SubmitReturnDecisionResponse::Status200
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                SubmitReturnDecisionResponse::Status400
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                SubmitReturnDecisionResponse::Status401
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                SubmitReturnDecisionResponse::Status403
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                SubmitReturnDecisionResponse::Status404
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                SubmitReturnDecisionResponse::Status420
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(420).expect("Unable to turn 420 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                SubmitReturnDecisionResponse::Status500
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
            },

            // GetReturnPhoto - GET /campaigns/{campaignId}/orders/{orderId}/returns/{returnId}/decision/{itemId}/image/{imageHash}
            hyper::Method::GET if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_RETURNS_RETURNID_DECISION_ITEMID_IMAGE_IMAGEHASH) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "market:partner-api".to_string(), // API Яндекс.Маркета / Поиска по товарам для партнеров
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_RETURNS_RETURNID_DECISION_ITEMID_IMAGE_IMAGEHASH
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_RETURNS_RETURNID_DECISION_ITEMID_IMAGE_IMAGEHASH in set but failed match against \"{}\"", path, paths::REGEX_CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_RETURNS_RETURNID_DECISION_ITEMID_IMAGE_IMAGEHASH.as_str())
                    );

                let param_campaign_id = match percent_encoding::percent_decode(path_params["campaignId"].as_bytes()).decode_utf8() {
                    Ok(param_campaign_id) => match param_campaign_id.parse::<i64>() {
                        Ok(param_campaign_id) => param_campaign_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter campaignId: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["campaignId"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                let param_order_id = match percent_encoding::percent_decode(path_params["orderId"].as_bytes()).decode_utf8() {
                    Ok(param_order_id) => match param_order_id.parse::<i64>() {
                        Ok(param_order_id) => param_order_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter orderId: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["orderId"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                let param_return_id = match percent_encoding::percent_decode(path_params["returnId"].as_bytes()).decode_utf8() {
                    Ok(param_return_id) => match param_return_id.parse::<i64>() {
                        Ok(param_return_id) => param_return_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter returnId: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["returnId"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                let param_item_id = match percent_encoding::percent_decode(path_params["itemId"].as_bytes()).decode_utf8() {
                    Ok(param_item_id) => match param_item_id.parse::<i64>() {
                        Ok(param_item_id) => param_item_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter itemId: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["itemId"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                let param_image_hash = match percent_encoding::percent_decode(path_params["imageHash"].as_bytes()).decode_utf8() {
                    Ok(param_image_hash) => match param_image_hash.parse::<String>() {
                        Ok(param_image_hash) => param_image_hash,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter imageHash: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["imageHash"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                                let result = api_impl.get_return_photo(
                                            param_campaign_id,
                                            param_order_id,
                                            param_return_id,
                                            param_item_id,
                                            param_image_hash,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                GetReturnPhotoResponse::Status200
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/octet-stream")
                                                            .expect("Unable to create Content-Type header for application/octet-stream"));
                                                    // Binary Body
                                                    let body = body.0;
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetReturnPhotoResponse::Status400
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetReturnPhotoResponse::Status401
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetReturnPhotoResponse::Status403
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetReturnPhotoResponse::Status404
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetReturnPhotoResponse::Status420
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(420).expect("Unable to turn 420 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetReturnPhotoResponse::Status500
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
            },

            // DownloadShipmentReceptionTransferAct - GET /campaigns/{campaignId}/shipments/reception-transfer-act
            hyper::Method::GET if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_SHIPMENTS_RECEPTION_TRANSFER_ACT) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "market:partner-api".to_string(), // API Яндекс.Маркета / Поиска по товарам для партнеров
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_CAMPAIGNS_CAMPAIGNID_SHIPMENTS_RECEPTION_TRANSFER_ACT
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE CAMPAIGNS_CAMPAIGNID_SHIPMENTS_RECEPTION_TRANSFER_ACT in set but failed match against \"{}\"", path, paths::REGEX_CAMPAIGNS_CAMPAIGNID_SHIPMENTS_RECEPTION_TRANSFER_ACT.as_str())
                    );

                let param_campaign_id = match percent_encoding::percent_decode(path_params["campaignId"].as_bytes()).decode_utf8() {
                    Ok(param_campaign_id) => match param_campaign_id.parse::<i64>() {
                        Ok(param_campaign_id) => param_campaign_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter campaignId: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["campaignId"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                // Query parameters (note that non-required or collection query parameters will ignore garbage values, rather than causing a 400 response)
                let query_params = form_urlencoded::parse(uri.query().unwrap_or_default().as_bytes()).collect::<Vec<_>>();
                let param_warehouse_id = query_params.iter().filter(|e| e.0 == "warehouse_id").map(|e| e.1.clone())
                    .next();
                let param_warehouse_id = match param_warehouse_id {
                    Some(param_warehouse_id) => {
                        let param_warehouse_id =
                            <i32 as std::str::FromStr>::from_str
                                (&param_warehouse_id);
                        match param_warehouse_id {
                            Ok(param_warehouse_id) => Some(param_warehouse_id),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter warehouse_id - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter warehouse_id")),
                        }
                    },
                    None => None,
                };

                                let result = api_impl.download_shipment_reception_transfer_act(
                                            param_campaign_id,
                                            param_warehouse_id,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                DownloadShipmentReceptionTransferActResponse::Status200
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/pdf")
                                                            .expect("Unable to create Content-Type header for application/pdf"));
                                                    // Binary Body
                                                    let body = body.0;
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                DownloadShipmentReceptionTransferActResponse::Status400
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                DownloadShipmentReceptionTransferActResponse::Status401
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                DownloadShipmentReceptionTransferActResponse::Status403
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                DownloadShipmentReceptionTransferActResponse::Status404
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                DownloadShipmentReceptionTransferActResponse::Status420
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(420).expect("Unable to turn 420 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                DownloadShipmentReceptionTransferActResponse::Status500
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
            },

            // SearchShipments - PUT /campaigns/{campaignId}/first-mile/shipments
            hyper::Method::PUT if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_FIRST_MILE_SHIPMENTS) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "market:partner-api".to_string(), // API Яндекс.Маркета / Поиска по товарам для партнеров
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_CAMPAIGNS_CAMPAIGNID_FIRST_MILE_SHIPMENTS
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE CAMPAIGNS_CAMPAIGNID_FIRST_MILE_SHIPMENTS in set but failed match against \"{}\"", path, paths::REGEX_CAMPAIGNS_CAMPAIGNID_FIRST_MILE_SHIPMENTS.as_str())
                    );

                let param_campaign_id = match percent_encoding::percent_decode(path_params["campaignId"].as_bytes()).decode_utf8() {
                    Ok(param_campaign_id) => match param_campaign_id.parse::<i64>() {
                        Ok(param_campaign_id) => param_campaign_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter campaignId: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["campaignId"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                // Query parameters (note that non-required or collection query parameters will ignore garbage values, rather than causing a 400 response)
                let query_params = form_urlencoded::parse(uri.query().unwrap_or_default().as_bytes()).collect::<Vec<_>>();
                let param_page_token = query_params.iter().filter(|e| e.0 == "page_token").map(|e| e.1.clone())
                    .next();
                let param_page_token = match param_page_token {
                    Some(param_page_token) => {
                        let param_page_token =
                            <String as std::str::FromStr>::from_str
                                (&param_page_token);
                        match param_page_token {
                            Ok(param_page_token) => Some(param_page_token),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter page_token - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter page_token")),
                        }
                    },
                    None => None,
                };
                let param_limit = query_params.iter().filter(|e| e.0 == "limit").map(|e| e.1.clone())
                    .next();
                let param_limit = match param_limit {
                    Some(param_limit) => {
                        let param_limit =
                            <i32 as std::str::FromStr>::from_str
                                (&param_limit);
                        match param_limit {
                            Ok(param_limit) => Some(param_limit),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter limit - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter limit")),
                        }
                    },
                    None => None,
                };

                // Handle body parameters (note that non-required body parameters will ignore garbage
                // values, rather than causing a 400 response). Produce warning header and logs for
                // any unused fields.
                let result = body.into_raw().await;
                match result {
                     Ok(body) => {
                                let mut unused_elements : Vec<String> = vec![];
                                let param_search_shipments_request: Option<models::SearchShipmentsRequest> = if !body.is_empty() {
                                    let deserializer = &mut serde_json::Deserializer::from_slice(&*body);
                                    match serde_ignored::deserialize(deserializer, |path| {
                                            warn!("Ignoring unknown field in body: {}", path);
                                            unused_elements.push(path.to_string());
                                    }) {
                                        Ok(param_search_shipments_request) => param_search_shipments_request,
                                        Err(e) => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from(format!("Couldn't parse body parameter SearchShipmentsRequest - doesn't match schema: {}", e)))
                                                        .expect("Unable to create Bad Request response for invalid body parameter SearchShipmentsRequest due to schema")),
                                    }
                                } else {
                                    None
                                };
                                let param_search_shipments_request = match param_search_shipments_request {
                                    Some(param_search_shipments_request) => param_search_shipments_request,
                                    None => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from("Missing required body parameter SearchShipmentsRequest"))
                                                        .expect("Unable to create Bad Request response for missing body parameter SearchShipmentsRequest")),
                                };


                                let result = api_impl.search_shipments(
                                            param_campaign_id,
                                            param_search_shipments_request,
                                            param_page_token,
                                            param_limit,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        if !unused_elements.is_empty() {
                                            response.headers_mut().insert(
                                                HeaderName::from_static("warning"),
                                                HeaderValue::from_str(format!("Ignoring unknown fields in body: {:?}", unused_elements).as_str())
                                                    .expect("Unable to create Warning header value"));
                                        }
                                        match result {
                                            Ok(rsp) => match rsp {
                                                SearchShipmentsResponse::Status200
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                SearchShipmentsResponse::Status400
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                SearchShipmentsResponse::Status401
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                SearchShipmentsResponse::Status403
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                SearchShipmentsResponse::Status404
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                SearchShipmentsResponse::Status420
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(420).expect("Unable to turn 420 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                SearchShipmentsResponse::Status500
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
                            },
                            Err(e) => Ok(Response::builder()
                                                .status(StatusCode::BAD_REQUEST)
                                                .body(Body::from(format!("Unable to read body: {}", e)))
                                                .expect("Unable to create Bad Request response due to unable to read body")),
                        }
            },

            // ConfirmShipment - POST /campaigns/{campaignId}/first-mile/shipments/{shipmentId}/confirm
            hyper::Method::POST if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_FIRST_MILE_SHIPMENTS_SHIPMENTID_CONFIRM) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "market:partner-api".to_string(), // API Яндекс.Маркета / Поиска по товарам для партнеров
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_CAMPAIGNS_CAMPAIGNID_FIRST_MILE_SHIPMENTS_SHIPMENTID_CONFIRM
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE CAMPAIGNS_CAMPAIGNID_FIRST_MILE_SHIPMENTS_SHIPMENTID_CONFIRM in set but failed match against \"{}\"", path, paths::REGEX_CAMPAIGNS_CAMPAIGNID_FIRST_MILE_SHIPMENTS_SHIPMENTID_CONFIRM.as_str())
                    );

                let param_campaign_id = match percent_encoding::percent_decode(path_params["campaignId"].as_bytes()).decode_utf8() {
                    Ok(param_campaign_id) => match param_campaign_id.parse::<i64>() {
                        Ok(param_campaign_id) => param_campaign_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter campaignId: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["campaignId"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                let param_shipment_id = match percent_encoding::percent_decode(path_params["shipmentId"].as_bytes()).decode_utf8() {
                    Ok(param_shipment_id) => match param_shipment_id.parse::<i64>() {
                        Ok(param_shipment_id) => param_shipment_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter shipmentId: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["shipmentId"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                // Handle body parameters (note that non-required body parameters will ignore garbage
                // values, rather than causing a 400 response). Produce warning header and logs for
                // any unused fields.
                let result = body.into_raw().await;
                match result {
                     Ok(body) => {
                                let mut unused_elements : Vec<String> = vec![];
                                let param_confirm_shipment_request: Option<models::ConfirmShipmentRequest> = if !body.is_empty() {
                                    let deserializer = &mut serde_json::Deserializer::from_slice(&*body);
                                    match serde_ignored::deserialize(deserializer, |path| {
                                            warn!("Ignoring unknown field in body: {}", path);
                                            unused_elements.push(path.to_string());
                                    }) {
                                        Ok(param_confirm_shipment_request) => param_confirm_shipment_request,
                                        Err(_) => None,
                                    }
                                } else {
                                    None
                                };


                                let result = api_impl.confirm_shipment(
                                            param_campaign_id,
                                            param_shipment_id,
                                            param_confirm_shipment_request,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        if !unused_elements.is_empty() {
                                            response.headers_mut().insert(
                                                HeaderName::from_static("warning"),
                                                HeaderValue::from_str(format!("Ignoring unknown fields in body: {:?}", unused_elements).as_str())
                                                    .expect("Unable to create Warning header value"));
                                        }
                                        match result {
                                            Ok(rsp) => match rsp {
                                                ConfirmShipmentResponse::Status200
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                ConfirmShipmentResponse::Status400
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                ConfirmShipmentResponse::Status401
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                ConfirmShipmentResponse::Status403
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                ConfirmShipmentResponse::Status404
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                ConfirmShipmentResponse::Status420
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(420).expect("Unable to turn 420 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                ConfirmShipmentResponse::Status500
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
                            },
                            Err(e) => Ok(Response::builder()
                                                .status(StatusCode::BAD_REQUEST)
                                                .body(Body::from(format!("Unable to read body: {}", e)))
                                                .expect("Unable to create Bad Request response due to unable to read body")),
                        }
            },

            // DownloadShipmentAct - GET /campaigns/{campaignId}/first-mile/shipments/{shipmentId}/act
            hyper::Method::GET if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_FIRST_MILE_SHIPMENTS_SHIPMENTID_ACT) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "market:partner-api".to_string(), // API Яндекс.Маркета / Поиска по товарам для партнеров
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_CAMPAIGNS_CAMPAIGNID_FIRST_MILE_SHIPMENTS_SHIPMENTID_ACT
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE CAMPAIGNS_CAMPAIGNID_FIRST_MILE_SHIPMENTS_SHIPMENTID_ACT in set but failed match against \"{}\"", path, paths::REGEX_CAMPAIGNS_CAMPAIGNID_FIRST_MILE_SHIPMENTS_SHIPMENTID_ACT.as_str())
                    );

                let param_campaign_id = match percent_encoding::percent_decode(path_params["campaignId"].as_bytes()).decode_utf8() {
                    Ok(param_campaign_id) => match param_campaign_id.parse::<i64>() {
                        Ok(param_campaign_id) => param_campaign_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter campaignId: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["campaignId"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                let param_shipment_id = match percent_encoding::percent_decode(path_params["shipmentId"].as_bytes()).decode_utf8() {
                    Ok(param_shipment_id) => match param_shipment_id.parse::<i64>() {
                        Ok(param_shipment_id) => param_shipment_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter shipmentId: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["shipmentId"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                                let result = api_impl.download_shipment_act(
                                            param_campaign_id,
                                            param_shipment_id,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                DownloadShipmentActResponse::Status200
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/pdf")
                                                            .expect("Unable to create Content-Type header for application/pdf"));
                                                    // Binary Body
                                                    let body = body.0;
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                DownloadShipmentActResponse::Status400
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                DownloadShipmentActResponse::Status401
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                DownloadShipmentActResponse::Status403
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                DownloadShipmentActResponse::Status404
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                DownloadShipmentActResponse::Status420
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(420).expect("Unable to turn 420 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                DownloadShipmentActResponse::Status500
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
            },

            // DownloadShipmentDiscrepancyAct - GET /campaigns/{campaignId}/first-mile/shipments/{shipmentId}/discrepancy-act
            hyper::Method::GET if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_FIRST_MILE_SHIPMENTS_SHIPMENTID_DISCREPANCY_ACT) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "market:partner-api".to_string(), // API Яндекс.Маркета / Поиска по товарам для партнеров
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_CAMPAIGNS_CAMPAIGNID_FIRST_MILE_SHIPMENTS_SHIPMENTID_DISCREPANCY_ACT
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE CAMPAIGNS_CAMPAIGNID_FIRST_MILE_SHIPMENTS_SHIPMENTID_DISCREPANCY_ACT in set but failed match against \"{}\"", path, paths::REGEX_CAMPAIGNS_CAMPAIGNID_FIRST_MILE_SHIPMENTS_SHIPMENTID_DISCREPANCY_ACT.as_str())
                    );

                let param_campaign_id = match percent_encoding::percent_decode(path_params["campaignId"].as_bytes()).decode_utf8() {
                    Ok(param_campaign_id) => match param_campaign_id.parse::<i64>() {
                        Ok(param_campaign_id) => param_campaign_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter campaignId: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["campaignId"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                let param_shipment_id = match percent_encoding::percent_decode(path_params["shipmentId"].as_bytes()).decode_utf8() {
                    Ok(param_shipment_id) => match param_shipment_id.parse::<i64>() {
                        Ok(param_shipment_id) => param_shipment_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter shipmentId: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["shipmentId"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                                let result = api_impl.download_shipment_discrepancy_act(
                                            param_campaign_id,
                                            param_shipment_id,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                DownloadShipmentDiscrepancyActResponse::Status200
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/vnd.ms-excel")
                                                            .expect("Unable to create Content-Type header for application/vnd.ms-excel"));
                                                    // Binary Body
                                                    let body = body.0;
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                DownloadShipmentDiscrepancyActResponse::Status400
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                DownloadShipmentDiscrepancyActResponse::Status401
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                DownloadShipmentDiscrepancyActResponse::Status403
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                DownloadShipmentDiscrepancyActResponse::Status404
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                DownloadShipmentDiscrepancyActResponse::Status420
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(420).expect("Unable to turn 420 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                DownloadShipmentDiscrepancyActResponse::Status500
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
            },

            // DownloadShipmentInboundAct - GET /campaigns/{campaignId}/first-mile/shipments/{shipmentId}/inbound-act
            hyper::Method::GET if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_FIRST_MILE_SHIPMENTS_SHIPMENTID_INBOUND_ACT) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "market:partner-api".to_string(), // API Яндекс.Маркета / Поиска по товарам для партнеров
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_CAMPAIGNS_CAMPAIGNID_FIRST_MILE_SHIPMENTS_SHIPMENTID_INBOUND_ACT
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE CAMPAIGNS_CAMPAIGNID_FIRST_MILE_SHIPMENTS_SHIPMENTID_INBOUND_ACT in set but failed match against \"{}\"", path, paths::REGEX_CAMPAIGNS_CAMPAIGNID_FIRST_MILE_SHIPMENTS_SHIPMENTID_INBOUND_ACT.as_str())
                    );

                let param_campaign_id = match percent_encoding::percent_decode(path_params["campaignId"].as_bytes()).decode_utf8() {
                    Ok(param_campaign_id) => match param_campaign_id.parse::<i64>() {
                        Ok(param_campaign_id) => param_campaign_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter campaignId: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["campaignId"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                let param_shipment_id = match percent_encoding::percent_decode(path_params["shipmentId"].as_bytes()).decode_utf8() {
                    Ok(param_shipment_id) => match param_shipment_id.parse::<i64>() {
                        Ok(param_shipment_id) => param_shipment_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter shipmentId: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["shipmentId"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                                let result = api_impl.download_shipment_inbound_act(
                                            param_campaign_id,
                                            param_shipment_id,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                DownloadShipmentInboundActResponse::Status200
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/pdf")
                                                            .expect("Unable to create Content-Type header for application/pdf"));
                                                    // Binary Body
                                                    let body = body.0;
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                DownloadShipmentInboundActResponse::Status400
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                DownloadShipmentInboundActResponse::Status401
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                DownloadShipmentInboundActResponse::Status403
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                DownloadShipmentInboundActResponse::Status404
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                DownloadShipmentInboundActResponse::Status420
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(420).expect("Unable to turn 420 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                DownloadShipmentInboundActResponse::Status500
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
            },

            // DownloadShipmentPalletLabels - GET /campaigns/{campaignId}/first-mile/shipments/{shipmentId}/pallet/labels
            hyper::Method::GET if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_FIRST_MILE_SHIPMENTS_SHIPMENTID_PALLET_LABELS) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "market:partner-api".to_string(), // API Яндекс.Маркета / Поиска по товарам для партнеров
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_CAMPAIGNS_CAMPAIGNID_FIRST_MILE_SHIPMENTS_SHIPMENTID_PALLET_LABELS
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE CAMPAIGNS_CAMPAIGNID_FIRST_MILE_SHIPMENTS_SHIPMENTID_PALLET_LABELS in set but failed match against \"{}\"", path, paths::REGEX_CAMPAIGNS_CAMPAIGNID_FIRST_MILE_SHIPMENTS_SHIPMENTID_PALLET_LABELS.as_str())
                    );

                let param_campaign_id = match percent_encoding::percent_decode(path_params["campaignId"].as_bytes()).decode_utf8() {
                    Ok(param_campaign_id) => match param_campaign_id.parse::<i64>() {
                        Ok(param_campaign_id) => param_campaign_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter campaignId: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["campaignId"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                let param_shipment_id = match percent_encoding::percent_decode(path_params["shipmentId"].as_bytes()).decode_utf8() {
                    Ok(param_shipment_id) => match param_shipment_id.parse::<i64>() {
                        Ok(param_shipment_id) => param_shipment_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter shipmentId: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["shipmentId"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                // Query parameters (note that non-required or collection query parameters will ignore garbage values, rather than causing a 400 response)
                let query_params = form_urlencoded::parse(uri.query().unwrap_or_default().as_bytes()).collect::<Vec<_>>();
                let param_format = query_params.iter().filter(|e| e.0 == "format").map(|e| e.1.clone())
                    .next();
                let param_format = match param_format {
                    Some(param_format) => {
                        let param_format =
                            <models::ShipmentPalletLabelPageFormatType as std::str::FromStr>::from_str
                                (&param_format);
                        match param_format {
                            Ok(param_format) => Some(param_format),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter format - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter format")),
                        }
                    },
                    None => None,
                };

                                let result = api_impl.download_shipment_pallet_labels(
                                            param_campaign_id,
                                            param_shipment_id,
                                            param_format,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                DownloadShipmentPalletLabelsResponse::PDF
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/pdf")
                                                            .expect("Unable to create Content-Type header for application/pdf"));
                                                    // Binary Body
                                                    let body = body.0;
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                DownloadShipmentPalletLabelsResponse::Status400
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                DownloadShipmentPalletLabelsResponse::Status401
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                DownloadShipmentPalletLabelsResponse::Status403
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                DownloadShipmentPalletLabelsResponse::Status404
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                DownloadShipmentPalletLabelsResponse::Status420
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(420).expect("Unable to turn 420 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                DownloadShipmentPalletLabelsResponse::Status500
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
            },

            // DownloadShipmentTransportationWaybill - GET /campaigns/{campaignId}/first-mile/shipments/{shipmentId}/transportation-waybill
            hyper::Method::GET if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_FIRST_MILE_SHIPMENTS_SHIPMENTID_TRANSPORTATION_WAYBILL) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "market:partner-api".to_string(), // API Яндекс.Маркета / Поиска по товарам для партнеров
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_CAMPAIGNS_CAMPAIGNID_FIRST_MILE_SHIPMENTS_SHIPMENTID_TRANSPORTATION_WAYBILL
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE CAMPAIGNS_CAMPAIGNID_FIRST_MILE_SHIPMENTS_SHIPMENTID_TRANSPORTATION_WAYBILL in set but failed match against \"{}\"", path, paths::REGEX_CAMPAIGNS_CAMPAIGNID_FIRST_MILE_SHIPMENTS_SHIPMENTID_TRANSPORTATION_WAYBILL.as_str())
                    );

                let param_campaign_id = match percent_encoding::percent_decode(path_params["campaignId"].as_bytes()).decode_utf8() {
                    Ok(param_campaign_id) => match param_campaign_id.parse::<i64>() {
                        Ok(param_campaign_id) => param_campaign_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter campaignId: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["campaignId"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                let param_shipment_id = match percent_encoding::percent_decode(path_params["shipmentId"].as_bytes()).decode_utf8() {
                    Ok(param_shipment_id) => match param_shipment_id.parse::<i64>() {
                        Ok(param_shipment_id) => param_shipment_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter shipmentId: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["shipmentId"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                                let result = api_impl.download_shipment_transportation_waybill(
                                            param_campaign_id,
                                            param_shipment_id,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                DownloadShipmentTransportationWaybillResponse::Status200
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/vnd.ms-excel")
                                                            .expect("Unable to create Content-Type header for application/vnd.ms-excel"));
                                                    // Binary Body
                                                    let body = body.0;
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                DownloadShipmentTransportationWaybillResponse::Status400
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                DownloadShipmentTransportationWaybillResponse::Status401
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                DownloadShipmentTransportationWaybillResponse::Status403
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                DownloadShipmentTransportationWaybillResponse::Status404
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                DownloadShipmentTransportationWaybillResponse::Status420
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(420).expect("Unable to turn 420 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                DownloadShipmentTransportationWaybillResponse::Status500
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
            },

            // GetShipment - GET /campaigns/{campaignId}/first-mile/shipments/{shipmentId}
            hyper::Method::GET if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_FIRST_MILE_SHIPMENTS_SHIPMENTID) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "market:partner-api".to_string(), // API Яндекс.Маркета / Поиска по товарам для партнеров
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_CAMPAIGNS_CAMPAIGNID_FIRST_MILE_SHIPMENTS_SHIPMENTID
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE CAMPAIGNS_CAMPAIGNID_FIRST_MILE_SHIPMENTS_SHIPMENTID in set but failed match against \"{}\"", path, paths::REGEX_CAMPAIGNS_CAMPAIGNID_FIRST_MILE_SHIPMENTS_SHIPMENTID.as_str())
                    );

                let param_campaign_id = match percent_encoding::percent_decode(path_params["campaignId"].as_bytes()).decode_utf8() {
                    Ok(param_campaign_id) => match param_campaign_id.parse::<i64>() {
                        Ok(param_campaign_id) => param_campaign_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter campaignId: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["campaignId"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                let param_shipment_id = match percent_encoding::percent_decode(path_params["shipmentId"].as_bytes()).decode_utf8() {
                    Ok(param_shipment_id) => match param_shipment_id.parse::<i64>() {
                        Ok(param_shipment_id) => param_shipment_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter shipmentId: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["shipmentId"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                // Query parameters (note that non-required or collection query parameters will ignore garbage values, rather than causing a 400 response)
                let query_params = form_urlencoded::parse(uri.query().unwrap_or_default().as_bytes()).collect::<Vec<_>>();
                let param_cancelled_orders = query_params.iter().filter(|e| e.0 == "cancelledOrders").map(|e| e.1.clone())
                    .next();
                let param_cancelled_orders = match param_cancelled_orders {
                    Some(param_cancelled_orders) => {
                        let param_cancelled_orders =
                            <bool as std::str::FromStr>::from_str
                                (&param_cancelled_orders);
                        match param_cancelled_orders {
                            Ok(param_cancelled_orders) => Some(param_cancelled_orders),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter cancelledOrders - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter cancelledOrders")),
                        }
                    },
                    None => None,
                };

                                let result = api_impl.get_shipment(
                                            param_campaign_id,
                                            param_shipment_id,
                                            param_cancelled_orders,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                GetShipmentResponse::Status200
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetShipmentResponse::Status400
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetShipmentResponse::Status401
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetShipmentResponse::Status403
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetShipmentResponse::Status404
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetShipmentResponse::Status420
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(420).expect("Unable to turn 420 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetShipmentResponse::Status500
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
            },

            // GetShipmentOrdersInfo - GET /campaigns/{campaignId}/first-mile/shipments/{shipmentId}/orders/info
            hyper::Method::GET if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_FIRST_MILE_SHIPMENTS_SHIPMENTID_ORDERS_INFO) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "market:partner-api".to_string(), // API Яндекс.Маркета / Поиска по товарам для партнеров
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_CAMPAIGNS_CAMPAIGNID_FIRST_MILE_SHIPMENTS_SHIPMENTID_ORDERS_INFO
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE CAMPAIGNS_CAMPAIGNID_FIRST_MILE_SHIPMENTS_SHIPMENTID_ORDERS_INFO in set but failed match against \"{}\"", path, paths::REGEX_CAMPAIGNS_CAMPAIGNID_FIRST_MILE_SHIPMENTS_SHIPMENTID_ORDERS_INFO.as_str())
                    );

                let param_campaign_id = match percent_encoding::percent_decode(path_params["campaignId"].as_bytes()).decode_utf8() {
                    Ok(param_campaign_id) => match param_campaign_id.parse::<i64>() {
                        Ok(param_campaign_id) => param_campaign_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter campaignId: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["campaignId"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                let param_shipment_id = match percent_encoding::percent_decode(path_params["shipmentId"].as_bytes()).decode_utf8() {
                    Ok(param_shipment_id) => match param_shipment_id.parse::<i64>() {
                        Ok(param_shipment_id) => param_shipment_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter shipmentId: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["shipmentId"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                                let result = api_impl.get_shipment_orders_info(
                                            param_campaign_id,
                                            param_shipment_id,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                GetShipmentOrdersInfoResponse::Status200
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetShipmentOrdersInfoResponse::Status400
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetShipmentOrdersInfoResponse::Status401
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetShipmentOrdersInfoResponse::Status403
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetShipmentOrdersInfoResponse::Status404
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetShipmentOrdersInfoResponse::Status420
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(420).expect("Unable to turn 420 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetShipmentOrdersInfoResponse::Status500
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
            },

            // SetShipmentPalletsCount - PUT /campaigns/{campaignId}/first-mile/shipments/{shipmentId}/pallets
            hyper::Method::PUT if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_FIRST_MILE_SHIPMENTS_SHIPMENTID_PALLETS) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "market:partner-api".to_string(), // API Яндекс.Маркета / Поиска по товарам для партнеров
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_CAMPAIGNS_CAMPAIGNID_FIRST_MILE_SHIPMENTS_SHIPMENTID_PALLETS
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE CAMPAIGNS_CAMPAIGNID_FIRST_MILE_SHIPMENTS_SHIPMENTID_PALLETS in set but failed match against \"{}\"", path, paths::REGEX_CAMPAIGNS_CAMPAIGNID_FIRST_MILE_SHIPMENTS_SHIPMENTID_PALLETS.as_str())
                    );

                let param_campaign_id = match percent_encoding::percent_decode(path_params["campaignId"].as_bytes()).decode_utf8() {
                    Ok(param_campaign_id) => match param_campaign_id.parse::<i64>() {
                        Ok(param_campaign_id) => param_campaign_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter campaignId: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["campaignId"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                let param_shipment_id = match percent_encoding::percent_decode(path_params["shipmentId"].as_bytes()).decode_utf8() {
                    Ok(param_shipment_id) => match param_shipment_id.parse::<i64>() {
                        Ok(param_shipment_id) => param_shipment_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter shipmentId: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["shipmentId"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                // Handle body parameters (note that non-required body parameters will ignore garbage
                // values, rather than causing a 400 response). Produce warning header and logs for
                // any unused fields.
                let result = body.into_raw().await;
                match result {
                     Ok(body) => {
                                let mut unused_elements : Vec<String> = vec![];
                                let param_set_shipment_pallets_count_request: Option<models::SetShipmentPalletsCountRequest> = if !body.is_empty() {
                                    let deserializer = &mut serde_json::Deserializer::from_slice(&*body);
                                    match serde_ignored::deserialize(deserializer, |path| {
                                            warn!("Ignoring unknown field in body: {}", path);
                                            unused_elements.push(path.to_string());
                                    }) {
                                        Ok(param_set_shipment_pallets_count_request) => param_set_shipment_pallets_count_request,
                                        Err(e) => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from(format!("Couldn't parse body parameter SetShipmentPalletsCountRequest - doesn't match schema: {}", e)))
                                                        .expect("Unable to create Bad Request response for invalid body parameter SetShipmentPalletsCountRequest due to schema")),
                                    }
                                } else {
                                    None
                                };
                                let param_set_shipment_pallets_count_request = match param_set_shipment_pallets_count_request {
                                    Some(param_set_shipment_pallets_count_request) => param_set_shipment_pallets_count_request,
                                    None => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from("Missing required body parameter SetShipmentPalletsCountRequest"))
                                                        .expect("Unable to create Bad Request response for missing body parameter SetShipmentPalletsCountRequest")),
                                };


                                let result = api_impl.set_shipment_pallets_count(
                                            param_campaign_id,
                                            param_shipment_id,
                                            param_set_shipment_pallets_count_request,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        if !unused_elements.is_empty() {
                                            response.headers_mut().insert(
                                                HeaderName::from_static("warning"),
                                                HeaderValue::from_str(format!("Ignoring unknown fields in body: {:?}", unused_elements).as_str())
                                                    .expect("Unable to create Warning header value"));
                                        }
                                        match result {
                                            Ok(rsp) => match rsp {
                                                SetShipmentPalletsCountResponse::Status200
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                SetShipmentPalletsCountResponse::Status400
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                SetShipmentPalletsCountResponse::Status401
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                SetShipmentPalletsCountResponse::Status403
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                SetShipmentPalletsCountResponse::Status404
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                SetShipmentPalletsCountResponse::Status420
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(420).expect("Unable to turn 420 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                SetShipmentPalletsCountResponse::Status500
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
                            },
                            Err(e) => Ok(Response::builder()
                                                .status(StatusCode::BAD_REQUEST)
                                                .body(Body::from(format!("Unable to read body: {}", e)))
                                                .expect("Unable to create Bad Request response due to unable to read body")),
                        }
            },

            // TransferOrdersFromShipment - POST /campaigns/{campaignId}/first-mile/shipments/{shipmentId}/orders/transfer
            hyper::Method::POST if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_FIRST_MILE_SHIPMENTS_SHIPMENTID_ORDERS_TRANSFER) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "market:partner-api".to_string(), // API Яндекс.Маркета / Поиска по товарам для партнеров
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_CAMPAIGNS_CAMPAIGNID_FIRST_MILE_SHIPMENTS_SHIPMENTID_ORDERS_TRANSFER
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE CAMPAIGNS_CAMPAIGNID_FIRST_MILE_SHIPMENTS_SHIPMENTID_ORDERS_TRANSFER in set but failed match against \"{}\"", path, paths::REGEX_CAMPAIGNS_CAMPAIGNID_FIRST_MILE_SHIPMENTS_SHIPMENTID_ORDERS_TRANSFER.as_str())
                    );

                let param_campaign_id = match percent_encoding::percent_decode(path_params["campaignId"].as_bytes()).decode_utf8() {
                    Ok(param_campaign_id) => match param_campaign_id.parse::<i64>() {
                        Ok(param_campaign_id) => param_campaign_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter campaignId: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["campaignId"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                let param_shipment_id = match percent_encoding::percent_decode(path_params["shipmentId"].as_bytes()).decode_utf8() {
                    Ok(param_shipment_id) => match param_shipment_id.parse::<i64>() {
                        Ok(param_shipment_id) => param_shipment_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter shipmentId: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["shipmentId"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                // Handle body parameters (note that non-required body parameters will ignore garbage
                // values, rather than causing a 400 response). Produce warning header and logs for
                // any unused fields.
                let result = body.into_raw().await;
                match result {
                     Ok(body) => {
                                let mut unused_elements : Vec<String> = vec![];
                                let param_transfer_orders_from_shipment_request: Option<models::TransferOrdersFromShipmentRequest> = if !body.is_empty() {
                                    let deserializer = &mut serde_json::Deserializer::from_slice(&*body);
                                    match serde_ignored::deserialize(deserializer, |path| {
                                            warn!("Ignoring unknown field in body: {}", path);
                                            unused_elements.push(path.to_string());
                                    }) {
                                        Ok(param_transfer_orders_from_shipment_request) => param_transfer_orders_from_shipment_request,
                                        Err(e) => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from(format!("Couldn't parse body parameter TransferOrdersFromShipmentRequest - doesn't match schema: {}", e)))
                                                        .expect("Unable to create Bad Request response for invalid body parameter TransferOrdersFromShipmentRequest due to schema")),
                                    }
                                } else {
                                    None
                                };
                                let param_transfer_orders_from_shipment_request = match param_transfer_orders_from_shipment_request {
                                    Some(param_transfer_orders_from_shipment_request) => param_transfer_orders_from_shipment_request,
                                    None => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from("Missing required body parameter TransferOrdersFromShipmentRequest"))
                                                        .expect("Unable to create Bad Request response for missing body parameter TransferOrdersFromShipmentRequest")),
                                };


                                let result = api_impl.transfer_orders_from_shipment(
                                            param_campaign_id,
                                            param_shipment_id,
                                            param_transfer_orders_from_shipment_request,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        if !unused_elements.is_empty() {
                                            response.headers_mut().insert(
                                                HeaderName::from_static("warning"),
                                                HeaderValue::from_str(format!("Ignoring unknown fields in body: {:?}", unused_elements).as_str())
                                                    .expect("Unable to create Warning header value"));
                                        }
                                        match result {
                                            Ok(rsp) => match rsp {
                                                TransferOrdersFromShipmentResponse::Status200
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                TransferOrdersFromShipmentResponse::Status400
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                TransferOrdersFromShipmentResponse::Status401
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                TransferOrdersFromShipmentResponse::Status403
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                TransferOrdersFromShipmentResponse::Status404
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                TransferOrdersFromShipmentResponse::Status420
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(420).expect("Unable to turn 420 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                TransferOrdersFromShipmentResponse::Status500
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
                            },
                            Err(e) => Ok(Response::builder()
                                                .status(StatusCode::BAD_REQUEST)
                                                .body(Body::from(format!("Unable to read body: {}", e)))
                                                .expect("Unable to create Bad Request response due to unable to read body")),
                        }
            },

            // GetStocks - POST /campaigns/{campaignId}/offers/stocks
            hyper::Method::POST if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_OFFERS_STOCKS) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "market:partner-api".to_string(), // API Яндекс.Маркета / Поиска по товарам для партнеров
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_CAMPAIGNS_CAMPAIGNID_OFFERS_STOCKS
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE CAMPAIGNS_CAMPAIGNID_OFFERS_STOCKS in set but failed match against \"{}\"", path, paths::REGEX_CAMPAIGNS_CAMPAIGNID_OFFERS_STOCKS.as_str())
                    );

                let param_campaign_id = match percent_encoding::percent_decode(path_params["campaignId"].as_bytes()).decode_utf8() {
                    Ok(param_campaign_id) => match param_campaign_id.parse::<i64>() {
                        Ok(param_campaign_id) => param_campaign_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter campaignId: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["campaignId"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                // Query parameters (note that non-required or collection query parameters will ignore garbage values, rather than causing a 400 response)
                let query_params = form_urlencoded::parse(uri.query().unwrap_or_default().as_bytes()).collect::<Vec<_>>();
                let param_page_token = query_params.iter().filter(|e| e.0 == "page_token").map(|e| e.1.clone())
                    .next();
                let param_page_token = match param_page_token {
                    Some(param_page_token) => {
                        let param_page_token =
                            <String as std::str::FromStr>::from_str
                                (&param_page_token);
                        match param_page_token {
                            Ok(param_page_token) => Some(param_page_token),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter page_token - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter page_token")),
                        }
                    },
                    None => None,
                };
                let param_limit = query_params.iter().filter(|e| e.0 == "limit").map(|e| e.1.clone())
                    .next();
                let param_limit = match param_limit {
                    Some(param_limit) => {
                        let param_limit =
                            <i32 as std::str::FromStr>::from_str
                                (&param_limit);
                        match param_limit {
                            Ok(param_limit) => Some(param_limit),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter limit - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter limit")),
                        }
                    },
                    None => None,
                };

                // Handle body parameters (note that non-required body parameters will ignore garbage
                // values, rather than causing a 400 response). Produce warning header and logs for
                // any unused fields.
                let result = body.into_raw().await;
                match result {
                     Ok(body) => {
                                let mut unused_elements : Vec<String> = vec![];
                                let param_get_warehouse_stocks_request: Option<models::GetWarehouseStocksRequest> = if !body.is_empty() {
                                    let deserializer = &mut serde_json::Deserializer::from_slice(&*body);
                                    match serde_ignored::deserialize(deserializer, |path| {
                                            warn!("Ignoring unknown field in body: {}", path);
                                            unused_elements.push(path.to_string());
                                    }) {
                                        Ok(param_get_warehouse_stocks_request) => param_get_warehouse_stocks_request,
                                        Err(_) => None,
                                    }
                                } else {
                                    None
                                };


                                let result = api_impl.get_stocks(
                                            param_campaign_id,
                                            param_page_token,
                                            param_limit,
                                            param_get_warehouse_stocks_request,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        if !unused_elements.is_empty() {
                                            response.headers_mut().insert(
                                                HeaderName::from_static("warning"),
                                                HeaderValue::from_str(format!("Ignoring unknown fields in body: {:?}", unused_elements).as_str())
                                                    .expect("Unable to create Warning header value"));
                                        }
                                        match result {
                                            Ok(rsp) => match rsp {
                                                GetStocksResponse::Status200
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetStocksResponse::Status400
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetStocksResponse::Status401
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetStocksResponse::Status403
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetStocksResponse::Status420
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(420).expect("Unable to turn 420 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetStocksResponse::Status500
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
                            },
                            Err(e) => Ok(Response::builder()
                                                .status(StatusCode::BAD_REQUEST)
                                                .body(Body::from(format!("Unable to read body: {}", e)))
                                                .expect("Unable to create Bad Request response due to unable to read body")),
                        }
            },

            // UpdateStocks - PUT /campaigns/{campaignId}/offers/stocks
            hyper::Method::PUT if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_OFFERS_STOCKS) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "market:partner-api".to_string(), // API Яндекс.Маркета / Поиска по товарам для партнеров
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_CAMPAIGNS_CAMPAIGNID_OFFERS_STOCKS
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE CAMPAIGNS_CAMPAIGNID_OFFERS_STOCKS in set but failed match against \"{}\"", path, paths::REGEX_CAMPAIGNS_CAMPAIGNID_OFFERS_STOCKS.as_str())
                    );

                let param_campaign_id = match percent_encoding::percent_decode(path_params["campaignId"].as_bytes()).decode_utf8() {
                    Ok(param_campaign_id) => match param_campaign_id.parse::<i64>() {
                        Ok(param_campaign_id) => param_campaign_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter campaignId: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["campaignId"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                // Handle body parameters (note that non-required body parameters will ignore garbage
                // values, rather than causing a 400 response). Produce warning header and logs for
                // any unused fields.
                let result = body.into_raw().await;
                match result {
                     Ok(body) => {
                                let mut unused_elements : Vec<String> = vec![];
                                let param_update_stocks_request: Option<models::UpdateStocksRequest> = if !body.is_empty() {
                                    let deserializer = &mut serde_json::Deserializer::from_slice(&*body);
                                    match serde_ignored::deserialize(deserializer, |path| {
                                            warn!("Ignoring unknown field in body: {}", path);
                                            unused_elements.push(path.to_string());
                                    }) {
                                        Ok(param_update_stocks_request) => param_update_stocks_request,
                                        Err(e) => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from(format!("Couldn't parse body parameter UpdateStocksRequest - doesn't match schema: {}", e)))
                                                        .expect("Unable to create Bad Request response for invalid body parameter UpdateStocksRequest due to schema")),
                                    }
                                } else {
                                    None
                                };
                                let param_update_stocks_request = match param_update_stocks_request {
                                    Some(param_update_stocks_request) => param_update_stocks_request,
                                    None => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from("Missing required body parameter UpdateStocksRequest"))
                                                        .expect("Unable to create Bad Request response for missing body parameter UpdateStocksRequest")),
                                };


                                let result = api_impl.update_stocks(
                                            param_campaign_id,
                                            param_update_stocks_request,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        if !unused_elements.is_empty() {
                                            response.headers_mut().insert(
                                                HeaderName::from_static("warning"),
                                                HeaderValue::from_str(format!("Ignoring unknown fields in body: {:?}", unused_elements).as_str())
                                                    .expect("Unable to create Warning header value"));
                                        }
                                        match result {
                                            Ok(rsp) => match rsp {
                                                UpdateStocksResponse::Status200
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                UpdateStocksResponse::Status400
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                UpdateStocksResponse::Status401
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                UpdateStocksResponse::Status403
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                UpdateStocksResponse::Status404
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                UpdateStocksResponse::Status420
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(420).expect("Unable to turn 420 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                UpdateStocksResponse::Status500
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
                            },
                            Err(e) => Ok(Response::builder()
                                                .status(StatusCode::BAD_REQUEST)
                                                .body(Body::from(format!("Unable to read body: {}", e)))
                                                .expect("Unable to create Bad Request response due to unable to read body")),
                        }
            },

            // CalculateTariffs - POST /tariffs/calculate
            hyper::Method::POST if path.matched(paths::ID_TARIFFS_CALCULATE) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "market:partner-api".to_string(), // API Яндекс.Маркета / Поиска по товарам для партнеров
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Handle body parameters (note that non-required body parameters will ignore garbage
                // values, rather than causing a 400 response). Produce warning header and logs for
                // any unused fields.
                let result = body.into_raw().await;
                match result {
                     Ok(body) => {
                                let mut unused_elements : Vec<String> = vec![];
                                let param_calculate_tariffs_request: Option<models::CalculateTariffsRequest> = if !body.is_empty() {
                                    let deserializer = &mut serde_json::Deserializer::from_slice(&*body);
                                    match serde_ignored::deserialize(deserializer, |path| {
                                            warn!("Ignoring unknown field in body: {}", path);
                                            unused_elements.push(path.to_string());
                                    }) {
                                        Ok(param_calculate_tariffs_request) => param_calculate_tariffs_request,
                                        Err(e) => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from(format!("Couldn't parse body parameter CalculateTariffsRequest - doesn't match schema: {}", e)))
                                                        .expect("Unable to create Bad Request response for invalid body parameter CalculateTariffsRequest due to schema")),
                                    }
                                } else {
                                    None
                                };
                                let param_calculate_tariffs_request = match param_calculate_tariffs_request {
                                    Some(param_calculate_tariffs_request) => param_calculate_tariffs_request,
                                    None => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from("Missing required body parameter CalculateTariffsRequest"))
                                                        .expect("Unable to create Bad Request response for missing body parameter CalculateTariffsRequest")),
                                };


                                let result = api_impl.calculate_tariffs(
                                            param_calculate_tariffs_request,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        if !unused_elements.is_empty() {
                                            response.headers_mut().insert(
                                                HeaderName::from_static("warning"),
                                                HeaderValue::from_str(format!("Ignoring unknown fields in body: {:?}", unused_elements).as_str())
                                                    .expect("Unable to create Warning header value"));
                                        }
                                        match result {
                                            Ok(rsp) => match rsp {
                                                CalculateTariffsResponse::Status200
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                CalculateTariffsResponse::Status400
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                CalculateTariffsResponse::Status401
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                CalculateTariffsResponse::Status403
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                CalculateTariffsResponse::Status404
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                CalculateTariffsResponse::Status420
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(420).expect("Unable to turn 420 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                CalculateTariffsResponse::Status500
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
                            },
                            Err(e) => Ok(Response::builder()
                                                .status(StatusCode::BAD_REQUEST)
                                                .body(Body::from(format!("Unable to read body: {}", e)))
                                                .expect("Unable to create Bad Request response due to unable to read body")),
                        }
            },

            // GetFulfillmentWarehouses - GET /warehouses
            hyper::Method::GET if path.matched(paths::ID_WAREHOUSES) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "market:partner-api".to_string(), // API Яндекс.Маркета / Поиска по товарам для партнеров
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                                let result = api_impl.get_fulfillment_warehouses(
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                GetFulfillmentWarehousesResponse::Status200
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetFulfillmentWarehousesResponse::Status400
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetFulfillmentWarehousesResponse::Status401
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetFulfillmentWarehousesResponse::Status403
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetFulfillmentWarehousesResponse::Status404
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetFulfillmentWarehousesResponse::Status420
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(420).expect("Unable to turn 420 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetFulfillmentWarehousesResponse::Status500
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
            },

            // GetWarehouses - GET /businesses/{businessId}/warehouses
            hyper::Method::GET if path.matched(paths::ID_BUSINESSES_BUSINESSID_WAREHOUSES) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "market:partner-api".to_string(), // API Яндекс.Маркета / Поиска по товарам для партнеров
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_BUSINESSES_BUSINESSID_WAREHOUSES
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE BUSINESSES_BUSINESSID_WAREHOUSES in set but failed match against \"{}\"", path, paths::REGEX_BUSINESSES_BUSINESSID_WAREHOUSES.as_str())
                    );

                let param_business_id = match percent_encoding::percent_decode(path_params["businessId"].as_bytes()).decode_utf8() {
                    Ok(param_business_id) => match param_business_id.parse::<i64>() {
                        Ok(param_business_id) => param_business_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter businessId: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["businessId"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                                let result = api_impl.get_warehouses(
                                            param_business_id,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                GetWarehousesResponse::Status200
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetWarehousesResponse::Status400
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetWarehousesResponse::Status401
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetWarehousesResponse::Status403
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetWarehousesResponse::Status404
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetWarehousesResponse::Status420
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(420).expect("Unable to turn 420 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                                GetWarehousesResponse::Status500
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for application/json"));
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body);

                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
            },

            _ if path.matched(paths::ID_BUSINESSES_BUSINESSID_BIDS) => method_not_allowed(),
            _ if path.matched(paths::ID_BUSINESSES_BUSINESSID_BIDS_INFO) => method_not_allowed(),
            _ if path.matched(paths::ID_BUSINESSES_BUSINESSID_BIDS_RECOMMENDATIONS) => method_not_allowed(),
            _ if path.matched(paths::ID_BUSINESSES_BUSINESSID_CHATS) => method_not_allowed(),
            _ if path.matched(paths::ID_BUSINESSES_BUSINESSID_CHATS_FILE_SEND) => method_not_allowed(),
            _ if path.matched(paths::ID_BUSINESSES_BUSINESSID_CHATS_HISTORY) => method_not_allowed(),
            _ if path.matched(paths::ID_BUSINESSES_BUSINESSID_CHATS_MESSAGE) => method_not_allowed(),
            _ if path.matched(paths::ID_BUSINESSES_BUSINESSID_CHATS_NEW) => method_not_allowed(),
            _ if path.matched(paths::ID_BUSINESSES_BUSINESSID_GOODS_FEEDBACK) => method_not_allowed(),
            _ if path.matched(paths::ID_BUSINESSES_BUSINESSID_GOODS_FEEDBACK_COMMENTS) => method_not_allowed(),
            _ if path.matched(paths::ID_BUSINESSES_BUSINESSID_GOODS_FEEDBACK_COMMENTS_DELETE) => method_not_allowed(),
            _ if path.matched(paths::ID_BUSINESSES_BUSINESSID_GOODS_FEEDBACK_COMMENTS_UPDATE) => method_not_allowed(),
            _ if path.matched(paths::ID_BUSINESSES_BUSINESSID_GOODS_FEEDBACK_SKIP_REACTION) => method_not_allowed(),
            _ if path.matched(paths::ID_BUSINESSES_BUSINESSID_OFFER_CARDS) => method_not_allowed(),
            _ if path.matched(paths::ID_BUSINESSES_BUSINESSID_OFFER_CARDS_UPDATE) => method_not_allowed(),
            _ if path.matched(paths::ID_BUSINESSES_BUSINESSID_OFFER_MAPPINGS) => method_not_allowed(),
            _ if path.matched(paths::ID_BUSINESSES_BUSINESSID_OFFER_MAPPINGS_ARCHIVE) => method_not_allowed(),
            _ if path.matched(paths::ID_BUSINESSES_BUSINESSID_OFFER_MAPPINGS_DELETE) => method_not_allowed(),
            _ if path.matched(paths::ID_BUSINESSES_BUSINESSID_OFFER_MAPPINGS_SUGGESTIONS) => method_not_allowed(),
            _ if path.matched(paths::ID_BUSINESSES_BUSINESSID_OFFER_MAPPINGS_UNARCHIVE) => method_not_allowed(),
            _ if path.matched(paths::ID_BUSINESSES_BUSINESSID_OFFER_MAPPINGS_UPDATE) => method_not_allowed(),
            _ if path.matched(paths::ID_BUSINESSES_BUSINESSID_OFFER_PRICES_UPDATES) => method_not_allowed(),
            _ if path.matched(paths::ID_BUSINESSES_BUSINESSID_OFFERS_RECOMMENDATIONS) => method_not_allowed(),
            _ if path.matched(paths::ID_BUSINESSES_BUSINESSID_PRICE_QUARANTINE) => method_not_allowed(),
            _ if path.matched(paths::ID_BUSINESSES_BUSINESSID_PRICE_QUARANTINE_CONFIRM) => method_not_allowed(),
            _ if path.matched(paths::ID_BUSINESSES_BUSINESSID_PROMOS) => method_not_allowed(),
            _ if path.matched(paths::ID_BUSINESSES_BUSINESSID_PROMOS_OFFERS) => method_not_allowed(),
            _ if path.matched(paths::ID_BUSINESSES_BUSINESSID_PROMOS_OFFERS_DELETE) => method_not_allowed(),
            _ if path.matched(paths::ID_BUSINESSES_BUSINESSID_PROMOS_OFFERS_UPDATE) => method_not_allowed(),
            _ if path.matched(paths::ID_BUSINESSES_BUSINESSID_RATINGS_QUALITY) => method_not_allowed(),
            _ if path.matched(paths::ID_BUSINESSES_BUSINESSID_SETTINGS) => method_not_allowed(),
            _ if path.matched(paths::ID_BUSINESSES_BUSINESSID_WAREHOUSES) => method_not_allowed(),
            _ if path.matched(paths::ID_CAMPAIGNS) => method_not_allowed(),
            _ if path.matched(paths::ID_CAMPAIGNS_BY_LOGIN_LOGIN) => method_not_allowed(),
            _ if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID) => method_not_allowed(),
            _ if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_BIDS) => method_not_allowed(),
            _ if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_FEEDBACK_UPDATES) => method_not_allowed(),
            _ if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_FEEDS) => method_not_allowed(),
            _ if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_FEEDS_FEEDID) => method_not_allowed(),
            _ if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_FEEDS_FEEDID_INDEX_LOGS) => method_not_allowed(),
            _ if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_FEEDS_FEEDID_PARAMS) => method_not_allowed(),
            _ if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_FEEDS_FEEDID_REFRESH) => method_not_allowed(),
            _ if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_FIRST_MILE_SHIPMENTS) => method_not_allowed(),
            _ if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_FIRST_MILE_SHIPMENTS_SHIPMENTID) => method_not_allowed(),
            _ if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_FIRST_MILE_SHIPMENTS_SHIPMENTID_ACT) => method_not_allowed(),
            _ if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_FIRST_MILE_SHIPMENTS_SHIPMENTID_CONFIRM) => method_not_allowed(),
            _ if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_FIRST_MILE_SHIPMENTS_SHIPMENTID_DISCREPANCY_ACT) => method_not_allowed(),
            _ if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_FIRST_MILE_SHIPMENTS_SHIPMENTID_INBOUND_ACT) => method_not_allowed(),
            _ if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_FIRST_MILE_SHIPMENTS_SHIPMENTID_ORDERS_INFO) => method_not_allowed(),
            _ if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_FIRST_MILE_SHIPMENTS_SHIPMENTID_ORDERS_TRANSFER) => method_not_allowed(),
            _ if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_FIRST_MILE_SHIPMENTS_SHIPMENTID_PALLET_LABELS) => method_not_allowed(),
            _ if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_FIRST_MILE_SHIPMENTS_SHIPMENTID_PALLETS) => method_not_allowed(),
            _ if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_FIRST_MILE_SHIPMENTS_SHIPMENTID_TRANSPORTATION_WAYBILL) => method_not_allowed(),
            _ if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_HIDDEN_OFFERS) => method_not_allowed(),
            _ if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_HIDDEN_OFFERS_DELETE) => method_not_allowed(),
            _ if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_LOGINS) => method_not_allowed(),
            _ if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_OFFER_MAPPING_ENTRIES) => method_not_allowed(),
            _ if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_OFFER_MAPPING_ENTRIES_SUGGESTIONS) => method_not_allowed(),
            _ if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_OFFER_MAPPING_ENTRIES_UPDATES) => method_not_allowed(),
            _ if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_OFFER_PRICES) => method_not_allowed(),
            _ if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_OFFER_PRICES_SUGGESTIONS) => method_not_allowed(),
            _ if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_OFFER_PRICES_UPDATES) => method_not_allowed(),
            _ if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_OFFERS) => method_not_allowed(),
            _ if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_OFFERS_ALL) => method_not_allowed(),
            _ if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_OFFERS_DELETE) => method_not_allowed(),
            _ if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_OFFERS_STOCKS) => method_not_allowed(),
            _ if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_OFFERS_UPDATE) => method_not_allowed(),
            _ if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_ORDERS) => method_not_allowed(),
            _ if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_ORDERS_STATUS_UPDATE) => method_not_allowed(),
            _ if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID) => method_not_allowed(),
            _ if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_BOXES) => method_not_allowed(),
            _ if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_BUSINESS_BUYER) => method_not_allowed(),
            _ if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_BUYER) => method_not_allowed(),
            _ if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_CANCELLATION_ACCEPT) => method_not_allowed(),
            _ if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_DELIVERDIGITALGOODS) => method_not_allowed(),
            _ if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_DELIVERY_DATE) => method_not_allowed(),
            _ if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_DELIVERY_LABELS) => method_not_allowed(),
            _ if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_DELIVERY_LABELS_DATA) => method_not_allowed(),
            _ if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_DELIVERY_SHIPMENTS_SHIPMENTID_BOXES) => method_not_allowed(),
            _ if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_DELIVERY_SHIPMENTS_SHIPMENTID_BOXES_BOXID_LABEL) => method_not_allowed(),
            _ if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_DELIVERY_STORAGE_LIMIT) => method_not_allowed(),
            _ if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_DELIVERY_TRACK) => method_not_allowed(),
            _ if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_DOCUMENTS) => method_not_allowed(),
            _ if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_IDENTIFIERS) => method_not_allowed(),
            _ if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_ITEMS) => method_not_allowed(),
            _ if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_RETURNS_RETURNID) => method_not_allowed(),
            _ if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_RETURNS_RETURNID_APPLICATION) => method_not_allowed(),
            _ if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_RETURNS_RETURNID_DECISION) => method_not_allowed(),
            _ if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_RETURNS_RETURNID_DECISION_SUBMIT) => method_not_allowed(),
            _ if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_RETURNS_RETURNID_DECISION_ITEMID_IMAGE_IMAGEHASH) => method_not_allowed(),
            _ if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_STATUS) => method_not_allowed(),
            _ if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_VERIFYEAC) => method_not_allowed(),
            _ if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_OUTLETS) => method_not_allowed(),
            _ if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_OUTLETS_LICENSES) => method_not_allowed(),
            _ if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_OUTLETS_OUTLETID) => method_not_allowed(),
            _ if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_PRICE_QUARANTINE) => method_not_allowed(),
            _ if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_PRICE_QUARANTINE_CONFIRM) => method_not_allowed(),
            _ if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_RATINGS_QUALITY_DETAILS) => method_not_allowed(),
            _ if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_REGION) => method_not_allowed(),
            _ if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_RETURNS) => method_not_allowed(),
            _ if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_SETTINGS) => method_not_allowed(),
            _ if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_SHIPMENTS_RECEPTION_TRANSFER_ACT) => method_not_allowed(),
            _ if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_STATS_ORDERS) => method_not_allowed(),
            _ if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_STATS_SKUS) => method_not_allowed(),
            _ if path.matched(paths::ID_CATEGORIES_MAX_SALE_QUANTUM) => method_not_allowed(),
            _ if path.matched(paths::ID_CATEGORIES_TREE) => method_not_allowed(),
            _ if path.matched(paths::ID_CATEGORY_CATEGORYID_PARAMETERS) => method_not_allowed(),
            _ if path.matched(paths::ID_DELIVERY_SERVICES) => method_not_allowed(),
            _ if path.matched(paths::ID_MODELS) => method_not_allowed(),
            _ if path.matched(paths::ID_MODELS_OFFERS) => method_not_allowed(),
            _ if path.matched(paths::ID_MODELS_MODELID) => method_not_allowed(),
            _ if path.matched(paths::ID_MODELS_MODELID_OFFERS) => method_not_allowed(),
            _ if path.matched(paths::ID_REGIONS) => method_not_allowed(),
            _ if path.matched(paths::ID_REGIONS_REGIONID) => method_not_allowed(),
            _ if path.matched(paths::ID_REGIONS_REGIONID_CHILDREN) => method_not_allowed(),
            _ if path.matched(paths::ID_REPORTS_BOOST_CONSOLIDATED_GENERATE) => method_not_allowed(),
            _ if path.matched(paths::ID_REPORTS_COMPETITORS_POSITION_GENERATE) => method_not_allowed(),
            _ if path.matched(paths::ID_REPORTS_DOCUMENTS_LABELS_GENERATE) => method_not_allowed(),
            _ if path.matched(paths::ID_REPORTS_DOCUMENTS_SHIPMENT_LIST_GENERATE) => method_not_allowed(),
            _ if path.matched(paths::ID_REPORTS_GOODS_FEEDBACK_GENERATE) => method_not_allowed(),
            _ if path.matched(paths::ID_REPORTS_GOODS_MOVEMENT_GENERATE) => method_not_allowed(),
            _ if path.matched(paths::ID_REPORTS_GOODS_REALIZATION_GENERATE) => method_not_allowed(),
            _ if path.matched(paths::ID_REPORTS_GOODS_TURNOVER_GENERATE) => method_not_allowed(),
            _ if path.matched(paths::ID_REPORTS_INFO_REPORTID) => method_not_allowed(),
            _ if path.matched(paths::ID_REPORTS_PRICES_GENERATE) => method_not_allowed(),
            _ if path.matched(paths::ID_REPORTS_SHELF_STATISTICS_GENERATE) => method_not_allowed(),
            _ if path.matched(paths::ID_REPORTS_SHOWS_SALES_GENERATE) => method_not_allowed(),
            _ if path.matched(paths::ID_REPORTS_STOCKS_ON_WAREHOUSES_GENERATE) => method_not_allowed(),
            _ if path.matched(paths::ID_REPORTS_UNITED_MARKETPLACE_SERVICES_GENERATE) => method_not_allowed(),
            _ if path.matched(paths::ID_REPORTS_UNITED_NETTING_GENERATE) => method_not_allowed(),
            _ if path.matched(paths::ID_REPORTS_UNITED_ORDERS_GENERATE) => method_not_allowed(),
            _ if path.matched(paths::ID_TARIFFS_CALCULATE) => method_not_allowed(),
            _ if path.matched(paths::ID_WAREHOUSES) => method_not_allowed(),
                _ => Ok(Response::builder().status(StatusCode::NOT_FOUND)
                        .body(Body::empty())
                        .expect("Unable to create Not Found response"))
            }
        }
        Box::pin(run(
            self.api_impl.clone(),
            req,
            self.multipart_form_size_limit,
        ))
    }
}

/// Request parser for `Api`.
pub struct ApiRequestParser;
impl<T> RequestParser<T> for ApiRequestParser {
    fn parse_operation_id(request: &Request<T>) -> Option<&'static str> {
        let path = paths::GLOBAL_REGEX_SET.matches(request.uri().path());
        match *request.method() {
            // GetBidsInfoForBusiness - POST /businesses/{businessId}/bids/info
            hyper::Method::POST if path.matched(paths::ID_BUSINESSES_BUSINESSID_BIDS_INFO) => Some("GetBidsInfoForBusiness"),
            // GetBidsRecommendations - POST /businesses/{businessId}/bids/recommendations
            hyper::Method::POST if path.matched(paths::ID_BUSINESSES_BUSINESSID_BIDS_RECOMMENDATIONS) => Some("GetBidsRecommendations"),
            // PutBidsForBusiness - PUT /businesses/{businessId}/bids
            hyper::Method::PUT if path.matched(paths::ID_BUSINESSES_BUSINESSID_BIDS) => Some("PutBidsForBusiness"),
            // PutBidsForCampaign - PUT /campaigns/{campaignId}/bids
            hyper::Method::PUT if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_BIDS) => Some("PutBidsForCampaign"),
            // AddOffersToArchive - POST /businesses/{businessId}/offer-mappings/archive
            hyper::Method::POST if path.matched(paths::ID_BUSINESSES_BUSINESSID_OFFER_MAPPINGS_ARCHIVE) => Some("AddOffersToArchive"),
            // DeleteOffers - POST /businesses/{businessId}/offer-mappings/delete
            hyper::Method::POST if path.matched(paths::ID_BUSINESSES_BUSINESSID_OFFER_MAPPINGS_DELETE) => Some("DeleteOffers"),
            // DeleteOffersFromArchive - POST /businesses/{businessId}/offer-mappings/unarchive
            hyper::Method::POST if path.matched(paths::ID_BUSINESSES_BUSINESSID_OFFER_MAPPINGS_UNARCHIVE) => Some("DeleteOffersFromArchive"),
            // GetOfferMappings - POST /businesses/{businessId}/offer-mappings
            hyper::Method::POST if path.matched(paths::ID_BUSINESSES_BUSINESSID_OFFER_MAPPINGS) => Some("GetOfferMappings"),
            // GetSuggestedOfferMappings - POST /businesses/{businessId}/offer-mappings/suggestions
            hyper::Method::POST if path.matched(paths::ID_BUSINESSES_BUSINESSID_OFFER_MAPPINGS_SUGGESTIONS) => Some("GetSuggestedOfferMappings"),
            // UpdateOfferMappings - POST /businesses/{businessId}/offer-mappings/update
            hyper::Method::POST if path.matched(paths::ID_BUSINESSES_BUSINESSID_OFFER_MAPPINGS_UPDATE) => Some("UpdateOfferMappings"),
            // GetBusinessSettings - POST /businesses/{businessId}/settings
            hyper::Method::POST if path.matched(paths::ID_BUSINESSES_BUSINESSID_SETTINGS) => Some("GetBusinessSettings"),
            // GetCampaigns - GET /campaigns
            hyper::Method::GET if path.matched(paths::ID_CAMPAIGNS) => Some("GetCampaigns"),
            // GetCampaign - GET /campaigns/{campaignId}
            hyper::Method::GET if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID) => Some("GetCampaign"),
            // GetCampaignLogins - GET /campaigns/{campaignId}/logins
            hyper::Method::GET if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_LOGINS) => Some("GetCampaignLogins"),
            // GetCampaignRegion - GET /campaigns/{campaignId}/region
            hyper::Method::GET if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_REGION) => Some("GetCampaignRegion"),
            // GetCampaignSettings - GET /campaigns/{campaignId}/settings
            hyper::Method::GET if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_SETTINGS) => Some("GetCampaignSettings"),
            // GetCampaignsByLogin - GET /campaigns/by_login/{login}
            hyper::Method::GET if path.matched(paths::ID_CAMPAIGNS_BY_LOGIN_LOGIN) => Some("GetCampaignsByLogin"),
            // GetCategoriesMaxSaleQuantum - POST /categories/max-sale-quantum
            hyper::Method::POST if path.matched(paths::ID_CATEGORIES_MAX_SALE_QUANTUM) => Some("GetCategoriesMaxSaleQuantum"),
            // GetCategoriesTree - POST /categories/tree
            hyper::Method::POST if path.matched(paths::ID_CATEGORIES_TREE) => Some("GetCategoriesTree"),
            // CreateChat - POST /businesses/{businessId}/chats/new
            hyper::Method::POST if path.matched(paths::ID_BUSINESSES_BUSINESSID_CHATS_NEW) => Some("CreateChat"),
            // GetChatHistory - POST /businesses/{businessId}/chats/history
            hyper::Method::POST if path.matched(paths::ID_BUSINESSES_BUSINESSID_CHATS_HISTORY) => Some("GetChatHistory"),
            // GetChats - POST /businesses/{businessId}/chats
            hyper::Method::POST if path.matched(paths::ID_BUSINESSES_BUSINESSID_CHATS) => Some("GetChats"),
            // SendFileToChat - POST /businesses/{businessId}/chats/file/send
            hyper::Method::POST if path.matched(paths::ID_BUSINESSES_BUSINESSID_CHATS_FILE_SEND) => Some("SendFileToChat"),
            // SendMessageToChat - POST /businesses/{businessId}/chats/message
            hyper::Method::POST if path.matched(paths::ID_BUSINESSES_BUSINESSID_CHATS_MESSAGE) => Some("SendMessageToChat"),
            // GetCategoryContentParameters - POST /category/{categoryId}/parameters
            hyper::Method::POST if path.matched(paths::ID_CATEGORY_CATEGORYID_PARAMETERS) => Some("GetCategoryContentParameters"),
            // GetOfferCardsContentStatus - POST /businesses/{businessId}/offer-cards
            hyper::Method::POST if path.matched(paths::ID_BUSINESSES_BUSINESSID_OFFER_CARDS) => Some("GetOfferCardsContentStatus"),
            // UpdateOfferContent - POST /businesses/{businessId}/offer-cards/update
            hyper::Method::POST if path.matched(paths::ID_BUSINESSES_BUSINESSID_OFFER_CARDS_UPDATE) => Some("UpdateOfferContent"),
            // GetDeliveryServices - GET /delivery/services
            hyper::Method::GET if path.matched(paths::ID_DELIVERY_SERVICES) => Some("GetDeliveryServices"),
            // GetFeedbackAndCommentUpdates - GET /campaigns/{campaignId}/feedback/updates
            hyper::Method::GET if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_FEEDBACK_UPDATES) => Some("GetFeedbackAndCommentUpdates"),
            // GetFeeds - GET /campaigns/{campaignId}/feeds
            hyper::Method::GET if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_FEEDS) => Some("GetFeeds"),
            // GetFeed - GET /campaigns/{campaignId}/feeds/{feedId}
            hyper::Method::GET if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_FEEDS_FEEDID) => Some("GetFeed"),
            // GetFeedIndexLogs - GET /campaigns/{campaignId}/feeds/{feedId}/index-logs
            hyper::Method::GET if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_FEEDS_FEEDID_INDEX_LOGS) => Some("GetFeedIndexLogs"),
            // RefreshFeed - POST /campaigns/{campaignId}/feeds/{feedId}/refresh
            hyper::Method::POST if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_FEEDS_FEEDID_REFRESH) => Some("RefreshFeed"),
            // SetFeedParams - POST /campaigns/{campaignId}/feeds/{feedId}/params
            hyper::Method::POST if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_FEEDS_FEEDID_PARAMS) => Some("SetFeedParams"),
            // DeleteGoodsFeedbackComment - POST /businesses/{businessId}/goods-feedback/comments/delete
            hyper::Method::POST if path.matched(paths::ID_BUSINESSES_BUSINESSID_GOODS_FEEDBACK_COMMENTS_DELETE) => Some("DeleteGoodsFeedbackComment"),
            // GetGoodsFeedbackComments - POST /businesses/{businessId}/goods-feedback/comments
            hyper::Method::POST if path.matched(paths::ID_BUSINESSES_BUSINESSID_GOODS_FEEDBACK_COMMENTS) => Some("GetGoodsFeedbackComments"),
            // GetGoodsFeedbacks - POST /businesses/{businessId}/goods-feedback
            hyper::Method::POST if path.matched(paths::ID_BUSINESSES_BUSINESSID_GOODS_FEEDBACK) => Some("GetGoodsFeedbacks"),
            // SkipGoodsFeedbacksReaction - POST /businesses/{businessId}/goods-feedback/skip-reaction
            hyper::Method::POST if path.matched(paths::ID_BUSINESSES_BUSINESSID_GOODS_FEEDBACK_SKIP_REACTION) => Some("SkipGoodsFeedbacksReaction"),
            // UpdateGoodsFeedbackComment - POST /businesses/{businessId}/goods-feedback/comments/update
            hyper::Method::POST if path.matched(paths::ID_BUSINESSES_BUSINESSID_GOODS_FEEDBACK_COMMENTS_UPDATE) => Some("UpdateGoodsFeedbackComment"),
            // GetGoodsStats - POST /campaigns/{campaignId}/stats/skus
            hyper::Method::POST if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_STATS_SKUS) => Some("GetGoodsStats"),
            // AddHiddenOffers - POST /campaigns/{campaignId}/hidden-offers
            hyper::Method::POST if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_HIDDEN_OFFERS) => Some("AddHiddenOffers"),
            // DeleteHiddenOffers - POST /campaigns/{campaignId}/hidden-offers/delete
            hyper::Method::POST if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_HIDDEN_OFFERS_DELETE) => Some("DeleteHiddenOffers"),
            // GetHiddenOffers - GET /campaigns/{campaignId}/hidden-offers
            hyper::Method::GET if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_HIDDEN_OFFERS) => Some("GetHiddenOffers"),
            // GetModels - POST /models
            hyper::Method::POST if path.matched(paths::ID_MODELS) => Some("GetModels"),
            // GetModelsOffers - POST /models/offers
            hyper::Method::POST if path.matched(paths::ID_MODELS_OFFERS) => Some("GetModelsOffers"),
            // SearchModels - GET /models
            hyper::Method::GET if path.matched(paths::ID_MODELS) => Some("SearchModels"),
            // GetModel - GET /models/{modelId}
            hyper::Method::GET if path.matched(paths::ID_MODELS_MODELID) => Some("GetModel"),
            // GetModelOffers - GET /models/{modelId}/offers
            hyper::Method::GET if path.matched(paths::ID_MODELS_MODELID_OFFERS) => Some("GetModelOffers"),
            // GetOfferMappingEntries - GET /campaigns/{campaignId}/offer-mapping-entries
            hyper::Method::GET if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_OFFER_MAPPING_ENTRIES) => Some("GetOfferMappingEntries"),
            // GetSuggestedOfferMappingEntries - POST /campaigns/{campaignId}/offer-mapping-entries/suggestions
            hyper::Method::POST if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_OFFER_MAPPING_ENTRIES_SUGGESTIONS) => Some("GetSuggestedOfferMappingEntries"),
            // UpdateOfferMappingEntries - POST /campaigns/{campaignId}/offer-mapping-entries/updates
            hyper::Method::POST if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_OFFER_MAPPING_ENTRIES_UPDATES) => Some("UpdateOfferMappingEntries"),
            // DeleteCampaignOffers - POST /campaigns/{campaignId}/offers/delete
            hyper::Method::POST if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_OFFERS_DELETE) => Some("DeleteCampaignOffers"),
            // GetAllOffers - GET /campaigns/{campaignId}/offers/all
            hyper::Method::GET if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_OFFERS_ALL) => Some("GetAllOffers"),
            // GetCampaignOffers - POST /campaigns/{campaignId}/offers
            hyper::Method::POST if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_OFFERS) => Some("GetCampaignOffers"),
            // GetOfferRecommendations - POST /businesses/{businessId}/offers/recommendations
            hyper::Method::POST if path.matched(paths::ID_BUSINESSES_BUSINESSID_OFFERS_RECOMMENDATIONS) => Some("GetOfferRecommendations"),
            // GetOffers - GET /campaigns/{campaignId}/offers
            hyper::Method::GET if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_OFFERS) => Some("GetOffers"),
            // UpdateCampaignOffers - POST /campaigns/{campaignId}/offers/update
            hyper::Method::POST if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_OFFERS_UPDATE) => Some("UpdateCampaignOffers"),
            // GetOrderBusinessBuyerInfo - POST /campaigns/{campaignId}/orders/{orderId}/business-buyer
            hyper::Method::POST if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_BUSINESS_BUYER) => Some("GetOrderBusinessBuyerInfo"),
            // GetOrderBusinessDocumentsInfo - POST /campaigns/{campaignId}/orders/{orderId}/documents
            hyper::Method::POST if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_DOCUMENTS) => Some("GetOrderBusinessDocumentsInfo"),
            // GetOrderBuyerInfo - GET /campaigns/{campaignId}/orders/{orderId}/buyer
            hyper::Method::GET if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_BUYER) => Some("GetOrderBuyerInfo"),
            // SetOrderDeliveryDate - PUT /campaigns/{campaignId}/orders/{orderId}/delivery/date
            hyper::Method::PUT if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_DELIVERY_DATE) => Some("SetOrderDeliveryDate"),
            // SetOrderDeliveryTrackCode - POST /campaigns/{campaignId}/orders/{orderId}/delivery/track
            hyper::Method::POST if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_DELIVERY_TRACK) => Some("SetOrderDeliveryTrackCode"),
            // UpdateOrderStorageLimit - PUT /campaigns/{campaignId}/orders/{orderId}/delivery/storage-limit
            hyper::Method::PUT if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_DELIVERY_STORAGE_LIMIT) => Some("UpdateOrderStorageLimit"),
            // VerifyOrderEac - PUT /campaigns/{campaignId}/orders/{orderId}/verifyEac
            hyper::Method::PUT if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_VERIFYEAC) => Some("VerifyOrderEac"),
            // GenerateOrderLabels - GET /campaigns/{campaignId}/orders/{orderId}/delivery/labels
            hyper::Method::GET if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_DELIVERY_LABELS) => Some("GenerateOrderLabels"),
            // GetOrderLabelsData - GET /campaigns/{campaignId}/orders/{orderId}/delivery/labels/data
            hyper::Method::GET if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_DELIVERY_LABELS_DATA) => Some("GetOrderLabelsData"),
            // GenerateOrderLabel - GET /campaigns/{campaignId}/orders/{orderId}/delivery/shipments/{shipmentId}/boxes/{boxId}/label
            hyper::Method::GET if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_DELIVERY_SHIPMENTS_SHIPMENTID_BOXES_BOXID_LABEL) => Some("GenerateOrderLabel"),
            // GetOrders - GET /campaigns/{campaignId}/orders
            hyper::Method::GET if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_ORDERS) => Some("GetOrders"),
            // UpdateOrderStatuses - POST /campaigns/{campaignId}/orders/status-update
            hyper::Method::POST if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_ORDERS_STATUS_UPDATE) => Some("UpdateOrderStatuses"),
            // AcceptOrderCancellation - PUT /campaigns/{campaignId}/orders/{orderId}/cancellation/accept
            hyper::Method::PUT if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_CANCELLATION_ACCEPT) => Some("AcceptOrderCancellation"),
            // GetOrder - GET /campaigns/{campaignId}/orders/{orderId}
            hyper::Method::GET if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID) => Some("GetOrder"),
            // ProvideOrderDigitalCodes - POST /campaigns/{campaignId}/orders/{orderId}/deliverDigitalGoods
            hyper::Method::POST if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_DELIVERDIGITALGOODS) => Some("ProvideOrderDigitalCodes"),
            // ProvideOrderItemIdentifiers - PUT /campaigns/{campaignId}/orders/{orderId}/identifiers
            hyper::Method::PUT if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_IDENTIFIERS) => Some("ProvideOrderItemIdentifiers"),
            // SetOrderBoxLayout - PUT /campaigns/{campaignId}/orders/{orderId}/boxes
            hyper::Method::PUT if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_BOXES) => Some("SetOrderBoxLayout"),
            // UpdateOrderItems - PUT /campaigns/{campaignId}/orders/{orderId}/items
            hyper::Method::PUT if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_ITEMS) => Some("UpdateOrderItems"),
            // UpdateOrderStatus - PUT /campaigns/{campaignId}/orders/{orderId}/status
            hyper::Method::PUT if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_STATUS) => Some("UpdateOrderStatus"),
            // SetOrderShipmentBoxes - PUT /campaigns/{campaignId}/orders/{orderId}/delivery/shipments/{shipmentId}/boxes
            hyper::Method::PUT if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_DELIVERY_SHIPMENTS_SHIPMENTID_BOXES) => Some("SetOrderShipmentBoxes"),
            // GetOrdersStats - POST /campaigns/{campaignId}/stats/orders
            hyper::Method::POST if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_STATS_ORDERS) => Some("GetOrdersStats"),
            // DeleteOutletLicenses - DELETE /campaigns/{campaignId}/outlets/licenses
            hyper::Method::DELETE if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_OUTLETS_LICENSES) => Some("DeleteOutletLicenses"),
            // GetOutletLicenses - GET /campaigns/{campaignId}/outlets/licenses
            hyper::Method::GET if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_OUTLETS_LICENSES) => Some("GetOutletLicenses"),
            // UpdateOutletLicenses - POST /campaigns/{campaignId}/outlets/licenses
            hyper::Method::POST if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_OUTLETS_LICENSES) => Some("UpdateOutletLicenses"),
            // CreateOutlet - POST /campaigns/{campaignId}/outlets
            hyper::Method::POST if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_OUTLETS) => Some("CreateOutlet"),
            // GetOutlets - GET /campaigns/{campaignId}/outlets
            hyper::Method::GET if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_OUTLETS) => Some("GetOutlets"),
            // DeleteOutlet - DELETE /campaigns/{campaignId}/outlets/{outletId}
            hyper::Method::DELETE if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_OUTLETS_OUTLETID) => Some("DeleteOutlet"),
            // GetOutlet - GET /campaigns/{campaignId}/outlets/{outletId}
            hyper::Method::GET if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_OUTLETS_OUTLETID) => Some("GetOutlet"),
            // UpdateOutlet - PUT /campaigns/{campaignId}/outlets/{outletId}
            hyper::Method::PUT if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_OUTLETS_OUTLETID) => Some("UpdateOutlet"),
            // ConfirmBusinessPrices - POST /businesses/{businessId}/price-quarantine/confirm
            hyper::Method::POST if path.matched(paths::ID_BUSINESSES_BUSINESSID_PRICE_QUARANTINE_CONFIRM) => Some("ConfirmBusinessPrices"),
            // ConfirmCampaignPrices - POST /campaigns/{campaignId}/price-quarantine/confirm
            hyper::Method::POST if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_PRICE_QUARANTINE_CONFIRM) => Some("ConfirmCampaignPrices"),
            // GetBusinessQuarantineOffers - POST /businesses/{businessId}/price-quarantine
            hyper::Method::POST if path.matched(paths::ID_BUSINESSES_BUSINESSID_PRICE_QUARANTINE) => Some("GetBusinessQuarantineOffers"),
            // GetCampaignQuarantineOffers - POST /campaigns/{campaignId}/price-quarantine
            hyper::Method::POST if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_PRICE_QUARANTINE) => Some("GetCampaignQuarantineOffers"),
            // GetPrices - GET /campaigns/{campaignId}/offer-prices
            hyper::Method::GET if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_OFFER_PRICES) => Some("GetPrices"),
            // GetPricesByOfferIds - POST /campaigns/{campaignId}/offer-prices
            hyper::Method::POST if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_OFFER_PRICES) => Some("GetPricesByOfferIds"),
            // GetSuggestedPrices - POST /campaigns/{campaignId}/offer-prices/suggestions
            hyper::Method::POST if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_OFFER_PRICES_SUGGESTIONS) => Some("GetSuggestedPrices"),
            // UpdateBusinessPrices - POST /businesses/{businessId}/offer-prices/updates
            hyper::Method::POST if path.matched(paths::ID_BUSINESSES_BUSINESSID_OFFER_PRICES_UPDATES) => Some("UpdateBusinessPrices"),
            // UpdatePrices - POST /campaigns/{campaignId}/offer-prices/updates
            hyper::Method::POST if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_OFFER_PRICES_UPDATES) => Some("UpdatePrices"),
            // DeletePromoOffers - POST /businesses/{businessId}/promos/offers/delete
            hyper::Method::POST if path.matched(paths::ID_BUSINESSES_BUSINESSID_PROMOS_OFFERS_DELETE) => Some("DeletePromoOffers"),
            // GetPromoOffers - POST /businesses/{businessId}/promos/offers
            hyper::Method::POST if path.matched(paths::ID_BUSINESSES_BUSINESSID_PROMOS_OFFERS) => Some("GetPromoOffers"),
            // GetPromos - POST /businesses/{businessId}/promos
            hyper::Method::POST if path.matched(paths::ID_BUSINESSES_BUSINESSID_PROMOS) => Some("GetPromos"),
            // UpdatePromoOffers - POST /businesses/{businessId}/promos/offers/update
            hyper::Method::POST if path.matched(paths::ID_BUSINESSES_BUSINESSID_PROMOS_OFFERS_UPDATE) => Some("UpdatePromoOffers"),
            // GetQualityRatingDetails - POST /campaigns/{campaignId}/ratings/quality/details
            hyper::Method::POST if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_RATINGS_QUALITY_DETAILS) => Some("GetQualityRatingDetails"),
            // GetQualityRatings - POST /businesses/{businessId}/ratings/quality
            hyper::Method::POST if path.matched(paths::ID_BUSINESSES_BUSINESSID_RATINGS_QUALITY) => Some("GetQualityRatings"),
            // SearchRegionsByName - GET /regions
            hyper::Method::GET if path.matched(paths::ID_REGIONS) => Some("SearchRegionsByName"),
            // SearchRegionChildren - GET /regions/{regionId}/children
            hyper::Method::GET if path.matched(paths::ID_REGIONS_REGIONID_CHILDREN) => Some("SearchRegionChildren"),
            // SearchRegionsById - GET /regions/{regionId}
            hyper::Method::GET if path.matched(paths::ID_REGIONS_REGIONID) => Some("SearchRegionsById"),
            // GenerateBoostConsolidatedReport - POST /reports/boost-consolidated/generate
            hyper::Method::POST if path.matched(paths::ID_REPORTS_BOOST_CONSOLIDATED_GENERATE) => Some("GenerateBoostConsolidatedReport"),
            // GenerateCompetitorsPositionReport - POST /reports/competitors-position/generate
            hyper::Method::POST if path.matched(paths::ID_REPORTS_COMPETITORS_POSITION_GENERATE) => Some("GenerateCompetitorsPositionReport"),
            // GenerateGoodsFeedbackReport - POST /reports/goods-feedback/generate
            hyper::Method::POST if path.matched(paths::ID_REPORTS_GOODS_FEEDBACK_GENERATE) => Some("GenerateGoodsFeedbackReport"),
            // GenerateGoodsMovementReport - POST /reports/goods-movement/generate
            hyper::Method::POST if path.matched(paths::ID_REPORTS_GOODS_MOVEMENT_GENERATE) => Some("GenerateGoodsMovementReport"),
            // GenerateGoodsRealizationReport - POST /reports/goods-realization/generate
            hyper::Method::POST if path.matched(paths::ID_REPORTS_GOODS_REALIZATION_GENERATE) => Some("GenerateGoodsRealizationReport"),
            // GenerateGoodsTurnoverReport - POST /reports/goods-turnover/generate
            hyper::Method::POST if path.matched(paths::ID_REPORTS_GOODS_TURNOVER_GENERATE) => Some("GenerateGoodsTurnoverReport"),
            // GenerateMassOrderLabelsReport - POST /reports/documents/labels/generate
            hyper::Method::POST if path.matched(paths::ID_REPORTS_DOCUMENTS_LABELS_GENERATE) => Some("GenerateMassOrderLabelsReport"),
            // GeneratePricesReport - POST /reports/prices/generate
            hyper::Method::POST if path.matched(paths::ID_REPORTS_PRICES_GENERATE) => Some("GeneratePricesReport"),
            // GenerateShelfsStatisticsReport - POST /reports/shelf-statistics/generate
            hyper::Method::POST if path.matched(paths::ID_REPORTS_SHELF_STATISTICS_GENERATE) => Some("GenerateShelfsStatisticsReport"),
            // GenerateShipmentListDocumentReport - POST /reports/documents/shipment-list/generate
            hyper::Method::POST if path.matched(paths::ID_REPORTS_DOCUMENTS_SHIPMENT_LIST_GENERATE) => Some("GenerateShipmentListDocumentReport"),
            // GenerateShowsSalesReport - POST /reports/shows-sales/generate
            hyper::Method::POST if path.matched(paths::ID_REPORTS_SHOWS_SALES_GENERATE) => Some("GenerateShowsSalesReport"),
            // GenerateStocksOnWarehousesReport - POST /reports/stocks-on-warehouses/generate
            hyper::Method::POST if path.matched(paths::ID_REPORTS_STOCKS_ON_WAREHOUSES_GENERATE) => Some("GenerateStocksOnWarehousesReport"),
            // GenerateUnitedMarketplaceServicesReport - POST /reports/united-marketplace-services/generate
            hyper::Method::POST if path.matched(paths::ID_REPORTS_UNITED_MARKETPLACE_SERVICES_GENERATE) => Some("GenerateUnitedMarketplaceServicesReport"),
            // GenerateUnitedNettingReport - POST /reports/united-netting/generate
            hyper::Method::POST if path.matched(paths::ID_REPORTS_UNITED_NETTING_GENERATE) => Some("GenerateUnitedNettingReport"),
            // GenerateUnitedOrdersReport - POST /reports/united-orders/generate
            hyper::Method::POST if path.matched(paths::ID_REPORTS_UNITED_ORDERS_GENERATE) => Some("GenerateUnitedOrdersReport"),
            // GetReportInfo - GET /reports/info/{reportId}
            hyper::Method::GET if path.matched(paths::ID_REPORTS_INFO_REPORTID) => Some("GetReportInfo"),
            // GetReturns - GET /campaigns/{campaignId}/returns
            hyper::Method::GET if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_RETURNS) => Some("GetReturns"),
            // GetReturn - GET /campaigns/{campaignId}/orders/{orderId}/returns/{returnId}
            hyper::Method::GET if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_RETURNS_RETURNID) => Some("GetReturn"),
            // GetReturnApplication - GET /campaigns/{campaignId}/orders/{orderId}/returns/{returnId}/application
            hyper::Method::GET if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_RETURNS_RETURNID_APPLICATION) => Some("GetReturnApplication"),
            // SetReturnDecision - POST /campaigns/{campaignId}/orders/{orderId}/returns/{returnId}/decision
            hyper::Method::POST if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_RETURNS_RETURNID_DECISION) => Some("SetReturnDecision"),
            // SubmitReturnDecision - POST /campaigns/{campaignId}/orders/{orderId}/returns/{returnId}/decision/submit
            hyper::Method::POST if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_RETURNS_RETURNID_DECISION_SUBMIT) => Some("SubmitReturnDecision"),
            // GetReturnPhoto - GET /campaigns/{campaignId}/orders/{orderId}/returns/{returnId}/decision/{itemId}/image/{imageHash}
            hyper::Method::GET if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_ORDERS_ORDERID_RETURNS_RETURNID_DECISION_ITEMID_IMAGE_IMAGEHASH) => Some("GetReturnPhoto"),
            // DownloadShipmentReceptionTransferAct - GET /campaigns/{campaignId}/shipments/reception-transfer-act
            hyper::Method::GET if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_SHIPMENTS_RECEPTION_TRANSFER_ACT) => Some("DownloadShipmentReceptionTransferAct"),
            // SearchShipments - PUT /campaigns/{campaignId}/first-mile/shipments
            hyper::Method::PUT if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_FIRST_MILE_SHIPMENTS) => Some("SearchShipments"),
            // ConfirmShipment - POST /campaigns/{campaignId}/first-mile/shipments/{shipmentId}/confirm
            hyper::Method::POST if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_FIRST_MILE_SHIPMENTS_SHIPMENTID_CONFIRM) => Some("ConfirmShipment"),
            // DownloadShipmentAct - GET /campaigns/{campaignId}/first-mile/shipments/{shipmentId}/act
            hyper::Method::GET if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_FIRST_MILE_SHIPMENTS_SHIPMENTID_ACT) => Some("DownloadShipmentAct"),
            // DownloadShipmentDiscrepancyAct - GET /campaigns/{campaignId}/first-mile/shipments/{shipmentId}/discrepancy-act
            hyper::Method::GET if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_FIRST_MILE_SHIPMENTS_SHIPMENTID_DISCREPANCY_ACT) => Some("DownloadShipmentDiscrepancyAct"),
            // DownloadShipmentInboundAct - GET /campaigns/{campaignId}/first-mile/shipments/{shipmentId}/inbound-act
            hyper::Method::GET if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_FIRST_MILE_SHIPMENTS_SHIPMENTID_INBOUND_ACT) => Some("DownloadShipmentInboundAct"),
            // DownloadShipmentPalletLabels - GET /campaigns/{campaignId}/first-mile/shipments/{shipmentId}/pallet/labels
            hyper::Method::GET if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_FIRST_MILE_SHIPMENTS_SHIPMENTID_PALLET_LABELS) => Some("DownloadShipmentPalletLabels"),
            // DownloadShipmentTransportationWaybill - GET /campaigns/{campaignId}/first-mile/shipments/{shipmentId}/transportation-waybill
            hyper::Method::GET if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_FIRST_MILE_SHIPMENTS_SHIPMENTID_TRANSPORTATION_WAYBILL) => Some("DownloadShipmentTransportationWaybill"),
            // GetShipment - GET /campaigns/{campaignId}/first-mile/shipments/{shipmentId}
            hyper::Method::GET if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_FIRST_MILE_SHIPMENTS_SHIPMENTID) => Some("GetShipment"),
            // GetShipmentOrdersInfo - GET /campaigns/{campaignId}/first-mile/shipments/{shipmentId}/orders/info
            hyper::Method::GET if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_FIRST_MILE_SHIPMENTS_SHIPMENTID_ORDERS_INFO) => Some("GetShipmentOrdersInfo"),
            // SetShipmentPalletsCount - PUT /campaigns/{campaignId}/first-mile/shipments/{shipmentId}/pallets
            hyper::Method::PUT if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_FIRST_MILE_SHIPMENTS_SHIPMENTID_PALLETS) => Some("SetShipmentPalletsCount"),
            // TransferOrdersFromShipment - POST /campaigns/{campaignId}/first-mile/shipments/{shipmentId}/orders/transfer
            hyper::Method::POST if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_FIRST_MILE_SHIPMENTS_SHIPMENTID_ORDERS_TRANSFER) => Some("TransferOrdersFromShipment"),
            // GetStocks - POST /campaigns/{campaignId}/offers/stocks
            hyper::Method::POST if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_OFFERS_STOCKS) => Some("GetStocks"),
            // UpdateStocks - PUT /campaigns/{campaignId}/offers/stocks
            hyper::Method::PUT if path.matched(paths::ID_CAMPAIGNS_CAMPAIGNID_OFFERS_STOCKS) => Some("UpdateStocks"),
            // CalculateTariffs - POST /tariffs/calculate
            hyper::Method::POST if path.matched(paths::ID_TARIFFS_CALCULATE) => Some("CalculateTariffs"),
            // GetFulfillmentWarehouses - GET /warehouses
            hyper::Method::GET if path.matched(paths::ID_WAREHOUSES) => Some("GetFulfillmentWarehouses"),
            // GetWarehouses - GET /businesses/{businessId}/warehouses
            hyper::Method::GET if path.matched(paths::ID_BUSINESSES_BUSINESSID_WAREHOUSES) => Some("GetWarehouses"),
            _ => None,
        }
    }
}
